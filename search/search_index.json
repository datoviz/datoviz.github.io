{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Datoviz: high-performance rendering for scientific data visualization","text":"<p>\u26a1\ufe0f Datoviz is an open-source, cross-platform, high-performance rendering library for scientific data visualization making extensive use of the graphics processing unit (GPU).</p> <p>Up to 10,000x faster than matplotlib, it delivers highly efficient high-quality GPU rendering of 2D and 3D graphical primitives\u2014markers, paths, images, text, meshes, volumes, and more\u2014that scale to millions of elements. Datoviz also supports graphical user interfaces (GUIs) for interactive visualization.</p> <p></p> <p>Built from the ground up with performance in mind, Datoviz is written primarily in C and C++, leveraging the Khronos Vulkan graphics API. It offers a C API, low-level Python bindings via <code>ctypes</code>, and a higher-level, idiomatic Python API \ud83d\udc0d.</p> <p>Written by one of the original creators of VisPy, a GPU-based Python scientific visualization library, Datoviz aims to serve as the default backend for the upcoming VisPy 2.0.</p> <p>The library is lightweight with minimal dependencies: mostly Vulkan, GLFW for windowing, and Dear ImGui for GUIs.</p> <p>Warning</p> <p>Datoviz is a young library. The API is stabilizing, but breaking changes may still occur as the project evolves with broader usage.</p>"},{"location":"#current-features","title":"\u2728 Current features","text":"<ul> <li>\ud83d\udcca 2D visuals: antialiased points, markers, line segments, paths, text, images</li> <li>\ud83d\udcc8 2D axes</li> <li>\ud83c\udf10 3D visuals: meshes, volumes, volume slices</li> <li>\ud83c\udf08 150 colormaps included (from matplotlib, colorcet, MATLAB)</li> <li>\ud83d\uddb1\ufe0f High-level interactivity: pan &amp; zoom for 2D, arcball for 3D (more later)</li> <li>\ud83c\udfa5 Manual control of cameras: custom interactivity</li> <li>\ud80c\ude08 Figure subplots (aka \"panels\")</li> <li>\ud83d\udda5\ufe0f GUIs using Dear ImGui</li> </ul>"},{"location":"#api-philosophy","title":"\ud83e\udde9 API philosophy","text":"<p>Datoviz does not use high-level plotting functions like <code>plot()</code>, <code>scatter()</code>, or <code>imshow()</code>. Instead, it exposes flexible visual primitives\u2014markers, images, meshes, and more\u2014that can be added to a scene and customized directly with data. This approach offers fine-grained control and high performance, while remaining concise enough for quick plots.</p> <p>A higher-level plotting interface is under development as part of VisPy 2.0, which will use Datoviz as its rendering backend. An intermediate layer called GSP (Graphics Specification Protocol) will provide a backend-agnostic API for declarative plotting.</p>"},{"location":"#comparison-with-other-libraries","title":"\ud83d\udd0d Comparison with other libraries","text":""},{"location":"#matplotlib","title":"\ud83d\udc0d Matplotlib","text":"<p>Matplotlib is the gold standard for static, publication-quality figures, with a mature, feature-rich API. But it's not optimized for interactivity or large datasets.</p> <p>Datoviz, in contrast, is a younger, GPU-based library designed for fast, interactive visualization. It lacks Matplotlib\u2019s high-level API but excels at rendering millions of points in real time.</p> <p>Use Matplotlib for polished static plots, Datoviz for responsive data exploration.</p>"},{"location":"#preliminary-performance-benchmark","title":"Preliminary performance benchmark","text":"<p>The figure below shows a preliminary performance benchmark comparing Datoviz and Matplotlib on an interactive 2D scatter plot, with increasing numbers of points and a simulated zoom interaction:</p> <p> </p> <p>In this benchmark, Datoviz outperforms Matplotlib by a factor of up to 10,000\u00d7, maintaining interactive framerates even with millions of points. Matplotlib, in contrast, becomes sluggish or fails entirely as the dataset size increases.</p>"},{"location":"#vtk","title":"\ud83e\uddca VTK","text":"<p>Datoviz is lighter, simpler, and easier to install than VTK. It compiles in seconds, has minimal dependencies, and focuses exclusively on real-time rendering of visual primitives. Unlike VTK, it does not include data file I/O (except minimal test loaders like <code>.obj</code>), computational geometry, or data processing.</p> <p>VTK is a powerful, heavyweight toolkit for 3D visualization, simulation, and scientific computing workflows. In contrast, Datoviz is designed for fast, high-quality 2D and 3D rendering.</p>"},{"location":"#get-started","title":"\ud83d\ude80 Get started","text":"<ul> <li>\ud83d\udc49 Quickstart guide \u2014 create your first scatter plot in a few lines of code</li> <li>\ud83d\udcda Learn \u2014 deep dive into visuals, layout, interactivity, and more</li> <li>\ud83d\uddbc\ufe0f Gallery \u2014 curated examples of what Datoviz can render</li> <li>\ud83e\udde9 API Reference \u2014 full Python and C documentation</li> </ul>"},{"location":"#installation","title":"\ud83d\udee0\ufe0f Installation","text":"<p>Datoviz runs out of the box on all major platforms:</p> <ul> <li>\u2705 Windows, macOS (Intel and Apple Silicon), and Linux</li> <li>\u2705 Prebuilt wheels for 64-bit architectures (x86_64 and arm64)</li> <li>\u2705 No system dependencies \u2014 just install and run</li> </ul> <p>Install the Python package via pip:</p> <pre><code>pip install datoviz\n</code></pre> <p>To use the C library directly, see the build instructions.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>Datoviz is open source and licensed under the MIT License.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This quickstart guide shows how to create an interactive 2D scatter plot with Datoviz. The plot includes axes, pan and zoom interactivity, and customizable visuals.</p>"},{"location":"quickstart/#requirements","title":"Requirements","text":"<p>Make sure you have Python and NumPy installed. You can install Datoviz via pip:</p> <pre><code>pip install datoviz\n</code></pre>"},{"location":"quickstart/#what-youll-build","title":"What you'll build","text":"<p>The following script generates 1,000 randomly positioned, colored, and sized points in a 2D scatter plot:</p> <p></p>"},{"location":"quickstart/#example-code","title":"Example code","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\n# Number of points\nn = 1000\n\n# Generate random (x, y) coordinates\nx, y = np.random.rand(2, n)\n\n# Generate RGBA colors (uint8 in range [0, 255])\ncolor = np.random.randint(100, 240, size=(n, 4), dtype=np.uint8)\ncolor[:, 3] = 255  # full opacity\n\n# Generate random point sizes (in pixels)\nsize = np.random.uniform(10, 30, size=n)\n\n# Create a Datoviz app with a white background\napp = dvz.App(background='white')\n\n# Create an 800x600 window\nfigure = app.figure(800, 600)\n\n# Add a panel (like a subplot) to the figure.\n# By default, it spans the entire figure.\npanel = figure.panel()\n\n# Define axis limits\nxlim = 0, 1\nylim = 0, 1\n\n# Add 2D axes to the panel with pan/zoom support\naxes = panel.axes(xlim, ylim)\n\n# Create a scatter plot visual\nvisual = app.point(\n    position=axes.normalize(x, y),  # map to normalized device coordinates\n    color=color,\n    size=size,\n)\n\n# Add the visual to the panel\npanel.add(visual)\n\n# Run the app (starts the event loop and opens the window)\napp.run()\n\n# Clean up after the window is closed\napp.destroy()\n</code></pre>"},{"location":"discussions/ARCHITECTURE/","title":"Architecture","text":"<p>This document provides a high-level overview of the Datoviz v0.3 code architecture.</p> <p>Warning</p> <p>Some architectural details described here are expected to change in Datoviz v0.4.</p>"},{"location":"discussions/ARCHITECTURE/#main-components","title":"Main components","text":"<p>The main components are:</p> <ul> <li>vklite (<code>include/datoviz/vklite.h</code>): A lightweight C wrapper around Vulkan, offering essential GPU compute and rendering functionality for scientific visualization.</li> <li>Renderer (<code>include/datoviz/renderer.h</code>): A C/C++ Vulkan-based visualization engine featuring a GLFW-based event loop that processes real-time visualization requests.</li> <li>Requests (<code>include/datoviz/requests.h</code>): A C API for generating real-time visualization requests to be handled by the renderer.</li> <li>Visuals (<code>includes/datoviz/scene/visuals/</code>): A comprehensive C/GLSL library of high-quality GPU graphical primitives\u2014points, markers, paths, images, glyphs, meshes, and volumes.</li> <li>Scene (<code>include/datoviz.h</code>): A C/C++ library for scientific visualization logic that generates renderer-bound requests.</li> </ul> <p>These components are structured around the Datoviz Intermediate Protocol: an intermediate-level, message-based visualization protocol that decouples high-level scientific logic from low-level Vulkan rendering.</p> <p>This separation allows the high-level components to be developed and maintained by research software engineers and scientists, while the low-level GPU rendering code\u2014requiring deep technical expertise more typical of the video game industry\u2014can evolve independently.</p> <p>The architecture also ensures that scientific visualization logic remains portable and insulated from changes in graphics APIs (OpenGL, Vulkan, Metal, DirectX, WebGPU, etc.). We are working toward porting Datoviz to non-Vulkan backends, including WebGPU-enabled web browsers.</p> <p>This supports our long-term vision of making high-performance GPU-based 2D/3D scientific visualization broadly accessible across platforms\u2014desktop, web, and remote/cloud environments\u2014with support for both local and distributed data, and across multiple programming languages (C/C++, Python, Julia, Rust, etc.).</p>"},{"location":"discussions/ARCHITECTURE/#renderer","title":"Renderer","text":"<p>At the lowest level, Datoviz relies on the raw Vulkan C API, known for its extreme verbosity and complexity.</p>"},{"location":"discussions/ARCHITECTURE/#vklite","title":"vklite","text":"<p>We built vklite, a thin wrapper over the Vulkan C API, to expose the most essential GPU functionality in a more accessible form (<code>vklite.h</code>):</p> <ul> <li>Device control and event loops:<ul> <li>Device discovery (<code>dvz_gpu</code>)</li> <li>Swapchain presentation (<code>dvz_swapchain</code>, <code>dvz_renderpass</code>, <code>dvz_framebuffers</code>, <code>dvz_surface</code>)</li> <li>Synchronization primitives (<code>dvz_barrier</code>, <code>dvz_semaphores</code>, <code>dvz_fences</code>)</li> </ul> </li> <li>GPU memory:<ul> <li>GPU data buffers (<code>dvz_buffers</code>)</li> <li>GPU images (<code>dvz_images</code>)</li> <li>Samplers (<code>dvz_sampler</code>)</li> </ul> </li> <li>Pipelines and shaders:<ul> <li>Compute pipelines (<code>dvz_compute</code>)</li> <li>Graphics pipelines (<code>dvz_graphics</code>) with fixed pipelines and custom shaders</li> <li>Slots and descriptors (<code>dvz_slots</code>, <code>dvz_descriptors</code>)</li> </ul> </li> <li>Command buffers:<ul> <li>Command buffer creation and submission (<code>dvz_commands</code>, <code>dvz_submit</code>)</li> <li>Command buffer recording (<code>dvz_cmd</code>)</li> </ul> </li> </ul> <p>In broad terms, these low-level components allow you to:</p> <ul> <li>Create GPU-side objects such as data buffers and textures (images and samplers)</li> <li>Define compute and graphics pipelines via SPIR-V shaders (compiled from GLSL)</li> <li>Submit compute or rendering jobs asynchronously through recorded command buffers, which are processed in an event loop that handles on-screen rendering.</li> </ul>"},{"location":"discussions/ARCHITECTURE/#gpu-resources-and-data-transfers","title":"GPU resources and data transfers","text":"<p>A significant part of the renderer is dedicated to managing GPU-resident data and facilitating CPU-GPU data transfers (<code>resources.h</code>, <code>context.h</code>, <code>alloc.h</code>, <code>transfers.h</code>, ...).</p> <p>Vulkan and vklite support two main types of GPU data:</p> <ul> <li>Buffers: Linear, contiguous memory blocks used for vertex data, attributes, shader parameters, or general-purpose storage buffers accessible by shaders.</li> <li>Images: Used to store textures or rendered output (1D, 2D, or 3D).</li> </ul> <p>Vulkan provides only low-level primitives for handling CPU-GPU data transfers\u2014such as creating/deleting buffers and images, memory mapping, and recording/submitting copy commands. Datoviz builds on this by offering a dedicated data transfer engine with a simpler interface focused on \"upload\" (CPU \u2192 GPU), \"download\" (GPU \u2192 CPU), and \"copy\" (GPU \u2192 GPU) of both buffers and images.</p> <p>To reduce overhead when dealing with small data chunks, Datoviz includes a custom memory allocator. Rather than creating numerous small buffers\u2014which is inefficient in Vulkan\u2014it allocates a few large shared buffers and manages sub-regions internally. This adds some complexity but significantly improves performance and scalability.</p> <p>Datoviz exposes this abstraction through: - dats: Contiguous data chunks stored on the GPU - texs: GPU images for texture and render targets These can be created, resized, deleted, and used for data uploads/downloads.</p>"},{"location":"discussions/ARCHITECTURE/#datoviz-intermediate-protocol-renderer","title":"Datoviz Intermediate Protocol Renderer","text":"<p>The Renderer executes requests defined by the Datoviz Intermediate Protocol using the low-level machinery described above (vklite, data transfer engine, etc.).</p> <p>It maintains an object hash table that maps unique request-level object IDs to their corresponding low-level GPU representations.</p>"},{"location":"discussions/ARCHITECTURE/#client","title":"Client","text":"<p>Datoviz includes a GPU-agnostic, GLFW-based client responsible for basic interactive behavior: window creation, input handling, and event loop integration (<code>window.h</code>, <code>client.h</code>, <code>fifo.h</code>, <code>mouse.h</code>, <code>keyboard.h</code>, <code>input.h</code>, ...).</p> <p>The client provides a thread-safe FIFO queue for communicating window and input events.</p> <p>This GPU-agnostic client is linked to the renderer via the presenter, which dynamically processes incoming rendering requests and synchronizes them with the event loop.</p>"},{"location":"discussions/ARCHITECTURE/#datoviz-intermediate-protocol","title":"Datoviz Intermediate Protocol","text":"<p>The Datoviz Intermediate Protocol is fully defined in <code>datoviz_protocol.h</code>.</p> <p>It provides a generic, intermediate-level GPU visualization interface that resembles the WebGPU API in spirit. This protocol operates exclusively on GPU objects, not on visual or graphical primitives. It offers no built-in visuals; instead, it supports arbitrary shaders and graphics pipelines. Graphical primitives and higher-level visualization constructs are implemented separately in the Visuals library and the Scene API (described below).</p> <p>Note</p> <p>The protocol will be expanded in Datoviz v0.4 to support compute shaders, multiple rendering passes, and additional low-level features.</p> <p>Requests are collected sequentially in a batch, which is submitted to the renderer for processing during the next iteration of the event loop.</p> <p>The main objects and concepts defined in the Datoviz Intermediate Protocol include:</p> <ul> <li>canvas \u2014 A window tied to a Vulkan surface, used for real-time GPU rendering and presentation.</li> <li>board \u2014 An offscreen canvas for static rendering, independent of the event loop.</li> <li>dat \u2014 A chunk of GPU memory (implemented as a subregion of a larger buffer managed by Datoviz).</li> <li>tex \u2014 A GPU image (1D, 2D, or 3D).</li> <li>sampler \u2014 A GPU object that applies filtering (nearest or linear) to textures.</li> <li>shader \u2014 A SPIR-V shader module.</li> <li>graphics \u2014 A graphics pipeline, consisting of a fixed-state configuration, vertex shader, fragment shader, and other components.</li> <li>bindings \u2014 Descriptors linking <code>dats</code> to shader uniforms.</li> <li>command buffer recording \u2014 Viewport definitions and graphics pipeline draw commands (support for compute commands will be added later).</li> </ul>"},{"location":"discussions/ARCHITECTURE/#scene-api","title":"Scene API","text":"<p>The Scene API provides higher-level scientific visualization constructs that are directly exposed to users of the Datoviz C API, unlike the lower-level internal components.</p>"},{"location":"discussions/ARCHITECTURE/#visuals-api","title":"Visuals API","text":"<p>A Visual is an abstraction representing a graphical object\u2014or a collection of similar objects\u2014that encapsulates a graphics pipeline. Each visual is defined by a pair of vertex and fragment shaders, descriptor bindings for uniforms, a vertex buffer, and visual-specific logic for CPU-side data \"baking\".</p> <p>Visuals are designed to handle collections of similar objects\u2014points, markers, glyphs, images, meshes, etc.\u2014which is key to batch rendering. Batch rendering of many objects of the same type (but with varying attributes such as position, color, or size) is essential for achieving high GPU performance.</p> <p>Each visual uses a pair of custom shaders (vertex and fragment), originally developed by Nicolas Rougier as part of his research in computer graphics. Rendering high-quality graphical primitives efficiently on the GPU remains an active area of research. Typically, the vertex shader requires the input data to be preprocessed in a way that suits GPU rendering\u2014this preprocessing step is referred to as baking.</p> <p>A visual consists of several layered abstractions:</p> <ul> <li>The array \u2014 A 1D data buffer on the CPU, with a specific data type (scalar or multi-component, floating-point or integer) and size.</li> <li>The dual \u2014 Links a CPU-side array with a GPU-side dat (a chunk of GPU memory). It manages synchronization and triggers data upload requests when the CPU-side array is modified.</li> <li>The baker \u2014 Generates one or more multiplexed vertex buffers from the user's original visual data (e.g. positions, colors, other attributes).</li> <li>The generic visual \u2014 A flexible mechanism for defining a visual by bundling together a graphics primitive, shaders, a baker, a vertex buffer, and optional uniform parameters.</li> <li>The custom visual \u2014 A specialized visual that builds on the generic visual to expose a dedicated API for specific visual types (e.g. marker, image, mesh). It includes functions to create the visual, set its data, and render it within a command buffer.</li> </ul>"},{"location":"discussions/ARCHITECTURE/#visuals-library","title":"Visuals library","text":"<p>Datoviz includes a built-in library of visuals commonly used in scientific visualization:</p> <ul> <li>Basic visuals rely on built-in OpenGL/Vulkan graphical primitives:</li> <li>Basic point \u2014 A pixel or plain square.</li> <li>Basic line \u2014 Aliased thin lines: line list, line strip.</li> <li> <p>Basic triangle \u2014 Aliased triangles: triangle list, triangle strip, triangle fan     (Note: triangle fan is not supported on macOS.)</p> </li> <li> <p>0D visuals represent collections of points in 2D or 3D space:</p> </li> <li>Pixel \u2014 Collection of single pixels (position, color).</li> <li>Point \u2014 Collection of discs (position, color, size).</li> <li>Marker \u2014 Collection of markers with rich styling (position, color, size, angle, shape, fill/stroke/outline, edge color, edge width).</li> <li> <p>Glyph \u2014 Collection of text glyphs (position, color, size, angle, etc.).</p> </li> <li> <p>1D visuals represent lines:</p> </li> <li>Segment \u2014 Collection of rigid line segments (start/end positions, color, line width, cap style).</li> <li> <p>Path \u2014 Collection of curved paths with variable size (position, line width, color).</p> </li> <li> <p>2D visuals represent images:</p> </li> <li> <p>Image \u2014 Collection of textured squares (corner positions, sampler filtering, texture image).</p> </li> <li> <p>3D visuals represent meshes or volume-like objects:</p> </li> <li>Mesh \u2014 Triangular meshes (vertex position, normal, color, texture coordinates, face indices, lighting parameters).</li> <li>Sphere \u2014 Collection of \"fake\" spheres rendered as 2D sprites with 3D appearance (position, color, size, lighting).</li> <li>Volume \u2014 Full 3D volume rendering.</li> <li>Slice \u2014 2D images embedded in 3D space, showing slices of a volume (corner positions, texture coordinates).</li> </ul>"},{"location":"discussions/ARCHITECTURE/#transforms","title":"Transforms","text":"<p>Datoviz includes a basic transform system, currently limited to standard model-view-projection linear transforms. This is still a work in progress; support for more advanced transforms (e.g. nonlinear mappings) may be added in the future.</p> <p>The system currently provides standalone components for common interaction modes: - Pan-zoom (2D) - Arcball (3D rotation)</p> <p>Future extensions may include more subjective camera controls such as fly mode or first-person navigation.</p>"},{"location":"discussions/ARCHITECTURE/#scene","title":"Scene","text":"<p>The Scene is the central public API in Datoviz, assembling all components into a hierarchical visualization structure:</p> <ul> <li>Scene \u2014 The root object of the system.</li> <li>Figure \u2014 A scene-aware window.</li> <li>Panel \u2014 A rectangular region within a Figure (i.e. subplot).<ul> <li>Each Panel has an associated transform and interactivity mode (e.g. panzoom, arcball).</li> <li>One or more visuals can be added to a Panel.</li> </ul> </li> </ul> <p>The viewset is responsible for tracking all these objects and assembling a command buffer that renders all visuals in all panels.</p>"},{"location":"discussions/ARCHITECTURE/#specialized-components","title":"Specialized components","text":"<p>The Scene API includes several specialized components used internally by visuals or transforms.</p> <ul> <li> <p>Text components:</p> <ul> <li>Font \u2014 Wraps the FreeType library to handle text composition using a built-in or custom TTF font.</li> <li>Atlas \u2014 Wraps Viktor Chlumsk\u00fd\u2019s msdfgen-atlas library to generate a texture atlas of font glyphs using Multi-channel Signed Distance Fields (MSDF) for high-quality GPU text rendering in the fragment shader.</li> </ul> </li> <li> <p>GUI components:</p> <ul> <li>GUI \u2014 Wraps Omar Cornut\u2019s Dear ImGui library to provide basic interactive GUI elements. Full ImGui API support is expected to work in C++ mode (pending further testing).</li> </ul> </li> <li> <p>Axis components:</p> <ul> <li>Ticks \u2014 Automatic tick positioning.</li> <li>Labels \u2014 Tick label generation.</li> <li>Axis \u2014 Manages a single axis with ticks and labels.</li> <li>Axes \u2014 Manages multiple axes in a panel.</li> </ul> </li> </ul>"},{"location":"discussions/BUILD/","title":"Building instructions","text":"<p>If precompiled pip wheels are unavailable or not working on your system\u2014or if you need a custom build (e.g. to create a C/C++ application that depends on Datoviz)\u2014you can build Datoviz manually.</p> <p>Note</p> <p>Datoviz is currently built and tested with the Vulkan LunarG SDK v1.3.280. On Linux and macOS, this SDK is bundled automatically and does not need to be installed separately. On Windows, however, manual installation is required. We regularly update the supported Vulkan SDK version.</p>"},{"location":"discussions/BUILD/#dependencies","title":"Dependencies","text":"<p>Versions of the various dependencies, including the bundled ones.</p> <ul> <li>Datoviz v0.3.0<ul> <li>cglm: <code>v0.9.4</code></li> <li>Dear ImGui: <code>v1.91.7-docking</code></li> <li>fpng: <code>v1.0.6</code></li> <li>glfw: <code>v3.4</code></li> <li>msdf-atlas-gen: <code>master</code></li> <li>Tiny Obj Loader: <code>v2.0.0</code></li> <li>tinyxml2: <code>v10.0.0</code></li> <li>Vulkan Memory Allocator: <code>v3.2.1</code></li> <li>Vulkan SDK: <code>v1.3.280</code></li> </ul> </li> </ul>"},{"location":"discussions/BUILD/#ubuntu-2404","title":"Ubuntu 24.04","text":"<pre><code># Install the build and system dependencies.\nsudo apt install build-essential cmake gcc ccache ninja-build xorg-dev clang-format patchelf tree libtinyxml2-dev libfreetype-dev\n\n# Install just, see https://github.com/casey/just\ncurl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash\n\n# Clone the Datoviz repo and build.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"discussions/BUILD/#macos-arm64","title":"macOS (arm64)","text":"<pre><code># Install brew if you don't have it already.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n    eval \"$(/opt/homebrew/bin/brew shellenv)\"\n\n# Install build dependencies.\nbrew install just cmake ccache ninja freetype clang-format tree cloc jq\n\n# Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"discussions/BUILD/#macos-intel-x86-64","title":"macOS (Intel x86-64)","text":"<pre><code># Install brew if you don't have it already.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n    eval \"$(/opt/homebrew/bin/brew shellenv)\"\n\n# Install build dependencies.\nbrew install just cmake ccache ninja freetype clang-format tree cloc jq\n\n# Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"discussions/BUILD/#windows","title":"Windows","text":"<p>Requirements:</p> <ul> <li>Git for Windows.</li> <li>WinLibs: Download and install the latest gcc UCRT version with POSIX threads.</li> <li>LunarG Vulkan SDK for Windows.</li> <li>vcpkg: The <code>VCPKG_ROOT</code> environment variable should be set and should be in the <code>PATH</code>.</li> <li>just: Extract the just.exe file into C:\\mingw64\\bin (created by WinLibs).`</li> <li>jq: For example, with winget, use <code>winget install jqlang.jq</code></li> <li>Python.</li> </ul> <p>Instructions:</p> <ol> <li>Install the above dependencies.</li> <li>Open Windows git-bash terminal at the directory location for the datoviz build.</li> </ol> <pre><code># Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"discussions/CONTRIBUTING/","title":"Contributing notes","text":"<p>This document is a work in progress.</p>"},{"location":"discussions/CONTRIBUTING/#management-commands","title":"Management commands","text":"<p>We use the just tool for all management commands. The commands are implemented in <code>justfile</code>.</p>"},{"location":"discussions/CONTRIBUTING/#branches","title":"Branches","text":"<ul> <li>The <code>main</code> branch is reserved to stable releases.</li> <li>Development occurs in the <code>dev</code> branch.</li> </ul>"},{"location":"discussions/CONTRIBUTING/#python-bindings","title":"Python bindings","text":"<p>Datoviz provides two layers of Python bindings:</p> <ol> <li>Low-level bindings \u2014 Automatically generated <code>ctypes</code> wrappers for the C API.</li> <li>High-level Pythonic API \u2014 A more user-friendly layer built on top of the raw bindings.</li> </ol>"},{"location":"discussions/CONTRIBUTING/#low-level-ctypes-bindings","title":"Low-level ctypes bindings","text":"<p>The low-level bindings are automatically generated from the C headers and written to <code>datoviz/_ctypes_.py</code>. This file is committed to the repository but should not be edited manually.</p> <p>The C header files are parsed by <code>tools/parse_headers.py</code>, which outputs a structured representation to <code>build/headers.json</code>. This JSON file serves as the source for both:</p> <ul> <li>The generation of the <code>ctypes</code> Python bindings.</li> <li>The generation of the C API documentation.</li> </ul> <p>C functions such as <code>dvz_function()</code> are exposed in Python as <code>dvz.function()</code> (after <code>import datoviz as dvz</code>). C enums like <code>DVZ_MYENUM</code> become <code>dvz.MYENUM</code> in Python.</p> <p>This layer is a nearly 1:1 mapping of the C API, useful for advanced users or debugging.</p>"},{"location":"discussions/CONTRIBUTING/#high-level-pythonic-api","title":"High-level Pythonic API","text":"<p>Since version v0.3, Datoviz also includes a more idiomatic Python API built on top of the <code>ctypes</code> layer. This API offers simplified, object-oriented access to Datoviz functionality.</p> <p>For example:</p> <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfig = app.figure()\npanel = fig.panel()\nmarker = app.marker(...)\npanel.add(marker)\napp.run()\n</code></pre> <p>This Pythonic layer abstracts away many of the lower-level details while retaining full performance and flexibility. It is the recommended entry point for most Python users.</p> <p>Documentation and examples are being expanded as the API evolves.</p>"},{"location":"discussions/CONTRIBUTING/#continuous-integrationcontinuous-delivery","title":"Continuous integration/continuous delivery","text":"<p>GitHub Actions-based CI/CD is not yet active in this repository. In the near future, we intend to activate it for:</p> <ul> <li>cross-platform automated testing of the C library and Python bindings ;</li> <li>automated build of the Python wheels on all supported platforms ;</li> <li>automated build of the documentation and gallery.</li> </ul>"},{"location":"discussions/CONTRIBUTING/#debugging","title":"Debugging","text":""},{"location":"discussions/CONTRIBUTING/#console-logging","title":"Console logging","text":"<p>You can control the verbosity of Datoviz's console output by setting the <code>DVZ_LOG_LEVEL</code> environment variable:</p> <ul> <li><code>DVZ_LOG_LEVEL=2</code> \u2014 Info level (default)</li> <li><code>DVZ_LOG_LEVEL=1</code> \u2014 Debug level</li> <li><code>DVZ_LOG_LEVEL=0</code> \u2014 Trace level (very verbose; use with caution)</li> </ul>"},{"location":"discussions/CONTRIBUTING/#datoviz-intermediate-protocol-requests","title":"Datoviz Intermediate Protocol requests","text":"<p>Datoviz user-facing commands generate an internal stream of rendering requests, which are processed in real time by the Vulkan renderer. For debugging, you can inspect these requests to determine whether issues originate in the high-level code (which builds the requests) or in the low-level renderer (less common).</p> <p>To print a YAML representation of the generated requests to standard output, set:</p> <ul> <li><code>DVZ_VERBOSE=prt</code></li> </ul>"},{"location":"discussions/CONTRIBUTING/#screenshot-capture","title":"Screenshot capture","text":"<p>To render all Datoviz applications offscreen and save a screenshot, set:</p> <ul> <li><code>DVZ_CAPTURE_PNG=path/to/image.png</code> \u2014 Saves the rendered figure to a PNG file.</li> </ul>"},{"location":"discussions/CONTRIBUTING/#performance-monitoring","title":"Performance monitoring","text":"<p>Set the following environment variables to enable performance-related diagnostics:</p> <ul> <li><code>DVZ_FPS=1</code> enables an FPS (frames per second) counter</li> <li><code>DVZ_MAX_FPS=200</code> sets a frame rate limit (default is 200 FPS to reduce GPU usage)</li> <li><code>DVZ_MAX_FPS=0</code> disables the frame rate limit for benchmarking purposes</li> <li><code>DVZ_MONITOR=1</code> \u2014 Show a GPU memory monitor (allocated memory usage).</li> </ul> <p>Note</p> <p>The current FPS computation is suboptimal and may not reflect true frame rate. Improvements are planned \u2014 contributions are welcome!</p>"},{"location":"discussions/CONTRIBUTING/#styling-guide","title":"Styling Guide","text":"<p>This section provides guidelines for maintaining consistent code style in the Datoviz project, for both C source code and the Python wrapper. Consistency helps readability and maintainability. Most formatting is automatically handled by tools.</p>"},{"location":"discussions/CONTRIBUTING/#c-code-style","title":"C Code Style","text":""},{"location":"discussions/CONTRIBUTING/#code-formatting","title":"Code Formatting","text":"<ul> <li>Automatic formatting: We use <code>clang-format</code> with a custom configuration. The <code>.clang-format</code> file is located at the root of the repository.</li> <li>Auto-format on save: It is assumed that your IDE or editor is configured to automatically format C/C++ files on save using this configuration.</li> </ul>"},{"location":"discussions/CONTRIBUTING/#additional-conventions","title":"Additional conventions","text":"<ul> <li>Use comment banners (<code>/*****...*****/</code>) to clearly separate sections.</li> <li>Group includes and sort them logically: system headers, followed by local headers.</li> <li>Use <code>ANN(ptr)</code> (assert not null) for pointer assertions and <code>ASSERT(condition)</code> for general assertions.</li> <li>Keep function definitions short and readable; use blocks and whitespace to visually separate logic when helpful.</li> <li>Prefer function names with consistent prefixes (e.g., <code>dvz_axes_resize</code>, <code>dvz_demo_panel_3D</code>).</li> <li>Avoid trailing whitespace and excessive blank lines (more than 3 is trimmed by clang-format).</li> </ul>"},{"location":"discussions/CONTRIBUTING/#python-wrapper-style","title":"Python Wrapper Style","text":""},{"location":"discussions/CONTRIBUTING/#code-formatting-and-linting","title":"Code Formatting and Linting","text":"<ul> <li>We use Ruff for linting and formatting.</li> <li>The configuration is in <code>pyproject.toml</code>.</li> <li>Python files should be auto-formatted and linted using <code>ruff format</code> and <code>ruff check</code>.</li> </ul>"},{"location":"discussions/CONTRIBUTING/#additional-conventions_1","title":"Additional conventions","text":"<ul> <li>Use PEP8 naming and structure wherever possible.</li> <li>Keep line length \u2264 99 characters.</li> <li>Docstrings should follow NumPy-style (<code>\"\"\" \"\"\"</code>) format, with <code>Parameters</code>, <code>Returns</code>, etc.</li> <li>Prefer <code>assert</code> for internal sanity checks in constructors.</li> <li>Type hints should be used consistently, including in attribute declarations.</li> <li>Wrap class-level attributes with type annotations (e.g., <code>c_axes: dvz.DvzAxes = None</code>).</li> <li>Group code sections using banners and comments (e.g., <code># Axes</code>,<code># ----...----</code>).</li> <li>Avoid complex logic in wrapper code; keep it minimal and declarative.</li> </ul>"},{"location":"discussions/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021-2025 Cyrille Rossant</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"discussions/MAINTAINERS/","title":"Maintainers instructions","text":""},{"location":"discussions/MAINTAINERS/#release-checklist-for-datoviz-maintainers","title":"Release checklist for Datoviz maintainers","text":"<p>Development happens on <code>dev</code> whereas <code>main</code> is stable.</p> <p>Your local setup is supposed to look like this:</p> <pre><code>/path/to/datoviz/\n/path/to/datoviz/build/         [build subdirectory]\n/path/to/datoviz/data/          [git submodule]\n/path/to/datoviz.github.io/\n</code></pre> <p>Release checklist from a Linux development machine:</p> <ol> <li>Preparation.<ul> <li><code>git branch</code>: check that you are on the <code>dev</code> branch.</li> <li>Write the <code>CHANGELOG.md</code> for the new version.</li> </ul> </li> <li>Cross-platform release build and test.<ul> <li>For each of Linux, macOS arm64, macOS x86_64, Windows, do:<ul> <li><code>just clean release api</code>: rebuild in release mode.</li> <li><code>just test</code>: run the C testing suite.</li> <li><code>just pytest</code>: run the Python testing suite.</li> </ul> </li> <li>On Linux only:<ul> <li><code>just act test-linux</code>: simulate the GitHub Actions tests locally.</li> <li><code>just wheel</code>: build the wheel</li> <li><code>just checkwheel</code>: check the wheel</li> <li><code>just testwheel</code>: check the wheel</li> </ul> </li> </ul> </li> <li>Version bump.<ul> <li><code>version=x.y.z</code>: set up the new version.</li> <li><code>just bump $version</code>: bump the codebase to the new version.</li> <li><code>just release</code>: recompile with the new version.</li> <li><code>git diff</code>: check the changes to commit.</li> <li><code>git commit -am \"Bump version to v$version\" &amp;&amp; git push</code>: commit the new version.</li> </ul> </li> <li>Wheel build and test.<ul> <li><code>just wheels</code>: build the wheels on GitHub Actions.</li> <li>Wait until the wheels have been successfully built on all supported platforms. This will take about 15 minutes (the Windows build is currently much longer than macOS and Linux builds because GitHub Actions does not support Windows Docker containers yet).</li> <li>For each of Linux, macOS arm64, macOS x86_64, Windows, do:<ul> <li><code>just checkartifact</code></li> <li>Fix and go back to (2) if there is any problem.</li> </ul> </li> </ul> </li> <li>Merge dev branch.<ul> <li><code>git fetch --all &amp;&amp; git status</code> : check we're up to date and on the <code>dev</code> branch.</li> <li><code>git checkout main &amp;&amp; git pull</code> : switch to <code>main</code> before merging.</li> <li><code>git merge dev</code>: merge <code>dev</code> to <code>main</code>.</li> <li><code>just tag $version</code>: once on <code>main</code>, tag with the new version.</li> <li><code>git push origin main &amp;&amp; git push origin --tags</code>: push the tag.</li> </ul> </li> <li>Release.<ul> <li><code>just draft</code>: create a new GitHub Release draft with the built wheels.</li> <li>Edit and publish the GitHub Release.</li> <li><code>just upload</code>: upload the wheels to PyPI.</li> <li><code>just publish</code>: update the website (this command will temporary go to the directory <code>../datoviz.github.io/</code>).</li> <li><code>git checkout dev</code>: go back to the <code>dev</code> branch.</li> <li><code>just bump a.b.c-dev</code>: bump to the new development version (replace with the next expected version number).</li> <li><code>git commit -am \"Bump to development version\" &amp;&amp; git push</code>: bump to the development version.</li> <li>Announce the new release on the various communication channels.</li> </ul> </li> </ol>"},{"location":"discussions/MAINTAINERS/#packaging-instructions-advanced-users","title":"Packaging instructions (advanced users)","text":"<p>This section provides instructions for Datoviz maintainers who'd like to create binary packages and Python wheels.</p>"},{"location":"discussions/MAINTAINERS/#ubuntu-2404","title":"Ubuntu 24.04","text":"<p>Requirements:</p> <ul> <li>Docker</li> <li>just</li> <li><code>sudo apt-get install dpkg-dev fakeroot nvidia-container-toolkit</code></li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.deb</code> Debian installable package for development (with C headers and shared libraries):</p> <pre><code>just deb\n</code></pre> <p>To test the <code>.deb</code> package in an isolated Docker container:</p> <pre><code>just testdeb\n</code></pre> <p>To build a <code>manylinux</code> wheel (using <code>manylinux_2_34_x86_64</code>, based on AlmaLinux 8):</p> <pre><code># Build Datoviz in the manylinux container.\njust buildmany\n\n# Build a Python wheel in that container (saved in dist/).\njust wheelmany\n</code></pre> <p>To test the <code>manylinux</code> wheel:</p> <pre><code>just testwheel\n</code></pre>"},{"location":"discussions/MAINTAINERS/#macos-arm64","title":"macOS (arm64)","text":"<p>Requirements:</p> <ul> <li>Homebrew</li> <li>just</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.pkg</code> macOS installable package for development (with C headers and shared libraries):</p> <pre><code>just pkg\n</code></pre> <p>To build a macOS Python wheel:</p> <pre><code>just wheel\n</code></pre> <p>To test the macOS package in an isolated environment:</p> <ol> <li> <p>Install sshpass:</p> <pre><code>brew install sshpass\n</code></pre> </li> <li> <p>Install UTM.</p> </li> <li>Create a new macOS virtual machine (VM) with at least 64 GB storage (for Xcode).</li> <li>Install macOS in the virtual machine. For simplicity, use your <code>$USER</code> as the login and password.</li> <li>Once installed, find the IP address in the VM macOS system preferences and write it down (for example, <code>192.168.64.4</code>).</li> <li>Set up remote access via SSH in the VM macOS system preferences to set up a SSH server.</li> <li> <p>Open a terminal in the VM and type:</p> <pre><code>type: xcode-select --install\n</code></pre> </li> </ol> <p>Go back to the host machine and type:</p> <pre><code># Test the .pkg installation in an UTM virtual machine, using the IP address you wrote down earlier.\njust testpkg 192.168.64.4\n</code></pre> <p>The virtual machine should show the Datoviz demo in a window.</p> <p>To test the macOS wheel, you can either test in a virtual Python environment, or in a virtual machine using UTM.</p> <p>To test the macOS wheel in a virtual Python environment:</p> <pre><code>just testwheel\n</code></pre> <p>To test the macOS wheel in a virtual machine, set up the virtual machine as indicated above, then run (replacing the IP address with your virtual machine's IP):</p> <pre><code>just testwheel 192.168.64.4\n</code></pre>"},{"location":"discussions/MAINTAINERS/#macos-intel-x86-64","title":"macOS (Intel x86-64)","text":"<p>Requirements:</p> <ul> <li>Homebrew</li> <li>just</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.pkg</code> macOS installable package for development (with C headers and shared libraries):</p> <pre><code>just pkg\n</code></pre> <p>To build a macOS Python wheel:</p> <pre><code>just wheel\n</code></pre>"},{"location":"discussions/MAINTAINERS/#windows","title":"Windows","text":"<p>Requirements:</p> <ul> <li>Git for Windows</li> <li>WinLibs</li> <li>just</li> <li>LunarG Vulkan SDK for Windows</li> <li>WSL2</li> <li>vcpkg</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just release\n</code></pre> <p>To build a Windows Python wheel, open a Git Bash and type:</p> <pre><code># see https://stackoverflow.com/a/36530750/1595060\necho \"alias python='winpty python.exe'\" &gt;&gt; ~/.bash_profile\njust pydev\njust wheel\n</code></pre> <p>To test the wheel in a Python virtual environment:</p> <pre><code>just testwheel\n</code></pre>"},{"location":"discussions/MAINTAINERS/#github-actions-notes","title":"GitHub Actions notes","text":"<p>Datoviz relies on GitHub Actions for cross-platform automated testing and wheel building.</p>"},{"location":"discussions/MAINTAINERS/#testing","title":"Testing","text":"<p>This workflow is defined in <code>test.yml</code></p>"},{"location":"discussions/MAINTAINERS/#linux","title":"Linux","text":"<p>The <code>test-linux</code> job relies on the custom Docker image <code>rossant/datoviz_ubuntu</code> (see the Dockerfile). This image has all build and run dependencies, as well as the Swiftshader software Vulkan renderer, and xvfb to run graphical applications on a headless server.</p>"},{"location":"discussions/MAINTAINERS/#macos","title":"macOS","text":"<p>Docker seems to be not supported on GitHub Actions macOS servers. The <code>test_macos</code> job installs build dependencies with Homebrew, Python dependencies, it builds Datoviz and it run the test suite.</p> <p>Note that there is a workaround to remove Mono's freetype library which conflicts with Homebrew's one.</p>"},{"location":"discussions/MAINTAINERS/#windows_1","title":"Windows","text":"<p>There is a custom Docker image <code>rossant/datoviz_windows</code> which is however unused at the moment because GitHub Actions Windows servers to not seem to support custom Docker images at the moment.</p> <p>Instead, the job installs dependencies with Chocolatey, vcpkg, the Vulkan SDK, and it extracts the Swiftshader dynamic library. Note that the Swiftshader Windows library is very large (&gt;100 MB) so it is stored as a compressed zip file in the <code>datoviz/data</code> submodule.</p>"},{"location":"discussions/MAINTAINERS/#wheel-building","title":"Wheel building","text":"<p>This workflow is defined in <code>wheels.yml</code></p> <p>For each supported platform, this workflow builds the library in release mode, builds the wheel, renames it for the current platform, and uploads it as a GitHub Actions build artifact.</p> <p>Refer to the Testing workflow for more information about the building process, which is mostly replicated in this workflow.</p>"},{"location":"discussions/MAINTAINERS/#linux-notes","title":"Linux notes","text":"<p>For improved compatibility with Linux Python wheels uploaded to PyPI, it is necessary to build Datoviz on a particular Linux distribution based on AlmaLinux (based on Red Hat Enterprise Linux, REHL).</p> <p>There is a custom Docker image <code>rossant/datoviz_manylinux</code> based on <code>quay.io/pypa/manylinux_2_34_x86_64</code> (see the Dockerfile) with all build dependencies. It also has Swiftshader compiled for this platform.</p>"},{"location":"discussions/MAINTAINERS/#macos-notes","title":"macOS notes","text":"<p>There are two separate jobs for x86_64 and amd64 architectures.</p>"},{"location":"gallery/","title":"Gallery","text":"<p>The Datoviz gallery shows what the library can do through concrete examples. It is divided into three sections.</p> <ul> <li>The showcase section features polished demos based on real-world data.</li> <li>The visuals section shows one example per visual type.</li> <li>The features section focuses on specific API features.</li> </ul>"},{"location":"gallery/#showcase","title":"Showcase","text":"<p>This section highlights polished demos built on real-world datasets.</p> Choropleth map <p></p> LIDAR point cloud Molecule using 3D spheres Mouse brain 3D surface mesh Raster plot with the Pixel visual Scalar field on 3D brain surface mesh Triangle splatting showcase example"},{"location":"gallery/#visuals","title":"Visuals","text":"<p>Each example in this section focuses on a single visual type.</p> Basic visual <p></p> Glyph visual Image visual Marker visual Mesh visual Path visual Pixel visual Point visual Segment visual Sphere visual Volume Wiggle visual"},{"location":"gallery/#features","title":"Features","text":"<p>This section isolates individual features of the Datoviz API. Each example is designed to demonstrate a specific capability.</p> <p>Warning</p> <p>Some examples use GUI elements that are not yet supported in automatic screenshots. As a result, certain screenshots may appear blank. This limitation will be addressed in a future release.</p> Advanced mesh lights <p></p> Animation Arcball Axes Basic visual from a ShapeCollection Camera Camera orbit Canvas presentation timestamps Colorbar Fixed dimensions on a visual Fly camera controller GUI panels GUI widgets Image anchor Keyboard events Light manipulation Mesh visual from an OBJ file Mouse events Panels Polygons Screenshots and offscreen rendering Shapes Sphere visual texture example Stopping an application Surface plot Tiled image grid Timer Toggling visual visibility Transparent meshes Video generation"},{"location":"gallery/features/anchor/","title":"Image anchor","text":"<p>Show how to use the image anchor. The anchor is a pair (x, y) within [-1, +1]^2 that indicates, in normalized coordinates within the image, the position within the image corresponding to the image position specified in Image.set_position(). This normalized coordinate system within the image is centered around the center of the image, x goes right, y goes up.</p> <p>Tags: image, anchor, texture, gui</p> <p>Extra Python dependencies: imageio</p> Python code <pre><code>import imageio.v3 as iio\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_image():\n    filepath = dvz.download_data('textures/image.png')\n    arr = iio.imread(filepath)\n    h, w, _ = arr.shape\n    return np.dstack((arr, np.full((h, w), 255))).astype(np.uint8)\n\n\nimage = load_image()\nheight, width, _ = image.shape\n\nposition = np.array([[0, 0, 0]], dtype=np.float32)\nsize = np.array([[1, 1]], dtype=np.float32)\nanchor = np.array([[0, 0]], dtype=np.float32)\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\n\napp = dvz.App()\nfigure = app.figure(800, 600, gui=True)\npanel = figure.panel(background=True)\npanzoom = panel.panzoom()\n\nvisual = app.image(\n    position=position,\n    size=size,\n    anchor=anchor,\n    texcoords=texcoords,\n    rescale='keep_ratio',\n    unit='ndc',\n)\ntexture = app.texture_2D(image, interpolation='linear')\nvisual.set_texture(texture)\npanel.add(visual)\n\n\nx_anchor = dvz.Out(0.0)\ny_anchor = dvz.Out(0.0)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_size(dvz.vec2(400, 100))\n    dvz.gui_begin('Change the image anchor', 0)\n    has_changed = False\n    has_changed |= dvz.gui_slider('x anchor', -1, +1, x_anchor)\n    has_changed |= dvz.gui_slider('y anchor', -1, +1, y_anchor)\n    dvz.gui_end()\n\n    if has_changed:\n        anchor[0, 0] = x_anchor.value\n        anchor[0, 1] = y_anchor.value\n        visual.set_anchor(anchor)\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/animation/","title":"Animation","text":"<p>Show how to make animations with timers.</p> <p>Tags: point, timer, animation</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\nn = 32\nx, y = np.meshgrid(np.linspace(-1, +1, n), np.linspace(-1, +1, n))\nnn = x.size\nposition = np.c_[x.flat, y.flat, np.zeros(nn)]\ninitial = position.copy()\ncolor = np.random.randint(low=100, high=240, size=(nn, 4)).astype(np.uint8)\nsize = np.full(nn, 20)\n\napp = dvz.App(background='white')\nfigure = app.figure()\npanel = figure.panel()\nvisual = app.point(position=position, color=color, size=size)\npanel.add(visual)\n\n\n# This callback function runs 60x per second.\n@app.timer(period=1.0 / 60.0)\ndef on_timer(e):\n    t = e.time()\n    a = 0.025\n    p = np.linspace(0.5, 2.0, nn)\n    position[:, 0] = initial[:, 0] + a * np.cos(2 * np.pi * p * t)\n    position[:, 1] = initial[:, 1] + a * np.sin(2 * np.pi * p * t)\n    visual.set_position(position)\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/arcball/","title":"Arcball","text":"<p>Show how to manipulate an arcball.</p> <p>Tags: arcball</p> <p></p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\npanel = figure.panel(background=True)\npanel.demo_3D()\n\n# Set initial angles for the arcball (which modifies the model matrix).\narcball = panel.arcball(initial=(-1.5, 0.0, +1.5))\n\n# Display a little GUI widget with sliders to control the arcball angles.\npanel.arcball_gui()\n\n# Angles can be set and retrieved as follows:\nangles = (-1.5, 0.0, +2.5)\narcball.set(angles)\nangles = arcball.get()\nprint('Arcball angles:', angles)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/axes/","title":"Axes","text":"<p>Show how to use 2D axes.</p> <p>Tags: point, axes, mouse</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\nn = 10\nxmin, xmax = 1, 10\nymin, ymax = 100, 1000\nx, y = np.meshgrid(np.linspace(xmin, xmax, n), np.linspace(ymin, ymax, n))\nnn = x.size\ncolor = np.random.randint(low=100, high=240, size=(nn, 4)).astype(np.uint8)\nsize = np.full(nn, 20)\n\napp = dvz.App(background='white')\nfigure = app.figure()\npanel = figure.panel()\naxes = panel.axes((xmin, xmax), (ymin, ymax))\n\nvisual = app.point(\n    position=axes.normalize(x, y),\n    color=color,\n    size=size,\n)\npanel.add(visual)\n\n\n@app.connect(figure)\ndef on_mouse(ev):\n    if ev.mouse_event() == 'drag':\n        xlim, ylim = axes.bounds()\n        print(f'x: [{xlim[0]:g}, {xlim[1]:g}] ; y: [{ylim[0]:g}, {ylim[1]:g}]')\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/basic_shape/","title":"Basic visual from a ShapeCollection","text":"<p>This example demonstrates how to create a Basic visual from a <code>ShapeCollection</code> in Datoviz.</p> <p>Compared to the Mesh visual, the Basic visual is much lighter and more efficient, but it does not support lighting, texturing, or wireframes. It only allows a single color per vertex.</p> <p>Tags: shape, arcball, basic</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n# Load the bunny mesh.\nsc = dvz.ShapeCollection()\nfile_path = dvz.download_data('mesh/bunny.obj')\nsc.add_obj(file_path)\n\n# Initialize the scene.\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=(0.35, 0, 0))\ncamera = panel.camera(initial=(0, 0, 3))\n\n# Random colors.\nnv = sc.vertex_count()\ncolor = np.random.randint(low=0, high=255, size=(nv, 4), dtype=np.uint8)\ncolor[:, 3] = 255  # Set alpha channel to fully opaque.\n\n# Create a basic visual from the ShapeCollection.\nvisual = app.basic(shape=sc, color=color, depth_test=True)\npanel.add(visual)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/camera/","title":"Camera","text":"<p>Show how to manipulate a camera.</p> <p>Tags: camera, keyboard</p> <p></p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\npanel.demo_3D()\n\n# Camera initial parameters (the ones used when calling camera_reset()).\nposition = (0, 0, 2)\nup = (0, 1, 0)\nlookat = (0, 0, 0)\n# Get or create the panel's 3D perspective camera.\ncamera = panel.camera(initial=position, initial_up=up, initial_lookat=lookat)\n\nd = 0.1\nmapping = {\n    'up': (2, -d),\n    'down': (2, +d),\n    'left': (0, -d),\n    'right': (0, +d),\n}\n\n\n@app.connect(figure)\ndef on_keyboard(ev):\n    # Keyboard events are PRESS, RELEASE, and REPEAT.\n    if ev.key_event() != 'release':\n        # Move the camera position depending on the pressed keys.\n        i, dp = mapping.get(ev.key_name(), (0, 0))\n        position = list(camera.position())\n        position[i] += dp\n        lookat = (position[0], position[1], position[2] - 1)\n\n        # Update the camera.\n        camera.set(position=position, lookat=lookat)\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/colorbar/","title":"Colorbar","text":"<p>Show how to display a colorbar.</p> <p>Tags: colorbar</p> <p></p> Python code <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import Out, vec2, vec3\n\n\napp = dvz.App()\nfigure = app.figure(gui=True)\npanel = figure.panel(background=True)\npanel.panzoom()\ncolorbar = figure.colorbar()\n\n\nslider = Out(10.0)\ndropdown = Out(0)\ncmaps = ['hsv', 'viridis', 'magma']\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_pos(vec2(25, 25), vec2(0, 0))\n    dvz.gui_size(vec2(400, 100))\n    dvz.gui_begin('GUI', 0)\n\n    if dvz.gui_dropdown('Colormap', 3, cmaps, dropdown, 0):\n        colorbar.set_cmap(cmaps[dropdown.value])\n\n    if dvz.gui_slider('Range', 1.0, 100.0, slider):\n        colorbar.set_range(slider.value, slider.value * 2)\n\n    dvz.gui_end()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/fixed/","title":"Fixed dimensions on a visual","text":"<p>Show how to fix a visual in the panel on one or several axes.</p> <p>Tags: fixed</p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\nvisual = panel.demo_2D()\nvisual.fixed('y')  # or 'x', or 'z', or 'x, y'... or True for all axes\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/fly/","title":"Fly camera controller","text":"<p>Show how to manipulate a fly camera controller.</p> <ul> <li>Left mouse drag: Look around (yaw/pitch)</li> <li>Right mouse drag: Orbit around a dynamic center (in front of the camera)</li> <li>Middle mouse drag: Move the camera left/right and up/down</li> <li>Arrow keys: Move in view direction (up/down) or strafe (left/right)</li> </ul> <p>Tags: fly</p> <p></p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\n\n# Set a fly camera controller.\nfly = panel.fly(initial=(0, 0.5, 4), initial_lookat=(0, 0, 0))\n\n# Add a horizontal grid.\ngrid = panel.horizontal_grid(elevation=-0.62)\n\n# Add a mesh.\nfile_path = dvz.download_data('mesh/bunny.obj')\nsc = dvz.ShapeCollection()\nsc.add_obj(file_path, contour='full')\nvisual = app.mesh(sc, contour=True, lighting=True)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/gui/","title":"GUI widgets","text":"<p>Show how to create a GUI dialog.</p> <p>Tags: gui, table, tree, widgets</p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\nfrom datoviz import Out, vec2, vec3\n\n# Dialog width.\nw = 300\n\nlabels = ['col0', 'col1', 'col2', '0', '1', '2', '3', '4', '5']\nrows = 2\ncols = 3\nselected = np.array([False, True], dtype=np.bool)\n\n# IMPORTANT: these values need to be defined outside of the GUI callback.\nchecked = Out(True)\ncolor = vec3(0.7, 0.5, 0.3)\n\nslider = Out(25.0)  # Warning: needs to be a float as it is passed to a function expecting a float\ndropdown_selected = Out(1)\n\n# GUI callback function, called at every frame. This is using Dear ImGui, an immediate-mode\n# GUI system. This means the GUI is recreated from scratch at every frame.\n\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    # Set the size of the next GUI dialog.\n    dvz.gui_pos(vec2(25, 25), vec2(0, 0))\n    dvz.gui_size(vec2(w + 20, 550))\n\n    # Start a GUI dialog, specifying a dialog title.\n    dvz.gui_begin('My GUI', 0)\n\n    # Add a button. The function returns whether the button was pressed during this frame.\n    if dvz.gui_button('Button', w, 30):\n        print('button clicked')\n\n    # Create a tree, this call returns True if this node is unfolded.\n    if dvz.gui_node('Item 1'):\n        # Display an item in the tree.\n        dvz.gui_selectable('Hello inside item 1')\n        # Return True if this item was clicked.\n        if dvz.gui_clicked():\n            print('clicked sub item 1')\n        # Go up one level.\n        dvz.gui_pop()\n\n    if dvz.gui_node('Item 2'):\n        if dvz.gui_node('Item 2.1'):\n            dvz.gui_selectable('Hello inside item 2')\n            if dvz.gui_clicked():\n                print('clicked sub item 2')\n            dvz.gui_pop()\n        dvz.gui_pop()\n\n    if dvz.gui_table('table', rows, cols, labels, selected, 0):\n        print('Selected rows:', np.nonzero(selected)[0])\n\n    if dvz.gui_checkbox('Checkbox', checked):\n        print('Checked status:', checked.value)\n\n    if dvz.gui_colorpicker('Color picker', color, 0):\n        print('Color:', color)\n\n    if dvz.gui_slider('Slider', 0.0, 100.0, slider):\n        print('Slider value:', slider.value)\n\n    if dvz.gui_dropdown('Dropdown', 3, ['item 1', 'item 2', 'item 3'], dropdown_selected, 0):\n        print('Dropdown index:', dropdown_selected.value)\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/gui_panel/","title":"GUI panels","text":"<p>Show how to create a GUI panel.</p> <p>Tags: gui_panel</p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\n\n# Create a panel, specifying the panel offset and size (x, y, width, height, in pixels).\npanel1 = figure.panel((50, 50), (300, 300))\npanel1.demo_3D()\n\npanel2 = figure.panel((400, 100), (300, 300))\npanel2.demo_2D()\n\n# We transform the static panels into GUI panels (experimental).\npanel1.gui('First panel')\npanel2.gui('Second panel')\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/hide/","title":"Toggling visual visibility","text":"<p>Show how to show/hide a visual.</p> <p>Tags: gui, show</p> Python code <pre><code>import datoviz as dvz\nfrom datoviz import Out\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\npanel = figure.panel(background=True)\nvisual = panel.demo_2D()\n\nvisible = Out(True)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_begin('GUI', 0)\n    if dvz.gui_checkbox('Visible?', visible):\n        visual.show(visible.value)\n        figure.update()\n    dvz.gui_end()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/keyboard/","title":"Keyboard events","text":"<p>Show how to react to keyboard events.</p> <p>Tags: keyboard</p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\n\n\n@app.connect(figure)\ndef on_keyboard(ev):\n    print(f'{ev.key_event()} key {ev.key()} ({ev.key_name()})')\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/light/","title":"Light manipulation","text":"<p>Show how to manipulate lights.</p> <p>Tags: sphere, light, gui</p> <p></p> Python code <pre><code>import datoviz as dvz\nfrom datoviz import vec4\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\npanel = figure.panel(background=True)\n\nvisual = panel.demo_3D()\n\nlight_pos = (\n    vec4(+0, +0, +5, +1),  # Pos 0  x,y,z\n    vec4(-5, +0, +5, +1),  # Pos 1  x,y,z\n    vec4(+0, +5, +5, +1),  # Pos 2  x,y,z\n    vec4(+5, +0, +5, +1),  # Pos 3  x,y,z\n)\n\nlight_color = (\n    vec4(1, 1, 1, 1),  # White\n    vec4(1, 0, 0, 1),  # Red\n    vec4(0, 1, 0, 1),  # Blue\n    vec4(0, 0, 1, 1),  # Green\n)\n\n\n# GUI callback\ndef update_params():\n    for i in range(4):\n        c = light_color[i]\n        visual.set_light_color(\n            (int(c[0] * 255), int(c[1] * 255), int(c[2] * 255), int(c[3] * 255)), i\n        )\n        visual.set_light_pos(light_pos[i], i)\n    visual.update()\n\n\nupdate_params()\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_size(dvz.vec2(400, 350))\n    dvz.gui_begin('Change the lights', 0)\n    has_changed = False\n    dvz.gui_text('Light 1:')\n    has_changed |= dvz.gui_slider_vec4('Pos 0 XYZ', -20, +20, light_pos[0])\n    has_changed |= dvz.gui_slider_vec4('Color 0 RGBA', 0, 1, light_color[0])\n\n    dvz.gui_text('Light 2:')\n    has_changed |= dvz.gui_slider_vec4('Pos 1 XYZ', -20, +20, light_pos[1])\n    has_changed |= dvz.gui_slider_vec4('Color 1 RGBA', 0, 1, light_color[1])\n\n    dvz.gui_text('Light 3:')\n    has_changed |= dvz.gui_slider_vec4('Pos 2 XYZ', -20, +20, light_pos[2])\n    has_changed |= dvz.gui_slider_vec4('Color 2 RGBA', 0, 1, light_color[2])\n\n    dvz.gui_text('Light 4:')\n    has_changed |= dvz.gui_slider_vec4('Pos 3 XYZ', -20, +20, light_pos[3])\n    has_changed |= dvz.gui_slider_vec4('Color 3 RGBA', 0, 1, light_color[3])\n    dvz.gui_end()\n\n    if has_changed:\n        update_params()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/mesh_light/","title":"Advanced mesh lights","text":"<p>Show how to manipulate advanced mesh lights.</p> <p>Tags: mesh, light</p> <p></p> Python code <pre><code>import datoviz as dvz\nfrom datoviz import Out, vec3, vec4\n\nfile_path = dvz.download_data('mesh/bunny.obj')\n\nlight_pos = (\n    vec4(0, 0, 5, 1),  # Pos 0  x,y,z\n    vec4(-5, 0, 5, 1),  # Pos 1  x,y,z\n    vec4(0, 5, 5, 1),  # Pos 2  x,y,z\n    vec4(5, 0, 5, 1),  # Pos 3  x,y,z\n)\n\nlight_color = (\n    vec4(1, 1, 1, 1),  # White\n    vec4(1, 0, 0, 1),  # Red\n    vec4(0, 1, 0, 1),  # Blue\n    vec4(0, 0, 1, 1),  # Green\n)\n\nmaterial = dict(\n    ambient_params=vec3(0.25, 0.25, 0.25),  # R, G, B levels\n    diffuse_params=vec3(0.75, 0.75, 0.75),\n    specular_params=vec3(0.75, 0.75, 0.75),\n    emission_params=vec3(0.5, 0.5, 0.5),\n    shine=Out(0.5),\n    emit=Out(0.0),\n)\n\n\nsc = dvz.ShapeCollection()\nsc.add_obj(file_path)\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\n\npanel = figure.panel(background=True)\n\narcball = panel.arcball(initial=(0.35, 0, 0))\ncamera = panel.camera(initial=(-0.75, 0, 4), initial_lookat=(-0.75, 0, 0))\nvisual = app.mesh(sc, lighting=True)\nvisual.clip('outer')\npanel.add(visual)\n\n\n# GUI callback\ndef update_params():\n    for i in range(4):\n        c = light_color[i]\n        visual.set_light_color(\n            (int(c[0] * 255), int(c[1] * 255), int(c[2] * 255), int(c[3] * 255)), i\n        )\n        visual.set_light_pos(light_pos[i], i)\n    visual.set_ambient_params(material['ambient_params'])\n    visual.set_diffuse_params(material['diffuse_params'])\n    visual.set_specular_params(material['specular_params'])\n    visual.set_emission_params(material['emission_params'])\n    visual.set_shine(material['shine'].value)\n    visual.set_emit(material['emit'].value)\n    visual.update()\n\n\nupdate_params()\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_size(dvz.vec2(350, 500))\n    dvz.gui_pos(dvz.vec2(20, 20), dvz.vec2(0, 0))\n\n    dvz.gui_begin('Change the light', 0)\n    has_changed = False\n\n    dvz.gui_text('Light 1:')\n    has_changed |= dvz.gui_slider_vec4('Pos 0 XYZ', -20, +20, light_pos[0])\n    has_changed |= dvz.gui_slider_vec4('Color 0 RGBA', 0, 1, light_color[0])\n\n    dvz.gui_text('Light 2:')\n    has_changed |= dvz.gui_slider_vec4('Pos 1 XYZ', -20, +20, light_pos[1])\n    has_changed |= dvz.gui_slider_vec4('Color 1 RGBA', 0, 1, light_color[1])\n\n    dvz.gui_text('Light 3:')\n    has_changed |= dvz.gui_slider_vec4('Pos 2 XYZ', -20, +20, light_pos[2])\n    has_changed |= dvz.gui_slider_vec4('Color 2 RGBA', 0, 1, light_color[2])\n\n    dvz.gui_text('Light 4:')\n    has_changed |= dvz.gui_slider_vec4('Pos 3 XYZ', -20, +20, light_pos[3])\n    has_changed |= dvz.gui_slider_vec4('Color 3 RGBA', 0, 1, light_color[3])\n\n    dvz.gui_text('Material properties:')\n    has_changed |= dvz.gui_slider_vec3('Ambient RGB', 0, 1, material['ambient_params'])\n    has_changed |= dvz.gui_slider_vec3('Diffuse RGB', 0, 1, material['diffuse_params'])\n    has_changed |= dvz.gui_slider_vec3('Specular RGB', 0, 1, material['specular_params'])\n    has_changed |= dvz.gui_slider_vec3('Emission RGB', 0, 1, material['emission_params'])\n    has_changed |= dvz.gui_slider('Shininess level', 0, 1, material['shine'])\n    has_changed |= dvz.gui_slider('Emission level', 0, 1, material['emit'])\n\n    dvz.gui_end()\n\n    if has_changed:\n        update_params()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/mesh_transparent/","title":"Transparent meshes","text":"<p>Show a transparent 3D mesh.</p> <p>Warning</p> <p>Transparency in 3D is difficult to handle correctly. The current implementation is suboptimal. Improved mesh transparency will be introduced in Datoviz v0.4, as it requires changes to the rendering backend.</p> <p>Tags: mesh, transparency, arcball</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\ndata = np.load(dvz.download_data('mesh/brain.npz'))\npos = data['pos']\nnormal = data['normal']\ncolor = data['color']\nindex = data['index']\nnv, ni = pos.shape[0], index.shape[0]\n\nindex = index.reshape((-1, 3))[::-1, :].ravel()\ncolor[:] = (255, 255, 255, 32)\n\nangles = (-2.5, -0.9, -0.1)\n\n# -------------------------------------------------------------------------------------------------\n\napp = dvz.App(background='white')\nfigure = app.figure()\npanel = figure.panel()\narcball = panel.arcball(initial=angles)\n\nvisual = app.mesh(indexed=True, lighting=True, cull='back')\nvisual.set_data(\n    position=pos,\n    normal=normal,\n    color=color,\n    index=index,\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/mouse/","title":"Mouse events","text":"<p>Show how to react to mouse events.</p> <p>Tags: mouse</p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\n\n\n@app.connect(figure)\ndef on_mouse(ev):\n    action = ev.mouse_event()\n    x, y = ev.pos()\n    print(f'{action} ({x:.0f}, {y:.0f}) ', end='')\n\n    if action in ('click', 'double_click'):\n        button = ev.button_name()\n        print(f'{button} button', end='')\n\n    if action in ('drag_start', 'drag_stop', 'drag'):\n        button = ev.button_name()\n        xd, yd = ev.press_pos()\n        print(f'{button} button pressed at ({xd:.0f}, {yd:.0f})', end='')\n\n    if action == 'wheel':\n        w = ev.wheel()\n        print(f'wheel direction {w}', end='')\n\n    print()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/obj/","title":"Mesh visual from an OBJ file","text":"<p>Show the mesh visual with an OBJ file and a 3D gizmo.</p> <p>Tags: mesh, shape, obj, arcball, gizmo</p> <p></p> Python code <pre><code>import datoviz as dvz\n\nfile_path = dvz.download_data('mesh/bunny.obj')\n\nlinewidth = 0.1\nedgecolor = (0, 0, 0, 96)\n\nsc = dvz.ShapeCollection()\nsc.add_obj(file_path, contour='full')\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=(0.35, 0, 0))\ncamera = panel.camera(initial=(0, 0, 3))\n\nvisual = app.mesh(sc, lighting=True, linewidth=linewidth, edgecolor=edgecolor)\npanel.add(visual)\n\n# Add a 3D gizmo.\npanel.gizmo()\n\napp.run()\napp.destroy()\n\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/offscreen/","title":"Screenshots and offscreen rendering","text":"<p>Show how to render an offscreen image.</p> <p>Warning</p> <p>The API for this feature may change in an upcoming version.</p> <p>Tags: offscreen</p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App(offscreen=True)\nfigure = app.figure()\npanel = figure.panel(background=True)\npanel.demo_2D()\n\n# Save a PNG screenshot.\napp.screenshot(figure, 'offscreen_python.png')\n\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/orbit/","title":"Camera orbit","text":"<p>Show how to easily make an animation with a camera orbit</p> <p>Tags: mesh, shape, obj, orbit, grid</p> <p></p> Python code <pre><code>import datoviz as dvz\n\nsc = dvz.ShapeCollection()\nfile_path = dvz.download_data('mesh/bunny.obj')\nsc.add_obj(file_path, contour='full')\nlinewidth = 0.1\nedgecolor = (0, 0, 0, 96)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\ncamera = panel.camera(initial=(0, 1, 3))\npanel.horizontal_grid(elevation=-0.62)\n\nvisual = app.mesh(sc, lighting=True, linewidth=linewidth, edgecolor=edgecolor)\npanel.add(visual)\n\n# Camera orbit with period of 10 seconds.\npanel.orbit(period=20)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/panel/","title":"Panels","text":"<p>Show how to create several panels.</p> <p>Tags: panel, clip</p> <p></p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\n\n# Create two panels side-by-side.\npanel1 = figure.panel((0, 0), (400, 600))\npanel2 = figure.panel((400, 0), (400, 600))\n\n# Add demo visuals to the panels.\nvisual1 = panel1.demo_2D()\nvisual2 = panel2.demo_3D()\n\n# Set some margins for the first panel, which affects the panel's coordinate systems.\n# [-1, +1] map to the \"inner\" viewport.\npanel1.margins(20, 100, 20, 20)  # top, right, bottom, left\n\n# Indicate that the first visual should be hidden inside the margins, outside of [-1, +1].\nvisual1.clip('outer')\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/polygon/","title":"Polygons","text":"<p>Tags: mesh, shape, colormap, polygon, ortho</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef make_polygon(n, center, radius):\n    # WARNING: watch the direction (-t) otherwise the contour_joints won't work!\n    t = np.linspace(0, 2 * np.pi, n + 1) - ((np.pi / 2.0) if n != 4 else np.pi / 4)\n    t = t[:-1]\n    x = center[0] + radius * np.cos(-t)\n    y = center[1] + radius * np.sin(-t)\n    return np.c_[x, y]\n\n\n# Generate the shapes.\nr = 0.25\nw = 0.9\nshapes = []\nsizes = (4, 5, 6, 8)\ncolors = dvz.cmap('BWR', np.linspace(0, 1, 4))\nsc = dvz.ShapeCollection()\nfor n, x, color in zip(sizes, np.linspace(-w, w, 4), colors):\n    points = make_polygon(n, (x, 0), r)\n    sc.add_polygon(points, color=color, contour=True)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\northo = panel.ortho()\n\nvisual = app.mesh(sc, linewidth=15, edgecolor=(255, 255, 255, 200))\npanel.add(visual)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/shapes/","title":"Shapes","text":"<p>Tags: shape, colormap, arcball, mesh</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\nrows = 12\ncols = 16\nN = rows * cols\nt = np.linspace(0, 1, N)\n\nx, y = np.meshgrid(np.linspace(-1, 1, rows), np.linspace(-1, 1, cols))\nz = np.zeros_like(x)\n\noffsets = np.c_[x.flat, y.flat, z.flat]\nscales = 1.0 / rows * (1 + 0.25 * np.sin(5 * 2 * np.pi * t))\ncolors = dvz.cmap('hsv', np.mod(t, 1))\n\nsc = dvz.ShapeCollection()\nfor offset, scale, color in zip(offsets, scales, colors):\n    sc.add_cube(offset=offset, scale=scale, color=color)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=(-1, -0.1, -0.25))\n\nvisual = app.mesh(sc, lighting=True)\n\npanel.add(visual)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/sphere_textures/","title":"Sphere visual texture example","text":"<p>Show the sphere visual with textures, using different projection modes.</p> <p>Tags: sphere, texture</p> <p></p> Python code <pre><code>import numpy as np\nimport imageio.v3 as iio\n\nimport datoviz as dvz\nfrom datoviz import vec3\n\n\ndef load_texture_rgba(path):\n    full_path = dvz.download_data(path)\n    arr = iio.imread(full_path)\n    return arr\n\n\n# Default visual values to save work later.\nvisual_values_defaults = dict(\n    position=np.array(((0.0, 0.0, 0.0),), dtype='f'),\n    color=np.array(((20, 100, 150, 255),)),\n    size=np.array((0.5,), dtype='f'),\n    lighting=True,\n    light_pos=(-30, +30, +100, 1),\n    ambient_params=vec3(0.2, 0.2, 0.2),\n    diffuse_params=vec3(0.9, 0.9, 0.9),\n    specular_params=vec3(0.5, 0.5, 0.5),\n    shine=0.1,\n)\n\n\n# Get app environment.\napp = dvz.App()\n\n\ndef get_visual_data():\n    # list of visual data to add to panel.\n    data = []\n    count = 0\n    spacing = 2\n    pos = np.linspace(0.5, -0.5, spacing)\n\n    # Symbol pattern =============================================================================\n    image = load_texture_rgba('textures/pushpin.png')\n    # Need to pad edges to avoid over stretching the image.\n    p = 100\n    image = np.pad(image, ((p, p), (p, p), (0, 0)), 'constant', constant_values=0)\n\n    values = visual_values_defaults.copy()\n    y, x = divmod(count, spacing)\n    values['position'] = np.array(((-pos[x], pos[y], 0),), dtype='f')\n    values['texture'] = app.texture(image, interpolation='linear', address_mode='repeat')\n    data.append(values)\n    count += 1\n\n    # Symbol pattern with equal_rectangular=True -------------------------------------------------\n    values = values.copy()  # Use previous data.\n    y, x = divmod(count, spacing)\n    values['position'] = np.array(((-pos[x], pos[y], 0),), dtype='f')\n    values['equal_rectangular'] = True\n    data.append(values)\n    count += 1\n\n    # Equal Rectangular Image =====================================================================\n    img = load_texture_rgba('textures/world.200412.3x5400x2700.jpg') / 255\n    a = np.ones_like(img[..., -1])\n    image = np.zeros((img.shape[0], img.shape[1], img.shape[2] + 1), dtype='f')\n    image[:, :, :-1] = img\n    image[:, :, -1] = a\n\n    values = visual_values_defaults.copy()\n    y, x = divmod(count, spacing)\n    values['position'] = np.array(((-pos[x], pos[y], 0),), dtype='f')\n    values['texture'] = app.texture(image, interpolation='linear', address_mode='repeat')\n    data.append(values)\n    count += 1\n\n    # Equal rectangular Image with equal_rectangular=True ----------------------------------------\n    values = values.copy()  # Start this one with previous data.\n    y, x = divmod(count, spacing)\n    values['position'] = np.array(((-pos[x], pos[y], 0),), dtype='f')\n    values['equal_rectangular'] = True\n    data.append(values)\n    count += 1\n\n    return data\n\n\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball()\n\n# Create visuals from visual data.\ndata = get_visual_data()\nfor visual_data in data:\n    visual = app.sphere(**visual_data)\n    panel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/stop/","title":"Stopping an application","text":"<p>Show how to stop the application while it is running.</p> <p>Tags: stop, timer</p> Python code <pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\npanel.demo_2D()\n\n\n# This call will stop the application after 500 ms.\n@app.timer(delay=0.5)\ndef on_timer(ev):\n    app.stop()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/surface/","title":"Surface plot","text":"<p>Show a rotating surface in 3D.</p> <p>Tags: background, colormap, shape, arcball, mesh</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\nHAS_CONTOUR = True\n\n# Grid parameters.\nrow_count = 200\ncol_count = row_count\n# n = row_count * col_count\n\n# Allocate heights and colors arrays.\ngrid = np.meshgrid(row_count, col_count)\nshape = (row_count, col_count)\nheights = np.zeros(shape, dtype=np.float32)\n\n# Create grid of coordinates\nx = np.arange(col_count)\ny = np.arange(row_count)\nxv, yv = np.meshgrid(x, y)\n\n# Distances.\ncenter_x = col_count / 2\ncenter_y = row_count / 2\nd = np.sqrt((xv - center_x) ** 2 + (yv - center_y) ** 2)\n\n# Heights.\na = 4.0 * 2 * np.pi / row_count\nb = 3.0 * 2 * np.pi / col_count\nc = 0.5\nhmin = -0.5\nhmax = +0.5\nheights = np.exp(-0.0001 * d**2) * np.sin(a * xv) * np.cos(b * yv)\n\n# Colors.\ncolors = dvz.cmap('plasma', heights, hmin, hmax)\n\nlinewidth = 0.1\nedgecolor = (0, 0, 0, 64)\n\n# -------------------------------------------------------------------------------------------------\n\nsc = dvz.ShapeCollection()\nsc.add_surface(heights=heights, colors=colors, contour='edges')\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=(0.41, -0.95, 0))\ncamera = panel.camera(initial=(0, 0, 3))\n\nvisual = app.mesh(sc, lighting=True, contour=HAS_CONTOUR, linewidth=linewidth, edgecolor=edgecolor)\n\npanel.add(visual)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/tile/","title":"Tiled image grid","text":"<p>Split an image into a grid of smaller images displayed using a single image visual.</p> <p>Tags: image, texture, panzoom</p> <p>Extra Python dependencies: imageio</p> <p></p> Python code <pre><code>import imageio.v3 as iio\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_image():\n    filepath = dvz.download_data('textures/image.png')\n    arr = iio.imread(filepath)\n    h, w, _ = arr.shape\n    return np.dstack((arr, np.full((h, w), 255))).astype(np.uint8)\n\n\n# Grid parameters\ncols, rows = 16, 12\nN = cols * rows\nmargin = 0.005\n\n\nimage = load_image()\nheight, width, _ = image.shape\n\n# Compute tile size in NDC\nextent = 2.0  # NDC range [-1, +1]\ntile_w = (extent - margin * (cols + 1)) / cols\ntile_h = (extent - margin * (rows + 1)) / rows\n\n# Compute NDC centers of tiles\nx_lin = np.linspace(-1 + margin + tile_w / 2, 1 - margin - tile_w / 2, cols)\ny_lin = np.linspace(-1 + margin + tile_h / 2, 1 - margin - tile_h / 2, rows)\nx_ndc, y_ndc = np.meshgrid(x_lin, y_lin[::-1])\nposition = (\n    np.stack([x_ndc, y_ndc, np.zeros_like(x_ndc)], axis=-1).reshape(-1, 3).astype(np.float32)\n)\n\nsize = np.full((N, 2), [tile_w, tile_h], dtype=np.float32)\n\nfigure_aspect = 4 / 3.0\nu_range = figure_aspect\nv_range = 1.0\nu = np.linspace(-1.333, +2.333, cols + 1)\nv = np.linspace(-1.5, 1.5, rows + 1)\nu0, v0 = np.meshgrid(u[:-1], v[:-1])\nu1, v1 = np.meshgrid(u[1:], v[1:])\ntexcoords = np.stack([u0, v0, u1, v1], axis=-1).reshape(-1, 4).astype(np.float32)\n\n# Set up Datoviz\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.image(\n    position=position,\n    size=size,\n    unit='ndc',\n    texcoords=texcoords,\n)\ntexture = app.texture_2D(image, address_mode='repeat', interpolation='linear')\nvisual.set_texture(texture)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/timer/","title":"Timer","text":"<p>Show how to use timers.</p> <p>Tags: glyph, timer</p> <p></p> Python code <pre><code>import datoviz as dvz\n\ncolor = [255, 255, 255, 255]\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\nvisual = app.glyph(font_size=84)\nvisual.set_strings(['Starting timer...'], color=color)\npanel.add(visual)\n\n\n@app.timer(period=0.5, delay=0.5, max_count=6)\ndef on_timer(e):\n    t = e.time()\n    i = e.tick()\n    visual.set_strings([f'tick #{i}/5    t={t:.1f}'], color=color)\n    if i &gt; 5:\n        visual.set_strings(['Timer stopped.'], color=color)\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/timestamps/","title":"Canvas presentation timestamps","text":"<p>Show how to retrieve the exact timestamps of the presentation of the last frames to the screen. This may be useful in specific use-cases (e.g. hardware synchronization in scientific experimental setups).</p> <p>Tags: timer, timestamps</p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanel.demo_2D()\n\n\n@app.timer(delay=0.0, period=1.0, max_count=0)\ndef on_timer(ev):\n    # Every second, we show the timestamps of the last `count` frames.\n    # NOTE: it is currently impossible to call dvz.app_timestamps() after the window was closed.\n    # The timestamps are automatically recorded at every frame, this call fetches the last 5.\n    seconds, nanoseconds = app.timestamps(figure, 5)\n\n    # We display the values.\n    print('Last 5 frames:')\n    print(np.c_[seconds, nanoseconds])\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/features/video/","title":"Video generation","text":"<p>Show how to generate an offscreen video.</p> <p>Warning</p> <p>This feature is experimental, the API is likely to change in a future version.</p> <p>Tags: offscreen, video</p> <p>Extra Python dependencies: imageio, tqdm</p> Python code <pre><code>import os\n\nimport numpy as np\n\ntry:\n    import imageio\n    import tqdm\nexcept ImportError:\n    print('This example requires the tqdm and imageio dependencies. Aborting')\n    exit()\n\nimport datoviz as dvz\nfrom datoviz import vec3\n\n# Image size.\nWIDTH, HEIGHT = 1920, 1280\n\n# Initialize Datoviz scene.\nserver = dvz.server(0)\nscene = dvz.scene(None)\nbatch = dvz.scene_batch(scene)\nfigure = dvz.figure(scene, WIDTH, HEIGHT, 0)\npanel = dvz.panel_default(figure)\nvisual = dvz.demo_panel_3D(panel)\narcball = dvz.panel_arcball(panel, 0)\ncamera = dvz.panel_camera(panel, 0)\n\n\n# Rendering function.\ndef render(angle):\n    # Update the arcball angle.\n    dvz.arcball_set(arcball, vec3(0, angle, 0))\n    dvz.panel_update(panel)\n\n    # Render the scene.\n    dvz.scene_render(scene, server)\n\n    # Get the image as a NumPy array (3*uint8 for RGB components).\n    rgb = dvz.server_grab(server, dvz.figure_id(figure), 0)\n    img = dvz.utils.pointer_image(rgb, WIDTH, HEIGHT)\n    return img\n\n\n# Make the video.\nfps = 60  # number of frames per second in the video\nlaps = 1  # number of rotations\nlap_duration = 4.0  # duration of each rotation\nframe_count = int(lap_duration * laps * fps)  # total number of frames to generate\n# path to video file to write\noutput_file = 'video.mp4'\nkwargs = dict(\n    fps=fps,\n    format='FFMPEG',\n    mode='I',\n    # Quality FFMPEG presets\n    codec='libx264',\n    output_params=(\n        '-preset slow -crf 18 -color_range 1 -colorspace bt709 '\n        '-color_primaries bt709 -color_trc bt709'\n    ).split(' '),\n    pixelformat='yuv420p',\n)\nif 'DVZ_CAPTURE' not in os.environ:  # HACK: avoid recording the video with `just runexamples`\n    with imageio.get_writer(output_file, **kwargs) as writer:\n        for angle in tqdm.tqdm(np.linspace(0, 2 * np.pi, frame_count)[:-1]):\n            writer.append_data(render(angle))\n\n# Cleanup.\ndvz.server_destroy(server)\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/brain_field/","title":"Scalar field on 3D brain surface mesh","text":"<p>Show a 3D mesh with a scalar field colored with a colormap.</p> <p>Tags: mesh, arcball</p> <p>Extra Python dependencies: nibabel, nilearn</p> <p></p> Python code <pre><code>import nibabel as nib\nimport numpy as np\nfrom nilearn import datasets\n\nimport datoviz as dvz\n\n# -------------------------------------------------------------------------------------------------\n# Brain with scalar field\n# -------------------------------------------------------------------------------------------------\n\nfsaverage = datasets.fetch_surf_fsaverage()\n\n\ndef process_hemisphere(pial_path, sulc_path):\n    coords, faces = nib.load(pial_path).darrays[0].data, nib.load(pial_path).darrays[1].data\n    sulc_map = nib.load(sulc_path).darrays[0].data\n\n    pos = coords.astype(np.float32)\n    index = faces.ravel().astype(np.uint32)\n\n    normals = np.zeros_like(pos, dtype=np.float32)\n    dvz.compute_normals(pos.shape[0], index.size, pos, index, normals)\n\n    colors = dvz.cmap('binary', sulc_map.astype(np.float32), sulc_map.min(), sulc_map.max())\n\n    return pos, normals, colors, index\n\n\n# Process left hemisphere\nleft_pos, left_normals, left_colors, left_index = process_hemisphere(\n    fsaverage.pial_left, fsaverage.sulc_left\n)\n\n# Process right hemisphere\nright_pos, right_normals, right_colors, right_index = process_hemisphere(\n    fsaverage.pial_right, fsaverage.sulc_right\n)\n\n# Combine left and right hemispheres\npos = np.vstack((left_pos, right_pos))\nnormals = np.vstack((left_normals, right_normals))\ncolors = np.vstack((left_colors, right_colors))\nindex_offset = left_pos.shape[0]\nindex = np.hstack((left_index, right_index + index_offset))\n\n# Normalize after concatenation\ncenter = np.mean(pos, axis=0)\nscale = (pos.max(axis=0) - pos.min(axis=0)).max() / 2\npos = (pos - center) / scale\n\n# -------------------------------------------------------------------------------------------------\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=(-1.5, 0.15, 1.5))\ncamera = panel.camera(initial=(0, 0, 3))\n\nvisual = app.mesh(indexed=True, lighting=True)\nvisual.set_data(\n    position=pos,\n    normal=normals,\n    color=colors,\n    index=index,\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/choropleth/","title":"Choropleth map","text":"<p>This example demonstrates how to create a choropleth map using polygons. It loads polygon data from a NumPy file, generates a unique color for each polygon, and visualizes them using the Mesh visual. The polygons are displayed with contours.</p> <p>A Basic visual could also have been used, but it would not support contours.</p> <p>Warning</p> <p>There may be visual artifacts along the contours of highly irregular polygons, such as those in this example. These can be resolved with a more robust triangulation algorithm. Improvements are planned for a future release.</p> <p>Tags: mesh, shape, colormap, polygon, ortho, choropleth</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n# Load polygons from france.npz\ndata = np.load(dvz.download_data('misc/france.npz'))\narrays = [data[key] for key in data]\n\n# Generate unique colors\ncolors = dvz.cmap('viridis', np.linspace(0, 1, len(arrays)))\n\n# Create shape collection and add polygons\nsc = dvz.ShapeCollection()\nfor points, color in zip(arrays, colors):\n    sc.add_polygon(points, color=color, contour=True)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\northo = panel.ortho()\n\nvisual = app.mesh(sc, linewidth=1, edgecolor=(0, 0, 0, 64))\npanel.add(visual)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/lidar/","title":"LIDAR point cloud","text":"<p>Data origin: https://lidarpayload.com/sample-data/, RESEPI-M2X-100m10ms-FOV90-On RangerPro.laz</p> <p>Tags: pixel, fly</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\ndata = np.load(dvz.download_data('misc/lidar.npz'))\npos, color = data['pos'], data['color']\nprint(f'Loaded LIDAR data with {len(pos)} points.')\nN = pos.shape[0]\npos *= 5\n\n# -------------------------------------------------------------------------------------------------\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\nfly = panel.fly(initial=(+2, 2.0, -6), initial_lookat=(0, -1, 0))\n\nvisual = app.pixel(position=pos, color=color, size=2, depth_test=True)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/molecule/","title":"Molecule using 3D spheres","text":"<p>Tags: sphere, arcball</p> <p></p> Python code <pre><code>import glob\nfrom pathlib import Path\n\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_data():\n    # comes from: https://www.rcsb.org/structure/6QZP\n    import MDAnalysis as mda\n\n    ROOT_DIR = Path(__file__).resolve().parent.parent.parent\n    files = sorted(glob.glob(str(ROOT_DIR / 'data/misc/molecule/6qzp-pdb-bundle*.pdb')))\n    universes = [mda.Universe(f) for f in files]\n\n    position = np.concatenate([u.atoms.positions for u in universes], axis=0)\n\n    element_colors_u8 = {\n        'H': (255, 255, 255),\n        'C': (200, 200, 200),\n        'N': (143, 143, 255),\n        'O': (240, 0, 0),\n        'S': (255, 200, 50),\n        'P': (255, 165, 0),\n        'Mg': (42, 128, 42),\n        'Zn': (165, 42, 42),\n    }\n\n    color = np.concatenate(\n        [\n            np.array([element_colors_u8[atom.element] for atom in u.atoms], dtype=np.uint8)\n            for u in universes\n        ],\n        axis=0,\n    )\n\n    color = np.concatenate([color, np.full((len(color), 1), 255, dtype=np.uint8)], axis=1)\n\n    vdw_radii = {\n        'H': 1.20,\n        'C': 1.70,\n        'N': 1.55,\n        'O': 1.52,\n        'S': 1.80,\n        'P': 1.80,\n        'Mg': 1.73,\n        'Zn': 1.39,\n    }\n\n    atomic_radii = np.concatenate(\n        [np.array([vdw_radii[atom.element] for atom in u.atoms]) for u in universes]\n    )\n    size = atomic_radii.astype(np.float32)\n    return position, color, size\n\n\n# # Save the data file\n# p, c, s = load_data()\n# np.savez(ROOT_DIR / 'data/misc/molecule/mol.npz', position=p, color=c, size=s)\n\n\n# Load the data\ndata = np.load(dvz.download_data('misc/molecule/mol.npz'))\nposition = data['position']\ncolor = data['color']\nsize = data['size']\nN = len(position)\nprint(f'Loaded {N} atoms')\n\n\n# Normalization.\nposition -= position.mean(axis=0)\nposition /= np.max(np.linalg.norm(position, axis=1))\nsize = 0.005 + 0.015 * (size - size.min()) / (size.max() - size.min()).astype(np.float32)\n\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball()\ncamera = panel.camera()\n\nvisual = app.sphere(\n    position=position,\n    color=color,\n    size=size,\n    lighting=True,\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/mouse_brain/","title":"Mouse brain 3D surface mesh","text":"<p>Show a 3D mesh.</p> <p>Tags: mesh, arcball</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\ndata = np.load(dvz.download_data('mesh/brain.npz'))\npos = data['pos']\nnormal = data['normal']\ncolor = data['color']\nindex = data['index']\nnv, ni = pos.shape[0], index.shape[0]\n\n\nangles = (-2.4, -0.9, 0.1)\n\n# -------------------------------------------------------------------------------------------------\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=angles)\n\nvisual = app.mesh(indexed=True, lighting=True)\nvisual.set_data(\n    position=pos,\n    normal=normal,\n    color=color,\n    index=index,\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/raster/","title":"Raster plot with the Pixel visual","text":"<p>Show a raster plot (spikes in 2D, time on the x axis, neuron depth on the y axis) using the Pixel visual.</p> <p>Tags: pixel, panzoom</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\nN = 1_000_000  # maximum number of spikes\n\n# Load the data.\ndata = np.load(dvz.download_data('misc/raster_1M.npz'))\nt = data['times'][:N]  # Spike times in seconds\nd = data['depths'][:N]  # Depth in microns\n\n# Normalization.\nt_min, t_max = t.min(), t.max()\nt_norm = 2 * (t - t_min) / (t_max - t_min) - 1\n\nd_min, d_max = d.min(), d.max()\nd_norm = 2 * (d - d_min) / (d_max - d_min) - 1\n\npositions = np.c_[t_norm, d_norm, np.zeros_like(t_norm)].astype(np.float32)\nnum_points = positions.shape[0]\n\ncolors = np.full((num_points, 4), 0, dtype=np.uint8)\ncolors[:] = dvz.cmap('kg', d, d_min, d_max)\ncolors[:, 3] = 64\n\n# -------------------------------------------------------------------------------------------------\n\napp = dvz.App(background='white')\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.pixel(position=positions, color=colors)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/showcase/splatting/","title":"Triangle splatting showcase example","text":"<p>Show triangle splatting using the Basic visual, data obtained from the 2025 paper Triangle Splatting for Real-Time Radiance Field Rendering by Held et al., 2025.</p> <p>Use the fly camera controller to navigate in the 3D scene:</p> <ul> <li>Left mouse drag: Look around (yaw/pitch)</li> <li>Right mouse drag: Orbit around a dynamic center (in front of the camera)</li> <li>Middle mouse drag: Move the camera left/right and up/down</li> <li>Arrow keys: Move in view direction (up/down) or strafe (left/right)</li> </ul>"},{"location":"gallery/showcase/splatting/#credits","title":"Credits","text":"<p>Dataset kindly provided by Jan Held.</p> <ul> <li>Github repo</li> <li>Project page</li> <li>Paper</li> </ul> <p>Tags: basic, splatting, fly, orbit</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef load_data(filepath):\n    data = np.load(filepath)\n    position = data['position']\n    color = data['color']\n\n    # Data transformation\n    position[:, 0] *= -1\n    position[:, 1] *= -1\n    position[:, 0] += 0.30\n    position[:, 1] += 0.5\n    position[:, 2] -= 0.5\n    angle = -0.5\n    rot = np.array(\n        [\n            [1, 0, 0],\n            [0, np.cos(angle), -np.sin(angle)],\n            [0, np.sin(angle), np.cos(angle)],\n        ]\n    )\n    position = position @ rot\n\n    return position, color\n\n\n# Use either interactive fly camera or orbit animation\nORBIT = True\n\nposition, color = load_data(dvz.download_data('misc/garden.npz'))\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\nif not ORBIT:\n    fly = panel.fly()\ncamera = panel.camera(initial=(-3, 1, 3))\n\nvisual = app.basic(\n    'triangle_list',\n    position=position,\n    color=color,\n    depth_test=True,\n)\npanel.add(visual)\n\nif ORBIT:\n    panel.orbit(period=20)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/basic/","title":"Basic visual","text":"<p>Show the basic visual with line strip topology and groups.</p> <p>Tags: basic, panzoom</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data(n_groups=20, n_samples=1_000):\n    N = n_groups * n_samples\n\n    t = np.linspace(-1, 1, n_samples)\n    group_indices = np.arange(n_groups)\n    y_base = np.linspace(-1, 1, n_groups)\n\n    positions = np.zeros((N, 3), dtype=np.float32)\n    groups = np.zeros(N, dtype=np.float32)\n\n    for i, g in enumerate(group_indices):\n        freq = 1 + 2 * np.exp(0.15 * i)\n        phase = g * np.pi / 4\n        y_offset = y_base[i]\n        y = y_offset + 0.1 * np.sin(2 * np.pi * freq * (t + 1) / 2 + phase)\n\n        start = i * n_samples\n        end = (i + 1) * n_samples\n        positions[start:end, 0] = t\n        positions[start:end, 1] = y\n        positions[start:end, 2] = 0.0\n        groups[start:end] = float(g)\n\n    t = np.linspace(0, n_groups - 0.25, N)\n    t = np.mod(t, 1).astype(np.float32)\n    colors = dvz.cmap('hsv', t, 0, 1)\n    positions[:, 1] *= 0.9\n    return N, positions, colors, groups\n\n\nN, position, color, group = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.basic('line_strip', position=position, color=color, group=group)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/glyph/","title":"Glyph visual","text":"<p>Show the glyph visual.</p> <p>Tags: glyph, colormap, panzoom</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\n# Define the strings and string parameters.\nstrings = ['Hello world'] * 8\nstring_count = len(strings)\nglyph_count = sum(map(len, strings))\nstring_pos = np.zeros((string_count, 3), dtype=np.float32)\nstring_pos[:, 0] = -0.8\nstring_pos[:, 1] = 1 - 1.8 * np.linspace(0.3, 1, string_count) ** 2\nscales = np.linspace(1, 4, string_count).astype(np.float32)\n\n# Per-glyph parameters.\ncolors = dvz.cmap('hsv', np.mod(np.linspace(0, 2, glyph_count), 1))\n\nvisual = app.glyph(font_size=30)\nvisual.set_strings(strings, string_pos=string_pos, scales=scales)\nvisual.set_color(colors)\n\npanel.add(visual)\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/image/","title":"Image visual","text":"<p>Show the image visual.</p> <p>Tags: image, panzoom, texture</p> <p>Extra Python dependencies: imageio</p> <p></p> Python code <pre><code>import imageio.v3 as iio\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_image():\n    filepath = dvz.download_data('textures/image.png')\n    arr = iio.imread(filepath)\n    h, w, _ = arr.shape\n    return np.dstack((arr, np.full((h, w), 255))).astype(np.uint8)\n\n\nimage = load_image()\nheight, width, _ = image.shape\n\nposition = np.array([[0, 0, 0]], dtype=np.float32)\nsize = np.array([[width, height]], dtype=np.float32)\nanchor = np.array([[0, 0]], dtype=np.float32)\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.image(\n    rescale='keep_ratio',\n    position=position,\n    size=size,\n    anchor=anchor,\n    texcoords=texcoords,\n    #\n    # Image border\n    linewidth=10,\n    edgecolor=(255, 255, 255, 255),\n    radius=50,\n)\ntexture = app.texture_2D(image, interpolation='linear')  # by default, no interpolation\nvisual.set_texture(texture)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/marker/","title":"Marker visual","text":"<p>Show the different types of marker visuals.</p> <p>Tags: marker, texture, svg</p> <p>Extra Python dependencies: imageio</p> <p></p> Python code <pre><code>from pathlib import Path\n\nimport imageio.v3 as iio\nimport numpy as np\n\nimport datoviz as dvz\n\nROOT_DIR = Path(__file__).resolve().parent.parent.parent\nW, H = 800, 600\nHW, HH = W / 2.0, H / 2.0\nsvg_path = 'M50,10 L61.8,35.5 L90,42 L69,61 L75,90 L50,75 L25,90 L31,61 L10,42 L38.2,35.5 Z'\n\n\ndef generate_data():\n    grid_x = 6\n    grid_y = 5\n    N = grid_x * grid_y\n\n    # Grid coordinates in [-1, 1]\n    x = np.linspace(-1, 1, grid_x)\n    y = np.linspace(-1, 1, grid_y)\n    X, Y = np.meshgrid(x, y)\n    x_flat = X.flatten()\n    y_flat = Y.flatten()\n    z_flat = np.zeros_like(x_flat)\n\n    positions = np.stack([x_flat, y_flat, z_flat], axis=1).astype(np.float32)\n    positions *= 0.8  # margin\n\n    # Hue along x-axis\n    hue = (x_flat + 1) / 2\n    colors = dvz.cmap('hsv', hue)\n\n    # Size: exponential growth from 10px to 50px along y-axis\n    y_norm = (y_flat + 1) / 2\n    sizes = 25 * 2.0**y_norm\n    sizes = sizes.astype(np.float32)\n\n    return N, positions, colors, sizes\n\n\ndef load_texture_rgba(path):\n    arr = iio.imread(path)\n    return arr\n\n\ndef make_texture(image):\n    assert image.ndim == 3\n    assert image.shape[2] == 4\n    assert image.dtype == np.uint8\n    return app.texture(image)\n\n\ndef make_svg_msdf_texture(svg_path, size=64):\n    msdf = dvz.msdf_from_svg(svg_path, size, size)\n    msdf_alpha = np.empty((size, size, 4), dtype=np.float32)\n    dvz.rgb_to_rgba_float(size * size, msdf, msdf_alpha.ravel())\n    return app.texture(msdf_alpha)\n\n\ndef make_visual(panel):\n    N, position, color, size = generate_data()\n    angle = np.linspace(0, 2 * np.pi, N)\n    visual = app.marker(\n        position=position,\n        color=color,\n        size=size,\n        angle=angle,\n        edgecolor=(255, 255, 255, 255),\n        linewidth=2.0,\n    )\n    panel.add(visual)\n    return visual\n\n\napp = dvz.App()\nfigure = app.figure()\n\n# Code Outline\npanel = figure.panel(offset=(0, 0), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_mode('code')\nvisual.set_aspect('outline')\nvisual.set_shape('club')  # pre-defined shapes coded in the shaders\n\n# Bitmap\npanel = figure.panel(offset=(HW, 0), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_mode('bitmap')\nvisual.set_aspect('filled')\nvisual.set_shape('club')\nimage = load_texture_rgba(dvz.download_data('textures/pushpin.png'))\ntexture = make_texture(image)\nvisual.set_texture(texture)  # bitmap textures\n\n# Code Stroke\npanel = figure.panel(offset=(0, HH), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_mode('code')\nvisual.set_aspect('stroke')\nvisual.set_shape('spade')\n\n# SVG\npanel = figure.panel(offset=(HW, HH), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_tex_scale(100)  # Important: let the visual know about the texture size\nvisual.set_mode('msdf')\nvisual.set_aspect('outline')\nmsdf = make_svg_msdf_texture(svg_path, size=100)\nvisual.set_texture(msdf)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/mesh/","title":"Mesh visual","text":"<p>Show the mesh visual with predefined shapes.</p> <p>Tags: mesh, shape, arcball</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\nN = 5\ncolors = dvz.cmap('spring', np.linspace(0, 1, N))\nscale = 0.35\n\nsc = dvz.ShapeCollection()\nsc.add_tetrahedron(offset=(-1, 0.5, -0.5), scale=scale, color=colors[0])\nsc.add_hexahedron(offset=(0, 0.5, -0.5), scale=scale, color=colors[1])\nsc.add_octahedron(offset=(1, 0.5, -0.5), scale=scale, color=colors[2])\nsc.add_dodecahedron(offset=(-0.5, -0.5, 0), scale=scale, color=colors[3])\nsc.add_icosahedron(offset=(+0.5, -0.5, 0), scale=scale, color=colors[4])\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\narcball = panel.arcball()  # initial=(-2, 0, 0))\n\nvisual = app.mesh(sc, lighting=True)\n\npanel.add(visual)\n\napp.run()\napp.destroy()\n\nsc.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/path/","title":"Path visual","text":"<p>Show the path visual.</p> <p>Tags: path, panzoom</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data(n_groups=20, n_samples=10_000):\n    N = n_groups * n_samples\n\n    t = np.linspace(-1, 1, n_samples)\n    group_indices = np.arange(n_groups)\n    y_base = np.linspace(-1, 1, n_groups)\n\n    positions = np.zeros((N, 3), dtype=np.float32)\n    linewidths = np.zeros(N, dtype=np.float32)\n\n    for i, g in enumerate(group_indices):\n        freq = 1 + 1.5 * np.exp(0.1 * i)\n        phase = g * np.pi / 4\n        y_offset = y_base[i]\n        y = y_offset + 0.1 * np.sin(2 * np.pi * freq * (t + 1) / 2 + phase)\n\n        start = i * n_samples\n        end = (i + 1) * n_samples\n        positions[start:end, 0] = t\n        positions[start:end, 1] = y\n        positions[start:end, 2] = 0.0\n\n    t = np.linspace(0, n_groups - 0.25, N).astype(np.float32)\n    t = np.mod(t, 1)\n    colors = dvz.cmap('hsv', t, 0, 1)\n\n    positions[:, 0] *= 0.9\n    positions[:, 1] *= 0.8\n\n    linewidths = np.linspace(0, 1, N)\n    linewidths = 8 + 6 * np.sin(2 * (n_groups - 1) * np.pi * linewidths)\n    linewidths = linewidths.astype(np.float32)\n\n    return N, positions, colors, linewidths\n\n\nn_groups = 20\nn_samples = 1_000\nN = n_groups * n_samples\nN, position, color, linewidth = generate_data(n_groups=n_groups, n_samples=n_samples)\nlengths = np.full(n_groups, n_samples, dtype=np.uint32)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.path()\nvisual.set_position(position, groups=n_groups)\nvisual.set_data(color=color, linewidth=linewidth, cap='round', join='round')\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/pixel/","title":"Pixel visual","text":"<p>Show the pixel visual.</p> <p>Tags: pixel, panzoom</p> <p>Extra Python dependencies: matplotlib</p> <p></p> Python code <pre><code>import matplotlib.colors as mcolors\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    \"\"\"Return N, positions (N,3) float32, colors (N,4) uint8\"\"\"\n    # Parameters\n    n_arms = 5\n    n_particles_per_arm = 200_000\n    n_total = n_arms * n_particles_per_arm\n\n    rng = np.random.default_rng(seed=42)\n\n    # Radius from center, with more points toward center\n    r = rng.power(2.0, size=n_total)  # values in [0, 1), biased toward 0\n\n    # Angle with swirl per arm and some noise\n    base_theta = np.repeat(np.linspace(0, 2 * np.pi, n_arms, endpoint=False), n_particles_per_arm)\n    swirl = r * 3  # spiral effect\n    noise = rng.normal(scale=0.2, size=n_total)\n    theta = base_theta + swirl + noise\n\n    # Convert polar to Cartesian\n    x = r * np.cos(theta) * 6.0 / 8.0  # HACK: window aspect ratio\n    y = r * np.sin(theta)\n    z = np.zeros_like(x)\n\n    positions = np.stack([x, y, z], axis=1).astype(np.float32)\n\n    # Colors based on radius and angle \u2014 create a vibrant, cosmic feel\n    hue = (theta % (2 * np.pi)) / (2 * np.pi)  # hue from angle\n    saturation = np.clip(r * 1.5, 0.2, 1.0)  # more saturated at edges\n    value = np.ones_like(hue)\n\n    # Convert HSV to RGB\n\n    rgb = mcolors.hsv_to_rgb(np.stack([hue, saturation, value], axis=1))\n    rgb_u8 = (rgb * 255).astype(np.uint8)\n\n    # Alpha: slight fade with radius\n    alpha = np.clip(128 * (1.0 - r), 1, 255).astype(np.uint8)\n    alpha = (200 * np.exp(-5 * r * r)).astype(np.uint8)\n\n    colors = np.concatenate([rgb_u8, alpha[:, None]], axis=1)\n\n    return n_total, positions, colors\n\n\nN, position, color = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.pixel(position=position, color=color)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/point/","title":"Point visual","text":"<p>Show the point visual.</p> <p>Tags: point, panzoom</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    grid_x = 16\n    grid_y = 12\n    N = grid_x * grid_y\n\n    # Grid coordinates in [-1, 1]\n    x = np.linspace(-1, 1, grid_x)\n    y = np.linspace(-1, 1, grid_y)\n    X, Y = np.meshgrid(x, y)\n    x_flat = X.flatten()\n    y_flat = Y.flatten()\n    z_flat = np.zeros_like(x_flat)\n\n    positions = np.stack([x_flat, y_flat, z_flat], axis=1).astype(np.float32)\n    positions *= 0.90  # margin\n\n    # Hue along x-axis\n    hue = (x_flat + 1) / 2\n    colors = dvz.cmap('hsv', hue)\n\n    # Size: exponential growth from 10px to 50px along y-axis\n    y_norm = (y_flat + 1) / 2\n    sizes = 10 * 4.0**y_norm\n    sizes = sizes.astype(np.float32)\n\n    return N, positions, colors, sizes\n\n\nN, position, color, size = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.point(position=position, color=color, size=size)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/segment/","title":"Segment visual","text":"<p>Show the segment visual.</p> <p>Tags: segment, colormap, panzoom</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    N = 16\n\n    x = np.linspace(-1, 1, N).astype(np.float32) * 0.9\n    y0 = -0.5\n    y1 = 0.5\n    z = 0.0\n\n    initial = np.stack([x, np.full(N, y0), np.full(N, z)], axis=1).astype(np.float32)\n    terminal = np.stack([x, np.full(N, y1), np.full(N, z)], axis=1).astype(np.float32)\n\n    linewidths = np.linspace(2, 30, N).astype(np.float32)\n\n    t = np.linspace(0, 1, N).astype(np.float32)\n    colors = dvz.cmap('hsv', t, 0.0, 1.0)\n\n    return N, initial, terminal, colors, linewidths\n\n\nN, initial, terminal, color, linewidth = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.segment(\n    initial=initial,\n    terminal=terminal,\n    color=color,\n    linewidth=linewidth,\n    cap=('round', 'round'),\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/sphere/","title":"Sphere visual","text":"<p>Show the sphere visual.</p> <p>Tags: sphere, arcball</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_ndc_grid(n):\n    lin = np.linspace(-1, 1, n)\n    x, y, z = np.meshgrid(lin, lin, lin, indexing='ij')\n    positions = np.stack([x, y, z], axis=-1).reshape(-1, 3)\n\n    # Normalize each coordinate to [0, 1] for radius/color mapping\n    x_norm = (x + 1) / 2\n    y_norm = (y + 1) / 2\n    z_norm = (z + 1) / 2\n\n    # Radius increases linearly in all directions (can be tuned)\n    size = 0.01 + 0.01 * np.exp(1 * (x_norm + y_norm + z_norm))\n    size = size.flatten()\n\n    r = x_norm.flatten()\n    g = y_norm.flatten()\n    b = z_norm.flatten()\n    a = np.ones_like(r)\n    rgb = np.stack([r[::-1], g[::-1], b, a], axis=1)\n    rgb = (255 * rgb).astype(np.uint8)\n\n    return positions.shape[0], positions, rgb, size\n\n\nN, position, color, size = generate_ndc_grid(8)\n\nwidth, height = 800, 600\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(offset=(0, 0), size=(width, height))\narcball = panel.arcball()\n\nvisual = app.sphere(\n    position=position,\n    color=color,\n    size=size,\n    lighting=True,\n    shine=0.8,\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/volume/","title":"Volume","text":"<p>Show a volume visual with an arcball camera.</p> <p>Tags: volume, arcball, camera, texture</p> <p></p> Python code <pre><code>import gzip\n\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_mouse_brain():\n    filepath = dvz.download_data('volumes/allen_mouse_brain_rgba.npy.gz')\n    with gzip.open(filepath, 'rb') as f:\n        return np.load(f)\n\n\nvolume = load_mouse_brain()\nshape = volume.shape\ndtype = volume.dtype\nD, H, W = shape[:3]\nscaling = 1.0 / D\nx, y, z = W * scaling, H * scaling, 1\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\narcball = panel.arcball(initial=(-2.25, 0.65, 1.5))\ncamera = panel.camera(initial=(0, 0, 3))\n\ntexture = app.texture_3D(volume, shape=(W, H, D), interpolation='linear')\nvisual = app.volume(\n    bounds=((-x, +x), (-y, +y), (-z, +z)), texture=texture, mode='rgba', transfer=(0.2, 0, 0, 0)\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"gallery/visuals/wiggle/","title":"Wiggle visual","text":"<p>Show the wiggle visual.</p> <p>Tags: wiggle, panzoom, texture</p> <p></p> Python code <pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef load_data(channels, samples):\n    \"\"\"Create a texture with the given number of channels and samples.\"\"\"\n    c0 = channels / 2.0\n    alpha = 2 * np.pi * 8\n    beta = 1.0\n\n    s = np.linspace(0, 1, samples)\n    x = s - 0.5\n    y = np.sinc(alpha * x / np.pi)\n\n    c = np.arange(channels).reshape(-1, 1)\n    gamma = np.exp(-beta * ((2 * (c - c0) / c0) ** 2))\n\n    texdata = gamma * y\n    return texdata.astype(np.float32).reshape((channels, samples))\n\n\nchannels = 16\nsamples = 1024\n\ndata = load_data(channels, samples)\nheight, width = data.shape\n\nposition = np.array([[0, 0, 0]], dtype=np.float32)\nsize = np.array([[width, height]], dtype=np.float32)\nanchor = np.array([[0, 0]], dtype=np.float32)\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\n\napp = dvz.App()\nfigure = app.figure(gui=True)\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.wiggle(\n    scale=1.0,\n    negative_color=(128, 128, 128, 255),\n    positive_color=(0, 0, 0, 255),\n    edgecolor=(0, 0, 0, 255),\n)\ntexture = app.texture_2D(data, interpolation='linear')\nvisual.set_texture(texture)\npanel.add(visual)\n\n\nscale = dvz.Out(1.0)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_pos(dvz.vec2(10, 10), dvz.vec2(0, 0))\n    dvz.gui_size(dvz.vec2(200, 70))\n    dvz.gui_begin('Change the scale', 0)\n    has_changed = False\n    has_changed |= dvz.gui_slider('scale', 0.1, 5, scale)\n    dvz.gui_end()\n\n    if has_changed:\n        visual.set_scale(scale.value)\n\n\napp.run()\napp.destroy()\n</code></pre> <p>\u2190 Back to gallery</p>"},{"location":"guide/","title":"Learn Datoviz","text":"<p>Welcome to the Datoviz user guide. This section introduces the main concepts of the library, shows how to create and customize visualizations, and explains advanced usage patterns when you're ready to go deeper.</p>"},{"location":"guide/#what-youll-learn","title":"What you'll learn","text":"<p>This guide is structured into three levels:</p>"},{"location":"guide/#1-essentials","title":"1. Essentials","text":"<p>Start here if you're new to Datoviz:</p> <ul> <li>\ud83d\udccc Quickstart \u2014 create your first scatter plot in just a few lines of code</li> <li>\ud83d\udcd0 Main Concepts \u2014 learn how figures, panels, and axes structure your visual scene</li> </ul>"},{"location":"guide/#2-visuals","title":"2. Visuals","text":"<p>Each visual primitive has its own page with examples and documentation:</p> <ul> <li>\ud83e\udded Overview</li> <li>\ud83d\udd3a Basic \u2014 raw Vulkan primitives (points, line strips, triangles) with uniform color and no custom shaders</li> <li>\ud83d\udfe6 Pixel \u2014 individual pixels with position, color, and size (squares)</li> <li>\u26aa Point \u2014 sized, colored antialiased discs without borders</li> <li>\u2733\ufe0f Marker \u2014 symbols with optional borders, using built-in shapes, SVGs, or bitmap images</li> <li>\u2796 Segment \u2014 variable-width line segments with optional caps</li> <li>\u27b0 Path \u2014 continuous polylines</li> <li>\ud83d\uddbc\ufe0f Image \u2014 RGB or single-channel images with optional colormaps</li> <li>\ud83d\udd24 Glyph \u2014 glyph-based text rendering</li> <li>\ud83e\uddca Mesh \u2014 3D triangle meshes with optional lighting (flat, basic, or advanced), textures, contours, or experimental isolines</li> <li>\ud83d\udd2e Sphere \u2014 3D spheres with customizable lighting and materials</li> <li>\ud83c\udf2b\ufe0f Volume \u2014 basic volume rendering of dense 3D voxel data</li> <li>\ud83e\ude93 Slice \u2014 2D orthogonal slices through 3D volumes</li> </ul>"},{"location":"guide/#3-advanced-topics","title":"3. Advanced Topics","text":"<p>Explore these pages to customize behavior or build more complex apps:</p> <ul> <li>\ud83d\uddb1\ufe0f Interactivity \u2014 built-in pan, zoom, and arcball camera controls</li> <li>\ud83c\udfae Input \u2014 define keyboard and mouse event callbacks</li> <li>\u23f1\ufe0f Timers and Frame Events \u2014 run code every frame or at regular time intervals</li> <li>\ud83e\uddf0 GUI Support (ImGui) \u2014 use Datoviz\u2019s built-in ImGui layer for interactive widgets</li> <li>\ud83d\udd27 Datoviz Rendering Protocol (DRP) \u2014 internal low-level rendering architecture</li> <li>\u2699\ufe0f Using Datoviz in C \u2014 native C interface for full performance and control</li> </ul>"},{"location":"guide/#where-to-go-next","title":"Where to go next","text":"<ul> <li>Start with the Quickstart to render your first plot</li> <li>Then read Main Concepts to understand how visuals are positioned and transformed</li> <li>Or explore the Gallery to see what\u2019s possible</li> </ul> <p>Need full technical details? Visit the API Reference.</p>"},{"location":"guide/c/","title":"Using Datoviz in C","text":"<p>Datoviz is written in portable C and can be used directly in C applications for high-performance GPU visualization. The C API gives you full access to the library's core functionality, including visuals, scenes, interactivity, and rendering.</p> <p>This guide shows how to build and run a simple C program with Datoviz, and how the Python API relates to it.</p>"},{"location":"guide/c/#c-api-overview","title":"C API Overview","text":"<p>The C API is defined in a single public header (which includes a few other files in <code>include/</code>):</p> <pre><code>#include &lt;datoviz.h&gt;\n</code></pre> <p>You create and manage:</p> <ul> <li><code>DvzApp</code> and <code>DvzBatch</code>: top-level context and command submission</li> <li><code>DvzScene</code>, <code>DvzFigure</code>, <code>DvzPanel</code>: layout and interaction</li> <li><code>DvzVisual</code>: one of the GPU-accelerated visual types</li> </ul> <p>See the C API reference for the full list of functions and types.</p>"},{"location":"guide/c/#python-c-correspondence","title":"Python \u2194 C Correspondence","text":"<p>The Datoviz Python bindings consist of:</p> <ol> <li>Low-level <code>ctypes</code> bindings that directly wrap the C library,</li> <li>A high-level Python wrapper built on top, with objects like <code>App</code>, <code>Visual</code>, <code>Panel</code>, etc.</li> </ol> <p>The mapping for the raw <code>ctypes</code> bindings is:</p> C API Python API <code>dvz_point_alloc(...)</code> <code>dvz.point_alloc(...)</code> <code>dvz_mock_color(...)</code> <code>dvz.mock_color(...)</code> <code>DVZ_MARKER_SHAPE_DISC</code> <code>dvz.MARKER_SHAPE_DISC</code> <p>Python functions are named the same (minus the <code>dvz_</code> prefix) and constants use <code>dvz.CONSTANT_NAME</code>.</p>"},{"location":"guide/c/#building-a-c-program","title":"Building a C Program","text":"<p>To build a C application based on Datoviz:</p> <ol> <li>Ensure Datoviz is compiled from source or use a prebuilt version (not yet available).</li> <li>Include the <code>datoviz/</code> header directory.</li> <li>Specify the link directories containing <code>libdatoviz.so</code> (or the equivalent for your OS).</li> <li>Link against <code>libdatoviz</code> and the standard math library.</li> </ol>"},{"location":"guide/c/#example-gcc","title":"Example (GCC):","text":"<pre><code>gcc -std=c11 -O2 -I/path/to/datoviz/include \\\n    my_program.c -L/path/to/datoviz/build -ldatoviz -lm -o my_program\n</code></pre> <p>Note</p> <p>We plan to provide downloadable builds for major platforms in the future.</p>"},{"location":"guide/c/#full-example","title":"Full Example","text":"<pre><code>/*************************************************************************************************/\n/*  Scatter plot example                                                                         */\n/*************************************************************************************************/\n\n/// We import the library public header.\n#include &lt;datoviz.h&gt;\n\n// Entry point.\nint main(int argc, char** argv)\n{\n    // Create app object.\n    DvzApp* app = dvz_app(0);\n    DvzBatch* batch = dvz_app_batch(app);\n\n    // Create a scene.\n    DvzScene* scene = dvz_scene(batch);\n\n    // Create a figure.\n    DvzFigure* figure = dvz_figure(scene, 800, 600, 0);\n\n    // Create a panel.\n    DvzPanel* panel = dvz_panel_default(figure);\n\n    // Panzoom.\n    DvzPanzoom* pz = dvz_panel_panzoom(panel, 0);\n\n    // Create a visual.\n    DvzVisual* visual = dvz_point(batch, 0);\n\n    // Allocate a number of points.\n    const uint32_t n = 10000;\n    dvz_point_alloc(visual, n);\n\n    // Set the point positions.\n    vec3* pos = dvz_mock_pos_2D(n, 0.25);\n    dvz_point_position(visual, 0, n, pos, 0);\n    FREE(pos);\n\n    // Set the point RGBA colors.\n    DvzColor* color = dvz_mock_color(n, 128);\n    dvz_point_color(visual, 0, n, color, 0);\n    FREE(color);\n\n    // Set the point sizes.\n    float* size = dvz_mock_uniform(n, 25, 50);\n    dvz_point_size(visual, 0, n, size, 0);\n    FREE(size);\n\n    // Add the visual to the panel AFTER setting the visual's data.\n    dvz_panel_visual(panel, visual, 0);\n\n    // Run the app.\n    dvz_scene_run(scene, app, 0);\n\n    // Cleanup.\n    dvz_scene_destroy(scene);\n    dvz_app_destroy(app);\n\n    return 0;\n}\n</code></pre> <p>This program creates a scatter plot with 10,000 points using the point visual. It uses mock data helpers for positions, colors, and sizes.</p>"},{"location":"guide/c/#notes","title":"Notes","text":"<ul> <li>C usage provides the lowest-level, most performant access to Datoviz.</li> <li>The API is designed to be clear and safe to use in systems programming.</li> <li>The auto-generated Python <code>ctypes</code> bindings is identical to this C API to ensure consistent behavior across both languages.</li> <li>Most examples and documentation use the higher-level Python wrapper built on top of the <code>ctypes</code> bindings, for user convenience and to better decouple user code from the C API, which may still change with each release.</li> </ul>"},{"location":"guide/c/#see-also","title":"See Also","text":"<ul> <li>Python Quickstart</li> <li>C API Reference</li> <li>Datoviz Architecture</li> </ul>"},{"location":"guide/common/","title":"Main Concepts","text":"<p>This page explains how figures, panels, and axes define the visual layout in Datoviz. It also covers how to properly position data in Normalized Device Coordinates (NDC), which all visuals require.</p>"},{"location":"guide/common/#figures-and-panels","title":"Figures and Panels","text":"<p>A figure is a window or drawing surface. It contains one or more panels, which are rectangular subregions used to organize visuals.</p> <pre><code>figure = app.figure(800, 600)\npanel = figure.panel((50, 50), (700, 500))\n</code></pre> <ul> <li>The panel's position and size are given in pixels: <code>(x, y)</code> for the top-left corner and <code>(w, h)</code> for the dimensions.</li> <li>Panels automatically resize proportionally when the figure window is resized.</li> <li>Customizing this behavior (e.g. fixed-size panels) will be documented soon.</li> </ul> <p>If you omit position and size, the panel fills the entire figure:</p> <pre><code>panel = figure.panel()\n</code></pre>"},{"location":"guide/common/#gui-panels","title":"GUI panels","text":"<p>Warning</p> <p>This feature is experimental and may not work reliably yet.</p> <p>Experimental support for GUI panels is available: instead of occupying a fixed region of the figure, a GUI panel includes a top bar and can be resized, dragged with the mouse, and docked to the window edge or to another panel. This is implemented using Dear ImGui.</p> <p>To use it, enable GUI support when creating the figure with <code>figure = app.figure(gui=True)</code>. Then, for each panel you want to wrap in a GUI window, simply do:</p> <pre><code>panel.gui('Panel name')\n</code></pre>"},{"location":"guide/common/#axes-2d-only","title":"Axes (2D only)","text":"<p>Axes for 2D data can be added to any panel as follows:</p> <pre><code>axes = panel.axes((xmin, xmax), (ymin, ymax))\n</code></pre> <p>This uses a pan-and-zoom interaction pattern with the mouse. It should not be used on panels with 3D data (arcball), as 3D axes are not yet supported.</p> <p>This:</p> <ul> <li>Draws X and Y axes with ticks and labels.</li> <li>Enables mouse-based pan and zoom interactivity.</li> <li>Defines the data limits for normalization.</li> </ul>"},{"location":"guide/common/#coordinate-system","title":"Coordinate system","text":"<p>All visuals in Datoviz expect their <code>position</code> input in 3D Normalized Device Coordinates (NDC) \u2014 a 3D coordinate system where all values lie in the range <code>[-1, +1]</code> on each axis.</p> <p>The position is always an <code>(N, 3)</code> array with <code>x, y, z</code> components in NDC.</p> <p>You have two options when preparing your data:</p>"},{"location":"guide/common/#1-manual-normalization","title":"1. Manual normalization","text":"<p>If you normalize your data manually, pass it directly to the visual:</p> <pre><code>norm_pos = 2 * (data - data.min()) / (data.max() - data.min()) - 1\napp.point(position=norm_pos)\n</code></pre>"},{"location":"guide/common/#2-use-axesnormalizex-y","title":"2. Use <code>axes.normalize(x, y)</code>","text":"<p>The preferred method when using 2D axes is to use the <code>axes.normalize()</code> function:</p> <pre><code>axes = panel.axes((xmin, xmax), (ymin, ymax))\nposition = axes.normalize(x, y)\nvisual = app.point(position=position)\n</code></pre> <p>This does two things:</p> <ul> <li>Converts the data to NDC using the current axis limits.</li> <li>Ensures that ticks, labels, and interactivity match the transformed coordinates.</li> </ul> <p>This approach keeps your data in its original units while making it compatible with the NDC rendering model.</p>"},{"location":"guide/common/#colors","title":"Colors","text":"<p>Datoviz includes built-in support for colormaps.</p> <p>Most visuals and functions expect colors in <code>cvec4</code> format: four <code>uint8</code> integers in the 0\u2013255 range representing the RGBA channels (red, green, blue, alpha).</p> <p>The <code>dvz.cmap()</code> function generates an <code>(N, 4)</code> array of <code>uint8</code> RGBA values using one of the built-in colormaps. For example:</p> <pre><code>color = dvz.cmap('hsv', np.linspace(-1, 1, 100), vmin=-1, vmax=+1)\n# color is an (100, 4) array\n</code></pre>"},{"location":"guide/common/#screenshots","title":"Screenshots","text":"<p>You can save a PNG screenshot of a figure as follows:</p> <pre><code>app.screenshot(figure, 'screenshot.png')\n</code></pre> <p>Warning</p> <p>Screenshots currently do not support GUIs. This feature will be available in Datoviz v0.4.</p>"},{"location":"guide/common/#summary","title":"Summary","text":"<ul> <li>Use <code>figure()</code> to create a window, and <code>panel()</code> to define drawable regions.</li> <li>Panels are defined in pixel coordinates and resize proportionally.</li> <li>Axes are 2D, provide labels/ticks, and enable interactivity.</li> <li>All visuals require NDC input \u2014 use <code>axes.normalize()</code> to transform and align your data easily.</li> </ul>"},{"location":"guide/drp/","title":"Datoviz Rendering Protocol (DRP)","text":"<p>The Datoviz Rendering Protocol (DRP) is a low-level specification intended to describe and execute GPU rendering pipelines in a backend-agnostic way. It is inspired by WebGPU and Vulkan, and is designed to serve as a foundation for flexible, portable, high-performance graphics in scientific applications.</p> <p>The Datoviz Scene API, which includes everything documented on this website, is entirely based on DRP.</p>"},{"location":"guide/drp/#status","title":"Status","text":"<p>Warning</p> <p>DRP is not yet documented in the Python API.</p> <p>The core infrastructure exists in the C backend, but it depends on runtime compilation of GPU shaders (SPIR-V). We are currently evaluating the best way to bundle a SPIR-V compiler into Datoviz while preserving cross-platform compatibility.</p> <p>Until a robust, lightweight solution is found, DRP will remain experimental and not documented on the Python side.</p>"},{"location":"guide/drp/#goals","title":"Goals","text":"<p>DRP is designed to:</p> <ul> <li>Represent GPU rendering pipelines declaratively</li> <li>Support custom visuals and advanced rendering techniques</li> <li>Enable fully dynamic shader graphs and GPU computation workflows</li> </ul> <p>In the long term, it will serve as the backend for custom shaders and rendering pipelines.</p>"},{"location":"guide/drp/#see-also","title":"See Also","text":"<ul> <li>Datoviz Architecture</li> <li>Visuals \u2014 current prebuilt visual pipeline</li> </ul> <p>This page will be updated once DRP becomes available in user-facing APIs.</p>"},{"location":"guide/events/","title":"Application Events","text":"<p>In addition to mouse and keyboard input, Datoviz supports two types of programmatic event callbacks:</p> <ul> <li>Frame callbacks: triggered at every rendered frame</li> <li>Timers: triggered at fixed time intervals</li> </ul> <p>These are useful for animations, simulation steps, or triggering regular updates independent of user input.</p>"},{"location":"guide/events/#frame-events","title":"Frame events","text":"<p>Frame events are called once per render loop iteration. They allow you to update visuals or application state continuously, such as animating objects or polling data.</p> <p>To register a frame event handler, decorate a function named <code>on_frame</code>:</p> <pre><code>@app.connect(figure)\ndef on_frame(ev):\n    # Update something every frame\n    print(\"Rendering frame\")\n</code></pre> <ul> <li>Triggered once per frame (hundreds of thousands of frames per second by default, ~60 FPS or the monitor refresh rate when the environment variable <code>DVZ_VSYNC=1</code> activates vertical synchronization)</li> <li>Bound to a specific <code>Figure</code></li> <li>Receives an event object (<code>ev</code>), though it is typically unused</li> </ul> <p>Avoid any computationally intensive operations in this function to prevent frame rate drops.</p>"},{"location":"guide/events/#timer-events","title":"Timer events","text":"<p>Use timers to trigger a function at regular time intervals.</p> <pre><code>@app.timer(delay=0.0, period=1.0, max_count=0)\ndef my_timer(ev):\n    print(\"Timer tick\")\n</code></pre>"},{"location":"guide/events/#parameters","title":"Parameters:","text":"Argument Description <code>delay</code> Initial delay in seconds before the timer starts <code>period</code> Time between calls (in seconds) <code>max_count</code> Maximum number of timer calls (0 = unlimited)"},{"location":"guide/events/#summary","title":"Summary","text":"Event type Trigger Use case <code>on_frame</code> Every render frame Animations, continuous updates <code>@app.timer</code> Fixed interval (in seconds) Simulation steps, timed triggers <p>These callbacks provide core building blocks for interactive and time-based applications in Datoviz.</p> <p>See also:</p> <ul> <li>User Input: mouse and keyboard events</li> <li>GUI: interactive GUI panels and widgets</li> </ul>"},{"location":"guide/gui/","title":"Graphical User Interfaces (GUI)","text":"<p>Datoviz includes a built-in immediate-mode GUI system based on Dear ImGui, accessible directly from Python. This system allows you to build interactive widgets like buttons, sliders, checkboxes, tables, and trees.</p> <p>Warning</p> <p>The GUI API currently mirrors the underlying C API closely. While powerful, it is relatively low-level and may be simplified in a future version.</p>"},{"location":"guide/gui/#enabling-gui","title":"Enabling GUI","text":"<p>To use GUI elements, the <code>Figure</code> must be created with <code>gui=True</code>:</p> <pre><code>figure = app.figure(gui=True)\n</code></pre> <p>You must then register a GUI callback using <code>@app.connect(figure)</code> and name the function <code>on_gui</code>.</p>"},{"location":"guide/gui/#immediate-mode","title":"Immediate Mode","text":"<p>The GUI is immediate-mode: widgets are recreated from scratch at every frame. Their state (e.g. a checkbox value) must be stored and updated explicitly between frames. Use <code>dvz.Out()</code> to define mutable state values:</p> <pre><code>from datoviz import Out\nchecked = Out(True)\n\nif dvz.gui_checkbox('Check me', checked):\n    print('Checked:', checked.value)\n</code></pre>"},{"location":"guide/gui/#common-widgets","title":"Common Widgets","text":"<p>Note</p> <p>You'll find the full list of GUI functions in the API reference.</p>"},{"location":"guide/gui/#buttons","title":"Buttons","text":"<pre><code>dvz.gui_button('Click me', width, height)\n</code></pre> <p>Returns <code>True</code> if pressed during this frame.</p>"},{"location":"guide/gui/#sliders","title":"Sliders","text":"<pre><code>slider = Out(25.0)\ndvz.gui_slider('My slider', 0.0, 100.0, slider)\n</code></pre> <p>Also supports <code>vec2</code>, <code>vec3</code>, <code>vec4</code> versions for multi-axis sliders.</p> <p>There are also integer versions: <code>dvz.gui_slider_int</code>, <code>dvz.gui_slider_ivec2</code>, etc.</p>"},{"location":"guide/gui/#checkboxes","title":"Checkboxes","text":"<pre><code>checked = Out(True)\ndvz.gui_checkbox('Checkbox', checked)\n</code></pre>"},{"location":"guide/gui/#tables","title":"Tables","text":"<pre><code>dvz.gui_table('Table', rows, cols, labels, selected, flags)\n</code></pre> <p><code>labels</code> is a list of strings (<code>rows * cols</code>), <code>selected</code> is a boolean array tracking selected rows (must be defined outside the GUI callback functions for data persistence).</p>"},{"location":"guide/gui/#trees","title":"Trees","text":"<pre><code>if dvz.gui_node('Parent'):\n    dvz.gui_selectable('Child')\n    dvz.gui_pop()\n</code></pre> <p>Use <code>dvz.gui_clicked()</code> to detect clicks on selectable items.</p>"},{"location":"guide/gui/#color-picker","title":"Color Picker","text":"<pre><code>color = dvz.vec3(0.5, 0.2, 0.7)\ndvz.gui_colorpicker('Color', color, 0)\n</code></pre>"},{"location":"guide/gui/#layout-helpers","title":"Layout Helpers","text":"<ul> <li><code>dvz.gui_pos(pos, pivot)</code>: position next dialog in pixels</li> <li><code>dvz.gui_size(size)</code>: set size of next dialog</li> <li><code>dvz.gui_begin(title, flags)</code>: start a new dialog</li> <li><code>dvz.gui_end()</code>: end current dialog</li> </ul>"},{"location":"guide/gui/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\nfrom datoviz import Out, vec2, vec3\n\n# Dialog width.\nw = 300\n\nlabels = ['col0', 'col1', 'col2', '0', '1', '2', '3', '4', '5']\nrows = 2\ncols = 3\nselected = np.array([False, True], dtype=np.bool)\n\n# IMPORTANT: these values need to be defined outside of the GUI callback.\nchecked = Out(True)\ncolor = vec3(0.7, 0.5, 0.3)\n\nslider = Out(25.0)  # Warning: needs to be a float as it is passed to a function expecting a float\ndropdown_selected = Out(1)\n\n# GUI callback function, called at every frame. This is using Dear ImGui, an immediate-mode\n# GUI system. This means the GUI is recreated from scratch at every frame.\n\n\napp = dvz.App()\n# NOTE: at the moment, you must indicate gui=True if you intend to use a GUI in a figure\nfigure = app.figure(gui=True)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    # Set the size of the next GUI dialog.\n    dvz.gui_pos(vec2(25, 25), vec2(0, 0))\n    dvz.gui_size(vec2(w + 20, 550))\n\n    # Start a GUI dialog, specifying a dialog title.\n    dvz.gui_begin('My GUI', 0)\n\n    # Add a button. The function returns whether the button was pressed during this frame.\n    if dvz.gui_button('Button', w, 30):\n        print('button clicked')\n\n    # Create a tree, this call returns True if this node is unfolded.\n    if dvz.gui_node('Item 1'):\n        # Display an item in the tree.\n        dvz.gui_selectable('Hello inside item 1')\n        # Return True if this item was clicked.\n        if dvz.gui_clicked():\n            print('clicked sub item 1')\n        # Go up one level.\n        dvz.gui_pop()\n\n    if dvz.gui_node('Item 2'):\n        if dvz.gui_node('Item 2.1'):\n            dvz.gui_selectable('Hello inside item 2')\n            if dvz.gui_clicked():\n                print('clicked sub item 2')\n            dvz.gui_pop()\n        dvz.gui_pop()\n\n    if dvz.gui_table('table', rows, cols, labels, selected, 0):\n        print('Selected rows:', np.nonzero(selected)[0])\n\n    if dvz.gui_checkbox('Checkbox', checked):\n        print('Checked status:', checked.value)\n\n    if dvz.gui_colorpicker('Color picker', color, 0):\n        print('Color:', color)\n\n    if dvz.gui_slider('Slider', 0.0, 100.0, slider):\n        print('Slider value:', slider.value)\n\n    if dvz.gui_dropdown('Dropdown', 3, ['item 1', 'item 2', 'item 3'], dropdown_selected, 0):\n        print('Dropdown index:', dropdown_selected.value)\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n\napp.run()\napp.destroy()\n</code></pre> <p>This example demonstrates several widgets including a button, tree, table, color picker, and slider.</p>"},{"location":"guide/gui/#summary","title":"Summary","text":"Feature Notes Built-in GUI Immediate mode, updated every frame API Style Low-level, mirrors C API closely Widgets Buttons, sliders, tables, trees, color pickers, etc. State Use <code>Out(...)</code> to track mutable widget values Rendering GUI renders as an overlay inside the figure window <p>See also:</p> <ul> <li>Events: for frame and timer callbacks</li> </ul>"},{"location":"guide/input/","title":"User Input","text":"<p>Datoviz supports interactive user input via mouse and keyboard event callbacks. These events can be attached to a <code>Figure</code> using the <code>@app.connect()</code> decorator, which automatically routes events based on the function name.</p>"},{"location":"guide/input/#overview","title":"Overview","text":"<p>Event callbacks respond to:</p> <ul> <li>Mouse events (click, drag, wheel, move)</li> <li>Keyboard events (key press and release)</li> </ul> <p>Each event is handled per figure and can be accessed using a simple decorator-based API.</p>"},{"location":"guide/input/#connecting-input-events","title":"Connecting input events","text":"<p>To register input callbacks, decorate a function with:</p> <pre><code>@app.connect(figure)\ndef on_mouse(ev):\n    ...\n</code></pre> <p>The function name determines the event type:</p> Function name Triggered by <code>on_mouse</code> Mouse actions <code>on_keyboard</code> Keyboard actions"},{"location":"guide/input/#mouse-events","title":"Mouse events","text":"<p>Mouse events include actions like move, click, drag, and scroll:</p> <pre><code>@app.connect(figure)\ndef on_mouse(ev):\n    action = ev.mouse_event()\n    x, y = ev.pos()\n    print(f'{action} at ({x:.0f}, {y:.0f})')\n\n    if action in ('click', 'double_click'):\n        print(f'{ev.button_name()} button')\n\n    if action in ('drag', 'drag_start', 'drag_stop'):\n        print(f'{ev.button_name()} drag from {ev.press_pos()}')\n\n    if action == 'wheel':\n        print(f'wheel scroll {ev.wheel()}')\n</code></pre>"},{"location":"guide/input/#mouse-event-properties","title":"Mouse event properties","text":"Method Description <code>ev.mouse_event()</code> Current mouse event name <code>ev.pos()</code> Current mouse position <code>(x, y)</code> <code>ev.press_pos()</code> Mouse press position during a drag <code>ev.button()</code> Raw button enum (int) <code>ev.button_name()</code> Button name: <code>'left'</code>, <code>'right'</code>, <code>'middle'</code> <code>ev.wheel()</code> Vertical wheel scroll amount (float)"},{"location":"guide/input/#example","title":"Example","text":"<pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\n\n\n@app.connect(figure)\ndef on_mouse(ev):\n    action = ev.mouse_event()\n    x, y = ev.pos()\n    print(f'{action} ({x:.0f}, {y:.0f}) ', end='')\n\n    if action in ('click', 'double_click'):\n        button = ev.button_name()\n        print(f'{button} button', end='')\n\n    if action in ('drag_start', 'drag_stop', 'drag'):\n        button = ev.button_name()\n        xd, yd = ev.press_pos()\n        print(f'{button} button pressed at ({xd:.0f}, {yd:.0f})', end='')\n\n    if action == 'wheel':\n        w = ev.wheel()\n        print(f'wheel direction {w}', end='')\n\n    print()\n\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"guide/input/#keyboard-events","title":"Keyboard events","text":"<p>Keyboard callbacks receive key presses and releases:</p> <pre><code>@app.connect(figure)\ndef on_keyboard(ev):\n    print(f'{ev.key_event()} key {ev.key()} ({ev.key_name()})')\n</code></pre> <p>Each event contains:</p> <ul> <li><code>key()</code>: the integer key code</li> <li><code>key_name()</code>: the name of the key (e.g. <code>'Escape'</code>, <code>'A'</code>)</li> <li><code>key_event()</code>: <code>'press'</code> or <code>'release'</code></li> </ul>"},{"location":"guide/input/#keyboard-event-properties","title":"Keyboard event properties","text":"Method Description <code>ev.key_event()</code> Current keyboard event name <code>ev.key()</code> Raw key code enum (int) <code>ev.key_name()</code> Key name string, e.g. <code>'a'</code>, <code>'Escape'</code>"},{"location":"guide/input/#example_1","title":"Example","text":"<pre><code>import datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\n\n\n@app.connect(figure)\ndef on_keyboard(ev):\n    print(f'{ev.key_event()} key {ev.key()} ({ev.key_name()})')\n\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"guide/input/#summary","title":"Summary","text":"<ul> <li>\u2714\ufe0f Simple decorator-based API</li> <li>\u2714\ufe0f Per-figure event handling</li> <li>\u2714\ufe0f Full mouse and keyboard support</li> </ul> <p>See also:</p> <ul> <li>Interactivity for camera and panzoom controls</li> <li>Events for timers, frames, and GUI callbacks</li> </ul>"},{"location":"guide/interactivity/","title":"Interactivity","text":"<p>Datoviz supports basic 2D and 3D interactivity on panels, including:</p> <ul> <li>Mouse-based pan and zoom</li> <li>3D arcball rotation</li> <li>Fly camera</li> <li>Orthographic projection control</li> </ul> <p>These modes are attached to a panel and control the panel's internal transformation matrices.</p> <p>Warning</p> <p>Interactivity features are still limited and evolving. Some functionality available in the C API is not yet exposed in Python.</p>"},{"location":"guide/interactivity/#pan-and-zoom-interactivity","title":"Pan and Zoom Interactivity","text":"<p>Adds standard 2D pan and zoom behavior to a panel. This is the most common interactivity used for 2D plots.</p> <pre><code>panzoom = panel.panzoom()\n</code></pre> <p>You can optionally lock one axis:</p> <pre><code>panzoom = panel.panzoom(fixed='x')  # lock horizontal movement\npanzoom = panel.panzoom(fixed='y')  # lock vertical movement\n</code></pre>"},{"location":"guide/interactivity/#orthographic-interactivity","title":"Orthographic Interactivity","text":"<p>Adds a basic orthographic projection controller. Similar to panzoom, but with fixed scale and behavior suited for 2D rendering.</p> <pre><code>ortho = panel.ortho()\n</code></pre> <p>This is useful for pixel-perfect rendering or interfaces that require fixed-size panels.</p> <p>Warning</p> <p>This controller is still experimental.</p>"},{"location":"guide/interactivity/#arcball-interactivity-3d","title":"Arcball Interactivity (3D)","text":"<p>Enables 3D rotation using an arcball-style controller. The arcball rotates the model around a virtual sphere.</p> <pre><code>arcball = panel.arcball()\n</code></pre> <p>You can set the initial orientation:</p> <pre><code>arcball = panel.arcball(initial=(0, 0, 0))\n</code></pre> <p>Once active, you can control it via:</p> <pre><code>arcball.set((x, y, z))    # set rotation angles\nangles = arcball.get()    # get current rotation\narcball.reset()           # reset to initial state\n</code></pre> <p>When using an arcball, you can add a 3D gizmo with:</p> <pre><code>panel.gizmo()\n</code></pre> <p>Warning</p> <p>This feature is still experimental. A known issue is that the gizmo may be obscured by other visuals in the scene if they are rendered in front of it. This will be fixed in version 0.4.</p>"},{"location":"guide/interactivity/#fly-camera-interactivity-3d","title":"Fly Camera Interactivity (3D)","text":"<p>The fly camera allows you to navigate through a 3D scene as if you were flying. It provides controls for moving forward, backward, left, right, and up/down, as well as rotating the view using the mouse or keyboard.</p> <pre><code>fly = panel.fly()\n</code></pre> <p>Features:</p> <ul> <li>Mouse Controls: Drag the left mouse button to rotate the view (yaw/pitch). Drag the right mouse button to roll or move sideways/upwards. Use the mouse wheel to move forward/backward.</li> <li>Keyboard Controls: Use arrow keys to move forward, backward, left, or right.</li> <li>Reset: Double-click to reset the camera to its initial position and orientation.</li> </ul> <p>Warning</p> <p>This controller is still experimental and may need further testing.</p>"},{"location":"guide/interactivity/#camera-interactivity-3d","title":"Camera Interactivity (3D)","text":"<p>Adds a 3D camera with position, target (look-at), and up vector.</p> <pre><code>camera = panel.camera()\n</code></pre> <p>You can initialize it with:</p> <pre><code>camera = panel.camera(\n    initial=(3, 3, 3),\n    initial_lookat=(0, 0, 0),\n    initial_up=(0, 0, 1)\n)\n</code></pre> <p>Note</p> <p>The camera is automatically added when using an arcball.</p> <p>To control it manually:</p> <pre><code>camera.set(position=(...), lookat=(...), up=(...))\npos = camera.position()\n</code></pre>"},{"location":"guide/interactivity/#summary","title":"Summary","text":"Interactivity Description Use cases <code>panzoom()</code> Mouse-driven 2D pan/zoom Line plots, scatter, 2D UI <code>ortho()</code> Fixed orthographic controller Pixel-accurate 2D panels <code>arcball()</code> Interactive 3D rotation Object inspection, rotation <code>fly()</code> Fly camera Navigation in a 3D scene <code>camera()</code> Custom 3D camera control Navigation in a 3D scene <p>Each mode provides access to its state (e.g. position, rotation) and can be reset or manually adjusted.</p> <p>More interactive features and fine-grained control will be added in future versions.</p>"},{"location":"guide/shape/","title":"Shape Collections","text":"<p>The <code>ShapeCollection</code> is a utility that lets you build complex 2D or 3D geometry by combining predefined shapes, custom meshes, and transformed objects. These collections are typically used with <code>app.mesh()</code> to create a mesh visual.</p>"},{"location":"guide/shape/#overview","title":"Overview","text":"<ul> <li>Add basic geometric shapes: squares, cubes, spheres, etc.</li> <li>Transform each shape independently (offset, scale, 4\u00d74 matrix)</li> <li>Load shapes from <code>.obj</code> files</li> <li>Generate surfaces from height maps or triangulated polygons</li> <li>Use in a mesh visual with lighting, textures, contours, or isolines</li> </ul>"},{"location":"guide/shape/#usage","title":"Usage","text":"<pre><code>sc = dvz.ShapeCollection()\nsc.add_cube(offset=(0, 0, 0), scale=1.0)\nvisual = app.mesh(sc, lighting=True)\n</code></pre> <p>After use, destroy the shape collection to free resources:</p> <pre><code>sc.destroy()\n</code></pre>"},{"location":"guide/shape/#supported-shapes","title":"Supported Shapes","text":"Shape Method Notes Square <code>add_square()</code> 2D quad in XY plane Disc <code>add_disc()</code> Circular disc with resolution Sector <code>add_sector()</code> Arc segment between two angles (2D disc slice) Cube <code>add_cube()</code> Axis-aligned 3D cube Sphere <code>add_sphere()</code> Specify <code>rows</code>, <code>cols</code> for resolution Tetrahedron <code>add_tetrahedron()</code> Platonic solid Hexahedron <code>add_hexahedron()</code> Cube variant Octahedron <code>add_octahedron()</code> Platonic solid Dodecahedron <code>add_dodecahedron()</code> Platonic solid Icosahedron <code>add_icosahedron()</code> Platonic solid Cone <code>add_cone()</code> Cone with cap Cylinder <code>add_cylinder()</code> Cylinder with caps Arrow <code>add_arrow()</code> Cylinder + cone composite Torus <code>add_torus()</code> Donut shape with tubular cross-section"},{"location":"guide/shape/#custom-geometry","title":"Custom Geometry","text":""},{"location":"guide/shape/#polygon","title":"Polygon","text":"<pre><code>sc.add_polygon(points, contour='full')\n</code></pre> <ul> <li><code>points</code>: Nx2 array of polygon vertices</li> <li>Uses earcut triangulation internally</li> </ul> <p>Warning</p> <p>There may be visual artifacts along the contours of highly irregular polygons, such as those derived from geographical data. These can be addressed with a more robust triangulation algorithm. Improvements are planned for a future release.</p>"},{"location":"guide/shape/#surface","title":"Surface","text":"<pre><code>sc.add_surface(heights, colors)\n</code></pre> <ul> <li>Heights: 2D array of Z-values</li> <li>Colors: 2D RGBA array (same shape)</li> <li>Generates a triangulated surface patch</li> </ul>"},{"location":"guide/shape/#obj-import","title":"OBJ Import","text":"<p>Load external 3D geometry from a Wavefront OBJ file:</p> <pre><code>sc.add_obj(\"models/teapot.obj\", scale=0.5)\n</code></pre> <p>This loads all vertices and faces into the shape collection.</p>"},{"location":"guide/shape/#transformations","title":"Transformations","text":"<p>Each shape can be transformed individually:</p> <ul> <li><code>offset</code>: a 3D translation <code>(x, y, z)</code></li> <li><code>scale</code>: a uniform scalar</li> <li><code>transform</code>: a 4\u00d74 transformation matrix (overrides offset/scale)</li> </ul>"},{"location":"guide/shape/#colors","title":"Colors","text":"<p>Each basic shape accepts a uniform <code>color</code> argument for the shape.</p>"},{"location":"guide/shape/#finalizing","title":"Finalizing","text":"<p>After building your collection, use:</p> <pre><code>visual = app.mesh(sc, lighting=True, contour=True)\n</code></pre> <p>And after you're done using it:</p> <pre><code>sc.destroy()   # Frees memory\n</code></pre>"},{"location":"guide/shape/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\nrows = 12\ncols = 16\nN = rows * cols\nt = np.linspace(0, 1, N)\n\nx, y = np.meshgrid(np.linspace(-1, 1, rows), np.linspace(-1, 1, cols))\nz = np.zeros_like(x)\n\noffsets = np.c_[x.flat, y.flat, z.flat]\nscales = 1.0 / rows * (1 + 0.25 * np.sin(5 * 2 * np.pi * t))\ncolors = dvz.cmap('hsv', np.mod(t, 1))\n\nsc = dvz.ShapeCollection()\nfor offset, scale, color in zip(offsets, scales, colors):\n    sc.add_cube(offset=offset, scale=scale, color=color)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(background=True)\narcball = panel.arcball(initial=(-1, -0.1, -0.25))\n\nvisual = app.mesh(sc, lighting=True)\n\npanel.add(visual)\n\napp.run()\napp.destroy()\nsc.destroy()\n</code></pre>"},{"location":"guide/shape/#summary","title":"Summary","text":"<p>The ShapeCollection system is a powerful way to build reusable geometry for the <code>mesh</code> visual.</p> <ul> <li>\u2714\ufe0f Add and transform 2D/3D primitives</li> <li>\u2714\ufe0f Generate and combine triangulated surfaces</li> </ul> <p>See also:</p> <ul> <li>Mesh for rendering options</li> <li>Volume for dense scalar fields</li> </ul>"},{"location":"guide/texture/","title":"Textures","text":"<p>Textures in Datoviz are GPU-side image data used by many visuals, such as <code>image</code>, <code>marker</code>, <code>mesh</code>, and <code>volume</code>. They can be 1D, 2D, or 3D, single-channel or multi-channel, and support different interpolation and wrapping modes.</p> <p>This page explains how to create, configure, and use textures in your application.</p>"},{"location":"guide/texture/#creating-a-texture","title":"Creating a Texture","text":"<p>To create a texture from a NumPy array, use the <code>app.texture_ND()</code> methods (with <code>N=1</code>, <code>2</code>, or <code>3</code>):</p> <pre><code>texture = app.texture_2D(image)\n</code></pre> <p>You can also create an empty texture with a specified shape and upload data to it later.</p>"},{"location":"guide/texture/#texture-dimensions","title":"Texture Dimensions","text":"<ul> <li><code>texture_1D(data)</code>: for 1D colormap textures or lookup tables</li> <li><code>texture_2D(image)</code>: for standard 2D images</li> <li><code>texture_3D(volume)</code>: for volumetric data</li> </ul>"},{"location":"guide/texture/#texture-parameters","title":"Texture Parameters","text":"<p>When creating a texture, you can specify either an image, or the texture parameters:</p> Parameter Description <code>shape</code> Shape of the texture (optional if <code>image</code> is given). <code>n_channels</code> Number of channels (e.g., 1 for grayscale, 3 for RGB, 4 for RGBA). <code>dtype</code> Data type of the texture. Common types: <code>np.uint8</code>, <code>np.float32</code>. <p>In all cases, you can also specify interpolation and address wrapping mode:</p> Parameter Description <code>interpolation</code> Interpolation mode <code>address_mode</code> Address wrapping mode"},{"location":"guide/texture/#texture-formats","title":"Texture Formats","text":"<p>When using an <code>image</code>, the format is automatically inferred from its shape and dtype:</p> <ul> <li>1-channel: grayscale or scalar field</li> <li>3-channel: RGB color</li> <li>4-channel: RGBA color</li> </ul> <p>Datoviz supports integer and float types such as <code>uint8</code>, <code>int16</code> and <code>float32</code> arrays.</p>"},{"location":"guide/texture/#interpolation-modes","title":"Interpolation Modes","text":"<p>Interpolation determines how texels are sampled when scaling or filtering.</p> Value Description <code>nearest</code> (default) No interpolation; use nearest texel <code>linear</code> Smooth linear interpolation between texels"},{"location":"guide/texture/#address-modes","title":"Address Modes","text":"<p>Address mode defines how out-of-bound texture coordinates are handled.</p> Value Description <code>clamp_to_border</code> (default) Clamp to a transparent or fixed border <code>clamp_to_edge</code> Clamp to the edge texel <code>repeat</code> Wrap around to the other side <code>mirrored_repeat</code> Mirror the texture across boundaries <code>mirror_clamp_to_edge</code> Mirror once and clamp at the edge"},{"location":"guide/texture/#uploading-data-later","title":"Uploading data later","text":"<p>You can create an empty texture and upload data later:</p> <pre><code>texture = app.texture_2D(shape=(512, 512), n_channels=4, dtype=np.uint8)\ntexture.data(my_image)\n</code></pre> <p>You can also upload to a sub-region using an offset:</p> <pre><code>texture.data(my_tile, offset=(128, 128, 0))\n</code></pre>"},{"location":"guide/texture/#using-a-texture-in-a-visual","title":"Using a Texture in a Visual","text":"<p>Once created, textures can be assigned to visuals using:</p> <pre><code>visual.set_texture(texture)\n</code></pre>"},{"location":"guide/texture/#example-2d-image","title":"Example: 2D Image","text":"<pre><code>visual = app.image(...)\ntexture = app.texture_2D(image, interpolation='linear')\nvisual.set_texture(texture)\n</code></pre>"},{"location":"guide/texture/#example-3d-volume","title":"Example: 3D Volume","text":"<pre><code>visual = app.volume(mode='rgba')\ntexture = app.texture_3D(volume_data, shape=(W, H, D))\nvisual.set_texture(texture)\n</code></pre>"},{"location":"guide/texture/#see-also","title":"See Also","text":"<ul> <li>Image visual</li> <li>Volume visual</li> <li>Mesh visual</li> <li>Marker visual</li> <li>Glyph visual</li> </ul>"},{"location":"guide/visuals/","title":"Visuals Overview","text":"<p>High-performance rendering in Datoviz is based on the concept of visuals \u2014 GPU-accelerated primitives such as points, lines, images, and 3D meshes. Each visual represents a collection of items of a specific type, rendered in a single batch for maximum efficiency.</p> <p>Datoviz is designed to render millions of visual items at interactive framerates, assuming items in a visual share the same transformation (e.g., coordinate space). This makes the grouping and batching model crucial to understand.</p> <p>Note</p> <p>Some visuals overlap in functionality, each offering different trade-offs in flexibility and performance. Try out similar visuals to find the one that best suits your needs.</p>"},{"location":"guide/visuals/#available-visuals","title":"Available visuals","text":"<p>Here is the list of available visuals.</p> <p>Note</p> <p>Additional visuals may be introduced in future versions based on user needs.</p> \ud83d\udd3a Basic: Low-level Vulkan primitives: points, line strips, triangles, etc. \ud83d\udfe6 Pixel: Individual pixels with custom position, size, and color (for rasters, point clouds, etc.). \u26aa Point: Borderless circular discs (for simple scatter plots with minimal styling).  \u2733\ufe0f Marker: Symbols with predefined (circle, square, cross, etc.) or custom (SVG, bitmap) shapes and optional borders.  \u2796 Segment: Line segments with arbitrary width and customizable caps (no arrows nor dashes for now).  \u27b0 Path: Continuous polylines with optional variable thickness, optionally closed (no arrows nor dashes for now).  \ud83d\uddbc\ufe0f Image: User-facing 2D images (RGBA or single-channel with colormap) anchored in world space.  \ud83d\uddbc\ufe0f Wiggle plot: Wiggle plot for multichannel time series.  \ud83d\udd24 Glyph: Minimally-customizable text (to be improved in future versions).  \ud83e\uddca Mesh: Triangulations in 2D or 3D, used for polygons or surface meshes, with optional lighting, texture, contour, wireframes (isolines documented soon).  \ud83e\uddca Sphere: 3D spheres with lighting.  \ud83c\udf2b\ufe0f Volume: Basic volume rendering for dense 3D scalar fields (RGBA or single-channel with colormap)."},{"location":"guide/visuals/#data-model-items-and-groups","title":"Data model: items and groups","text":"<p>Each visual manages a collection of items. The definition of an item depends on the visual type:</p> <ul> <li>Pixel, Point, Marker: 1 item = 1 point or marker</li> <li>Segment: 1 item = 1 line segment</li> <li>Path: 1 item = 1 point in a polyline (multiple disjoint paths can be batched)</li> <li>Image: 1 item = 1 image</li> <li>Glyph: 1 item = 1 character, grouped into strings by position</li> <li>Mesh: 1 item = 1 vertex (connectivity defined by faces, a separate list of indices)</li> <li>Sphere: 1 item = 1 3D sphere</li> <li>Volume: 1 item = the full volume (typically only 1)</li> </ul> <p>A given visual instance has many items that share:</p> <ul> <li>The same visual type</li> <li>The same visual options (for example, mesh visual with lighting support)</li> <li>The same data transformation (specific to a panel)</li> </ul> <p>This model is key to Datoviz's performance: many visual instances are submitted in a single GPU draw call, with tight memory layout and no redundant state changes.</p>"},{"location":"guide/visuals/#coordinate-system","title":"Coordinate system","text":"<p>All visuals expect positions in 3D Normalized Device Coordinates (NDC), where each axis ranges from <code>-1</code> to <code>+1</code>.</p> <p>For 2D rendering, simply set the Z coordinate to <code>0</code> and use a 2D camera or interaction mode (e.g. pan-zoom). This keeps your data in the XY plane while leveraging the full GPU pipeline.</p>"},{"location":"guide/visuals/#working-with-visuals","title":"Working with visuals","text":"<p>All visuals are created using the <code>app.visual_name()</code> functions:</p> <pre><code>visual = app.point(position=..., color=..., size=...)\n</code></pre> <p>Properties can also be set or modified as follows:</p> <pre><code>visual.set_position(position)\nvisual.set_color(color)\n...\n</code></pre> <p>The <code>position</code> is usually an <code>(N, 3)</code> NumPy array (automatically cast to <code>float32</code>, which the GPU expects), and <code>color</code> is an <code>(N, 4)</code> array of RGBA values in the 0\u2013255 range, automatically cast to <code>uint8</code>.</p> <p>Visuals must then be added to a panel:</p> <pre><code>panel.add(visual)\n</code></pre>"},{"location":"guide/visuals/#enabling-depth-testing","title":"Enabling depth testing","text":"<p>In 3D visualizations, you can control whether visual elements are rendered with or without depth testing:</p> <pre><code>visual.set_data(..., depth_test=True)\n</code></pre> <ul> <li><code>depth_test=True</code>: Items respect the 3D depth buffer (closer points appear in front)</li> <li><code>depth_test=False</code>: Items are rendered in the order they are submitted</li> </ul>"},{"location":"guide/visuals/#culling-and-front-face","title":"Culling and front face","text":"<p>Warning</p> <p>This section of the documentation has not been written yet.</p> <p>For more details, see each visual's documentation page.</p>"},{"location":"reference/api_c/","title":"C API Reference","text":""},{"location":"reference/api_c/#functions","title":"Functions","text":""},{"location":"reference/api_c/#app","title":"App","text":""},{"location":"reference/api_c/#dvz_app_batch","title":"<code>dvz_app_batch()</code>","text":"<p>Return the app batch.</p> CPython <pre><code>DvzBatch* dvz_app_batch(  // returns the batch\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_batch(  # returns the batch : DvzBatch*\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_destroy","title":"<code>dvz_app_destroy()</code>","text":"<p>Destroy the app.</p> CPython <pre><code>void dvz_app_destroy(\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_destroy(\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_frame","title":"<code>dvz_app_frame()</code>","text":"<p>Run one frame.</p> CPython <pre><code>void dvz_app_frame(\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_frame(\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_fullscreen","title":"<code>dvz_app_fullscreen()</code>","text":"<p>Set display to fullscreen.</p> CPython <pre><code>void dvz_app_fullscreen(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the ID of the canvas\n    bool is_fullscreen,  // True for fullscreen, False for windowed.\n);\n</code></pre> <pre><code>dvz.app_fullscreen(\n    app,  # the app : DvzApp*\n    canvas_id,  # the ID of the canvas : DvzId\n    is_fullscreen,  # True for fullscreen, False for windowed. : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_gui","title":"<code>dvz_app_gui()</code>","text":"<p>Register a GUI callback.</p> CPython <pre><code>void dvz_app_gui(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas ID\n    DvzAppGuiCallback callback,  // the GUI callback\n    void* user_data,  // the user data\n);\n</code></pre> <pre><code>dvz.app_gui(\n    app,  # the app : DvzApp*\n    canvas_id,  # the canvas ID : DvzId\n    callback,  # the GUI callback : DvzAppGuiCallback\n    user_data,  # the user data : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_keyboard","title":"<code>dvz_app_keyboard()</code>","text":"<p>Return the last keyboard key pressed.</p> CPython <pre><code>void dvz_app_keyboard(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas id\n    DvzKeyCode* key,  // a pointer to the last pressed key\n);\n</code></pre> <pre><code>dvz.app_keyboard(\n    app,  # the app : DvzApp*\n    canvas_id,  # the canvas id : DvzId\n    key,  # a pointer to the last pressed key : Out[DvzKeyCode]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_mouse","title":"<code>dvz_app_mouse()</code>","text":"<p>Return the last mouse position and pressed button.</p> CPython <pre><code>void dvz_app_mouse(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas id\n    double* x,  // a pointer to the mouse x position\n    double* y,  // a pointer to the mouse y position\n    DvzMouseButton* button,  // a pointer to the pressed button\n);\n</code></pre> <pre><code>dvz.app_mouse(\n    app,  # the app : DvzApp*\n    canvas_id,  # the canvas id : DvzId\n    x,  # a pointer to the mouse x position : Out[float]\n    y,  # a pointer to the mouse y position : Out[float]\n    button,  # a pointer to the pressed button : Out[DvzMouseButton]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_on_frame","title":"<code>dvz_app_on_frame()</code>","text":"<p>Register a frame callback.</p> CPython <pre><code>void dvz_app_on_frame(\n    DvzApp* app,  // the app\n    DvzAppFrameCallback callback,  // the callback\n    void* user_data,  // the user data\n);\n</code></pre> <pre><code>dvz.app_on_frame(\n    app,  # the app : DvzApp*\n    callback,  # the callback : DvzAppFrameCallback\n    user_data,  # the user data : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_on_keyboard","title":"<code>dvz_app_on_keyboard()</code>","text":"<p>Register a keyboard callback.</p> CPython <pre><code>void dvz_app_on_keyboard(\n    DvzApp* app,  // the app\n    DvzAppKeyboardCallback callback,  // the callback\n    void* user_data,  // the user data\n);\n</code></pre> <pre><code>dvz.app_on_keyboard(\n    app,  # the app : DvzApp*\n    callback,  # the callback : DvzAppKeyboardCallback\n    user_data,  # the user data : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_on_mouse","title":"<code>dvz_app_on_mouse()</code>","text":"<p>Register a mouse callback.</p> CPython <pre><code>void dvz_app_on_mouse(\n    DvzApp* app,  // the app\n    DvzAppMouseCallback callback,  // the callback\n    void* user_data,  // the user data\n);\n</code></pre> <pre><code>dvz.app_on_mouse(\n    app,  # the app : DvzApp*\n    callback,  # the callback : DvzAppMouseCallback\n    user_data,  # the user data : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_on_resize","title":"<code>dvz_app_on_resize()</code>","text":"<p>Register a resize callback.</p> CPython <pre><code>void dvz_app_on_resize(\n    DvzApp* app,  // the app\n    DvzAppResizeCallback callback,  // the callback\n    void* user_data,  // the user data\n);\n</code></pre> <pre><code>dvz.app_on_resize(\n    app,  # the app : DvzApp*\n    callback,  # the callback : DvzAppResizeCallback\n    user_data,  # the user data : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_on_timer","title":"<code>dvz_app_on_timer()</code>","text":"<p>Register a timer callback.</p> CPython <pre><code>void dvz_app_on_timer(\n    DvzApp* app,  // the app\n    DvzAppTimerCallback callback,  // the timer callback\n    void* user_data,  // the user data\n);\n</code></pre> <pre><code>dvz.app_on_timer(\n    app,  # the app : DvzApp*\n    callback,  # the timer callback : DvzAppTimerCallback\n    user_data,  # the user data : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_run","title":"<code>dvz_app_run()</code>","text":"<p>Start the application event loop.</p> CPython <pre><code>void dvz_app_run(\n    DvzApp* app,  // the app\n    uint64_t frame_count,  // the maximum number of frames, 0 for infinite loop\n);\n</code></pre> <pre><code>dvz.app_run(\n    app,  # the app : DvzApp*\n    frame_count,  # the maximum number of frames, 0 for infinite loop : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_screenshot","title":"<code>dvz_app_screenshot()</code>","text":"<p>Make a screenshot of a canvas.</p> CPython <pre><code>void dvz_app_screenshot(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the ID of the canvas\n    char* filename,  // the path to the PNG file with the screenshot\n);\n</code></pre> <pre><code>dvz.app_screenshot(\n    app,  # the app : DvzApp*\n    canvas_id,  # the ID of the canvas : DvzId\n    filename,  # the path to the PNG file with the screenshot : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_stop","title":"<code>dvz_app_stop()</code>","text":"<p>Stop the app's client.</p> CPython <pre><code>void dvz_app_stop(\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_stop(\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_submit","title":"<code>dvz_app_submit()</code>","text":"<p>Submit the current batch to the application.</p> CPython <pre><code>void dvz_app_submit(\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_submit(\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_timer","title":"<code>dvz_app_timer()</code>","text":"<p>Create a timer.</p> CPython <pre><code>DvzTimerItem* dvz_app_timer(  // returns the timer\n    DvzApp* app,  // the app\n    double delay,  // the delay, in seconds, until the first event\n    double period,  // the period, in seconds, between two events\n    uint64_t max_count,  // the maximum number of events\n);\n</code></pre> <pre><code>dvz.app_timer(  # returns the timer : DvzTimerItem*\n    app,  # the app : DvzApp*\n    delay,  # the delay, in seconds, until the first event : float\n    period,  # the period, in seconds, between two events : float\n    max_count,  # the maximum number of events : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_timer_clear","title":"<code>dvz_app_timer_clear()</code>","text":"<p>Stop and remove all timers.</p> CPython <pre><code>void dvz_app_timer_clear(\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_timer_clear(\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_timestamps","title":"<code>dvz_app_timestamps()</code>","text":"<p>Return the precise display timestamps of the last <code>count</code> frames.</p> CPython <pre><code>void dvz_app_timestamps(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the ID of the canvas\n    uint32_t count,  // number of frames\n    uint64_t* seconds,  // (array) a buffer holding at least `count` uint64_t values (seconds)\n    uint64_t* nanoseconds,  // (array) a buffer holding at least `count` uint64_t values (nanoseconds)\n);\n</code></pre> <pre><code>dvz.app_timestamps(\n    app,  # the app : DvzApp*\n    canvas_id,  # the ID of the canvas : DvzId\n    count,  # number of frames : int\n    seconds,  # (array) a buffer holding at least `count` uint64_t values (seconds) : Out[int]\n    nanoseconds,  # (array) a buffer holding at least `count` uint64_t values (nanoseconds) : Out[int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_app_wait","title":"<code>dvz_app_wait()</code>","text":"<p>Wait until the GPU has finished processing.</p> CPython <pre><code>void dvz_app_wait(\n    DvzApp* app,  // the app\n);\n</code></pre> <pre><code>dvz.app_wait(\n    app,  # the app : DvzApp*\n)\n</code></pre>"},{"location":"reference/api_c/#arcball","title":"Arcball","text":""},{"location":"reference/api_c/#dvz_arcball_angles","title":"<code>dvz_arcball_angles()</code>","text":"<p>Get the current arcball angles.</p> CPython <pre><code>void dvz_arcball_angles(\n    DvzArcball* arcball,  // the arcball\n    vec3 out_angles,  // the arcball angles\n);\n</code></pre> <pre><code>dvz.arcball_angles(\n    arcball,  # the arcball : DvzArcball*\n    out_angles,  # the arcball angles : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_constrain","title":"<code>dvz_arcball_constrain()</code>","text":"<p>Add arcball constraints.</p> CPython <pre><code>void dvz_arcball_constrain(\n    DvzArcball* arcball,  // the arcball\n    vec3 constrain,  // the constrain values\n);\n</code></pre> <pre><code>dvz.arcball_constrain(\n    arcball,  # the arcball : DvzArcball*\n    constrain,  # the constrain values : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_end","title":"<code>dvz_arcball_end()</code>","text":"<p>Finalize arcball position update.</p> CPython <pre><code>void dvz_arcball_end(\n    DvzArcball* arcball,  // the arcball\n);\n</code></pre> <pre><code>dvz.arcball_end(\n    arcball,  # the arcball : DvzArcball*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_flags","title":"<code>dvz_arcball_flags()</code>","text":"<p>Set the arcball flags.</p> CPython <pre><code>void dvz_arcball_flags(\n    DvzArcball* arcball,  // the arcball\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.arcball_flags(\n    arcball,  # the arcball : DvzArcball*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_gui","title":"<code>dvz_arcball_gui()</code>","text":"<p>Show a GUI with sliders controlling the three arcball angles.</p> CPython <pre><code>void dvz_arcball_gui(\n    DvzArcball* arcball,  // the arcball\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas (or figure) ID\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.arcball_gui(\n    arcball,  # the arcball : DvzArcball*\n    app,  # the app : DvzApp*\n    canvas_id,  # the canvas (or figure) ID : DvzId\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_initial","title":"<code>dvz_arcball_initial()</code>","text":"<p>Set the initial arcball angles.</p> CPython <pre><code>void dvz_arcball_initial(\n    DvzArcball* arcball,  // the arcball\n    vec3 angles,  // the initial angles\n);\n</code></pre> <pre><code>dvz.arcball_initial(\n    arcball,  # the arcball : DvzArcball*\n    angles,  # the initial angles : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_model","title":"<code>dvz_arcball_model()</code>","text":"<p>Return the model matrix of an arcball.</p> CPython <pre><code>void dvz_arcball_model(\n    DvzArcball* arcball,  // the arcball\n    mat4 model,  // the model\n);\n</code></pre> <pre><code>dvz.arcball_model(\n    arcball,  # the arcball : DvzArcball*\n    model,  # the model : Out[mat4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_mvp","title":"<code>dvz_arcball_mvp()</code>","text":"<p>Apply an MVP matrix to an arcball (only the model matrix).</p> CPython <pre><code>void dvz_arcball_mvp(\n    DvzArcball* arcball,  // the arcball\n    DvzMVP* mvp,  // the MVP\n);\n</code></pre> <pre><code>dvz.arcball_mvp(\n    arcball,  # the arcball : DvzArcball*\n    mvp,  # the MVP : DvzMVP*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_print","title":"<code>dvz_arcball_print()</code>","text":"<p>Display information about an arcball.</p> CPython <pre><code>void dvz_arcball_print(\n    DvzArcball* arcball,  // the arcball\n);\n</code></pre> <pre><code>dvz.arcball_print(\n    arcball,  # the arcball : DvzArcball*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_reset","title":"<code>dvz_arcball_reset()</code>","text":"<p>Reset an arcball to its initial position.</p> CPython <pre><code>void dvz_arcball_reset(\n    DvzArcball* arcball,  // the arcball\n);\n</code></pre> <pre><code>dvz.arcball_reset(\n    arcball,  # the arcball : DvzArcball*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_resize","title":"<code>dvz_arcball_resize()</code>","text":"<p>Inform an arcball of a panel resize.</p> CPython <pre><code>void dvz_arcball_resize(\n    DvzArcball* arcball,  // the arcball\n    float width,  // the panel width\n    float height,  // the panel height\n);\n</code></pre> <pre><code>dvz.arcball_resize(\n    arcball,  # the arcball : DvzArcball*\n    width,  # the panel width : float\n    height,  # the panel height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_rotate","title":"<code>dvz_arcball_rotate()</code>","text":"<p>Apply a rotation to an arcball.</p> CPython <pre><code>void dvz_arcball_rotate(\n    DvzArcball* arcball,  // the arcball\n    vec2 cur_pos,  // the initial position\n    vec2 last_pos,  // the final position\n);\n</code></pre> <pre><code>dvz.arcball_rotate(\n    arcball,  # the arcball : DvzArcball*\n    cur_pos,  # the initial position : Tuple[float, float]\n    last_pos,  # the final position : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_arcball_set","title":"<code>dvz_arcball_set()</code>","text":"<p>Set the arcball angles.</p> CPython <pre><code>void dvz_arcball_set(\n    DvzArcball* arcball,  // the arcball\n    vec3 angles,  // the angles\n);\n</code></pre> <pre><code>dvz.arcball_set(\n    arcball,  # the arcball : DvzArcball*\n    angles,  # the angles : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#atlas","title":"Atlas","text":""},{"location":"reference/api_c/#dvz_atlas_destroy","title":"<code>dvz_atlas_destroy()</code>","text":"<p>Destroy an atlas.</p> CPython <pre><code>void dvz_atlas_destroy(\n    DvzAtlas* atlas,  // the atlas\n);\n</code></pre> <pre><code>dvz.atlas_destroy(\n    atlas,  # the atlas : DvzAtlas*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_atlas_font","title":"<code>dvz_atlas_font()</code>","text":"<p>Load the default atlas and font.</p> CPython <pre><code>void dvz_atlas_font(\n    float font_size,  // the font size\n    DvzAtlasFont* af,  // the returned DvzAtlasFont object with DvzAtlas and DvzFont objects.\n);\n</code></pre> <pre><code>dvz.atlas_font(\n    font_size,  # the font size : float\n    af,  # the returned DvzAtlasFont object with DvzAtlas and DvzFont objects. : Out[DvzAtlasFont]\n)\n</code></pre>"},{"location":"reference/api_c/#camera","title":"Camera","text":""},{"location":"reference/api_c/#dvz_camera_get_lookat","title":"<code>dvz_camera_get_lookat()</code>","text":"<p>Get the camera lookat position.</p> CPython <pre><code>void dvz_camera_get_lookat(\n    DvzCamera* camera,  // the camera\n    vec3 lookat,  // the lookat position\n);\n</code></pre> <pre><code>dvz.camera_get_lookat(\n    camera,  # the camera : DvzCamera*\n    lookat,  # the lookat position : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_get_position","title":"<code>dvz_camera_get_position()</code>","text":"<p>Get the camera position.</p> CPython <pre><code>void dvz_camera_get_position(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the pos\n);\n</code></pre> <pre><code>dvz.camera_get_position(\n    camera,  # the camera : DvzCamera*\n    pos,  # the pos : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_get_up","title":"<code>dvz_camera_get_up()</code>","text":"<p>Get the camera up vector.</p> CPython <pre><code>void dvz_camera_get_up(\n    DvzCamera* camera,  // the camera\n    vec3 up,  // the up vector\n);\n</code></pre> <pre><code>dvz.camera_get_up(\n    camera,  # the camera : DvzCamera*\n    up,  # the up vector : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_initial","title":"<code>dvz_camera_initial()</code>","text":"<p>Set the initial camera parameters.</p> CPython <pre><code>void dvz_camera_initial(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the initial position\n    vec3 lookat,  // the lookat position\n    vec3 up,  // the up vector\n);\n</code></pre> <pre><code>dvz.camera_initial(\n    camera,  # the camera : DvzCamera*\n    pos,  # the initial position : Tuple[float, float, float]\n    lookat,  # the lookat position : Tuple[float, float, float]\n    up,  # the up vector : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_lookat","title":"<code>dvz_camera_lookat()</code>","text":"<p>Set a camera lookat position.</p> CPython <pre><code>void dvz_camera_lookat(\n    DvzCamera* camera,  // the camera\n    vec3 lookat,  // the lookat position\n);\n</code></pre> <pre><code>dvz.camera_lookat(\n    camera,  # the camera : DvzCamera*\n    lookat,  # the lookat position : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_mvp","title":"<code>dvz_camera_mvp()</code>","text":"<p>Apply an MVP to a camera.</p> CPython <pre><code>void dvz_camera_mvp(\n    DvzCamera* camera,  // the camera\n    DvzMVP* mvp,  // the MVP\n);\n</code></pre> <pre><code>dvz.camera_mvp(\n    camera,  # the camera : DvzCamera*\n    mvp,  # the MVP : DvzMVP*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_ortho","title":"<code>dvz_camera_ortho()</code>","text":"<p>Make an orthographic camera.</p> CPython <pre><code>void dvz_camera_ortho(\n    DvzCamera* camera,  // the camera\n    float left,  // the left value\n    float right,  // the right value\n    float bottom,  // the bottom value\n    float top,  // the top value\n);\n</code></pre> <pre><code>dvz.camera_ortho(\n    camera,  # the camera : DvzCamera*\n    left,  # the left value : float\n    right,  # the right value : float\n    bottom,  # the bottom value : float\n    top,  # the top value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_perspective","title":"<code>dvz_camera_perspective()</code>","text":"<p>Set a camera perspective.</p> CPython <pre><code>void dvz_camera_perspective(\n    DvzCamera* camera,  // the camera\n    float fov,  // the field of view angle (in radians)\n);\n</code></pre> <pre><code>dvz.camera_perspective(\n    camera,  # the camera : DvzCamera*\n    fov,  # the field of view angle (in radians) : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_position","title":"<code>dvz_camera_position()</code>","text":"<p>Set a camera position.</p> CPython <pre><code>void dvz_camera_position(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the pos\n);\n</code></pre> <pre><code>dvz.camera_position(\n    camera,  # the camera : DvzCamera*\n    pos,  # the pos : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_print","title":"<code>dvz_camera_print()</code>","text":"<p>Display information about a camera.</p> CPython <pre><code>void dvz_camera_print(\n    DvzCamera* camera,  // the camera\n);\n</code></pre> <pre><code>dvz.camera_print(\n    camera,  # the camera : DvzCamera*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_reset","title":"<code>dvz_camera_reset()</code>","text":"<p>Reset a camera.</p> CPython <pre><code>void dvz_camera_reset(\n    DvzCamera* camera,  // the camera\n);\n</code></pre> <pre><code>dvz.camera_reset(\n    camera,  # the camera : DvzCamera*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_resize","title":"<code>dvz_camera_resize()</code>","text":"<p>Inform a camera of a panel resize.</p> CPython <pre><code>void dvz_camera_resize(\n    DvzCamera* camera,  // the camera\n    float width,  // the panel width\n    float height,  // the panel height\n);\n</code></pre> <pre><code>dvz.camera_resize(\n    camera,  # the camera : DvzCamera*\n    width,  # the panel width : float\n    height,  # the panel height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_up","title":"<code>dvz_camera_up()</code>","text":"<p>Set a camera up vector.</p> CPython <pre><code>void dvz_camera_up(\n    DvzCamera* camera,  // the camera\n    vec3 up,  // the up vector\n);\n</code></pre> <pre><code>dvz.camera_up(\n    camera,  # the camera : DvzCamera*\n    up,  # the up vector : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_viewproj","title":"<code>dvz_camera_viewproj()</code>","text":"<p>Return the view and proj matrices of the camera.</p> CPython <pre><code>void dvz_camera_viewproj(\n    DvzCamera* camera,  // the camera\n    mat4 view,  // the view matrix\n    mat4 proj,  // the proj matrix\n);\n</code></pre> <pre><code>dvz.camera_viewproj(\n    camera,  # the camera : DvzCamera*\n    view,  # the view matrix : Out[mat4]\n    proj,  # the proj matrix : Out[mat4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_camera_zrange","title":"<code>dvz_camera_zrange()</code>","text":"<p>Set the camera zrange.</p> CPython <pre><code>void dvz_camera_zrange(\n    DvzCamera* camera,  // the camera\n    float near,  // the near value\n    float far,  // the far value\n);\n</code></pre> <pre><code>dvz.camera_zrange(\n    camera,  # the camera : DvzCamera*\n    near,  # the near value : float\n    far,  # the far value : float\n)\n</code></pre>"},{"location":"reference/api_c/#circular","title":"Circular","text":""},{"location":"reference/api_c/#dvz_circular_2d","title":"<code>dvz_circular_2D()</code>","text":"<p>Generate a 2D circular motion.</p> CPython <pre><code>void dvz_circular_2D(\n    vec2 center,  // the circle center\n    float radius,  // the circle radius\n    float angle,  // the initial angle\n    float t,  // the normalized value\n    vec2 out,  // the 2D position\n);\n</code></pre> <pre><code>dvz.circular_2D(\n    center,  # the circle center : Tuple[float, float]\n    radius,  # the circle radius : float\n    angle,  # the initial angle : float\n    t,  # the normalized value : float\n    out,  # the 2D position : Out[Tuple[float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_circular_3d","title":"<code>dvz_circular_3D()</code>","text":"<p>Generate a 3D circular motion.</p> CPython <pre><code>void dvz_circular_3D(\n    vec3 pos_init,  // the initial position\n    vec3 center,  // the center position\n    vec3 axis,  // the axis around which to rotate\n    float t,  // the normalized value (1 = full circle)\n    vec3 out,  // the 3D position\n);\n</code></pre> <pre><code>dvz.circular_3D(\n    pos_init,  # the initial position : Tuple[float, float, float]\n    center,  # the center position : Tuple[float, float, float]\n    axis,  # the axis around which to rotate : Tuple[float, float, float]\n    t,  # the normalized value (1 = full circle) : float\n    out,  # the 3D position : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#colorbar","title":"Colorbar","text":""},{"location":"reference/api_c/#dvz_colorbar_anchor","title":"<code>dvz_colorbar_anchor()</code>","text":"<p>Set the anchor of a colorbar</p> CPython <pre><code>void dvz_colorbar_anchor(\n    DvzColorbar* colorbar,  // the colorbar\n    vec2 anchor,  // the colorbar anchor\n);\n</code></pre> <pre><code>dvz.colorbar_anchor(\n    colorbar,  # the colorbar : DvzColorbar*\n    anchor,  # the colorbar anchor : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_cmap","title":"<code>dvz_colorbar_cmap()</code>","text":"<p>Set the colormap of a colorbar.</p> CPython <pre><code>void dvz_colorbar_cmap(\n    DvzColorbar* colorbar,  // the colorbar\n    DvzColormap cmap,  // the colormap\n);\n</code></pre> <pre><code>dvz.colorbar_cmap(\n    colorbar,  # the colorbar : DvzColorbar*\n    cmap,  # the colormap : DvzColormap\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_destroy","title":"<code>dvz_colorbar_destroy()</code>","text":"<p>Destroy a colorbar.</p> CPython <pre><code>void dvz_colorbar_destroy(\n    DvzColorbar* colorbar,  // the colorbar\n);\n</code></pre> <pre><code>dvz.colorbar_destroy(\n    colorbar,  # the colorbar : DvzColorbar*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_panel","title":"<code>dvz_colorbar_panel()</code>","text":"<p>Add a colorbar to a panel.</p> CPython <pre><code>void dvz_colorbar_panel(\n    DvzColorbar* colorbar,  // the colorbar\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.colorbar_panel(\n    colorbar,  # the colorbar : DvzColorbar*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_position","title":"<code>dvz_colorbar_position()</code>","text":"<p>Set the position of a colorbar.</p> CPython <pre><code>void dvz_colorbar_position(\n    DvzColorbar* colorbar,  // the colorbar\n    vec2 position,  // the 2D position in NDC\n);\n</code></pre> <pre><code>dvz.colorbar_position(\n    colorbar,  # the colorbar : DvzColorbar*\n    position,  # the 2D position in NDC : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_range","title":"<code>dvz_colorbar_range()</code>","text":"<p>Set the colorbar range.</p> CPython <pre><code>void dvz_colorbar_range(\n    DvzColorbar* colorbar,  // the colorbar\n    double dmin,  // the minimal value\n    double dmax,  // the maximal value\n);\n</code></pre> <pre><code>dvz.colorbar_range(\n    colorbar,  # the colorbar : DvzColorbar*\n    dmin,  # the minimal value : float\n    dmax,  # the maximal value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_size","title":"<code>dvz_colorbar_size()</code>","text":"<p>Set the size of a colorbar</p> CPython <pre><code>void dvz_colorbar_size(\n    DvzColorbar* colorbar,  // the colorbar\n    vec2 size,  // the colorbar size in pixels\n);\n</code></pre> <pre><code>dvz.colorbar_size(\n    colorbar,  # the colorbar : DvzColorbar*\n    size,  # the colorbar size in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar_update","title":"<code>dvz_colorbar_update()</code>","text":"<p>Update a colorbar.</p> CPython <pre><code>void dvz_colorbar_update(\n    DvzColorbar* colorbar,  // the colorbar\n);\n</code></pre> <pre><code>dvz.colorbar_update(\n    colorbar,  # the colorbar : DvzColorbar*\n)\n</code></pre>"},{"location":"reference/api_c/#colormap","title":"Colormap","text":""},{"location":"reference/api_c/#dvz_colormap_8bit","title":"<code>dvz_colormap_8bit()</code>","text":"<p>Fetch a color from a colormap and a value (8-bit version).</p> CPython <pre><code>void dvz_colormap_8bit(\n    DvzColormap cmap,  // the colormap\n    uint8_t value,  // the value\n    cvec4 color,  // the fetched color\n);\n</code></pre> <pre><code>dvz.colormap_8bit(\n    cmap,  # the colormap : DvzColormap\n    value,  # the value : uint8_t\n    color,  # the fetched color : Out[cvec4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colormap_array","title":"<code>dvz_colormap_array()</code>","text":"<p>Fetch colors from a colormap and an array of values.</p> CPython <pre><code>void dvz_colormap_array(\n    DvzColormap cmap,  // the colormap\n    uint32_t count,  // the number of values\n    float* values,  // pointer to the array of float numbers\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    DvzColor* out,  // (array) the fetched colors\n);\n</code></pre> <pre><code>dvz.colormap_array(\n    cmap,  # the colormap : DvzColormap\n    count,  # the number of values : int\n    values,  # pointer to the array of float numbers : np.ndarray[float]\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n    out,  # (array) the fetched colors : Out[Tuple[int, int, int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colormap_scale","title":"<code>dvz_colormap_scale()</code>","text":"<p>Fetch a color from a colormap and an interpolated value.</p> CPython <pre><code>void dvz_colormap_scale(\n    DvzColormap cmap,  // the colormap\n    float value,  // the value\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    DvzColor color,  // the fetched color\n);\n</code></pre> <pre><code>dvz.colormap_scale(\n    cmap,  # the colormap : DvzColormap\n    value,  # the value : float\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n    color,  # the fetched color : Out[Tuple[int, int, int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#compute","title":"Compute","text":""},{"location":"reference/api_c/#dvz_compute_normals","title":"<code>dvz_compute_normals()</code>","text":"<p>Compute face normals.</p> CPython <pre><code>void dvz_compute_normals(\n    uint32_t vertex_count,  // number of vertices\n    uint32_t index_count,  // number of indices (triple of the number of faces)\n    vec3* pos,  // array of vec3 positions\n    DvzIndex* index,  // pos array of uint32_t indices\n    vec3* normal,  // (array) the vec3 normals (to be overwritten by this function)\n);\n</code></pre> <pre><code>dvz.compute_normals(\n    vertex_count,  # number of vertices : int\n    index_count,  # number of indices (triple of the number of faces) : int\n    pos,  # array of vec3 positions : np.ndarray[vec3]\n    index,  # pos array of uint32_t indices : DvzIndex*\n    normal,  # (array) the vec3 normals (to be overwritten by this function) : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#demo","title":"Demo","text":""},{"location":"reference/api_c/#dvz_demo_panel_2d","title":"<code>dvz_demo_panel_2D()</code>","text":"<p>Demo panel (random scatter plot).</p> CPython <pre><code>DvzVisual* dvz_demo_panel_2D(  // returns the marker visual\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.demo_panel_2D(  # returns the marker visual : DvzVisual*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_demo_panel_3d","title":"<code>dvz_demo_panel_3D()</code>","text":"<p>Demo panel (random scatter plot).</p> CPython <pre><code>DvzVisual* dvz_demo_panel_3D(  // returns the marker visual\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.demo_panel_3D(  # returns the marker visual : DvzVisual*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#error","title":"Error","text":""},{"location":"reference/api_c/#dvz_error_callback","title":"<code>dvz_error_callback()</code>","text":"<p>Register an error callback, a C function taking as input a string.</p> CPython <pre><code>void dvz_error_callback(\n    DvzErrorCallback cb,  // the error callback\n);\n</code></pre> <pre><code>dvz.error_callback(\n    cb,  # the error callback : DvzErrorCallback\n)\n</code></pre>"},{"location":"reference/api_c/#external","title":"External","text":""},{"location":"reference/api_c/#dvz_external_dat","title":"<code>dvz_external_dat()</code>","text":"<p>Get an external memory handle of a dat.</p> CPython <pre><code>int dvz_external_dat(  // returns the external memory handle of that buffer\n    DvzRenderer* rd,  // the renderer\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index of the dat\n    DvzSize* offset,  // the offset, in bytes, of the dat, within the buffer containing that dat\n);\n</code></pre> <pre><code>dvz.external_dat(  # returns the external memory handle of that buffer : int\n    rd,  # the renderer : DvzRenderer*\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index of the dat : int\n    offset,  # the offset, in bytes, of the dat, within the buffer containing that dat : Out[DvzSize]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_external_index","title":"<code>dvz_external_index()</code>","text":"<p>Get an external memory handle of an index dat.</p> CPython <pre><code>int dvz_external_index(  // returns the external memory handle of that buffer\n    DvzRenderer* rd,  // the renderer\n    DvzVisual* visual,  // the visual\n    DvzSize* offset,  // the offset, in bytes, of the dat, within the buffer containing that dat\n);\n</code></pre> <pre><code>dvz.external_index(  # returns the external memory handle of that buffer : int\n    rd,  # the renderer : DvzRenderer*\n    visual,  # the visual : DvzVisual*\n    offset,  # the offset, in bytes, of the dat, within the buffer containing that dat : Out[DvzSize]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_external_tex","title":"<code>dvz_external_tex()</code>","text":"<p>Get an external memory handle of a tex's staging buffer.</p> CPython <pre><code>int dvz_external_tex(  // returns the external memory handle of that buffer\n    DvzRenderer* rd,  // the renderer\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index of the tex\n    DvzSize* offset,  // the offset, in bytes, of the tex's staging dat, within the buffer containing\n);\n</code></pre> <pre><code>dvz.external_tex(  # returns the external memory handle of that buffer : int\n    rd,  # the renderer : DvzRenderer*\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index of the tex : int\n    offset,  # the offset, in bytes, of the tex's staging dat, within the buffer containing : Out[DvzSize]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_external_vertex","title":"<code>dvz_external_vertex()</code>","text":"<p>Get an external memory handle of a vertex dat.</p> CPython <pre><code>int dvz_external_vertex(  // returns the external memory handle of that buffer\n    DvzRenderer* rd,  // the renderer\n    DvzVisual* visual,  // the visual\n    uint32_t binding_idx,  // the binding index of the dat that is being used as vertex buffer\n    DvzSize* offset,  // the offset, in bytes, of the dat, within the buffer containing that dat\n);\n</code></pre> <pre><code>dvz.external_vertex(  # returns the external memory handle of that buffer : int\n    rd,  # the renderer : DvzRenderer*\n    visual,  # the visual : DvzVisual*\n    binding_idx,  # the binding index of the dat that is being used as vertex buffer : int\n    offset,  # the offset, in bytes, of the dat, within the buffer containing that dat : Out[DvzSize]\n)\n</code></pre>"},{"location":"reference/api_c/#figure","title":"Figure","text":""},{"location":"reference/api_c/#dvz_figure_destroy","title":"<code>dvz_figure_destroy()</code>","text":"<p>Destroy a figure.</p> CPython <pre><code>void dvz_figure_destroy(\n    DvzFigure* figure,  // the figure\n);\n</code></pre> <pre><code>dvz.figure_destroy(\n    figure,  # the figure : DvzFigure*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_figure_height","title":"<code>dvz_figure_height()</code>","text":"<p>Return a figure height.</p> CPython <pre><code>uint32_t dvz_figure_height(  // returns the figure height\n    DvzFigure* fig,  // the figure\n);\n</code></pre> <pre><code>dvz.figure_height(  # returns the figure height : uint32_t\n    fig,  # the figure : DvzFigure*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_figure_id","title":"<code>dvz_figure_id()</code>","text":"<p>Return a figure ID.</p> CPython <pre><code>DvzId dvz_figure_id(  // returns the figure ID\n    DvzFigure* figure,  // the figure\n);\n</code></pre> <pre><code>dvz.figure_id(  # returns the figure ID : DvzId\n    figure,  # the figure : DvzFigure*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_figure_resize","title":"<code>dvz_figure_resize()</code>","text":"<p>Resize a figure.</p> CPython <pre><code>void dvz_figure_resize(\n    DvzFigure* fig,  // the figure\n    uint32_t width,  // the window width\n    uint32_t height,  // the window height\n);\n</code></pre> <pre><code>dvz.figure_resize(\n    fig,  # the figure : DvzFigure*\n    width,  # the window width : int\n    height,  # the window height : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_figure_update","title":"<code>dvz_figure_update()</code>","text":"<p>Update a figure after the composition of the panels and visuals has changed.</p> CPython <pre><code>void dvz_figure_update(\n    DvzFigure* figure,  // the figure\n);\n</code></pre> <pre><code>dvz.figure_update(\n    figure,  # the figure : DvzFigure*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_figure_width","title":"<code>dvz_figure_width()</code>","text":"<p>Return a figure width.</p> CPython <pre><code>uint32_t dvz_figure_width(  // returns the figure width\n    DvzFigure* fig,  // the figure\n);\n</code></pre> <pre><code>dvz.figure_width(  # returns the figure width : uint32_t\n    fig,  # the figure : DvzFigure*\n)\n</code></pre>"},{"location":"reference/api_c/#fly","title":"Fly","text":""},{"location":"reference/api_c/#dvz_fly_destroy","title":"<code>dvz_fly_destroy()</code>","text":"<p>Destroy a fly camera controller.</p> CPython <pre><code>void dvz_fly_destroy(\n    DvzFly* fly,  // the fly camera controller\n);\n</code></pre> <pre><code>dvz.fly_destroy(\n    fly,  # the fly camera controller : DvzFly*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_get_lookat","title":"<code>dvz_fly_get_lookat()</code>","text":"<p>Get the current lookat point of the fly camera.</p> CPython <pre><code>void dvz_fly_get_lookat(\n    DvzFly* fly,  // the fly camera controller\n    vec3 out_lookat,  // the current lookat point\n);\n</code></pre> <pre><code>dvz.fly_get_lookat(\n    fly,  # the fly camera controller : DvzFly*\n    out_lookat,  # the current lookat point : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_get_position","title":"<code>dvz_fly_get_position()</code>","text":"<p>Get the current position of the fly camera.</p> CPython <pre><code>void dvz_fly_get_position(\n    DvzFly* fly,  // the fly camera controller\n    vec3 out_pos,  // the current position\n);\n</code></pre> <pre><code>dvz.fly_get_position(\n    fly,  # the fly camera controller : DvzFly*\n    out_pos,  # the current position : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_get_up","title":"<code>dvz_fly_get_up()</code>","text":"<p>Get the current up vector of the fly camera.</p> CPython <pre><code>void dvz_fly_get_up(\n    DvzFly* fly,  // the fly camera controller\n    vec3 out_up,  // the current up vector\n);\n</code></pre> <pre><code>dvz.fly_get_up(\n    fly,  # the fly camera controller : DvzFly*\n    out_up,  # the current up vector : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_initial","title":"<code>dvz_fly_initial()</code>","text":"<p>Set the initial position and orientation of a fly camera.</p> CPython <pre><code>void dvz_fly_initial(\n    DvzFly* fly,  // the fly camera controller\n    vec3 position,  // the initial position\n    float yaw,  // the initial yaw angle (rotation around Y axis)\n    float pitch,  // the initial pitch angle (rotation around X axis)\n    float roll,  // the initial roll angle (rotation around Z/view axis)\n);\n</code></pre> <pre><code>dvz.fly_initial(\n    fly,  # the fly camera controller : DvzFly*\n    position,  # the initial position : Tuple[float, float, float]\n    yaw,  # the initial yaw angle (rotation around Y axis) : float\n    pitch,  # the initial pitch angle (rotation around X axis) : float\n    roll,  # the initial roll angle (rotation around Z/view axis) : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_initial_lookat","title":"<code>dvz_fly_initial_lookat()</code>","text":"<p>Set the initial position and orientation of a fly camera.</p> CPython <pre><code>void dvz_fly_initial_lookat(\n    DvzFly* fly,  // the fly camera controller\n    vec3 position,  // the initial position\n    vec3 lookat,  // the initial lookat position\n);\n</code></pre> <pre><code>dvz.fly_initial_lookat(\n    fly,  # the fly camera controller : DvzFly*\n    position,  # the initial position : Tuple[float, float, float]\n    lookat,  # the initial lookat position : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_keyboard","title":"<code>dvz_fly_keyboard()</code>","text":"<p>Process a keyboard event for the fly camera controller.</p> CPython <pre><code>bool dvz_fly_keyboard(  // returns whether the event was handled by the fly camera\n    DvzFly* fly,  // the fly camera controller\n    DvzKeyboardEvent* ev,  // the keyboard event\n);\n</code></pre> <pre><code>dvz.fly_keyboard(  # returns whether the event was handled by the fly camera : bool\n    fly,  # the fly camera controller : DvzFly*\n    ev,  # the keyboard event : DvzKeyboardEvent*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_mouse","title":"<code>dvz_fly_mouse()</code>","text":"<p>Process a mouse event for the fly camera controller.</p> CPython <pre><code>bool dvz_fly_mouse(  // returns whether the event was handled by the fly camera\n    DvzFly* fly,  // the fly camera controller\n    DvzMouseEvent* ev,  // the mouse event\n);\n</code></pre> <pre><code>dvz.fly_mouse(  # returns whether the event was handled by the fly camera : bool\n    fly,  # the fly camera controller : DvzFly*\n    ev,  # the mouse event : DvzMouseEvent*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_move_forward","title":"<code>dvz_fly_move_forward()</code>","text":"<p>Move the fly camera forward or backward along its view direction.</p> CPython <pre><code>void dvz_fly_move_forward(\n    DvzFly* fly,  // the fly camera controller\n    float amount,  // the movement amount (positive for forward, negative for backward)\n);\n</code></pre> <pre><code>dvz.fly_move_forward(\n    fly,  # the fly camera controller : DvzFly*\n    amount,  # the movement amount (positive for forward, negative for backward) : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_move_right","title":"<code>dvz_fly_move_right()</code>","text":"<p>Move the fly camera right or left perpendicular to its view direction.</p> CPython <pre><code>void dvz_fly_move_right(\n    DvzFly* fly,  // the fly camera controller\n    float amount,  // the movement amount (positive for right, negative for left)\n);\n</code></pre> <pre><code>dvz.fly_move_right(\n    fly,  # the fly camera controller : DvzFly*\n    amount,  # the movement amount (positive for right, negative for left) : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_move_up","title":"<code>dvz_fly_move_up()</code>","text":"<p>Move the fly camera up or down along its up vector.</p> CPython <pre><code>void dvz_fly_move_up(\n    DvzFly* fly,  // the fly camera controller\n    float amount,  // the movement amount (positive for up, negative for down)\n);\n</code></pre> <pre><code>dvz.fly_move_up(\n    fly,  # the fly camera controller : DvzFly*\n    amount,  # the movement amount (positive for up, negative for down) : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_reset","title":"<code>dvz_fly_reset()</code>","text":"<p>Reset a fly camera to its initial position and orientation.</p> CPython <pre><code>void dvz_fly_reset(\n    DvzFly* fly,  // the fly camera controller\n);\n</code></pre> <pre><code>dvz.fly_reset(\n    fly,  # the fly camera controller : DvzFly*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_resize","title":"<code>dvz_fly_resize()</code>","text":"<p>Inform a fly camera of a panel resize.</p> CPython <pre><code>void dvz_fly_resize(\n    DvzFly* fly,  // the fly\n    float width,  // the panel width\n    float height,  // the panel height\n);\n</code></pre> <pre><code>dvz.fly_resize(\n    fly,  # the fly : DvzFly*\n    width,  # the panel width : float\n    height,  # the panel height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_roll","title":"<code>dvz_fly_roll()</code>","text":"<p>Roll the fly camera around its view direction.</p> CPython <pre><code>void dvz_fly_roll(\n    DvzFly* fly,  // the fly camera controller\n    float dx,  // the roll amount\n);\n</code></pre> <pre><code>dvz.fly_roll(\n    fly,  # the fly camera controller : DvzFly*\n    dx,  # the roll amount : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_rotate","title":"<code>dvz_fly_rotate()</code>","text":"<p>Rotate the fly camera's view direction (yaw and pitch).</p> CPython <pre><code>void dvz_fly_rotate(\n    DvzFly* fly,  // the fly camera controller\n    float dx,  // the horizontal rotation amount\n    float dy,  // the vertical rotation amount\n);\n</code></pre> <pre><code>dvz.fly_rotate(\n    fly,  # the fly camera controller : DvzFly*\n    dx,  # the horizontal rotation amount : float\n    dy,  # the vertical rotation amount : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly_set_lookat","title":"<code>dvz_fly_set_lookat()</code>","text":"<p>Set the lookat point of the fly camera.</p> CPython <pre><code>void dvz_fly_set_lookat(\n    DvzFly* fly,  // the fly camera controller\n    vec3 lookat,  // the lookat point\n);\n</code></pre> <pre><code>dvz.fly_set_lookat(\n    fly,  # the fly camera controller : DvzFly*\n    lookat,  # the lookat point : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#font","title":"Font","text":""},{"location":"reference/api_c/#dvz_font_ascii","title":"<code>dvz_font_ascii()</code>","text":"<p>Compute the shift of each glyph in an ASCII string, using the Freetype library.</p> CPython <pre><code>void dvz_font_ascii(\n    DvzFont* font,  // the font\n    char* string,  // the ASCII string\n    vec4* xywh,  // the returned array of (x,y,w,h) shifts\n);\n</code></pre> <pre><code>dvz.font_ascii(\n    font,  # the font : DvzFont*\n    string,  # the ASCII string : str\n    xywh,  # the returned array of (x,y,w,h) shifts : np.ndarray[vec4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_font_destroy","title":"<code>dvz_font_destroy()</code>","text":"<p>Destroy a font.</p> CPython <pre><code>void dvz_font_destroy(\n    DvzFont* font,  // the font\n);\n</code></pre> <pre><code>dvz.font_destroy(\n    font,  # the font : DvzFont*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_font_draw","title":"<code>dvz_font_draw()</code>","text":"<p>Render a string using Freetype. Note: the caller must free the output after use.</p> CPython <pre><code>uint8_t* dvz_font_draw(  // returns an RGBA array allocated by this function and that MUST be freed by the caller\n    DvzFont* font,  // the font\n    uint32_t length,  // the number of glyphs\n    uint32_t* codepoints,  // the Unicode codepoints of the glyphs\n    vec4* xywh,  // an array of (x,y,w,h) shifts, returned by dvz_font_layout()\n    int flags,  // the font flags\n    uvec2 out_size,  // the number of bytes in the returned image\n);\n</code></pre> <pre><code>dvz.font_draw(  # returns an RGBA array allocated by this function and that MUST be freed by the caller : uint8_t*\n    font,  # the font : DvzFont*\n    length,  # the number of glyphs : int\n    codepoints,  # the Unicode codepoints of the glyphs : np.ndarray[uint32_t]\n    xywh,  # an array of (x,y,w,h) shifts, returned by dvz_font_layout() : np.ndarray[vec4]\n    flags,  # the font flags : int\n    out_size,  # the number of bytes in the returned image : Out[Tuple[int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_font_layout","title":"<code>dvz_font_layout()</code>","text":"<p>Compute the shift of each glyph in a Unicode string, using the Freetype library.</p> CPython <pre><code>void dvz_font_layout(\n    DvzFont* font,  // the font\n    uint32_t length,  // the number of glyphs\n    uint32_t* codepoints,  // the Unicode codepoints of the glyphs\n    vec4* xywh,  // an array of (x,y,w,h) shifts\n);\n</code></pre> <pre><code>dvz.font_layout(\n    font,  # the font : DvzFont*\n    length,  # the number of glyphs : int\n    codepoints,  # the Unicode codepoints of the glyphs : np.ndarray[uint32_t]\n    xywh,  # an array of (x,y,w,h) shifts : np.ndarray[vec4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_font_size","title":"<code>dvz_font_size()</code>","text":"<p>Set the font size.</p> CPython <pre><code>void dvz_font_size(\n    DvzFont* font,  // the font\n    double size,  // the font size\n);\n</code></pre> <pre><code>dvz.font_size(\n    font,  # the font : DvzFont*\n    size,  # the font size : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_font_texture","title":"<code>dvz_font_texture()</code>","text":"<p>Generate a texture with a rendered text.</p> CPython <pre><code>DvzTexture* dvz_font_texture(  // returns the texture\n    DvzFont* font,  // the font\n    DvzBatch* batch,  // the batch\n    uint32_t length,  // the number of Unicode codepoints\n    uint32_t* codepoints,  // the Unicode codepoints\n    uvec3 size,  // the generated texture size\n);\n</code></pre> <pre><code>dvz.font_texture(  # returns the texture : DvzTexture*\n    font,  # the font : DvzFont*\n    batch,  # the batch : DvzBatch*\n    length,  # the number of Unicode codepoints : int\n    codepoints,  # the Unicode codepoints : np.ndarray[uint32_t]\n    size,  # the generated texture size : Out[Tuple[int, int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#interpolate","title":"Interpolate","text":""},{"location":"reference/api_c/#dvz_interpolate_2d","title":"<code>dvz_interpolate_2D()</code>","text":"<p>Make a linear interpolation between two 2D points.</p> CPython <pre><code>void dvz_interpolate_2D(\n    vec2 p0,  // the first point\n    vec2 p1,  // the second point\n    float t,  // the normalized value\n    vec2 out,  // the interpolated point\n);\n</code></pre> <pre><code>dvz.interpolate_2D(\n    p0,  # the first point : Tuple[float, float]\n    p1,  # the second point : Tuple[float, float]\n    t,  # the normalized value : float\n    out,  # the interpolated point : Out[Tuple[float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_interpolate_3d","title":"<code>dvz_interpolate_3D()</code>","text":"<p>Make a linear interpolation between two 3D points.</p> CPython <pre><code>void dvz_interpolate_3D(\n    vec3 p0,  // the first point\n    vec3 p1,  // the second point\n    float t,  // the normalized value\n    vec3 out,  // the interpolated point\n);\n</code></pre> <pre><code>dvz.interpolate_3D(\n    p0,  # the first point : Tuple[float, float, float]\n    p1,  # the second point : Tuple[float, float, float]\n    t,  # the normalized value : float\n    out,  # the interpolated point : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#min","title":"Min","text":""},{"location":"reference/api_c/#dvz_min_max","title":"<code>dvz_min_max()</code>","text":"<p>Compute the min and max of an array of float values.</p> CPython <pre><code>void dvz_min_max(\n    uint32_t n,  // the number of values\n    float* values,  // an array of float numbers\n    vec2 out_min_max,  // the min and max\n);\n</code></pre> <pre><code>dvz.min_max(\n    n,  # the number of values : int\n    values,  # an array of float numbers : np.ndarray[float]\n    out_min_max,  # the min and max : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#misc","title":"Misc","text":""},{"location":"reference/api_c/#dvz_app","title":"<code>dvz_app()</code>","text":"<p>Create an app.</p> CPython <pre><code>DvzApp* dvz_app(  // returns the app\n    int flags,  // the app creation flags\n);\n</code></pre> <pre><code>dvz.app(  # returns the app : DvzApp*\n    flags,  # the app creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colorbar","title":"<code>dvz_colorbar()</code>","text":"<p>Create a colorbar.</p> CPython <pre><code>DvzColorbar* dvz_colorbar(  // returns the colorbar\n    DvzBatch* batch,  // the batch\n    DvzColormap cmap,  // the colormap\n    double dmin,  // the minimal value\n    double dmax,  // the maximal value\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.colorbar(  # returns the colorbar : DvzColorbar*\n    batch,  # the batch : DvzBatch*\n    cmap,  # the colormap : DvzColormap\n    dmin,  # the minimal value : float\n    dmax,  # the maximal value : float\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_colormap","title":"<code>dvz_colormap()</code>","text":"<p>Fetch a color from a colormap and a value (either 8-bit or float, depending on DVZ_COLOR_CVEC4).</p> CPython <pre><code>void dvz_colormap(\n    DvzColormap cmap,  // the colormap\n    uint8_t value,  // the value\n    DvzColor color,  // the fetched color\n);\n</code></pre> <pre><code>dvz.colormap(\n    cmap,  # the colormap : DvzColormap\n    value,  # the value : uint8_t\n    color,  # the fetched color : Out[Tuple[int, int, int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_demo","title":"<code>dvz_demo()</code>","text":"<p>Run a demo.</p> CPython <pre><code>void dvz_demo(\n);\n</code></pre> <pre><code>dvz.demo(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_earcut","title":"<code>dvz_earcut()</code>","text":"<p>Compute a polygon triangulation with only indexing on the polygon contour vertices.</p> CPython <pre><code>DvzIndex* dvz_earcut(  // returns the computed indices (must be FREED by the caller)\n    uint32_t point_count,  // the number of points\n    dvec2* polygon,  // the polygon 2D positions\n    uint32_t* out_index_count,  // the computed index count\n);\n</code></pre> <pre><code>dvz.earcut(  # returns the computed indices (must be FREED by the caller) : DvzIndex*\n    point_count,  # the number of points : int\n    polygon,  # the polygon 2D positions : np.ndarray[dvec2]\n    out_index_count,  # the computed index count : Out[int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_easing","title":"<code>dvz_easing()</code>","text":"<p>Apply an easing function to a normalized value.</p> CPython <pre><code>double dvz_easing(  // returns the eased value\n    DvzEasing easing,  // the easing mode\n    double t,  // the normalized value\n);\n</code></pre> <pre><code>dvz.easing(  # returns the eased value : double\n    easing,  # the easing mode : DvzEasing\n    t,  # the normalized value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_figure","title":"<code>dvz_figure()</code>","text":"<p>Create a figure, a desktop window with panels and visuals.</p> CPython <pre><code>DvzFigure* dvz_figure(  // returns the figure\n    DvzScene* scene,  // the scene\n    uint32_t width,  // the window width\n    uint32_t height,  // the window height\n    int flags,  // the figure creation flags (not yet stabilized)\n);\n</code></pre> <pre><code>dvz.figure(  # returns the figure : DvzFigure*\n    scene,  # the scene : DvzScene*\n    width,  # the window width : int\n    height,  # the window height : int\n    flags,  # the figure creation flags (not yet stabilized) : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_fly","title":"<code>dvz_fly()</code>","text":"<p>Create a fly camera controller.</p> CPython <pre><code>DvzFly* dvz_fly(  // returns the fly camera controller\n    int flags,  // the fly camera controller flags\n);\n</code></pre> <pre><code>dvz.fly(  # returns the fly camera controller : DvzFly*\n    flags,  # the fly camera controller flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_font","title":"<code>dvz_font()</code>","text":"<p>Create a font.</p> CPython <pre><code>DvzFont* dvz_font(  // returns the font\n    long ttf_size,  // size in bytes of a TTF font raw buffer\n    char* ttf_bytes,  // TTF font raw buffer\n);\n</code></pre> <pre><code>dvz.font(  # returns the font : DvzFont*\n    ttf_size,  # size in bytes of a TTF font raw buffer : long\n    ttf_bytes,  # TTF font raw buffer : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_free","title":"<code>dvz_free()</code>","text":"<p>Free a pointer.</p> CPython <pre><code>void dvz_free(\n    void* pointer,  // a pointer\n);\n</code></pre> <pre><code>dvz.free(\n    pointer,  # a pointer : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_interpolate","title":"<code>dvz_interpolate()</code>","text":"<p>Make a linear interpolation between two scalar value.</p> CPython <pre><code>float dvz_interpolate(  // returns the interpolated value\n    float p0,  // the first value\n    float p1,  // the second value\n    float t,  // the normalized value\n);\n</code></pre> <pre><code>dvz.interpolate(  # returns the interpolated value : float\n    p0,  # the first value : float\n    p1,  # the second value : float\n    t,  # the normalized value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mean","title":"<code>dvz_mean()</code>","text":"<p>Compute the mean of an array of double values.</p> CPython <pre><code>double dvz_mean(  // returns the mean\n    uint32_t n,  // the number of values\n    double* values,  // an array of double numbers\n);\n</code></pre> <pre><code>dvz.mean(  # returns the mean : double\n    n,  # the number of values : int\n    values,  # an array of double numbers : np.ndarray[double]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mouse","title":"<code>dvz_mouse()</code>","text":"<p>Create a mouse object.</p> CPython <pre><code>DvzMouse* dvz_mouse(  // returns the mouse\n);\n</code></pre> <pre><code>dvz.mouse(  # returns the mouse : DvzMouse*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel","title":"<code>dvz_panel()</code>","text":"<p>Create a panel in a figure (partial or complete rectangular portion of a figure).</p> CPython <pre><code>DvzPanel* dvz_panel(\n    DvzFigure* fig,  // the figure\n    float x,  // the x coordinate of the top left corner, in pixels\n    float y,  // the y coordinate of the top left corner, in pixels\n    float width,  // the panel width, in pixels\n    float height,  // the panel height, in pixels\n);\n</code></pre> <pre><code>dvz.panel(\n    fig,  # the figure : DvzFigure*\n    x,  # the x coordinate of the top left corner, in pixels : float\n    y,  # the y coordinate of the top left corner, in pixels : float\n    width,  # the panel width, in pixels : float\n    height,  # the panel height, in pixels : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom","title":"<code>dvz_panzoom()</code>","text":"<p>Create a panzoom object (usually you'd rather use <code>dvz_panel_panzoom()</code>).</p> CPython <pre><code>DvzPanzoom* dvz_panzoom(  // returns the Panzoom object\n    float width,  // the panel width\n    float height,  // the panel height\n    int flags,  // the panzoom creation flags\n);\n</code></pre> <pre><code>dvz.panzoom(  # returns the Panzoom object : DvzPanzoom*\n    width,  # the panel width : float\n    height,  # the panel height : float\n    flags,  # the panzoom creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_range","title":"<code>dvz_range()</code>","text":"<p>Compute the range of an array of double values.</p> CPython <pre><code>void dvz_range(\n    uint32_t n,  // the number of values\n    double* values,  // an array of double numbers\n    dvec2 min_max,  // the min and max values\n);\n</code></pre> <pre><code>dvz.range(\n    n,  # the number of values : int\n    values,  # an array of double numbers : np.ndarray[double]\n    min_max,  # the min and max values : Out[dvec2]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref","title":"<code>dvz_ref()</code>","text":"<p>Create a reference frame (wrapping a 3D box representing the data in its original coordinates).</p> CPython <pre><code>DvzRef* dvz_ref(  // returns the reference frame\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.ref(  # returns the reference frame : DvzRef*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_resample","title":"<code>dvz_resample()</code>","text":"<p>Normalize a value in an interval.</p> CPython <pre><code>double dvz_resample(  // returns the normalized value between 0 and 1\n    double t0,  // the interval start\n    double t1,  // the interval end\n    double t,  // the value within the interval\n);\n</code></pre> <pre><code>dvz.resample(  # returns the normalized value between 0 and 1 : double\n    t0,  # the interval start : float\n    t1,  # the interval end : float\n    t,  # the value within the interval : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_scene","title":"<code>dvz_scene()</code>","text":"<p>Create a scene.</p> CPython <pre><code>DvzScene* dvz_scene(  // returns the scene\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.scene(  # returns the scene : DvzScene*\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_server","title":"<code>dvz_server()</code>","text":"<p>Placeholder.</p> CPython <pre><code>DvzServer* dvz_server(\n    int flags,  // placeholder\n);\n</code></pre> <pre><code>dvz.server(\n    flags,  # placeholder : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape","title":"<code>dvz_shape()</code>","text":"<p>Create an empty shape.</p> CPython <pre><code>DvzShape* dvz_shape(  // returns the shape\n);\n</code></pre> <pre><code>dvz.shape(  # returns the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture","title":"<code>dvz_texture()</code>","text":"<p>Create a texture.</p> CPython <pre><code>DvzTexture* dvz_texture(  // returns the texture\n    DvzBatch* batch,  // the batch\n    DvzTexDims dims,  // the number of dimensions in the texture\n    int flags,  // the texture creation flags\n);\n</code></pre> <pre><code>dvz.texture(  # returns the texture : DvzTexture*\n    batch,  # the batch : DvzBatch*\n    dims,  # the number of dimensions in the texture : DvzTexDims\n    flags,  # the texture creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_time","title":"<code>dvz_time()</code>","text":"<p>Get the current time.</p> CPython <pre><code>void dvz_time(\n    DvzTime* time,  // fill a structure with seconds and nanoseconds integers\n);\n</code></pre> <pre><code>dvz.time(\n    time,  # fill a structure with seconds and nanoseconds integers : Out[DvzTime]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_version","title":"<code>dvz_version()</code>","text":"<p>Return the current version string.</p> CPython <pre><code>char* dvz_version(  // returns the version string\n);\n</code></pre> <pre><code>dvz.version(  # returns the version string : char*\n)\n</code></pre>"},{"location":"reference/api_c/#mock","title":"Mock","text":""},{"location":"reference/api_c/#dvz_mock_band","title":"<code>dvz_mock_band()</code>","text":"<p>Generate points on a band.</p> CPython <pre><code>vec3* dvz_mock_band(  // returns the positions\n    uint32_t count,  // the number of positions to generate\n    vec2 size,  // the size of the band\n);\n</code></pre> <pre><code>dvz.mock_band(  # returns the positions : vec3*\n    count,  # the number of positions to generate : int\n    size,  # the size of the band : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_circle","title":"<code>dvz_mock_circle()</code>","text":"<p>Generate points on a circle.</p> CPython <pre><code>vec3* dvz_mock_circle(  // returns the positions\n    uint32_t count,  // the number of positions to generate\n    float radius,  // the radius of the circle\n);\n</code></pre> <pre><code>dvz.mock_circle(  # returns the positions : vec3*\n    count,  # the number of positions to generate : int\n    radius,  # the radius of the circle : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_cmap","title":"<code>dvz_mock_cmap()</code>","text":"<p>Generate a set of colormap colors.</p> CPython <pre><code>DvzColor* dvz_mock_cmap(  // returns colors\n    uint32_t count,  // the number of colors to generate\n    DvzColormap cmap,  // the colormap\n    DvzAlpha alpha,  // the alpha value\n);\n</code></pre> <pre><code>dvz.mock_cmap(  # returns colors : DvzColor*\n    count,  # the number of colors to generate : int\n    cmap,  # the colormap : DvzColormap\n    alpha,  # the alpha value : DvzAlpha\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_color","title":"<code>dvz_mock_color()</code>","text":"<p>Generate a set of random colors.</p> CPython <pre><code>DvzColor* dvz_mock_color(  // returns random colors\n    uint32_t count,  // the number of colors to generate\n    DvzAlpha alpha,  // the alpha value\n);\n</code></pre> <pre><code>dvz.mock_color(  # returns random colors : DvzColor*\n    count,  # the number of colors to generate : int\n    alpha,  # the alpha value : DvzAlpha\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_fixed","title":"<code>dvz_mock_fixed()</code>","text":"<p>Generate identical 3D positions.</p> CPython <pre><code>vec3* dvz_mock_fixed(  // returns the repeated positions\n    uint32_t count,  // the number of positions to generate\n    vec3 fixed,  // the position\n);\n</code></pre> <pre><code>dvz.mock_fixed(  # returns the repeated positions : vec3*\n    count,  # the number of positions to generate : int\n    fixed,  # the position : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_full","title":"<code>dvz_mock_full()</code>","text":"<p>Generate an array with the same value.</p> CPython <pre><code>float* dvz_mock_full(  // returns the values\n    uint32_t count,  // the number of scalars to generate\n    float value,  // the value\n);\n</code></pre> <pre><code>dvz.mock_full(  # returns the values : float*\n    count,  # the number of scalars to generate : int\n    value,  # the value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_line","title":"<code>dvz_mock_line()</code>","text":"<p>Generate 3D positions on a line.</p> CPython <pre><code>vec3* dvz_mock_line(  // returns the positions\n    uint32_t count,  // the number of positions to generate\n    vec3 p0,  // initial position\n    vec3 p1,  // terminal position\n);\n</code></pre> <pre><code>dvz.mock_line(  # returns the positions : vec3*\n    count,  # the number of positions to generate : int\n    p0,  # initial position : Tuple[float, float, float]\n    p1,  # terminal position : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_linspace","title":"<code>dvz_mock_linspace()</code>","text":"<p>Generate an array ranging from an initial value to a final value.</p> CPython <pre><code>float* dvz_mock_linspace(  // returns the values\n    uint32_t count,  // the number of scalars to generate\n    float initial,  // the initial value\n    float final,  // the final value\n);\n</code></pre> <pre><code>dvz.mock_linspace(  # returns the values : float*\n    count,  # the number of scalars to generate : int\n    initial,  # the initial value : float\n    final,  # the final value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_monochrome","title":"<code>dvz_mock_monochrome()</code>","text":"<p>Repeat a color in an array.</p> CPython <pre><code>DvzColor* dvz_mock_monochrome(  // returns colors\n    uint32_t count,  // the number of colors to generate\n    DvzColor mono,  // the color to repeat\n);\n</code></pre> <pre><code>dvz.mock_monochrome(  # returns colors : DvzColor*\n    count,  # the number of colors to generate : int\n    mono,  # the color to repeat : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_pos_2d","title":"<code>dvz_mock_pos_2D()</code>","text":"<p>Generate a set of random 2D positions.</p> CPython <pre><code>vec3* dvz_mock_pos_2D(  // returns the positions\n    uint32_t count,  // the number of positions to generate\n    float std,  // the standard deviation\n);\n</code></pre> <pre><code>dvz.mock_pos_2D(  # returns the positions : vec3*\n    count,  # the number of positions to generate : int\n    std,  # the standard deviation : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_pos_3d","title":"<code>dvz_mock_pos_3D()</code>","text":"<p>Generate a set of random 3D positions.</p> CPython <pre><code>vec3* dvz_mock_pos_3D(  // returns the positions\n    uint32_t count,  // the number of positions to generate\n    float std,  // the standard deviation\n);\n</code></pre> <pre><code>dvz.mock_pos_3D(  # returns the positions : vec3*\n    count,  # the number of positions to generate : int\n    std,  # the standard deviation : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_range","title":"<code>dvz_mock_range()</code>","text":"<p>Generate an array of consecutive positive numbers.</p> CPython <pre><code>uint32_t* dvz_mock_range(  // returns the values\n    uint32_t count,  // the number of consecutive integers to generate\n    uint32_t initial,  // the initial value\n);\n</code></pre> <pre><code>dvz.mock_range(  # returns the values : uint32_t*\n    count,  # the number of consecutive integers to generate : int\n    initial,  # the initial value : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mock_uniform","title":"<code>dvz_mock_uniform()</code>","text":"<p>Generate a set of uniformly random scalar values.</p> CPython <pre><code>float* dvz_mock_uniform(  // returns the values\n    uint32_t count,  // the number of values to generate\n    float vmin,  // the minimum value of the interval\n    float vmax,  // the maximum value of the interval\n);\n</code></pre> <pre><code>dvz.mock_uniform(  # returns the values : float*\n    count,  # the number of values to generate : int\n    vmin,  # the minimum value of the interval : float\n    vmax,  # the maximum value of the interval : float\n)\n</code></pre>"},{"location":"reference/api_c/#mouse","title":"Mouse","text":""},{"location":"reference/api_c/#dvz_mouse_destroy","title":"<code>dvz_mouse_destroy()</code>","text":"<p>Destroy a mouse.</p> CPython <pre><code>void dvz_mouse_destroy(\n    DvzMouse* mouse,  // the mouse\n);\n</code></pre> <pre><code>dvz.mouse_destroy(\n    mouse,  # the mouse : DvzMouse*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mouse_event","title":"<code>dvz_mouse_event()</code>","text":"<p>Create a generic mouse event.</p> CPython <pre><code>void dvz_mouse_event(\n    DvzMouse* mouse,  // the mouse\n    DvzMouseEvent* ev,  // the mouse event\n);\n</code></pre> <pre><code>dvz.mouse_event(\n    mouse,  # the mouse : DvzMouse*\n    ev,  # the mouse event : DvzMouseEvent*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mouse_move","title":"<code>dvz_mouse_move()</code>","text":"<p>Create a mouse move event.</p> CPython <pre><code>void dvz_mouse_move(\n    DvzMouse* mouse,  // the mouse\n    vec2 pos,  // the cursor position, in pixels\n    int mods,  // the keyboard modifier flags\n);\n</code></pre> <pre><code>dvz.mouse_move(\n    mouse,  # the mouse : DvzMouse*\n    pos,  # the cursor position, in pixels : Tuple[float, float]\n    mods,  # the keyboard modifier flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mouse_press","title":"<code>dvz_mouse_press()</code>","text":"<p>Create a mouse press event.</p> CPython <pre><code>void dvz_mouse_press(\n    DvzMouse* mouse,  // the mouse\n    DvzMouseButton button,  // the mouse button (enum int)\n    int mods,  // the keyboard modifier flags\n);\n</code></pre> <pre><code>dvz.mouse_press(\n    mouse,  # the mouse : DvzMouse*\n    button,  # the mouse button (enum int) : DvzMouseButton\n    mods,  # the keyboard modifier flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mouse_release","title":"<code>dvz_mouse_release()</code>","text":"<p>Create a mouse release event.</p> CPython <pre><code>void dvz_mouse_release(\n    DvzMouse* mouse,  // the mouse\n    DvzMouseButton button,  // the mouse button (enum int)\n    int mods,  // the keyboard modifier flags\n);\n</code></pre> <pre><code>dvz.mouse_release(\n    mouse,  # the mouse : DvzMouse*\n    button,  # the mouse button (enum int) : DvzMouseButton\n    mods,  # the keyboard modifier flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mouse_wheel","title":"<code>dvz_mouse_wheel()</code>","text":"<p>Create a mouse wheel event.</p> CPython <pre><code>void dvz_mouse_wheel(\n    DvzMouse* mouse,  // the mouse\n    vec2 dir,  // the mouse wheel direction (x, y)\n    int mods,  // the keyboard modifier flags\n);\n</code></pre> <pre><code>dvz.mouse_wheel(\n    mouse,  # the mouse : DvzMouse*\n    dir,  # the mouse wheel direction (x, y) : Tuple[float, float]\n    mods,  # the keyboard modifier flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#msdf","title":"Msdf","text":""},{"location":"reference/api_c/#dvz_msdf_from_svg","title":"<code>dvz_msdf_from_svg()</code>","text":"<p>Generate a multichannel SDF from an SVG path.</p> CPython <pre><code>float* dvz_msdf_from_svg(  // returns the generated texture as RGB floats\n    char* svg_path,  // the SVG path\n    uint32_t width,  // the width of the generated SDF, in pixels\n    uint32_t height,  // the height of the generated SDF, in pixels\n);\n</code></pre> <pre><code>dvz.msdf_from_svg(  # returns the generated texture as RGB floats : float*\n    svg_path,  # the SVG path : str\n    width,  # the width of the generated SDF, in pixels : int\n    height,  # the height of the generated SDF, in pixels : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_msdf_to_rgb","title":"<code>dvz_msdf_to_rgb()</code>","text":"<p>Convert a multichannel SDF float texture to a byte texture.</p> CPython <pre><code>uint8_t* dvz_msdf_to_rgb(  // returns the byte texture\n    float* sdf,  // the SDF float texture\n    uint32_t width,  // the width of the texture\n    uint32_t height,  // the height of the texture\n);\n</code></pre> <pre><code>dvz.msdf_to_rgb(  # returns the byte texture : uint8_t*\n    sdf,  # the SDF float texture : np.ndarray[float]\n    width,  # the width of the texture : int\n    height,  # the height of the texture : int\n)\n</code></pre>"},{"location":"reference/api_c/#next","title":"Next","text":""},{"location":"reference/api_c/#dvz_next_pow2","title":"<code>dvz_next_pow2()</code>","text":"<p>Return the smallest power of 2 larger or equal than a positive integer.</p> CPython <pre><code>uint64_t dvz_next_pow2(  // returns the power of 2\n    uint64_t x,  // the value\n);\n</code></pre> <pre><code>dvz.next_pow2(  # returns the power of 2 : uint64_t\n    x,  # the value : int\n)\n</code></pre>"},{"location":"reference/api_c/#normalize","title":"Normalize","text":""},{"location":"reference/api_c/#dvz_normalize_bytes","title":"<code>dvz_normalize_bytes()</code>","text":"<p>Normalize the array.</p> CPython <pre><code>void dvz_normalize_bytes(\n    vec2 min_max,  // the minimum and maximum values, mapped to 0 and 255, the result will be clipped\n    uint32_t count,  // the number of values\n    float* values,  // an array of float numbers\n    uint8_t* out,  // the out uint8 array\n);\n</code></pre> <pre><code>dvz.normalize_bytes(\n    min_max,  # the minimum and maximum values, mapped to 0 and 255, the result will be clipped : Tuple[float, float]\n    count,  # the number of values : int\n    values,  # an array of float numbers : np.ndarray[float]\n    out,  # the out uint8 array : np.ndarray[uint8_t]\n)\n</code></pre>"},{"location":"reference/api_c/#num","title":"Num","text":""},{"location":"reference/api_c/#dvz_num_procs","title":"<code>dvz_num_procs()</code>","text":"<p>Return the number of processors on the current system.</p> CPython <pre><code>int dvz_num_procs(  // returns the number of processors\n);\n</code></pre> <pre><code>dvz.num_procs(  # returns the number of processors : int\n)\n</code></pre>"},{"location":"reference/api_c/#ortho","title":"Ortho","text":""},{"location":"reference/api_c/#dvz_ortho_end","title":"<code>dvz_ortho_end()</code>","text":"<p>End an ortho interaction.</p> CPython <pre><code>void dvz_ortho_end(\n    DvzOrtho* ortho,  // the ortho\n);\n</code></pre> <pre><code>dvz.ortho_end(\n    ortho,  # the ortho : DvzOrtho*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_flags","title":"<code>dvz_ortho_flags()</code>","text":"<p>Set the ortho flags.</p> CPython <pre><code>void dvz_ortho_flags(\n    DvzOrtho* ortho,  // the ortho\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.ortho_flags(\n    ortho,  # the ortho : DvzOrtho*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_mvp","title":"<code>dvz_ortho_mvp()</code>","text":"<p>Apply an MVP matrix to an ortho.</p> CPython <pre><code>void dvz_ortho_mvp(\n    DvzOrtho* ortho,  // the ortho\n    DvzMVP* mvp,  // the MVP\n);\n</code></pre> <pre><code>dvz.ortho_mvp(\n    ortho,  # the ortho : DvzOrtho*\n    mvp,  # the MVP : DvzMVP*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_pan","title":"<code>dvz_ortho_pan()</code>","text":"<p>Apply a pan value to an ortho.</p> CPython <pre><code>void dvz_ortho_pan(\n    DvzOrtho* ortho,  // the ortho\n    vec2 pan,  // the pan, in NDC\n);\n</code></pre> <pre><code>dvz.ortho_pan(\n    ortho,  # the ortho : DvzOrtho*\n    pan,  # the pan, in NDC : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_pan_shift","title":"<code>dvz_ortho_pan_shift()</code>","text":"<p>Apply a pan shift to an ortho.</p> CPython <pre><code>void dvz_ortho_pan_shift(\n    DvzOrtho* ortho,  // the ortho\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n);\n</code></pre> <pre><code>dvz.ortho_pan_shift(\n    ortho,  # the ortho : DvzOrtho*\n    shift_px,  # the shift value, in pixels : Tuple[float, float]\n    center_px,  # the center position, in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_reset","title":"<code>dvz_ortho_reset()</code>","text":"<p>Reset an ortho.</p> CPython <pre><code>void dvz_ortho_reset(\n    DvzOrtho* ortho,  // the ortho\n);\n</code></pre> <pre><code>dvz.ortho_reset(\n    ortho,  # the ortho : DvzOrtho*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_resize","title":"<code>dvz_ortho_resize()</code>","text":"<p>Inform an ortho of a panel resize.</p> CPython <pre><code>void dvz_ortho_resize(\n    DvzOrtho* ortho,  // the ortho\n    float width,  // the panel width\n    float height,  // the panel height\n);\n</code></pre> <pre><code>dvz.ortho_resize(\n    ortho,  # the ortho : DvzOrtho*\n    width,  # the panel width : float\n    height,  # the panel height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_zoom","title":"<code>dvz_ortho_zoom()</code>","text":"<p>Apply a zoom value to an ortho.</p> CPython <pre><code>void dvz_ortho_zoom(\n    DvzOrtho* ortho,  // the ortho\n    float zoom,  // the zoom level\n);\n</code></pre> <pre><code>dvz.ortho_zoom(\n    ortho,  # the ortho : DvzOrtho*\n    zoom,  # the zoom level : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_zoom_shift","title":"<code>dvz_ortho_zoom_shift()</code>","text":"<p>Apply a zoom shift to an ortho.</p> CPython <pre><code>void dvz_ortho_zoom_shift(\n    DvzOrtho* ortho,  // the ortho\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n);\n</code></pre> <pre><code>dvz.ortho_zoom_shift(\n    ortho,  # the ortho : DvzOrtho*\n    shift_px,  # the shift value, in pixels : Tuple[float, float]\n    center_px,  # the center position, in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ortho_zoom_wheel","title":"<code>dvz_ortho_zoom_wheel()</code>","text":"<p>Apply a wheel zoom to an ortho.</p> CPython <pre><code>void dvz_ortho_zoom_wheel(\n    DvzOrtho* ortho,  // the ortho\n    vec2 dir,  // the wheel direction\n    vec2 center_px,  // the center position, in pixels\n);\n</code></pre> <pre><code>dvz.ortho_zoom_wheel(\n    ortho,  # the ortho : DvzOrtho*\n    dir,  # the wheel direction : Tuple[float, float]\n    center_px,  # the center position, in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#panel","title":"Panel","text":""},{"location":"reference/api_c/#dvz_panel_arcball","title":"<code>dvz_panel_arcball()</code>","text":"<p>Set arcball interactivity for a panel.</p> CPython <pre><code>DvzArcball* dvz_panel_arcball(  // returns the arcball\n    DvzPanel* panel,  // the panel\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.panel_arcball(  # returns the arcball : DvzArcball*\n    panel,  # the panel : DvzPanel*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_at","title":"<code>dvz_panel_at()</code>","text":"<p>Return the panel containing a given point.</p> CPython <pre><code>DvzPanel* dvz_panel_at(  // returns the panel containing the point, or NULL if there is none\n    DvzFigure* figure,  // the figure\n    vec2 pos,  // the position\n);\n</code></pre> <pre><code>dvz.panel_at(  # returns the panel containing the point, or NULL if there is none : DvzPanel*\n    figure,  # the figure : DvzFigure*\n    pos,  # the position : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_axes","title":"<code>dvz_panel_axes()</code>","text":"<p>Get the axes.</p> CPython <pre><code>DvzAxes* dvz_panel_axes(  // returns the axes\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.panel_axes(  # returns the axes : DvzAxes*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_axes_2d","title":"<code>dvz_panel_axes_2D()</code>","text":"<p>Create 2D axes.</p> CPython <pre><code>DvzAxes* dvz_panel_axes_2D(  // returns the axes\n    DvzPanel* panel,  // the panel\n    double xmin,  // xmin\n    double xmax,  // xmax\n    double ymin,  // ymin\n    double ymax,  // ymax\n);\n</code></pre> <pre><code>dvz.panel_axes_2D(  # returns the axes : DvzAxes*\n    panel,  # the panel : DvzPanel*\n    xmin,  # xmin : float\n    xmax,  # xmax : float\n    ymin,  # ymin : float\n    ymax,  # ymax : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_background","title":"<code>dvz_panel_background()</code>","text":"<p>Set a colored background for a panel.</p> CPython <pre><code>void dvz_panel_background(\n    DvzPanel* panel,  // the panel\n    cvec4* background,  // the colors of the four corners (top-left, top-right, bottom left\n);\n</code></pre> <pre><code>dvz.panel_background(\n    panel,  # the panel : DvzPanel*\n    background,  # the colors of the four corners (top-left, top-right, bottom left, : np.ndarray[cvec4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_batch","title":"<code>dvz_panel_batch()</code>","text":"<p>Return the batch from a panel.</p> CPython <pre><code>DvzBatch* dvz_panel_batch(  // returns the batch\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.panel_batch(  # returns the batch : DvzBatch*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_camera","title":"<code>dvz_panel_camera()</code>","text":"<p>Set a camera for a panel.</p> CPython <pre><code>DvzCamera* dvz_panel_camera(  // returns the camera\n    DvzPanel* panel,  // the panel\n    int flags,  // the camera flags\n);\n</code></pre> <pre><code>dvz.panel_camera(  # returns the camera : DvzCamera*\n    panel,  # the panel : DvzPanel*\n    flags,  # the camera flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_contains","title":"<code>dvz_panel_contains()</code>","text":"<p>Return whether a point is inside a panel.</p> CPython <pre><code>bool dvz_panel_contains(  // returns true if the position lies within the panel\n    DvzPanel* panel,  // the panel\n    vec2 pos,  // the position\n);\n</code></pre> <pre><code>dvz.panel_contains(  # returns true if the position lies within the panel : bool\n    panel,  # the panel : DvzPanel*\n    pos,  # the position : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_default","title":"<code>dvz_panel_default()</code>","text":"<p>Return the default full panel spanning an entire figure.</p> CPython <pre><code>DvzPanel* dvz_panel_default(  // returns the panel spanning the entire figure\n    DvzFigure* fig,  // the figure\n);\n</code></pre> <pre><code>dvz.panel_default(  # returns the panel spanning the entire figure : DvzPanel*\n    fig,  # the figure : DvzFigure*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_destroy","title":"<code>dvz_panel_destroy()</code>","text":"<p>Destroy a panel.</p> CPython <pre><code>void dvz_panel_destroy(\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.panel_destroy(\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_figure","title":"<code>dvz_panel_figure()</code>","text":"<p>Return the figure from a panel.</p> CPython <pre><code>DvzFigure* dvz_panel_figure(  // returns the figure\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.panel_figure(  # returns the figure : DvzFigure*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_flags","title":"<code>dvz_panel_flags()</code>","text":"<p>Set the panel flags</p> CPython <pre><code>void dvz_panel_flags(\n    DvzPanel* panel,  // the panel\n    int flags,  // the panel flags\n);\n</code></pre> <pre><code>dvz.panel_flags(\n    panel,  # the panel : DvzPanel*\n    flags,  # the panel flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_fly","title":"<code>dvz_panel_fly()</code>","text":"<p>Set fly interactivity for a panel.</p> CPython <pre><code>DvzFly* dvz_panel_fly(  // returns the fly\n    DvzPanel* panel,  // the panel\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.panel_fly(  # returns the fly : DvzFly*\n    panel,  # the panel : DvzPanel*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_grid","title":"<code>dvz_panel_grid()</code>","text":"<p>Add a 3D horizontal grid.</p> CPython <pre><code>DvzVisual* dvz_panel_grid(  // returns the grid\n    DvzPanel* panel,  // the panel\n    int flags,  // the grid creation flags\n);\n</code></pre> <pre><code>dvz.panel_grid(  # returns the grid : DvzVisual*\n    panel,  # the panel : DvzPanel*\n    flags,  # the grid creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_gui","title":"<code>dvz_panel_gui()</code>","text":"<p>Set a panel as a GUI panel.</p> CPython <pre><code>void dvz_panel_gui(\n    DvzPanel* panel,  // the panel\n    char* title,  // the GUI dialog title\n    int flags,  // the GUI dialog flags (unused at the moment)\n);\n</code></pre> <pre><code>dvz.panel_gui(\n    panel,  # the panel : DvzPanel*\n    title,  # the GUI dialog title : str\n    flags,  # the GUI dialog flags (unused at the moment) : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_link","title":"<code>dvz_panel_link()</code>","text":"<p>Add or remove a link between two panels. At all times, the target panel's transform is copied from the source panel's transform.</p> CPython <pre><code>void dvz_panel_link(\n    DvzPanel* panel,  // the target panel\n    DvzPanel* source,  // the source panel\n    int flags,  // the panel link flags: 0 to remove, or a bit field with model, view, projection\n);\n</code></pre> <pre><code>dvz.panel_link(\n    panel,  # the target panel : DvzPanel*\n    source,  # the source panel : DvzPanel*\n    flags,  # the panel link flags: 0 to remove, or a bit field with model, view, projection : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_margins","title":"<code>dvz_panel_margins()</code>","text":"<p>Set the margins of a panel.</p> CPython <pre><code>void dvz_panel_margins(\n    DvzPanel* panel,  // the panel\n    float top,  // the top margin, in pixels\n    float right,  // the right margin, in pixels\n    float bottom,  // the bottom margin, in pixels\n    float left,  // the left margin, in pixels\n);\n</code></pre> <pre><code>dvz.panel_margins(\n    panel,  # the panel : DvzPanel*\n    top,  # the top margin, in pixels : float\n    right,  # the right margin, in pixels : float\n    bottom,  # the bottom margin, in pixels : float\n    left,  # the left margin, in pixels : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_mvp","title":"<code>dvz_panel_mvp()</code>","text":"<p>Assign a MVP structure to a panel.</p> CPython <pre><code>void dvz_panel_mvp(\n    DvzPanel* panel,  // the panel\n    DvzMVP* mvp,  // a pointer to the MVP structure\n);\n</code></pre> <pre><code>dvz.panel_mvp(\n    panel,  # the panel : DvzPanel*\n    mvp,  # a pointer to the MVP structure : DvzMVP*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_mvpmat","title":"<code>dvz_panel_mvpmat()</code>","text":"<p>Assign the model-view-proj matrices to a panel.</p> CPython <pre><code>void dvz_panel_mvpmat(\n    DvzPanel* panel,  // the panel\n    mat4 model,  // the model matrix\n    mat4 view,  // the view matrix\n    mat4 proj,  // the projection matrix\n);\n</code></pre> <pre><code>dvz.panel_mvpmat(\n    panel,  # the panel : DvzPanel*\n    model,  # the model matrix : mat4\n    view,  # the view matrix : mat4\n    proj,  # the projection matrix : mat4\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_ortho","title":"<code>dvz_panel_ortho()</code>","text":"<p>Set ortho interactivity for a panel.</p> CPython <pre><code>DvzOrtho* dvz_panel_ortho(  // returns the ortho\n    DvzPanel* panel,  // the panel\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.panel_ortho(  # returns the ortho : DvzOrtho*\n    panel,  # the panel : DvzPanel*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_panzoom","title":"<code>dvz_panel_panzoom()</code>","text":"<p>Set panzoom interactivity for a panel.</p> CPython <pre><code>DvzPanzoom* dvz_panel_panzoom(  // returns the panzoom\n    DvzPanel* panel,  // the panel\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.panel_panzoom(  # returns the panzoom : DvzPanzoom*\n    panel,  # the panel : DvzPanel*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_ref","title":"<code>dvz_panel_ref()</code>","text":"<p>Get the panel's reference.</p> CPython <pre><code>DvzRef* dvz_panel_ref(  // returns the reference\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.panel_ref(  # returns the reference : DvzRef*\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_remove","title":"<code>dvz_panel_remove()</code>","text":"<p>Remove a visual from a panel.</p> CPython <pre><code>void dvz_panel_remove(\n    DvzPanel* panel,  // the panel\n    DvzVisual* visual,  // the visual\n);\n</code></pre> <pre><code>dvz.panel_remove(\n    panel,  # the panel : DvzPanel*\n    visual,  # the visual : DvzVisual*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_resize","title":"<code>dvz_panel_resize()</code>","text":"<p>Resize a panel.</p> CPython <pre><code>void dvz_panel_resize(\n    DvzPanel* panel,  // the panel\n    float x,  // the x coordinate of the top left corner, in pixels\n    float y,  // the y coordinate of the top left corner, in pixels\n    float width,  // the panel width, in pixels\n    float height,  // the panel height, in pixels\n);\n</code></pre> <pre><code>dvz.panel_resize(\n    panel,  # the panel : DvzPanel*\n    x,  # the x coordinate of the top left corner, in pixels : float\n    y,  # the y coordinate of the top left corner, in pixels : float\n    width,  # the panel width, in pixels : float\n    height,  # the panel height, in pixels : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_show","title":"<code>dvz_panel_show()</code>","text":"<p>Show or hide a panel.</p> CPython <pre><code>void dvz_panel_show(\n    DvzPanel* panel,  // the panel\n    bool is_visible,  // whether to show or hide the panel\n);\n</code></pre> <pre><code>dvz.panel_show(\n    panel,  # the panel : DvzPanel*\n    is_visible,  # whether to show or hide the panel : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_transform","title":"<code>dvz_panel_transform()</code>","text":"<p>Assign a transform to a panel.</p> CPython <pre><code>void dvz_panel_transform(\n    DvzPanel* panel,  // the panel\n    DvzTransform* tr,  // the transform\n);\n</code></pre> <pre><code>dvz.panel_transform(\n    panel,  # the panel : DvzPanel*\n    tr,  # the transform : DvzTransform*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_update","title":"<code>dvz_panel_update()</code>","text":"<p>Trigger a panel update.</p> CPython <pre><code>void dvz_panel_update(\n    DvzPanel* panel,  // the panel\n);\n</code></pre> <pre><code>dvz.panel_update(\n    panel,  # the panel : DvzPanel*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panel_visual","title":"<code>dvz_panel_visual()</code>","text":"<p>Add a visual to a panel.</p> CPython <pre><code>void dvz_panel_visual(\n    DvzPanel* panel,  // the panel\n    DvzVisual* visual,  // the visual\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.panel_visual(\n    panel,  # the panel : DvzPanel*\n    visual,  # the visual : DvzVisual*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#panzoom","title":"Panzoom","text":""},{"location":"reference/api_c/#dvz_panzoom_bounds","title":"<code>dvz_panzoom_bounds()</code>","text":"<p>Get x-y bounds.</p> CPython <pre><code>void dvz_panzoom_bounds(\n    DvzPanzoom* pz,  // the panzoom\n    DvzRef* ref,  // the ref\n    double* xmin,  // xmin\n    double* xmax,  // xmax\n    double* ymin,  // ymin\n    double* ymax,  // ymax\n);\n</code></pre> <pre><code>dvz.panzoom_bounds(\n    pz,  # the panzoom : DvzPanzoom*\n    ref,  # the ref : DvzRef*\n    xmin,  # xmin : Out[float]\n    xmax,  # xmax : Out[float]\n    ymin,  # ymin : Out[float]\n    ymax,  # ymax : Out[float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_destroy","title":"<code>dvz_panzoom_destroy()</code>","text":"<p>Destroy a panzoom.</p> CPython <pre><code>void dvz_panzoom_destroy(\n    DvzPanzoom* pz,  // the pz\n);\n</code></pre> <pre><code>dvz.panzoom_destroy(\n    pz,  # the pz : DvzPanzoom*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_end","title":"<code>dvz_panzoom_end()</code>","text":"<p>End a panzoom interaction.</p> CPython <pre><code>void dvz_panzoom_end(\n    DvzPanzoom* pz,  // the panzoom\n);\n</code></pre> <pre><code>dvz.panzoom_end(\n    pz,  # the panzoom : DvzPanzoom*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_extent","title":"<code>dvz_panzoom_extent()</code>","text":"<p>Get the extent box.</p> CPython <pre><code>void dvz_panzoom_extent(\n    DvzPanzoom* pz,  // the panzoom\n    DvzBox* extent,  // the extent box in normalized coordinates\n);\n</code></pre> <pre><code>dvz.panzoom_extent(\n    pz,  # the panzoom : DvzPanzoom*\n    extent,  # the extent box in normalized coordinates : Out[DvzBox]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_flags","title":"<code>dvz_panzoom_flags()</code>","text":"<p>Set the panzoom flags.</p> CPython <pre><code>void dvz_panzoom_flags(\n    DvzPanzoom* pz,  // the panzoom\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.panzoom_flags(\n    pz,  # the panzoom : DvzPanzoom*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_level","title":"<code>dvz_panzoom_level()</code>","text":"<p>Get the current zoom level.</p> CPython <pre><code>float dvz_panzoom_level(\n    DvzPanzoom* pz,  // the panzoom\n    DvzDim dim,  // the dimension\n);\n</code></pre> <pre><code>dvz.panzoom_level(\n    pz,  # the panzoom : DvzPanzoom*\n    dim,  # the dimension : DvzDim\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_mouse","title":"<code>dvz_panzoom_mouse()</code>","text":"<p>Register a mouse event to a panzoom.</p> CPython <pre><code>bool dvz_panzoom_mouse(  // returns whether the panzoom is affected by the mouse event\n    DvzPanzoom* pz,  // the panzoom\n    DvzMouseEvent* ev,  // the mouse event\n);\n</code></pre> <pre><code>dvz.panzoom_mouse(  # returns whether the panzoom is affected by the mouse event : bool\n    pz,  # the panzoom : DvzPanzoom*\n    ev,  # the mouse event : DvzMouseEvent*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_mvp","title":"<code>dvz_panzoom_mvp()</code>","text":"<p>Apply an MVP matrix to a panzoom.</p> CPython <pre><code>void dvz_panzoom_mvp(\n    DvzPanzoom* pz,  // the panzoom\n    DvzMVP* mvp,  // the MVP\n);\n</code></pre> <pre><code>dvz.panzoom_mvp(\n    pz,  # the panzoom : DvzPanzoom*\n    mvp,  # the MVP : DvzMVP*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_pan","title":"<code>dvz_panzoom_pan()</code>","text":"<p>Apply a pan value to a panzoom.</p> CPython <pre><code>void dvz_panzoom_pan(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 pan,  // the pan, in NDC\n);\n</code></pre> <pre><code>dvz.panzoom_pan(\n    pz,  # the panzoom : DvzPanzoom*\n    pan,  # the pan, in NDC : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_pan_shift","title":"<code>dvz_panzoom_pan_shift()</code>","text":"<p>Apply a pan shift to a panzoom.</p> CPython <pre><code>void dvz_panzoom_pan_shift(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n);\n</code></pre> <pre><code>dvz.panzoom_pan_shift(\n    pz,  # the panzoom : DvzPanzoom*\n    shift_px,  # the shift value, in pixels : Tuple[float, float]\n    center_px,  # the center position, in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_reset","title":"<code>dvz_panzoom_reset()</code>","text":"<p>Reset a panzoom.</p> CPython <pre><code>void dvz_panzoom_reset(\n    DvzPanzoom* pz,  // the panzoom\n);\n</code></pre> <pre><code>dvz.panzoom_reset(\n    pz,  # the panzoom : DvzPanzoom*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_resize","title":"<code>dvz_panzoom_resize()</code>","text":"<p>Inform a panzoom of a panel resize.</p> CPython <pre><code>void dvz_panzoom_resize(\n    DvzPanzoom* pz,  // the panzoom\n    float width,  // the panel width\n    float height,  // the panel height\n);\n</code></pre> <pre><code>dvz.panzoom_resize(\n    pz,  # the panzoom : DvzPanzoom*\n    width,  # the panel width : float\n    height,  # the panel height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_set","title":"<code>dvz_panzoom_set()</code>","text":"<p>Set the extent box.</p> CPython <pre><code>void dvz_panzoom_set(\n    DvzPanzoom* pz,  // the panzoom\n    DvzBox* extent,  // the extent box\n);\n</code></pre> <pre><code>dvz.panzoom_set(\n    pz,  # the panzoom : DvzPanzoom*\n    extent,  # the extent box : DvzBox*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_xlim","title":"<code>dvz_panzoom_xlim()</code>","text":"<p>Set x bounds.</p> CPython <pre><code>void dvz_panzoom_xlim(\n    DvzPanzoom* pz,  // the panzoom\n    DvzRef* ref,  // the ref\n    double xmin,  // xmin\n    double xmax,  // xmax\n);\n</code></pre> <pre><code>dvz.panzoom_xlim(\n    pz,  # the panzoom : DvzPanzoom*\n    ref,  # the ref : DvzRef*\n    xmin,  # xmin : float\n    xmax,  # xmax : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_ylim","title":"<code>dvz_panzoom_ylim()</code>","text":"<p>Set y bounds.</p> CPython <pre><code>void dvz_panzoom_ylim(\n    DvzPanzoom* pz,  // the panzoom\n    DvzRef* ref,  // the ref\n    double ymin,  // ymin\n    double ymax,  // ymax\n);\n</code></pre> <pre><code>dvz.panzoom_ylim(\n    pz,  # the panzoom : DvzPanzoom*\n    ref,  # the ref : DvzRef*\n    ymin,  # ymin : float\n    ymax,  # ymax : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_zoom","title":"<code>dvz_panzoom_zoom()</code>","text":"<p>Apply a zoom value to a panzoom.</p> CPython <pre><code>void dvz_panzoom_zoom(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 zoom,  // the zoom, in NDC\n);\n</code></pre> <pre><code>dvz.panzoom_zoom(\n    pz,  # the panzoom : DvzPanzoom*\n    zoom,  # the zoom, in NDC : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_zoom_shift","title":"<code>dvz_panzoom_zoom_shift()</code>","text":"<p>Apply a zoom shift to a panzoom.</p> CPython <pre><code>void dvz_panzoom_zoom_shift(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n);\n</code></pre> <pre><code>dvz.panzoom_zoom_shift(\n    pz,  # the panzoom : DvzPanzoom*\n    shift_px,  # the shift value, in pixels : Tuple[float, float]\n    center_px,  # the center position, in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_panzoom_zoom_wheel","title":"<code>dvz_panzoom_zoom_wheel()</code>","text":"<p>Apply a wheel zoom to a panzoom.</p> CPython <pre><code>void dvz_panzoom_zoom_wheel(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 dir,  // the wheel direction\n    vec2 center_px,  // the center position, in pixels\n);\n</code></pre> <pre><code>dvz.panzoom_zoom_wheel(\n    pz,  # the panzoom : DvzPanzoom*\n    dir,  # the wheel direction : Tuple[float, float]\n    center_px,  # the center position, in pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#qt","title":"Qt","text":""},{"location":"reference/api_c/#dvz_qt_app","title":"<code>dvz_qt_app()</code>","text":"<p>Placeholder.</p> CPython <pre><code>DvzQtApp* dvz_qt_app(\n    QApplication* qapp,  // placeholder\n    int flags,  // placeholder\n);\n</code></pre> <pre><code>dvz.qt_app(\n    qapp,  # placeholder : np.ndarray[QApplication]\n    flags,  # placeholder : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_qt_app_destroy","title":"<code>dvz_qt_app_destroy()</code>","text":"<p>Placeholder.</p> CPython <pre><code>void dvz_qt_app_destroy(\n    DvzQtApp* app,  // placeholder\n);\n</code></pre> <pre><code>dvz.qt_app_destroy(\n    app,  # placeholder : DvzQtApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_qt_batch","title":"<code>dvz_qt_batch()</code>","text":"<p>Placeholder.</p> CPython <pre><code>DvzBatch* dvz_qt_batch(\n    DvzQtApp* app,  // placeholder\n);\n</code></pre> <pre><code>dvz.qt_batch(\n    app,  # placeholder : DvzQtApp*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_qt_submit","title":"<code>dvz_qt_submit()</code>","text":"<p>Placeholder.</p> CPython <pre><code>void dvz_qt_submit(\n    DvzQtApp* app,  // placeholder\n    DvzBatch* batch,  // placeholder\n);\n</code></pre> <pre><code>dvz.qt_submit(\n    app,  # placeholder : DvzQtApp*\n    batch,  # placeholder : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_qt_window","title":"<code>dvz_qt_window()</code>","text":"<p>Placeholder.</p> CPython <pre><code>DvzQtWindow* dvz_qt_window(\n    DvzQtApp* app,  // placeholder\n);\n</code></pre> <pre><code>dvz.qt_window(\n    app,  # placeholder : DvzQtApp*\n)\n</code></pre>"},{"location":"reference/api_c/#rand","title":"Rand","text":""},{"location":"reference/api_c/#dvz_rand_byte","title":"<code>dvz_rand_byte()</code>","text":"<p>Return a random integer number between 0 and 255.</p> CPython <pre><code>uint8_t dvz_rand_byte(  // returns random number\n);\n</code></pre> <pre><code>dvz.rand_byte(  # returns random number : uint8_t\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_rand_double","title":"<code>dvz_rand_double()</code>","text":"<p>Return a random floating-point number between 0 and 1.</p> CPython <pre><code>double dvz_rand_double(  // returns random number\n);\n</code></pre> <pre><code>dvz.rand_double(  # returns random number : double\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_rand_float","title":"<code>dvz_rand_float()</code>","text":"<p>Return a random floating-point number between 0 and 1.</p> CPython <pre><code>float dvz_rand_float(  // returns random number\n);\n</code></pre> <pre><code>dvz.rand_float(  # returns random number : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_rand_int","title":"<code>dvz_rand_int()</code>","text":"<p>Return a random integer number.</p> CPython <pre><code>int dvz_rand_int(  // returns random number\n);\n</code></pre> <pre><code>dvz.rand_int(  # returns random number : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_rand_normal","title":"<code>dvz_rand_normal()</code>","text":"<p>Return a random normal floating-point number.</p> CPython <pre><code>double dvz_rand_normal(  // returns random number\n);\n</code></pre> <pre><code>dvz.rand_normal(  # returns random number : double\n)\n</code></pre>"},{"location":"reference/api_c/#ref","title":"Ref","text":""},{"location":"reference/api_c/#dvz_ref_destroy","title":"<code>dvz_ref_destroy()</code>","text":"<p>Destroy a reference frame.</p> CPython <pre><code>void dvz_ref_destroy(\n    DvzRef* ref,  // the reference frame\n);\n</code></pre> <pre><code>dvz.ref_destroy(\n    ref,  # the reference frame : DvzRef*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_expand","title":"<code>dvz_ref_expand()</code>","text":"<p>Expand the reference by ensuring it contains the specified range.</p> CPython <pre><code>void dvz_ref_expand(\n    DvzRef* ref,  // the reference frame\n    DvzDim dim,  // the dimension axis\n    double vmin,  // the minimum value\n    double vmax,  // the maximum value\n);\n</code></pre> <pre><code>dvz.ref_expand(\n    ref,  # the reference frame : DvzRef*\n    dim,  # the dimension axis : DvzDim\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_expand_2d","title":"<code>dvz_ref_expand_2D()</code>","text":"<p>Expand the reference by ensuring it contains the specified 2D data.</p> CPython <pre><code>void dvz_ref_expand_2D(\n    DvzRef* ref,  // the reference frame\n    uint32_t count,  // the number of positions\n    dvec2* pos,  // the 2D positions\n);\n</code></pre> <pre><code>dvz.ref_expand_2D(\n    ref,  # the reference frame : DvzRef*\n    count,  # the number of positions : int\n    pos,  # the 2D positions : np.ndarray[dvec2]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_expand_3d","title":"<code>dvz_ref_expand_3D()</code>","text":"<p>Expand the reference by ensuring it contains the specified 3D data.</p> CPython <pre><code>void dvz_ref_expand_3D(\n    DvzRef* ref,  // the reference frame\n    uint32_t count,  // the number of positions\n    dvec3* pos,  // the 3D positions\n);\n</code></pre> <pre><code>dvz.ref_expand_3D(\n    ref,  # the reference frame : DvzRef*\n    count,  # the number of positions : int\n    pos,  # the 3D positions : np.ndarray[dvec3]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_get","title":"<code>dvz_ref_get()</code>","text":"<p>Get the range on a given axis.</p> CPython <pre><code>void dvz_ref_get(\n    DvzRef* ref,  // the reference frame\n    DvzDim dim,  // the dimension axis\n    double* vmin,  // the minimum value\n    double* vmax,  // the maximum value\n);\n</code></pre> <pre><code>dvz.ref_get(\n    ref,  # the reference frame : DvzRef*\n    dim,  # the dimension axis : DvzDim\n    vmin,  # the minimum value : Out[float]\n    vmax,  # the maximum value : Out[float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_inverse","title":"<code>dvz_ref_inverse()</code>","text":"<p>Inverse transform from normalized device coordinates [-1..+1] to the reference frame.</p> CPython <pre><code>void dvz_ref_inverse(\n    DvzRef* ref,  // the reference frame\n    vec3 pos_tr,  // the 3D position in normalized device coordinates\n    dvec3* pos,  // the original position\n);\n</code></pre> <pre><code>dvz.ref_inverse(\n    ref,  # the reference frame : DvzRef*\n    pos_tr,  # the 3D position in normalized device coordinates : Tuple[float, float, float]\n    pos,  # the original position : Out[dvec3]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_is_set","title":"<code>dvz_ref_is_set()</code>","text":"<p>Indicate whether the reference is set on a given axis.</p> CPython <pre><code>bool dvz_ref_is_set(  // returns whether the ref is set on this axis.\n    DvzRef* ref,  // the reference frame\n    DvzDim dim,  // the dimension axis\n);\n</code></pre> <pre><code>dvz.ref_is_set(  # returns whether the ref is set on this axis. : bool\n    ref,  # the reference frame : DvzRef*\n    dim,  # the dimension axis : DvzDim\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_normalize_1d","title":"<code>dvz_ref_normalize_1D()</code>","text":"<p>Transform 1D data from the reference frame to normalized device coordinates [-1..+1].</p> CPython <pre><code>void dvz_ref_normalize_1D(\n    DvzRef* ref,  // the reference frame\n    DvzDim dim,  // which dimension\n    uint32_t count,  // the number of positions\n    double* pos,  // the 1D positions\n    vec3* pos_tr,  // (array) the transformed positions\n);\n</code></pre> <pre><code>dvz.ref_normalize_1D(\n    ref,  # the reference frame : DvzRef*\n    dim,  # which dimension : DvzDim\n    count,  # the number of positions : int\n    pos,  # the 1D positions : np.ndarray[double]\n    pos_tr,  # (array) the transformed positions : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_normalize_2d","title":"<code>dvz_ref_normalize_2D()</code>","text":"<p>Transform 2D data from the reference frame to normalized device coordinates [-1..+1].</p> CPython <pre><code>void dvz_ref_normalize_2D(\n    DvzRef* ref,  // the reference frame\n    uint32_t count,  // the number of positions\n    dvec2* pos,  // the 2D positions\n    vec3* pos_tr,  // (array) the transformed 3D positions\n);\n</code></pre> <pre><code>dvz.ref_normalize_2D(\n    ref,  # the reference frame : DvzRef*\n    count,  # the number of positions : int\n    pos,  # the 2D positions : np.ndarray[dvec2]\n    pos_tr,  # (array) the transformed 3D positions : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_normalize_3d","title":"<code>dvz_ref_normalize_3D()</code>","text":"<p>Transform 3D data from the reference frame to normalized device coordinates [-1..+1].</p> CPython <pre><code>void dvz_ref_normalize_3D(\n    DvzRef* ref,  // the reference frame\n    uint32_t count,  // the number of positions\n    dvec3* pos,  // the 3D positions\n    vec3* pos_tr,  // (array) the transformed positions\n);\n</code></pre> <pre><code>dvz.ref_normalize_3D(\n    ref,  # the reference frame : DvzRef*\n    count,  # the number of positions : int\n    pos,  # the 3D positions : np.ndarray[dvec3]\n    pos_tr,  # (array) the transformed positions : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_normalize_polygon","title":"<code>dvz_ref_normalize_polygon()</code>","text":"<p>Transform 2D data from the reference frame to normalized device coordinates [-1..+1] in 2D.</p> CPython <pre><code>void dvz_ref_normalize_polygon(\n    DvzRef* ref,  // the reference frame\n    uint32_t count,  // the number of positions\n    dvec2* pos,  // the 2D positions\n    dvec2* pos_tr,  // (array) the transformed 2D positions\n);\n</code></pre> <pre><code>dvz.ref_normalize_polygon(\n    ref,  # the reference frame : DvzRef*\n    count,  # the number of positions : int\n    pos,  # the 2D positions : np.ndarray[dvec2]\n    pos_tr,  # (array) the transformed 2D positions : Out[dvec2]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_ref_set","title":"<code>dvz_ref_set()</code>","text":"<p>Set the range on a given axis.</p> CPython <pre><code>void dvz_ref_set(\n    DvzRef* ref,  // the reference frame\n    DvzDim dim,  // the dimension axis\n    double vmin,  // the minimum value\n    double vmax,  // the maximum value\n);\n</code></pre> <pre><code>dvz.ref_set(\n    ref,  # the reference frame : DvzRef*\n    dim,  # the dimension axis : DvzDim\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n)\n</code></pre>"},{"location":"reference/api_c/#rgb","title":"Rgb","text":""},{"location":"reference/api_c/#dvz_rgb_to_rgba_char","title":"<code>dvz_rgb_to_rgba_char()</code>","text":"<p>Convert an RGB byte texture to an RGBA one.</p> CPython <pre><code>void dvz_rgb_to_rgba_char(\n    uint32_t count,  // the number of pixels (and NOT the number of bytes) in the byte texture\n    uint8_t* rgb,  // the RGB texture\n    uint8_t* rgba,  // the returned RGBA texture\n);\n</code></pre> <pre><code>dvz.rgb_to_rgba_char(\n    count,  # the number of pixels (and NOT the number of bytes) in the byte texture : int\n    rgb,  # the RGB texture : np.ndarray[uint8_t]\n    rgba,  # the returned RGBA texture : np.ndarray[uint8_t]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_rgb_to_rgba_float","title":"<code>dvz_rgb_to_rgba_float()</code>","text":"<p>Convert an RGB float texture to an RGBA one.</p> CPython <pre><code>void dvz_rgb_to_rgba_float(\n    uint32_t count,  // the number of pixels (and NOT the number of bytes) in the float texture\n    float* rgb,  // the RGB texture\n    float* rgba,  // the returned RGBA texture\n);\n</code></pre> <pre><code>dvz.rgb_to_rgba_float(\n    count,  # the number of pixels (and NOT the number of bytes) in the float texture : int\n    rgb,  # the RGB texture : np.ndarray[float]\n    rgba,  # the returned RGBA texture : np.ndarray[float]\n)\n</code></pre>"},{"location":"reference/api_c/#scene","title":"Scene","text":""},{"location":"reference/api_c/#dvz_scene_batch","title":"<code>dvz_scene_batch()</code>","text":"<p>Return the batch from a scene.</p> CPython <pre><code>DvzBatch* dvz_scene_batch(  // returns the batch\n    DvzScene* scene,  // the scene\n);\n</code></pre> <pre><code>dvz.scene_batch(  # returns the batch : DvzBatch*\n    scene,  # the scene : DvzScene*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_scene_destroy","title":"<code>dvz_scene_destroy()</code>","text":"<p>Destroy a scene.</p> CPython <pre><code>void dvz_scene_destroy(\n    DvzScene* scene,  // the scene\n);\n</code></pre> <pre><code>dvz.scene_destroy(\n    scene,  # the scene : DvzScene*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_scene_figure","title":"<code>dvz_scene_figure()</code>","text":"<p>Get a figure from its id.</p> CPython <pre><code>DvzFigure* dvz_scene_figure(  // returns the figure\n    DvzScene* scene,  // the scene\n    DvzId id,  // the figure id\n);\n</code></pre> <pre><code>dvz.scene_figure(  # returns the figure : DvzFigure*\n    scene,  # the scene : DvzScene*\n    id,  # the figure id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_scene_mouse","title":"<code>dvz_scene_mouse()</code>","text":"<p>Manually pass a mouse event to the scene.</p> CPython <pre><code>void dvz_scene_mouse(\n    DvzScene* scene,  // the scene\n    DvzFigure* fig,  // the figure\n    DvzMouseEvent* ev,  // the mouse event\n);\n</code></pre> <pre><code>dvz.scene_mouse(\n    scene,  # the scene : DvzScene*\n    fig,  # the figure : DvzFigure*\n    ev,  # the mouse event : DvzMouseEvent*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_scene_render","title":"<code>dvz_scene_render()</code>","text":"<p>Placeholder.</p> CPython <pre><code>void dvz_scene_render(\n    DvzScene* scene,  // placeholder\n    DvzServer* server,  // placeholder\n);\n</code></pre> <pre><code>dvz.scene_render(\n    scene,  # placeholder : DvzScene*\n    server,  # placeholder : DvzServer*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_scene_run","title":"<code>dvz_scene_run()</code>","text":"<p>Start the event loop and render the scene in a window.</p> CPython <pre><code>void dvz_scene_run(\n    DvzScene* scene,  // the scene\n    DvzApp* app,  // the app\n    uint64_t frame_count,  // the maximum number of frames, 0 for infinite loop\n);\n</code></pre> <pre><code>dvz.scene_run(\n    scene,  # the scene : DvzScene*\n    app,  # the app : DvzApp*\n    frame_count,  # the maximum number of frames, 0 for infinite loop : int\n)\n</code></pre>"},{"location":"reference/api_c/#sdf","title":"Sdf","text":""},{"location":"reference/api_c/#dvz_sdf_from_svg","title":"<code>dvz_sdf_from_svg()</code>","text":"<p>Generate an SDF from an SVG path.</p> CPython <pre><code>float* dvz_sdf_from_svg(  // returns the generated texture as RGB floats\n    char* svg_path,  // the SVG path\n    uint32_t width,  // the width of the generated SDF, in pixels\n    uint32_t height,  // the height of the generated SDF, in pixels\n);\n</code></pre> <pre><code>dvz.sdf_from_svg(  # returns the generated texture as RGB floats : float*\n    svg_path,  # the SVG path : str\n    width,  # the width of the generated SDF, in pixels : int\n    height,  # the height of the generated SDF, in pixels : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sdf_to_rgb","title":"<code>dvz_sdf_to_rgb()</code>","text":"<p>Convert an SDF float texture to a byte texture.</p> CPython <pre><code>uint8_t* dvz_sdf_to_rgb(  // returns the byte texture\n    float* sdf,  // the SDF float texture\n    uint32_t width,  // the width of the texture\n    uint32_t height,  // the height of the texture\n);\n</code></pre> <pre><code>dvz.sdf_to_rgb(  # returns the byte texture : uint8_t*\n    sdf,  # the SDF float texture : np.ndarray[float]\n    width,  # the width of the texture : int\n    height,  # the height of the texture : int\n)\n</code></pre>"},{"location":"reference/api_c/#server","title":"Server","text":""},{"location":"reference/api_c/#dvz_server_destroy","title":"<code>dvz_server_destroy()</code>","text":"<p>Placeholder.</p> CPython <pre><code>void dvz_server_destroy(\n    DvzServer* server,  // placeholder\n);\n</code></pre> <pre><code>dvz.server_destroy(\n    server,  # placeholder : DvzServer*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_server_grab","title":"<code>dvz_server_grab()</code>","text":"<p>Placeholder.</p> CPython <pre><code>uint8_t* dvz_server_grab(\n    DvzServer* server,  // placeholder\n    DvzId canvas_id,  // placeholder\n    int flags,  // placeholder\n);\n</code></pre> <pre><code>dvz.server_grab(\n    server,  # placeholder : DvzServer*\n    canvas_id,  # placeholder : DvzId\n    flags,  # placeholder : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_server_keyboard","title":"<code>dvz_server_keyboard()</code>","text":"<p>Placeholder.</p> CPython <pre><code>DvzKeyboard* dvz_server_keyboard(\n    DvzServer* server,  // placeholder\n);\n</code></pre> <pre><code>dvz.server_keyboard(\n    server,  # placeholder : DvzServer*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_server_mouse","title":"<code>dvz_server_mouse()</code>","text":"<p>Placeholder.</p> CPython <pre><code>DvzMouse* dvz_server_mouse(\n    DvzServer* server,  // placeholder\n);\n</code></pre> <pre><code>dvz.server_mouse(\n    server,  # placeholder : DvzServer*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_server_resize","title":"<code>dvz_server_resize()</code>","text":"<p>Placeholder.</p> CPython <pre><code>void dvz_server_resize(\n    DvzServer* server,  // placeholder\n    DvzId canvas_id,  // placeholder\n    uint32_t width,  // placeholder\n    uint32_t height,  // placeholder\n);\n</code></pre> <pre><code>dvz.server_resize(\n    server,  # placeholder : DvzServer*\n    canvas_id,  # placeholder : DvzId\n    width,  # placeholder : int\n    height,  # placeholder : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_server_submit","title":"<code>dvz_server_submit()</code>","text":"<p>Placeholder.</p> CPython <pre><code>void dvz_server_submit(\n    DvzServer* server,  // placeholder\n    DvzBatch* batch,  // placeholder\n);\n</code></pre> <pre><code>dvz.server_submit(\n    server,  # placeholder : DvzServer*\n    batch,  # placeholder : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#shape","title":"Shape","text":""},{"location":"reference/api_c/#dvz_shape_arrow","title":"<code>dvz_shape_arrow()</code>","text":"<p>Create a 3D arrow using a cylinder and cone. The total length is 1.</p> CPython <pre><code>void dvz_shape_arrow(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of sides to the shaft and head\n    float head_length,  // the length of the head\n    float head_radius,  // the radius of the head\n    float shaft_radius,  // the radius of the shaft\n    DvzColor color,  // the arrow color\n);\n</code></pre> <pre><code>dvz.shape_arrow(\n    shape,  # the shape : DvzShape*\n    count,  # the number of sides to the shaft and head : int\n    head_length,  # the length of the head : float\n    head_radius,  # the radius of the head : float\n    shaft_radius,  # the radius of the shaft : float\n    color,  # the arrow color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_begin","title":"<code>dvz_shape_begin()</code>","text":"<p>Start a transformation sequence.</p> CPython <pre><code>void dvz_shape_begin(\n    DvzShape* shape,  // the shape\n    uint32_t first,  // the first vertex to modify\n    uint32_t count,  // the number of vertices to modify\n);\n</code></pre> <pre><code>dvz.shape_begin(\n    shape,  # the shape : DvzShape*\n    first,  # the first vertex to modify : int\n    count,  # the number of vertices to modify : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_cone","title":"<code>dvz_shape_cone()</code>","text":"<p>Create a cone shape.</p> CPython <pre><code>void dvz_shape_cone(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of points along the disc border\n    DvzColor color,  // the cone color\n);\n</code></pre> <pre><code>dvz.shape_cone(\n    shape,  # the shape : DvzShape*\n    count,  # the number of points along the disc border : int\n    color,  # the cone color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_cube","title":"<code>dvz_shape_cube()</code>","text":"<p>Create a cube shape.</p> CPython <pre><code>void dvz_shape_cube(\n    DvzShape* shape,  // the shape\n    DvzColor* colors,  // the colors of the six faces\n);\n</code></pre> <pre><code>dvz.shape_cube(\n    shape,  # the shape : DvzShape*\n    colors,  # the colors of the six faces : DvzColor*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_custom","title":"<code>dvz_shape_custom()</code>","text":"<p>Create a shape out of an array of vertices and faces.</p> CPython <pre><code>void dvz_shape_custom(\n    DvzShape* shape,  // the shape\n    uint32_t vertex_count,  // number of vertices\n    vec3* positions,  // 3D positions of the vertices\n    vec3* normals,  // normal vectors (optional, will be otherwise computed automatically)\n    DvzColor* colors,  // vertex vectors (optional)\n    vec4* texcoords,  // texture uv*a coordinates (optional)\n    uint32_t index_count,  // number of indices (3x the number of triangular faces)\n    DvzIndex* indices,  // vertex indices, three per face\n);\n</code></pre> <pre><code>dvz.shape_custom(\n    shape,  # the shape : DvzShape*\n    vertex_count,  # number of vertices : int\n    positions,  # 3D positions of the vertices : np.ndarray[vec3]\n    normals,  # normal vectors (optional, will be otherwise computed automatically) : np.ndarray[vec3]\n    colors,  # vertex vectors (optional) : DvzColor*\n    texcoords,  # texture uv*a coordinates (optional) : np.ndarray[vec4]\n    index_count,  # number of indices (3x the number of triangular faces) : int\n    indices,  # vertex indices, three per face : DvzIndex*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_cylinder","title":"<code>dvz_shape_cylinder()</code>","text":"<p>Create a cylinder shape.</p> CPython <pre><code>void dvz_shape_cylinder(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of points along the cylinder border\n    DvzColor color,  // the cylinder color\n);\n</code></pre> <pre><code>dvz.shape_cylinder(\n    shape,  # the shape : DvzShape*\n    count,  # the number of points along the cylinder border : int\n    color,  # the cylinder color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_destroy","title":"<code>dvz_shape_destroy()</code>","text":"<p>Destroy a shape.</p> CPython <pre><code>void dvz_shape_destroy(\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_destroy(\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_disc","title":"<code>dvz_shape_disc()</code>","text":"<p>Create a disc shape.</p> CPython <pre><code>void dvz_shape_disc(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of points along the disc border\n    DvzColor color,  // the disc color\n);\n</code></pre> <pre><code>dvz.shape_disc(\n    shape,  # the shape : DvzShape*\n    count,  # the number of points along the disc border : int\n    color,  # the disc color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_dodecahedron","title":"<code>dvz_shape_dodecahedron()</code>","text":"<p>Create a dodecahedron.</p> CPython <pre><code>void dvz_shape_dodecahedron(\n    DvzShape* shape,  // the shape\n    DvzColor color,  // the color\n);\n</code></pre> <pre><code>dvz.shape_dodecahedron(\n    shape,  # the shape : DvzShape*\n    color,  # the color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_end","title":"<code>dvz_shape_end()</code>","text":"<p>Apply the transformation sequence and reset it.</p> CPython <pre><code>void dvz_shape_end(\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_end(\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_gizmo","title":"<code>dvz_shape_gizmo()</code>","text":"<p>Create a 3D gizmo with three arrows on the three axes.</p> CPython <pre><code>void dvz_shape_gizmo(\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_gizmo(\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_hexahedron","title":"<code>dvz_shape_hexahedron()</code>","text":"<p>Create a tetrahedron.</p> CPython <pre><code>void dvz_shape_hexahedron(\n    DvzShape* shape,  // the shape\n    DvzColor color,  // the color\n);\n</code></pre> <pre><code>dvz.shape_hexahedron(\n    shape,  # the shape : DvzShape*\n    color,  # the color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_histogram","title":"<code>dvz_shape_histogram()</code>","text":"<p>Create a histogram shape.</p> CPython <pre><code>void dvz_shape_histogram(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of bars\n    float* heights,  // the height of each bar\n    DvzColor color,  // the sector color\n);\n</code></pre> <pre><code>dvz.shape_histogram(\n    shape,  # the shape : DvzShape*\n    count,  # the number of bars : int\n    heights,  # the height of each bar : np.ndarray[float]\n    color,  # the sector color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_icosahedron","title":"<code>dvz_shape_icosahedron()</code>","text":"<p>Create a icosahedron.</p> CPython <pre><code>void dvz_shape_icosahedron(\n    DvzShape* shape,  // the shape\n    DvzColor color,  // the color\n);\n</code></pre> <pre><code>dvz.shape_icosahedron(\n    shape,  # the shape : DvzShape*\n    color,  # the color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_index_count","title":"<code>dvz_shape_index_count()</code>","text":"<p>Return the number of index of a shape.</p> CPython <pre><code>uint32_t dvz_shape_index_count(  // returns the number of index\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_index_count(  # returns the number of index : uint32_t\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_merge","title":"<code>dvz_shape_merge()</code>","text":"<p>Merge several shapes.</p> CPython <pre><code>void dvz_shape_merge(\n    DvzShape* shape,  // the merged shape\n    uint32_t count,  // the number of shapes to merge\n    DvzShape** shapes,  // the shapes to merge\n);\n</code></pre> <pre><code>dvz.shape_merge(\n    shape,  # the merged shape : DvzShape*\n    count,  # the number of shapes to merge : int\n    shapes,  # the shapes to merge : DvzShape**\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_normalize","title":"<code>dvz_shape_normalize()</code>","text":"<p>Normalize a shape.</p> CPython <pre><code>void dvz_shape_normalize(\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_normalize(\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_normals","title":"<code>dvz_shape_normals()</code>","text":"<p>Recompute the face normals.</p> CPython <pre><code>void dvz_shape_normals(\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_normals(\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_obj","title":"<code>dvz_shape_obj()</code>","text":"<p>Load a .obj shape.</p> CPython <pre><code>void dvz_shape_obj(\n    DvzShape* shape,  // the shape\n    char* file_path,  // the path to the .obj file\n);\n</code></pre> <pre><code>dvz.shape_obj(\n    shape,  # the shape : DvzShape*\n    file_path,  # the path to the .obj file : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_octahedron","title":"<code>dvz_shape_octahedron()</code>","text":"<p>Create a octahedron.</p> CPython <pre><code>void dvz_shape_octahedron(\n    DvzShape* shape,  // the shape\n    DvzColor color,  // the color\n);\n</code></pre> <pre><code>dvz.shape_octahedron(\n    shape,  # the shape : DvzShape*\n    color,  # the color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_polygon","title":"<code>dvz_shape_polygon()</code>","text":"<p>Create a polygon shape using the simple earcut polygon triangulation algorithm.</p> CPython <pre><code>void dvz_shape_polygon(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of points along the polygon border\n    dvec2* points,  // the points 2D coordinates\n    DvzColor color,  // the polygon color\n);\n</code></pre> <pre><code>dvz.shape_polygon(\n    shape,  # the shape : DvzShape*\n    count,  # the number of points along the polygon border : int\n    points,  # the points 2D coordinates : np.ndarray[dvec2]\n    color,  # the polygon color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_print","title":"<code>dvz_shape_print()</code>","text":"<p>Show information about a shape.</p> CPython <pre><code>void dvz_shape_print(\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_print(\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_rescaling","title":"<code>dvz_shape_rescaling()</code>","text":"<p>Compute the rescaling factor to renormalize a shape.</p> CPython <pre><code>float dvz_shape_rescaling(\n    DvzShape* shape,  // the shape\n    int flags,  // the rescaling flags\n    vec3 out_scale,  // the computed scaling factors\n);\n</code></pre> <pre><code>dvz.shape_rescaling(\n    shape,  # the shape : DvzShape*\n    flags,  # the rescaling flags : int\n    out_scale,  # the computed scaling factors : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_rotate","title":"<code>dvz_shape_rotate()</code>","text":"<p>Append a rotation to a shape.</p> CPython <pre><code>void dvz_shape_rotate(\n    DvzShape* shape,  // the shape\n    float angle,  // the rotation angle\n    vec3 axis,  // the rotation axis\n);\n</code></pre> <pre><code>dvz.shape_rotate(\n    shape,  # the shape : DvzShape*\n    angle,  # the rotation angle : float\n    axis,  # the rotation axis : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_scale","title":"<code>dvz_shape_scale()</code>","text":"<p>Append a scaling transform to a shape.</p> CPython <pre><code>void dvz_shape_scale(\n    DvzShape* shape,  // the shape\n    vec3 scale,  // the scaling factors\n);\n</code></pre> <pre><code>dvz.shape_scale(\n    shape,  # the shape : DvzShape*\n    scale,  # the scaling factors : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_sector","title":"<code>dvz_shape_sector()</code>","text":"<p>Create a sector shape.</p> CPython <pre><code>void dvz_shape_sector(\n    DvzShape* shape,  // the shape\n    uint32_t count,  // the number of points along the sector border\n    float angle_start,  // the initial angle\n    float angle_stop,  // the final angle\n    DvzColor color,  // the sector color\n);\n</code></pre> <pre><code>dvz.shape_sector(\n    shape,  # the shape : DvzShape*\n    count,  # the number of points along the sector border : int\n    angle_start,  # the initial angle : float\n    angle_stop,  # the final angle : float\n    color,  # the sector color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_sphere","title":"<code>dvz_shape_sphere()</code>","text":"<p>Create a sphere shape.</p> CPython <pre><code>void dvz_shape_sphere(\n    DvzShape* shape,  // the shape\n    uint32_t rows,  // the number of rows\n    uint32_t cols,  // the number of columns\n    DvzColor color,  // the sphere color\n);\n</code></pre> <pre><code>dvz.shape_sphere(\n    shape,  # the shape : DvzShape*\n    rows,  # the number of rows : int\n    cols,  # the number of columns : int\n    color,  # the sphere color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_square","title":"<code>dvz_shape_square()</code>","text":"<p>Create a square shape.</p> CPython <pre><code>void dvz_shape_square(\n    DvzShape* shape,  // the shape\n    DvzColor color,  // the square color\n);\n</code></pre> <pre><code>dvz.shape_square(\n    shape,  # the shape : DvzShape*\n    color,  # the square color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_surface","title":"<code>dvz_shape_surface()</code>","text":"<p>Create a grid shape.</p> CPython <pre><code>void dvz_shape_surface(\n    DvzShape* shape,  // the shape\n    uint32_t row_count,  // number of rows\n    uint32_t col_count,  // number of cols\n    float* heights,  // a pointer to row_count*col_count height values (floats)\n    DvzColor* colors,  // a pointer to row_count*col_count color values (DvzColor: cvec4 or vec4)\n    vec3 o,  // the origin\n    vec3 u,  // the unit vector parallel to each column\n    vec3 v,  // the unit vector parallel to each row\n    int flags,  // the grid creation flags\n);\n</code></pre> <pre><code>dvz.shape_surface(\n    shape,  # the shape : DvzShape*\n    row_count,  # number of rows : int\n    col_count,  # number of cols : int\n    heights,  # a pointer to row_count*col_count height values (floats) : np.ndarray[float]\n    colors,  # a pointer to row_count*col_count color values (DvzColor: cvec4 or vec4) : DvzColor*\n    o,  # the origin : Tuple[float, float, float]\n    u,  # the unit vector parallel to each column : Tuple[float, float, float]\n    v,  # the unit vector parallel to each row : Tuple[float, float, float]\n    flags,  # the grid creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_tetrahedron","title":"<code>dvz_shape_tetrahedron()</code>","text":"<p>Create a tetrahedron.</p> CPython <pre><code>void dvz_shape_tetrahedron(\n    DvzShape* shape,  // the shape\n    DvzColor color,  // the color\n);\n</code></pre> <pre><code>dvz.shape_tetrahedron(\n    shape,  # the shape : DvzShape*\n    color,  # the color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_torus","title":"<code>dvz_shape_torus()</code>","text":"<p>Create a torus shape. The radius of the ring is 0.5.</p> CPython <pre><code>void dvz_shape_torus(\n    DvzShape* shape,  // the shape\n    uint32_t count_radial,  // the number of points around the ring\n    uint32_t count_tubular,  // the number of points in each cross-section\n    float tube_radius,  // the radius of the tube.\n    DvzColor color,  // the torus color\n);\n</code></pre> <pre><code>dvz.shape_torus(\n    shape,  # the shape : DvzShape*\n    count_radial,  # the number of points around the ring : int\n    count_tubular,  # the number of points in each cross-section : int\n    tube_radius,  # the radius of the tube. : float\n    color,  # the torus color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_transform","title":"<code>dvz_shape_transform()</code>","text":"<p>Append an arbitrary transformation.</p> CPython <pre><code>void dvz_shape_transform(\n    DvzShape* shape,  // the shape\n    mat4 transform,  // the transform mat4 matrix\n);\n</code></pre> <pre><code>dvz.shape_transform(\n    shape,  # the shape : DvzShape*\n    transform,  # the transform mat4 matrix : mat4\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_translate","title":"<code>dvz_shape_translate()</code>","text":"<p>Append a translation to a shape.</p> CPython <pre><code>void dvz_shape_translate(\n    DvzShape* shape,  // the shape\n    vec3 translate,  // the translation vector\n);\n</code></pre> <pre><code>dvz.shape_translate(\n    shape,  # the shape : DvzShape*\n    translate,  # the translation vector : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_unindex","title":"<code>dvz_shape_unindex()</code>","text":"<p>Convert an indexed shape to a non-indexed one by duplicating the vertex values according to the indices. This is used by the mesh wireframe option, as a given vertex may have distinct barycentric coordinates depending on its index.</p> CPython <pre><code>void dvz_shape_unindex(\n    DvzShape* shape,  // the shape\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.shape_unindex(\n    shape,  # the shape : DvzShape*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_shape_vertex_count","title":"<code>dvz_shape_vertex_count()</code>","text":"<p>Return the number of vertices of a shape.</p> CPython <pre><code>uint32_t dvz_shape_vertex_count(  // returns the number of vertices\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.shape_vertex_count(  # returns the number of vertices : uint32_t\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#texture","title":"Texture","text":""},{"location":"reference/api_c/#dvz_texture_1d","title":"<code>dvz_texture_1D()</code>","text":"<p>Create a 1D texture.</p> CPython <pre><code>DvzTexture* dvz_texture_1D(  // returns the texture\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    DvzFilter filter,  // the filter\n    DvzSamplerAddressMode address_mode,  // the address mode\n    uint32_t width,  // the texture width\n    void* data,  // the texture data to upload\n    int flags,  // the texture creation flags\n);\n</code></pre> <pre><code>dvz.texture_1D(  # returns the texture : DvzTexture*\n    batch,  # the batch : DvzBatch*\n    format,  # the texture format : DvzFormat\n    filter,  # the filter : DvzFilter\n    address_mode,  # the address mode : DvzSamplerAddressMode\n    width,  # the texture width : int\n    data,  # the texture data to upload : np.ndarray\n    flags,  # the texture creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_2d","title":"<code>dvz_texture_2D()</code>","text":"<p>Create a 2D texture to be used in an image visual.</p> CPython <pre><code>DvzTexture* dvz_texture_2D(  // returns the texture\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    DvzFilter filter,  // the filter\n    DvzSamplerAddressMode address_mode,  // the address mode\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    void* data,  // the texture data to upload\n    int flags,  // the texture creation flags\n);\n</code></pre> <pre><code>dvz.texture_2D(  # returns the texture : DvzTexture*\n    batch,  # the batch : DvzBatch*\n    format,  # the texture format : DvzFormat\n    filter,  # the filter : DvzFilter\n    address_mode,  # the address mode : DvzSamplerAddressMode\n    width,  # the texture width : int\n    height,  # the texture height : int\n    data,  # the texture data to upload : np.ndarray\n    flags,  # the texture creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_3d","title":"<code>dvz_texture_3D()</code>","text":"<p>Create a 3D texture to be used in a volume visual.</p> CPython <pre><code>DvzTexture* dvz_texture_3D(  // returns the texture\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    DvzFilter filter,  // the filter\n    DvzSamplerAddressMode address_mode,  // the address mode\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    uint32_t depth,  // the texture depth\n    void* data,  // the texture data to upload\n    int flags,  // the texture creation flags\n);\n</code></pre> <pre><code>dvz.texture_3D(  # returns the texture : DvzTexture*\n    batch,  # the batch : DvzBatch*\n    format,  # the texture format : DvzFormat\n    filter,  # the filter : DvzFilter\n    address_mode,  # the address mode : DvzSamplerAddressMode\n    width,  # the texture width : int\n    height,  # the texture height : int\n    depth,  # the texture depth : int\n    data,  # the texture data to upload : np.ndarray\n    flags,  # the texture creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_address_mode","title":"<code>dvz_texture_address_mode()</code>","text":"<p>Set the texture's associated sampler's address mode.</p> CPython <pre><code>void dvz_texture_address_mode(\n    DvzTexture* texture,  // the texture\n    DvzSamplerAddressMode address_mode,  // the address mode\n);\n</code></pre> <pre><code>dvz.texture_address_mode(\n    texture,  # the texture : DvzTexture*\n    address_mode,  # the address mode : DvzSamplerAddressMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_create","title":"<code>dvz_texture_create()</code>","text":"<p>Create the texture once set.</p> CPython <pre><code>void dvz_texture_create(\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.texture_create(\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_data","title":"<code>dvz_texture_data()</code>","text":"<p>Upload all or part of the the texture data.</p> CPython <pre><code>void dvz_texture_data(\n    DvzTexture* texture,  // the texture\n    uint32_t xoffset,  // the x offset inside the texture\n    uint32_t yoffset,  // the y offset inside the texture\n    uint32_t zoffset,  // the z offset inside the texture\n    uint32_t width,  // the width of the uploaded image\n    uint32_t height,  // the height of the uploaded image\n    uint32_t depth,  // the depth of the uploaded image\n    DvzSize size,  // the size of the data buffer\n    void* data,  // the data buffer\n);\n</code></pre> <pre><code>dvz.texture_data(\n    texture,  # the texture : DvzTexture*\n    xoffset,  # the x offset inside the texture : int\n    yoffset,  # the y offset inside the texture : int\n    zoffset,  # the z offset inside the texture : int\n    width,  # the width of the uploaded image : int\n    height,  # the height of the uploaded image : int\n    depth,  # the depth of the uploaded image : int\n    size,  # the size of the data buffer : DvzSize\n    data,  # the data buffer : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_destroy","title":"<code>dvz_texture_destroy()</code>","text":"<p>Destroy a texture.</p> CPython <pre><code>void dvz_texture_destroy(\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.texture_destroy(\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_filter","title":"<code>dvz_texture_filter()</code>","text":"<p>Set the texture's associated sampler's filter (nearest or linear).</p> CPython <pre><code>void dvz_texture_filter(\n    DvzTexture* texture,  // the texture\n    DvzFilter filter,  // the filter\n);\n</code></pre> <pre><code>dvz.texture_filter(\n    texture,  # the texture : DvzTexture*\n    filter,  # the filter : DvzFilter\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_format","title":"<code>dvz_texture_format()</code>","text":"<p>Set the texture format.</p> CPython <pre><code>void dvz_texture_format(\n    DvzTexture* texture,  // the texture\n    DvzFormat format,  // the format\n);\n</code></pre> <pre><code>dvz.texture_format(\n    texture,  # the texture : DvzTexture*\n    format,  # the format : DvzFormat\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_texture_shape","title":"<code>dvz_texture_shape()</code>","text":"<p>Set the texture shape.</p> CPython <pre><code>void dvz_texture_shape(\n    DvzTexture* texture,  // the texture\n    uint32_t width,  // the width\n    uint32_t height,  // the height\n    uint32_t depth,  // the depth\n);\n</code></pre> <pre><code>dvz.texture_shape(\n    texture,  # the texture : DvzTexture*\n    width,  # the width : int\n    height,  # the height : int\n    depth,  # the depth : int\n)\n</code></pre>"},{"location":"reference/api_c/#threads","title":"Threads","text":""},{"location":"reference/api_c/#dvz_threads_default","title":"<code>dvz_threads_default()</code>","text":"<p>Set the number of threads to use in OpenMP-aware functions based on DVZ_NUM_THREADS, or take half of dvz_num_procs().</p> CPython <pre><code>void dvz_threads_default(\n);\n</code></pre> <pre><code>dvz.threads_default(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_threads_get","title":"<code>dvz_threads_get()</code>","text":"<p>Get the number of threads to use in OpenMP-aware functions.</p> CPython <pre><code>int dvz_threads_get(  // returns the current number of threads specified to OpenMP\n);\n</code></pre> <pre><code>dvz.threads_get(  # returns the current number of threads specified to OpenMP : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_threads_set","title":"<code>dvz_threads_set()</code>","text":"<p>Set the number of threads to use in OpenMP-aware functions.</p> CPython <pre><code>void dvz_threads_set(\n    int num_threads,  // the requested number of threads\n);\n</code></pre> <pre><code>dvz.threads_set(\n    num_threads,  # the requested number of threads : int\n)\n</code></pre>"},{"location":"reference/api_c/#time","title":"Time","text":""},{"location":"reference/api_c/#dvz_time_print","title":"<code>dvz_time_print()</code>","text":"<p>Display a time.</p> CPython <pre><code>void dvz_time_print(\n    DvzTime* time,  // a time structure\n);\n</code></pre> <pre><code>dvz.time_print(\n    time,  # a time structure : DvzTime*\n)\n</code></pre>"},{"location":"reference/api_c/#visual","title":"Visual","text":""},{"location":"reference/api_c/#dvz_visual_alloc","title":"<code>dvz_visual_alloc()</code>","text":"<p>Allocate a visual.</p> CPython <pre><code>void dvz_visual_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the number of items\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices\n);\n</code></pre> <pre><code>dvz.visual_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the number of items : int\n    vertex_count,  # the number of vertices : int\n    index_count,  # the number of indices : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_attr","title":"<code>dvz_visual_attr()</code>","text":"<p>Declare a visual attribute.</p> CPython <pre><code>void dvz_visual_attr(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    DvzSize offset,  // the attribute offset within the vertex buffer, in bytes\n    DvzSize item_size,  // the attribute size, in bytes\n    DvzFormat format,  // the attribute data format\n    int flags,  // the attribute flags\n);\n</code></pre> <pre><code>dvz.visual_attr(\n    visual,  # the visual : DvzVisual*\n    attr_idx,  # the attribute index : int\n    offset,  # the attribute offset within the vertex buffer, in bytes : DvzSize\n    item_size,  # the attribute size, in bytes : DvzSize\n    format,  # the attribute data format : DvzFormat\n    flags,  # the attribute flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_blend","title":"<code>dvz_visual_blend()</code>","text":"<p>Set the blend type of a visual.</p> CPython <pre><code>void dvz_visual_blend(\n    DvzVisual* visual,  // the visual\n    DvzBlendType blend_type,  // the blend type\n);\n</code></pre> <pre><code>dvz.visual_blend(\n    visual,  # the visual : DvzVisual*\n    blend_type,  # the blend type : DvzBlendType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_clip","title":"<code>dvz_visual_clip()</code>","text":"<p>Set the visual clipping.</p> CPython <pre><code>void dvz_visual_clip(\n    DvzVisual* visual,  // the visual\n    DvzViewportClip clip,  // the viewport clipping\n);\n</code></pre> <pre><code>dvz.visual_clip(\n    visual,  # the visual : DvzVisual*\n    clip,  # the viewport clipping : DvzViewportClip\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_cull","title":"<code>dvz_visual_cull()</code>","text":"<p>Set the cull mode of a visual.</p> CPython <pre><code>void dvz_visual_cull(\n    DvzVisual* visual,  // the visual\n    DvzCullMode cull_mode,  // the cull mode\n);\n</code></pre> <pre><code>dvz.visual_cull(\n    visual,  # the visual : DvzVisual*\n    cull_mode,  # the cull mode : DvzCullMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_dat","title":"<code>dvz_visual_dat()</code>","text":"<p>Bind a dat to a visual slot.</p> CPython <pre><code>void dvz_visual_dat(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    DvzId dat,  // the dat ID\n);\n</code></pre> <pre><code>dvz.visual_dat(\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index : int\n    dat,  # the dat ID : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_data","title":"<code>dvz_visual_data()</code>","text":"<p>Set visual data.</p> CPython <pre><code>void dvz_visual_data(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    uint32_t first,  // the index of the first item to set\n    uint32_t count,  // the number of items to set\n    void* data,  // a pointer to the data buffer\n);\n</code></pre> <pre><code>dvz.visual_data(\n    visual,  # the visual : DvzVisual*\n    attr_idx,  # the attribute index : int\n    first,  # the index of the first item to set : int\n    count,  # the number of items to set : int\n    data,  # a pointer to the data buffer : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_depth","title":"<code>dvz_visual_depth()</code>","text":"<p>Set the visual depth.</p> CPython <pre><code>void dvz_visual_depth(\n    DvzVisual* visual,  // the visual\n    DvzDepthTest depth_test,  // whether to activate the depth test\n);\n</code></pre> <pre><code>dvz.visual_depth(\n    visual,  # the visual : DvzVisual*\n    depth_test,  # whether to activate the depth test : DvzDepthTest\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_dynamic","title":"<code>dvz_visual_dynamic()</code>","text":"<p>Declare a dynamic attribute, meaning that it is stored in a separate dat rather than being interleaved with the other attributes in the same vertex buffer.</p> CPython <pre><code>void dvz_visual_dynamic(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    uint32_t binding_idx,  // the binding index (0 = common vertex buffer, use 1 or 2, 3... for each\n);\n</code></pre> <pre><code>dvz.visual_dynamic(\n    visual,  # the visual : DvzVisual*\n    attr_idx,  # the attribute index : int\n    binding_idx,  # the binding index (0 = common vertex buffer, use 1 or 2, 3... for each : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_fixed","title":"<code>dvz_visual_fixed()</code>","text":"<p>Fix some axes in a visual.</p> CPython <pre><code>void dvz_visual_fixed(\n    DvzVisual* visual,  // the visual\n    int flags,  // the fixed bitmask (combination of `DVZ_VISUAL_FLAGS_FIXED_X|Y|Z`)\n);\n</code></pre> <pre><code>dvz.visual_fixed(\n    visual,  # the visual : DvzVisual*\n    flags,  # the fixed bitmask (combination of `DVZ_VISUAL_FLAGS_FIXED_X|Y|Z`) : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_front","title":"<code>dvz_visual_front()</code>","text":"<p>Set the front face mode of a visual.</p> CPython <pre><code>void dvz_visual_front(\n    DvzVisual* visual,  // the visual\n    DvzFrontFace front_face,  // the front face mode\n);\n</code></pre> <pre><code>dvz.visual_front(\n    visual,  # the visual : DvzVisual*\n    front_face,  # the front face mode : DvzFrontFace\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_groups","title":"<code>dvz_visual_groups()</code>","text":"<p>Set groups in a visual.</p> CPython <pre><code>void dvz_visual_groups(\n    DvzVisual* visual,  // the visual\n    uint32_t group_count,  // the number of groups\n    uint32_t* group_sizes,  // the size of each group\n);\n</code></pre> <pre><code>dvz.visual_groups(\n    visual,  # the visual : DvzVisual*\n    group_count,  # the number of groups : int\n    group_sizes,  # the size of each group : np.ndarray[uint32_t]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_index","title":"<code>dvz_visual_index()</code>","text":"<p>Set the visual index data.</p> CPython <pre><code>void dvz_visual_index(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first index to set\n    uint32_t count,  // the number of indices\n    DvzIndex* data,  // a pointer to a buffer of DvzIndex (uint32_t) values with the indices\n);\n</code></pre> <pre><code>dvz.visual_index(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first index to set : int\n    count,  # the number of indices : int\n    data,  # a pointer to a buffer of DvzIndex (uint32_t) values with the indices : DvzIndex*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_param","title":"<code>dvz_visual_param()</code>","text":"<p>Set a visual parameter value.</p> CPython <pre><code>void dvz_visual_param(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    uint32_t attr_idx,  // the index of the parameter attribute within the params structure\n    void* item,  // a pointer to the value to use for that parameter\n);\n</code></pre> <pre><code>dvz.visual_param(\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index : int\n    attr_idx,  # the index of the parameter attribute within the params structure : int\n    item,  # a pointer to the value to use for that parameter : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_params","title":"<code>dvz_visual_params()</code>","text":"<p>Declare a set of visual parameters.</p> CPython <pre><code>DvzParams* dvz_visual_params(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index of the uniform buffer storing the parameter values\n    DvzSize size,  // the size, in bytes, of that uniform buffer\n);\n</code></pre> <pre><code>dvz.visual_params(\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index of the uniform buffer storing the parameter values : int\n    size,  # the size, in bytes, of that uniform buffer : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_polygon","title":"<code>dvz_visual_polygon()</code>","text":"<p>Set the polygon mode of a visual.</p> CPython <pre><code>void dvz_visual_polygon(\n    DvzVisual* visual,  // the visual\n    DvzPolygonMode polygon_mode,  // the polygon mode\n);\n</code></pre> <pre><code>dvz.visual_polygon(\n    visual,  # the visual : DvzVisual*\n    polygon_mode,  # the polygon mode : DvzPolygonMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_primitive","title":"<code>dvz_visual_primitive()</code>","text":"<p>Set the primitive topology of a visual.</p> CPython <pre><code>void dvz_visual_primitive(\n    DvzVisual* visual,  // the visual\n    DvzPrimitiveTopology primitive,  // the primitive topology\n);\n</code></pre> <pre><code>dvz.visual_primitive(\n    visual,  # the visual : DvzVisual*\n    primitive,  # the primitive topology : DvzPrimitiveTopology\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_push","title":"<code>dvz_visual_push()</code>","text":"<p>Set a push constant of a visual.</p> CPython <pre><code>void dvz_visual_push(\n    DvzVisual* visual,  // the visual\n    DvzShaderStageFlags shader_stages,  // the shader stage flags\n    DvzSize offset,  // the offset, in bytes\n    DvzSize size,  // the size, in bytes\n);\n</code></pre> <pre><code>dvz.visual_push(\n    visual,  # the visual : DvzVisual*\n    shader_stages,  # the shader stage flags : DvzShaderStageFlags\n    offset,  # the offset, in bytes : DvzSize\n    size,  # the size, in bytes : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_quads","title":"<code>dvz_visual_quads()</code>","text":"<p>Set visual data as quads.</p> CPython <pre><code>void dvz_visual_quads(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    uint32_t first,  // the index of the first item to set\n    uint32_t count,  // the number of items to set\n    vec4* tl_br,  // a pointer to a buffer of vec4 with the 2D coordinates of the top-left and\n);\n</code></pre> <pre><code>dvz.visual_quads(\n    visual,  # the visual : DvzVisual*\n    attr_idx,  # the attribute index : int\n    first,  # the index of the first item to set : int\n    count,  # the number of items to set : int\n    tl_br,  # a pointer to a buffer of vec4 with the 2D coordinates of the top-left and : np.ndarray[vec4]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_resize","title":"<code>dvz_visual_resize()</code>","text":"<p>Resize a visual allocation.</p> CPython <pre><code>void dvz_visual_resize(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the number of items\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices (0 if there is no index buffer)\n);\n</code></pre> <pre><code>dvz.visual_resize(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the number of items : int\n    vertex_count,  # the number of vertices : int\n    index_count,  # the number of indices (0 if there is no index buffer) : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_shader","title":"<code>dvz_visual_shader()</code>","text":"<p>Set the shader SPIR-V name of a visual.</p> CPython <pre><code>void dvz_visual_shader(\n    DvzVisual* visual,  // the visual\n    char* name,  // the built-in resource name of the shader (_vert and _frag are appended)\n);\n</code></pre> <pre><code>dvz.visual_shader(\n    visual,  # the visual : DvzVisual*\n    name,  # the built-in resource name of the shader (_vert and _frag are appended) : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_show","title":"<code>dvz_visual_show()</code>","text":"<p>Set the visibility of a visual.</p> CPython <pre><code>void dvz_visual_show(\n    DvzVisual* visual,  // the visual\n    bool is_visible,  // the visual visibility\n);\n</code></pre> <pre><code>dvz.visual_show(\n    visual,  # the visual : DvzVisual*\n    is_visible,  # the visual visibility : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_slot","title":"<code>dvz_visual_slot()</code>","text":"<p>Declare a visual slot.</p> CPython <pre><code>void dvz_visual_slot(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    DvzSlotType type,  // the slot type\n);\n</code></pre> <pre><code>dvz.visual_slot(\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index : int\n    type,  # the slot type : DvzSlotType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_specialization","title":"<code>dvz_visual_specialization()</code>","text":"<p>Set a specialization constant of a visual.</p> CPython <pre><code>void dvz_visual_specialization(\n    DvzVisual* visual,  // the visual\n    DvzShaderType shader,  // the shader type\n    uint32_t idx,  // the specialization constant index\n    DvzSize size,  // the size, in bytes, of the value passed to this function\n    void* value,  // a pointer to the value to use for that specialization constant\n);\n</code></pre> <pre><code>dvz.visual_specialization(\n    visual,  # the visual : DvzVisual*\n    shader,  # the shader type : DvzShaderType\n    idx,  # the specialization constant index : int\n    size,  # the size, in bytes, of the value passed to this function : DvzSize\n    value,  # a pointer to the value to use for that specialization constant : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_spirv","title":"<code>dvz_visual_spirv()</code>","text":"<p>Set the shader SPIR-V code of a visual.</p> CPython <pre><code>void dvz_visual_spirv(\n    DvzVisual* visual,  // the visual\n    DvzShaderType type,  // the shader type\n    DvzSize size,  // the size, in bytes, of the SPIR-V buffer\n    char* buffer,  // a pointer to the SPIR-V buffer\n);\n</code></pre> <pre><code>dvz.visual_spirv(\n    visual,  # the visual : DvzVisual*\n    type,  # the shader type : DvzShaderType\n    size,  # the size, in bytes, of the SPIR-V buffer : DvzSize\n    buffer,  # a pointer to the SPIR-V buffer : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_stride","title":"<code>dvz_visual_stride()</code>","text":"<p>Declare a visual binding.</p> CPython <pre><code>void dvz_visual_stride(\n    DvzVisual* visual,  // the visual\n    uint32_t binding_idx,  // the binding index\n    DvzSize stride,  // the binding stride, in bytes\n);\n</code></pre> <pre><code>dvz.visual_stride(\n    visual,  # the visual : DvzVisual*\n    binding_idx,  # the binding index : int\n    stride,  # the binding stride, in bytes : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_tex","title":"<code>dvz_visual_tex()</code>","text":"<p>Bind a tex to a visual slot.</p> CPython <pre><code>void dvz_visual_tex(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    DvzId tex,  // the tex ID\n    DvzId sampler,  // the sampler ID\n    uvec3 offset,  // the texture offset\n);\n</code></pre> <pre><code>dvz.visual_tex(\n    visual,  # the visual : DvzVisual*\n    slot_idx,  # the slot index : int\n    tex,  # the tex ID : DvzId\n    sampler,  # the sampler ID : DvzId\n    offset,  # the texture offset : Tuple[int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_transform","title":"<code>dvz_visual_transform()</code>","text":"<p>Set a visual transform.</p> CPython <pre><code>void dvz_visual_transform(\n    DvzVisual* visual,  // the visual\n    DvzTransform* tr,  // the transform\n    uint32_t vertex_attr,  // the vertex attribute on which the transform applies to\n);\n</code></pre> <pre><code>dvz.visual_transform(\n    visual,  # the visual : DvzVisual*\n    tr,  # the transform : DvzTransform*\n    vertex_attr,  # the vertex attribute on which the transform applies to : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_visual_update","title":"<code>dvz_visual_update()</code>","text":"<p>Update a visual after its data has changed. Note: this function is automatically called in the event loop internally, so you should not need to use it in most cases.</p> CPython <pre><code>void dvz_visual_update(\n    DvzVisual* visual,  // the visual\n);\n</code></pre> <pre><code>dvz.visual_update(\n    visual,  # the visual : DvzVisual*\n)\n</code></pre>"},{"location":"reference/api_c/#visual-functions","title":"Visual functions","text":""},{"location":"reference/api_c/#basic","title":"Basic","text":""},{"location":"reference/api_c/#dvz_basic_alloc","title":"<code>dvz_basic_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_basic_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.basic_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_basic_color","title":"<code>dvz_basic_color()</code>","text":"<p>Set the vertex colors.</p> CPython <pre><code>void dvz_basic_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.basic_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_basic_group","title":"<code>dvz_basic_group()</code>","text":"<p>Set the vertex group index.</p> CPython <pre><code>void dvz_basic_group(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the group index of each vertex\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.basic_group(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the group index of each vertex : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_basic_position","title":"<code>dvz_basic_position()</code>","text":"<p>Set the vertex positions.</p> CPython <pre><code>void dvz_basic_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.basic_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_basic_shape","title":"<code>dvz_basic_shape()</code>","text":"<p>Create a basic visual from a DvzShape instance.</p> CPython <pre><code>DvzVisual* dvz_basic_shape(  // returns the visual\n    DvzBatch* batch,  // the batch\n    DvzShape* shape,  // the shape\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.basic_shape(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    shape,  # the shape : DvzShape*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_basic_size","title":"<code>dvz_basic_size()</code>","text":"<p>Set the point size (for POINT_LIST topology only).</p> CPython <pre><code>void dvz_basic_size(\n    DvzVisual* visual,  // the visual\n    float size,  // the point size in pixels\n);\n</code></pre> <pre><code>dvz.basic_size(\n    visual,  # the visual : DvzVisual*\n    size,  # the point size in pixels : float\n)\n</code></pre>"},{"location":"reference/api_c/#glyph","title":"Glyph","text":""},{"location":"reference/api_c/#dvz_glyph_alloc","title":"<code>dvz_glyph_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_glyph_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.glyph_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_anchor","title":"<code>dvz_glyph_anchor()</code>","text":"<p>Set the glyph anchors. The anchor should be the same for each glyph in a given string. In addition, it is important to set dvz_glyph_group_size() (the size of each string in pixels) for the anchor computation to be correct. The anchor determines the relationship between the glyph 3D position, and the position of the string bounding box. Each string comes with a local coordinate system extending from (-1, -1) (bottom-left corner) to (+1, +1) (top-right corner), and (0, 0) refers to the center of the string. The anchor is the point, in this local coordinate system, that matches the glyph 3D position. For example, to center a string around the glyph 3D position, use (0, 0) as anchor. To align the string to the right of the glyph 3D position, use (-1, -1) for example.</p> CPython <pre><code>void dvz_glyph_anchor(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the anchors (x and y) of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_anchor(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the anchors (x and y) of the items to update : np.ndarray[vec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_angle","title":"<code>dvz_glyph_angle()</code>","text":"<p>Set the glyph angles.</p> CPython <pre><code>void dvz_glyph_angle(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the angles of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_angle(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the angles of the items to update : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_ascii","title":"<code>dvz_glyph_ascii()</code>","text":"<p>Set the glyph ascii characters.</p> CPython <pre><code>void dvz_glyph_ascii(\n    DvzVisual* visual,  // the visual\n    char* string,  // the characters\n);\n</code></pre> <pre><code>dvz.glyph_ascii(\n    visual,  # the visual : DvzVisual*\n    string,  # the characters : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_atlas_font","title":"<code>dvz_glyph_atlas_font()</code>","text":"<p>Associate an atlas and font with a glyph visual.</p> CPython <pre><code>void dvz_glyph_atlas_font(\n    DvzVisual* visual,  // the visual\n    DvzAtlasFont* af,  // the atlas font\n);\n</code></pre> <pre><code>dvz.glyph_atlas_font(\n    visual,  # the visual : DvzVisual*\n    af,  # the atlas font : DvzAtlasFont*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_axis","title":"<code>dvz_glyph_axis()</code>","text":"<p>Set the glyph axes.</p> CPython <pre><code>void dvz_glyph_axis(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D axis vectors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_axis(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D axis vectors of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_bgcolor","title":"<code>dvz_glyph_bgcolor()</code>","text":"<p>Set the glyph background color.</p> CPython <pre><code>void dvz_glyph_bgcolor(\n    DvzVisual* visual,  // the visual\n    DvzColor bgcolor,  // the background color\n);\n</code></pre> <pre><code>dvz.glyph_bgcolor(\n    visual,  # the visual : DvzVisual*\n    bgcolor,  # the background color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_color","title":"<code>dvz_glyph_color()</code>","text":"<p>Set the glyph colors.</p> CPython <pre><code>void dvz_glyph_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_group_size","title":"<code>dvz_glyph_group_size()</code>","text":"<p>Set the glyph group size, in pixels (size of each string).</p> CPython <pre><code>void dvz_glyph_group_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the glyph group shapes (width and height, in pixels)\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_group_size(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the glyph group shapes (width and height, in pixels) : np.ndarray[vec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_position","title":"<code>dvz_glyph_position()</code>","text":"<p>Set the glyph positions.</p> CPython <pre><code>void dvz_glyph_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_scale","title":"<code>dvz_glyph_scale()</code>","text":"<p>Set the glyph scaling applied to the size of all individual glyphs. We assume that the scaling is the same within each string (group of glyphs).</p> CPython <pre><code>void dvz_glyph_scale(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the scaling of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_scale(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the scaling of the items to update : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_shift","title":"<code>dvz_glyph_shift()</code>","text":"<p>Set the glyph shifts.</p> CPython <pre><code>void dvz_glyph_shift(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the shifts (x and y) of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_shift(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the shifts (x and y) of the items to update : np.ndarray[vec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_size","title":"<code>dvz_glyph_size()</code>","text":"<p>Set the glyph sizes, in pixels.</p> CPython <pre><code>void dvz_glyph_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the sizes (width and height) of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_size(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the sizes (width and height) of the items to update : np.ndarray[vec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_strings","title":"<code>dvz_glyph_strings()</code>","text":"<p>Helper function to easily set multiple strings of the same size and color on a glyph visual.</p> CPython <pre><code>void dvz_glyph_strings(\n    DvzVisual* visual,  // the visual\n    uint32_t string_count,  // the number of strings\n    char** strings,  // the strings\n    vec3* positions,  // the positions of each string\n    float* scales,  // the scaling of each string\n    DvzColor color,  // the same color for all strings\n    vec2 offset,  // the same offset for all strings\n    vec2 anchor,  // the same anchor for all strings\n);\n</code></pre> <pre><code>dvz.glyph_strings(\n    visual,  # the visual : DvzVisual*\n    string_count,  # the number of strings : int\n    strings,  # the strings : List[str]\n    positions,  # the positions of each string : np.ndarray[vec3]\n    scales,  # the scaling of each string : np.ndarray[float]\n    color,  # the same color for all strings : Tuple[int, int, int, int]\n    offset,  # the same offset for all strings : Tuple[float, float]\n    anchor,  # the same anchor for all strings : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_texcoords","title":"<code>dvz_glyph_texcoords()</code>","text":"<p>Set the glyph texture coordinates.</p> CPython <pre><code>void dvz_glyph_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* coords,  // the x,y,w,h texture coordinates\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_texcoords(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    coords,  # the x,y,w,h texture coordinates : np.ndarray[vec4]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_texture","title":"<code>dvz_glyph_texture()</code>","text":"<p>Assign a texture to a glyph visual.</p> CPython <pre><code>void dvz_glyph_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.glyph_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_unicode","title":"<code>dvz_glyph_unicode()</code>","text":"<p>Set the glyph unicode code points.</p> CPython <pre><code>void dvz_glyph_unicode(\n    DvzVisual* visual,  // the visual\n    uint32_t count,  // the number of glyphs\n    uint32_t* codepoints,  // the unicode codepoints\n);\n</code></pre> <pre><code>dvz.glyph_unicode(\n    visual,  # the visual : DvzVisual*\n    count,  # the number of glyphs : int\n    codepoints,  # the unicode codepoints : np.ndarray[uint32_t]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph_xywh","title":"<code>dvz_glyph_xywh()</code>","text":"<p>Set the xywh parameters of each glyph.</p> CPython <pre><code>void dvz_glyph_xywh(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the xywh values of each glyph\n    vec2 offset,  // the xy offsets of each glyph\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.glyph_xywh(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the xywh values of each glyph : np.ndarray[vec4]\n    offset,  # the xy offsets of each glyph : Tuple[float, float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#grid","title":"Grid","text":""},{"location":"reference/api_c/#dvz_grid_color","title":"<code>dvz_grid_color()</code>","text":"<p>Set the grid line color.</p> CPython <pre><code>void dvz_grid_color(\n    DvzVisual* grid,  // the grid visual\n    vec4 value,  // RGBA color of fine lines\n);\n</code></pre> <pre><code>dvz.grid_color(\n    grid,  # the grid visual : DvzVisual*\n    value,  # RGBA color of fine lines : Tuple[float, float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_grid_elevation","title":"<code>dvz_grid_elevation()</code>","text":"<p>Set the grid elevation on the Y axis.</p> CPython <pre><code>void dvz_grid_elevation(\n    DvzVisual* grid,  // the grid visual\n    float value,  // grid elevation\n);\n</code></pre> <pre><code>dvz.grid_elevation(\n    grid,  # the grid visual : DvzVisual*\n    value,  # grid elevation : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_grid_linewidth","title":"<code>dvz_grid_linewidth()</code>","text":"<p>Set the line width.</p> CPython <pre><code>void dvz_grid_linewidth(\n    DvzVisual* grid,  // the grid visual\n    float value,  // width of lines (in world units)\n);\n</code></pre> <pre><code>dvz.grid_linewidth(\n    grid,  # the grid visual : DvzVisual*\n    value,  # width of lines (in world units) : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_grid_scale","title":"<code>dvz_grid_scale()</code>","text":"<p>Set the grid spacing.</p> CPython <pre><code>void dvz_grid_scale(\n    DvzVisual* grid,  // the grid visual\n    float value,  // spacing between grid lines (in world units)\n);\n</code></pre> <pre><code>dvz.grid_scale(\n    grid,  # the grid visual : DvzVisual*\n    value,  # spacing between grid lines (in world units) : float\n)\n</code></pre>"},{"location":"reference/api_c/#image","title":"Image","text":""},{"location":"reference/api_c/#dvz_image_alloc","title":"<code>dvz_image_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_image_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of images to allocate for this visual\n);\n</code></pre> <pre><code>dvz.image_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of images to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_anchor","title":"<code>dvz_image_anchor()</code>","text":"<p>Set the image anchors. The anchor determines the relationship between the image 3D position, and the position of the image on the screen. Each images comes with a local coordinate system extending from (-1, -1) (bottom-left corner) to (+1, +1) (top-right corner), and (0, 0) refers to the center of the image. The anchor is the point, in this local coordinate system, that matches the image 3D position. For example, to center an image around the image 3D position, use (0, 0) as anchor. To align the image to the right and bottom of the image 3D position, so that this position refers to the top-left corner, use (-1, +1) as anchor.</p> CPython <pre><code>void dvz_image_anchor(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the relative anchors of each image, (0,0 = position pertains to top left corner)\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.image_anchor(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the relative anchors of each image, (0,0 = position pertains to top left corner) : np.ndarray[vec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_colormap","title":"<code>dvz_image_colormap()</code>","text":"<p>Specify the colormap when using DVZ_IMAGE_FLAGS_MODE_COLORMAP. Only the following colormaps are available on the GPU at the moment: <code>CMAP_BINARY</code> <code>CMAP_HSV</code> <code>CMAP_CIVIDIS</code> <code>CMAP_INFERNO</code> <code>CMAP_MAGMA</code> <code>CMAP_PLASMA</code> <code>CMAP_VIRIDIS</code> <code>CMAP_AUTUMN</code> <code>CMAP_BONE</code> <code>CMAP_COOL</code> <code>CMAP_COPPER</code> <code>CMAP_HOT</code> <code>CMAP_SPRING</code> <code>CMAP_SUMMER</code> <code>CMAP_WINTER</code> <code>CMAP_JET</code></p> CPython <pre><code>void dvz_image_colormap(\n    DvzVisual* visual,  // the visual\n    DvzColormap cmap,  // the colormap\n);\n</code></pre> <pre><code>dvz.image_colormap(\n    visual,  # the visual : DvzVisual*\n    cmap,  # the colormap : DvzColormap\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_edgecolor","title":"<code>dvz_image_edgecolor()</code>","text":"<p>Set the edge color.</p> CPython <pre><code>void dvz_image_edgecolor(\n    DvzVisual* visual,  // the visual\n    DvzColor color,  // the edge color\n);\n</code></pre> <pre><code>dvz.image_edgecolor(\n    visual,  # the visual : DvzVisual*\n    color,  # the edge color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_facecolor","title":"<code>dvz_image_facecolor()</code>","text":"<p>Set the image colors (only when using DVZ_IMAGE_FLAGS_FILL).</p> CPython <pre><code>void dvz_image_facecolor(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the image colors\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.image_facecolor(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the image colors : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_linewidth","title":"<code>dvz_image_linewidth()</code>","text":"<p>Set the edge width.</p> CPython <pre><code>void dvz_image_linewidth(\n    DvzVisual* visual,  // the visual\n    float width,  // the edge width\n);\n</code></pre> <pre><code>dvz.image_linewidth(\n    visual,  # the visual : DvzVisual*\n    width,  # the edge width : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_permutation","title":"<code>dvz_image_permutation()</code>","text":"<p>Set the texture coordinates index permutation.</p> CPython <pre><code>void dvz_image_permutation(\n    DvzVisual* visual,  // the visual\n    ivec2 ij,  // index permutation\n);\n</code></pre> <pre><code>dvz.image_permutation(\n    visual,  # the visual : DvzVisual*\n    ij,  # index permutation : Tuple[int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_position","title":"<code>dvz_image_position()</code>","text":"<p>Set the image positions.</p> CPython <pre><code>void dvz_image_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the top left corner\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.image_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the top left corner : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_radius","title":"<code>dvz_image_radius()</code>","text":"<p>Use a rounded rectangle for images, with a given radius in pixels.</p> CPython <pre><code>void dvz_image_radius(\n    DvzVisual* visual,  // the visual\n    float radius,  // the rounded corner radius, in pixel\n);\n</code></pre> <pre><code>dvz.image_radius(\n    visual,  # the visual : DvzVisual*\n    radius,  # the rounded corner radius, in pixel : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_size","title":"<code>dvz_image_size()</code>","text":"<p>Set the image sizes.</p> CPython <pre><code>void dvz_image_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the sizes of each image, in pixels\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.image_size(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the sizes of each image, in pixels : np.ndarray[vec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_texcoords","title":"<code>dvz_image_texcoords()</code>","text":"<p>Set the image texture coordinates.</p> CPython <pre><code>void dvz_image_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* tl_br,  // the tex coordinates of the top left and bottom right corners (vec4 u0,v0,u1,v1)\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.image_texcoords(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    tl_br,  # the tex coordinates of the top left and bottom right corners (vec4 u0,v0,u1,v1) : np.ndarray[vec4]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image_texture","title":"<code>dvz_image_texture()</code>","text":"<p>Assign a texture to an image visual.</p> CPython <pre><code>void dvz_image_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.image_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#marker","title":"Marker","text":""},{"location":"reference/api_c/#dvz_marker_alloc","title":"<code>dvz_marker_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_marker_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.marker_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_angle","title":"<code>dvz_marker_angle()</code>","text":"<p>Set the marker angles.</p> CPython <pre><code>void dvz_marker_angle(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the angles of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.marker_angle(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the angles of the items to update : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_aspect","title":"<code>dvz_marker_aspect()</code>","text":"<p>Set the marker aspect.</p> CPython <pre><code>void dvz_marker_aspect(\n    DvzVisual* visual,  // the visual\n    DvzMarkerAspect aspect,  // the marker aspect, one of DVZ_MARKER_ASPECT_FILLED, DVZ_MARKER_ASPECT_STROKE\n);\n</code></pre> <pre><code>dvz.marker_aspect(\n    visual,  # the visual : DvzVisual*\n    aspect,  # the marker aspect, one of DVZ_MARKER_ASPECT_FILLED, DVZ_MARKER_ASPECT_STROKE, : DvzMarkerAspect\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_color","title":"<code>dvz_marker_color()</code>","text":"<p>Set the marker colors.</p> CPython <pre><code>void dvz_marker_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.marker_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_edgecolor","title":"<code>dvz_marker_edgecolor()</code>","text":"<p>Set the marker edge color.</p> CPython <pre><code>void dvz_marker_edgecolor(\n    DvzVisual* visual,  // the visual\n    DvzColor color,  // the edge color\n);\n</code></pre> <pre><code>dvz.marker_edgecolor(\n    visual,  # the visual : DvzVisual*\n    color,  # the edge color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_linewidth","title":"<code>dvz_marker_linewidth()</code>","text":"<p>Set the marker edge width.</p> CPython <pre><code>void dvz_marker_linewidth(\n    DvzVisual* visual,  // the visual\n    float width,  // the edge width\n);\n</code></pre> <pre><code>dvz.marker_linewidth(\n    visual,  # the visual : DvzVisual*\n    width,  # the edge width : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_mode","title":"<code>dvz_marker_mode()</code>","text":"<p>Set the marker mode.</p> CPython <pre><code>void dvz_marker_mode(\n    DvzVisual* visual,  // the visual\n    DvzMarkerMode mode,  // the marker mode, one of DVZ_MARKER_MODE_CODE, DVZ_MARKER_MODE_BITMAP\n);\n</code></pre> <pre><code>dvz.marker_mode(\n    visual,  # the visual : DvzVisual*\n    mode,  # the marker mode, one of DVZ_MARKER_MODE_CODE, DVZ_MARKER_MODE_BITMAP, : DvzMarkerMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_position","title":"<code>dvz_marker_position()</code>","text":"<p>Set the marker positions.</p> CPython <pre><code>void dvz_marker_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.marker_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_shape","title":"<code>dvz_marker_shape()</code>","text":"<p>Set the marker shape.</p> CPython <pre><code>void dvz_marker_shape(\n    DvzVisual* visual,  // the visual\n    DvzMarkerShape shape,  // the marker shape\n);\n</code></pre> <pre><code>dvz.marker_shape(\n    visual,  # the visual : DvzVisual*\n    shape,  # the marker shape : DvzMarkerShape\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_size","title":"<code>dvz_marker_size()</code>","text":"<p>Set the marker sizes.</p> CPython <pre><code>void dvz_marker_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.marker_size(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_tex_scale","title":"<code>dvz_marker_tex_scale()</code>","text":"<p>Set the texture scale.</p> CPython <pre><code>void dvz_marker_tex_scale(\n    DvzVisual* visual,  // the visual\n    float scale,  // the texture scale\n);\n</code></pre> <pre><code>dvz.marker_tex_scale(\n    visual,  # the visual : DvzVisual*\n    scale,  # the texture scale : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker_texture","title":"<code>dvz_marker_texture()</code>","text":"<p>Set the marker texture.</p> CPython <pre><code>void dvz_marker_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.marker_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#mesh","title":"Mesh","text":""},{"location":"reference/api_c/#dvz_mesh_alloc","title":"<code>dvz_mesh_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_mesh_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices\n);\n</code></pre> <pre><code>dvz.mesh_alloc(\n    visual,  # the visual : DvzVisual*\n    vertex_count,  # the number of vertices : int\n    index_count,  # the number of indices : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_color","title":"<code>dvz_mesh_color()</code>","text":"<p>Set the mesh colors.</p> CPython <pre><code>void dvz_mesh_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the vertex colors\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the vertex colors : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_contour","title":"<code>dvz_mesh_contour()</code>","text":"<p>Set the contour information for polygon contours.</p> CPython <pre><code>void dvz_mesh_contour(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // for vertex A, B, C, the least significant bit is 1 if the opposite edge is a\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_contour(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # for vertex A, B, C, the least significant bit is 1 if the opposite edge is a : np.ndarray[cvec4]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_density","title":"<code>dvz_mesh_density()</code>","text":"<p>Set the number of isolines</p> CPython <pre><code>void dvz_mesh_density(\n    DvzVisual* visual,  // the mesh\n    uint32_t count,  // the number of isolines\n);\n</code></pre> <pre><code>dvz.mesh_density(\n    visual,  # the mesh : DvzVisual*\n    count,  # the number of isolines : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_edgecolor","title":"<code>dvz_mesh_edgecolor()</code>","text":"<p>Set the marker edge color. Note: the alpha component is currently unused.</p> CPython <pre><code>void dvz_mesh_edgecolor(\n    DvzVisual* visual,  // the mesh\n    DvzColor rgba,  // the rgba components\n);\n</code></pre> <pre><code>dvz.mesh_edgecolor(\n    visual,  # the mesh : DvzVisual*\n    rgba,  # the rgba components : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_emit","title":"<code>dvz_mesh_emit()</code>","text":"<p>Set the mesh surface emission level.</p> CPython <pre><code>void dvz_mesh_emit(\n    DvzVisual* visual,  // the mesh\n    float emit,  // the emission level\n);\n</code></pre> <pre><code>dvz.mesh_emit(\n    visual,  # the mesh : DvzVisual*\n    emit,  # the emission level : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_index","title":"<code>dvz_mesh_index()</code>","text":"<p>Set the mesh indices.</p> CPython <pre><code>void dvz_mesh_index(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzIndex* values,  // the face indices (three vertex indices per triangle)\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_index(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the face indices (three vertex indices per triangle) : DvzIndex*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_isoline","title":"<code>dvz_mesh_isoline()</code>","text":"<p>Set the isolines values.</p> CPython <pre><code>void dvz_mesh_isoline(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the scalar field for which to draw isolines\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_isoline(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the scalar field for which to draw isolines : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_left","title":"<code>dvz_mesh_left()</code>","text":"<p>Set the distance between the current vertex to the left edge at corner A, B, or C in triangle ABC.</p> CPython <pre><code>void dvz_mesh_left(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the distance to the left edge adjacent to each triangle vertex\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_left(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the distance to the left edge adjacent to each triangle vertex : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_light_color","title":"<code>dvz_mesh_light_color()</code>","text":"<p>Set the light color.</p> CPython <pre><code>void dvz_mesh_light_color(\n    DvzVisual* visual,  // the mesh\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n    DvzColor rgba,  // the light color (a&gt;0 indicates light is on.)\n);\n</code></pre> <pre><code>dvz.mesh_light_color(\n    visual,  # the mesh : DvzVisual*\n    idx,  # the light index (0, 1, 2, or 3) : int\n    rgba,  # the light color (a&gt;0 indicates light is on.) : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_light_pos","title":"<code>dvz_mesh_light_pos()</code>","text":"<p>Set the light direction.</p> CPython <pre><code>void dvz_mesh_light_pos(\n    DvzVisual* visual,  // the mesh\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n    vec4 pos,  // the light position (w=0 indicates it is a direction.)\n);\n</code></pre> <pre><code>dvz.mesh_light_pos(\n    visual,  # the mesh : DvzVisual*\n    idx,  # the light index (0, 1, 2, or 3) : int\n    pos,  # the light position (w=0 indicates it is a direction.) : Tuple[float, float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_linewidth","title":"<code>dvz_mesh_linewidth()</code>","text":"<p>Set the mesh contour linewidth (wireframe or isoline).</p> CPython <pre><code>void dvz_mesh_linewidth(\n    DvzVisual* visual,  // the mesh\n    float linewidth,  // the line width\n);\n</code></pre> <pre><code>dvz.mesh_linewidth(\n    visual,  # the mesh : DvzVisual*\n    linewidth,  # the line width : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_material_params","title":"<code>dvz_mesh_material_params()</code>","text":"<p>Set the mesh material parameters.</p> CPython <pre><code>void dvz_mesh_material_params(\n    DvzVisual* visual,  // the mesh\n    uint32_t idx,  // the material index (0, 1, 2, or 3) for (ambient, diffuse, specular, exponent)\n    vec3 params,  // the material parameters (vec3 r, g, b)\n);\n</code></pre> <pre><code>dvz.mesh_material_params(\n    visual,  # the mesh : DvzVisual*\n    idx,  # the material index (0, 1, 2, or 3) for (ambient, diffuse, specular, exponent) : int\n    params,  # the material parameters (vec3 r, g, b) : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_normal","title":"<code>dvz_mesh_normal()</code>","text":"<p>Set the mesh normals.</p> CPython <pre><code>void dvz_mesh_normal(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the vertex normal vectors\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_normal(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the vertex normal vectors : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_position","title":"<code>dvz_mesh_position()</code>","text":"<p>Set the mesh vertex positions.</p> CPython <pre><code>void dvz_mesh_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D vertex positions\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D vertex positions : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_reshape","title":"<code>dvz_mesh_reshape()</code>","text":"<p>Update a mesh once a shape has been updated.</p> CPython <pre><code>void dvz_mesh_reshape(\n    DvzVisual* visual,  // the mesh\n    DvzShape* shape,  // the shape\n);\n</code></pre> <pre><code>dvz.mesh_reshape(\n    visual,  # the mesh : DvzVisual*\n    shape,  # the shape : DvzShape*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_right","title":"<code>dvz_mesh_right()</code>","text":"<p>Set the distance between the current vertex to the right edge at corner A, B, or C in triangle ABC.</p> CPython <pre><code>void dvz_mesh_right(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the distance to the right edge adjacent to each triangle vertex\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_right(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the distance to the right edge adjacent to each triangle vertex : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_shape","title":"<code>dvz_mesh_shape()</code>","text":"<p>Create a mesh out of a shape.</p> CPython <pre><code>DvzVisual* dvz_mesh_shape(  // returns the mesh\n    DvzBatch* batch,  // the batch\n    DvzShape* shape,  // the shape\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.mesh_shape(  # returns the mesh : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    shape,  # the shape : DvzShape*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_shine","title":"<code>dvz_mesh_shine()</code>","text":"<p>Set the mesh surface shine level.</p> CPython <pre><code>void dvz_mesh_shine(\n    DvzVisual* visual,  // the mesh\n    float shine,  // the surface shininess\n);\n</code></pre> <pre><code>dvz.mesh_shine(\n    visual,  # the mesh : DvzVisual*\n    shine,  # the surface shininess : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_texcoords","title":"<code>dvz_mesh_texcoords()</code>","text":"<p>Set the mesh texture coordinates.</p> CPython <pre><code>void dvz_mesh_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the vertex texture coordinates (vec4 u,v,*,alpha)\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.mesh_texcoords(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the vertex texture coordinates (vec4 u,v,*,alpha) : np.ndarray[vec4]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh_texture","title":"<code>dvz_mesh_texture()</code>","text":"<p>Assign a 2D texture to a mesh visual.</p> CPython <pre><code>void dvz_mesh_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.mesh_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#misc_1","title":"Misc","text":""},{"location":"reference/api_c/#dvz_basic","title":"<code>dvz_basic()</code>","text":"<p>Create a basic visual using the few GPU visual primitives (point, line, triangles).</p> CPython <pre><code>DvzVisual* dvz_basic(  // returns the visual\n    DvzBatch* batch,  // the batch\n    DvzPrimitiveTopology topology,  // the primitive topology\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.basic(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    topology,  # the primitive topology : DvzPrimitiveTopology\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_glyph","title":"<code>dvz_glyph()</code>","text":"<p>Create a glyph visual.</p> CPython <pre><code>DvzVisual* dvz_glyph(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.glyph(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_image","title":"<code>dvz_image()</code>","text":"<p>Create an image visual.</p> CPython <pre><code>DvzVisual* dvz_image(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.image(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_marker","title":"<code>dvz_marker()</code>","text":"<p>Create a marker visual.</p> CPython <pre><code>DvzVisual* dvz_marker(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.marker(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mesh","title":"<code>dvz_mesh()</code>","text":"<p>Create a mesh visual.</p> CPython <pre><code>DvzVisual* dvz_mesh(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.mesh(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph","title":"<code>dvz_monoglyph()</code>","text":"<p>Create a monoglyph visual.</p> CPython <pre><code>DvzVisual* dvz_monoglyph(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.monoglyph(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_path","title":"<code>dvz_path()</code>","text":"<p>Create a path visual.</p> CPython <pre><code>DvzVisual* dvz_path(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.path(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_pixel","title":"<code>dvz_pixel()</code>","text":"<p>Create a pixel visual.</p> CPython <pre><code>DvzVisual* dvz_pixel(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.pixel(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_point","title":"<code>dvz_point()</code>","text":"<p>Create a point visual.</p> CPython <pre><code>DvzVisual* dvz_point(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.point(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_segment","title":"<code>dvz_segment()</code>","text":"<p>Create a segment visual.</p> CPython <pre><code>DvzVisual* dvz_segment(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.segment(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_slice","title":"<code>dvz_slice()</code>","text":"<p>Create a slice visual (multiple 2D images with slices of a 3D texture).</p> CPython <pre><code>DvzVisual* dvz_slice(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.slice(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere","title":"<code>dvz_sphere()</code>","text":"<p>Create a sphere visual.</p> CPython <pre><code>DvzVisual* dvz_sphere(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.sphere(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_volume","title":"<code>dvz_volume()</code>","text":"<p>Create a volume visual.</p> CPython <pre><code>DvzVisual* dvz_volume(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.volume(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_wiggle","title":"<code>dvz_wiggle()</code>","text":"<p>Create a wiggle visual.</p> CPython <pre><code>DvzVisual* dvz_wiggle(  // returns the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n);\n</code></pre> <pre><code>dvz.wiggle(  # returns the visual : DvzVisual*\n    batch,  # the batch : DvzBatch*\n    flags,  # the visual creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#monoglyph","title":"Monoglyph","text":""},{"location":"reference/api_c/#dvz_monoglyph_alloc","title":"<code>dvz_monoglyph_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_monoglyph_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.monoglyph_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_anchor","title":"<code>dvz_monoglyph_anchor()</code>","text":"<p>Set the glyph anchor (relative to the glyph size).</p> CPython <pre><code>void dvz_monoglyph_anchor(\n    DvzVisual* visual,  // the visual\n    vec2 anchor,  // the anchor\n);\n</code></pre> <pre><code>dvz.monoglyph_anchor(\n    visual,  # the visual : DvzVisual*\n    anchor,  # the anchor : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_color","title":"<code>dvz_monoglyph_color()</code>","text":"<p>Set the glyph colors.</p> CPython <pre><code>void dvz_monoglyph_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.monoglyph_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_glyph","title":"<code>dvz_monoglyph_glyph()</code>","text":"<p>Set the text.</p> CPython <pre><code>void dvz_monoglyph_glyph(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the first item\n    char* text,  // the ASCII test (string length without the null terminal byte = number of glyphs)\n    int flags,  // the upload flags\n);\n</code></pre> <pre><code>dvz.monoglyph_glyph(\n    visual,  # the visual : DvzVisual*\n    first,  # the first item : int\n    text,  # the ASCII test (string length without the null terminal byte = number of glyphs) : str\n    flags,  # the upload flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_offset","title":"<code>dvz_monoglyph_offset()</code>","text":"<p>Set the glyph offsets.</p> CPython <pre><code>void dvz_monoglyph_offset(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    ivec2* values,  // the glyph offsets (ivec2 integers: row,column)\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.monoglyph_offset(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the glyph offsets (ivec2 integers: row,column) : np.ndarray[ivec2]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_position","title":"<code>dvz_monoglyph_position()</code>","text":"<p>Set the glyph positions.</p> CPython <pre><code>void dvz_monoglyph_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.monoglyph_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_size","title":"<code>dvz_monoglyph_size()</code>","text":"<p>Set the glyph size (relative to the initial glyph size).</p> CPython <pre><code>void dvz_monoglyph_size(\n    DvzVisual* visual,  // the visual\n    float size,  // the glyph size\n);\n</code></pre> <pre><code>dvz.monoglyph_size(\n    visual,  # the visual : DvzVisual*\n    size,  # the glyph size : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_monoglyph_textarea","title":"<code>dvz_monoglyph_textarea()</code>","text":"<p>All-in-one function for multiline text.</p> CPython <pre><code>void dvz_monoglyph_textarea(\n    DvzVisual* visual,  // the visual\n    vec3 pos,  // the text position\n    DvzColor color,  // the text color\n    float size,  // the glyph size\n    char* text,  // the text, can contain `\\n` new lines\n);\n</code></pre> <pre><code>dvz.monoglyph_textarea(\n    visual,  # the visual : DvzVisual*\n    pos,  # the text position : Tuple[float, float, float]\n    color,  # the text color : Tuple[int, int, int, int]\n    size,  # the glyph size : float\n    text,  # the text, can contain `\\n` new lines : str\n)\n</code></pre>"},{"location":"reference/api_c/#path","title":"Path","text":""},{"location":"reference/api_c/#dvz_path_alloc","title":"<code>dvz_path_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_path_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t total_point_count,  // the total number of points to allocate for this visual\n);\n</code></pre> <pre><code>dvz.path_alloc(\n    visual,  # the visual : DvzVisual*\n    total_point_count,  # the total number of points to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_path_cap","title":"<code>dvz_path_cap()</code>","text":"<p>Set the path cap.</p> CPython <pre><code>void dvz_path_cap(\n    DvzVisual* visual,  // the visual\n    DvzCapType cap,  // the cap\n);\n</code></pre> <pre><code>dvz.path_cap(\n    visual,  # the visual : DvzVisual*\n    cap,  # the cap : DvzCapType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_path_color","title":"<code>dvz_path_color()</code>","text":"<p>Set the path colors.</p> CPython <pre><code>void dvz_path_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.path_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_path_join","title":"<code>dvz_path_join()</code>","text":"<p>Set the path join.</p> CPython <pre><code>void dvz_path_join(\n    DvzVisual* visual,  // the visual\n    DvzJoinType join,  // the join\n);\n</code></pre> <pre><code>dvz.path_join(\n    visual,  # the visual : DvzVisual*\n    join,  # the join : DvzJoinType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_path_linewidth","title":"<code>dvz_path_linewidth()</code>","text":"<p>Set the path line width (may be variable along a path).</p> CPython <pre><code>void dvz_path_linewidth(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the line width of the vertex, in pixels\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.path_linewidth(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the line width of the vertex, in pixels : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_path_position","title":"<code>dvz_path_position()</code>","text":"<p>Set the path positions. Note: all path point positions must be updated at once for now.</p> CPython <pre><code>void dvz_path_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t point_count,  // the total number of points across all paths\n    vec3* positions,  // the path point positions\n    uint32_t path_count,  // the number of different paths\n    uint32_t* path_lengths,  // the number of points in each path\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.path_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    point_count,  # the total number of points across all paths : int\n    positions,  # the path point positions : np.ndarray[vec3]\n    path_count,  # the number of different paths : int\n    path_lengths,  # the number of points in each path : np.ndarray[uint32_t]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#pixel","title":"Pixel","text":""},{"location":"reference/api_c/#dvz_pixel_alloc","title":"<code>dvz_pixel_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_pixel_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.pixel_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_pixel_color","title":"<code>dvz_pixel_color()</code>","text":"<p>Set the pixel colors.</p> CPython <pre><code>void dvz_pixel_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.pixel_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_pixel_position","title":"<code>dvz_pixel_position()</code>","text":"<p>Set the pixel positions.</p> CPython <pre><code>void dvz_pixel_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.pixel_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_pixel_size","title":"<code>dvz_pixel_size()</code>","text":"<p>Set the pixel size.</p> CPython <pre><code>void dvz_pixel_size(\n    DvzVisual* visual,  // the visual\n    float size,  // the point size in pixels\n);\n</code></pre> <pre><code>dvz.pixel_size(\n    visual,  # the visual : DvzVisual*\n    size,  # the point size in pixels : float\n)\n</code></pre>"},{"location":"reference/api_c/#point","title":"Point","text":""},{"location":"reference/api_c/#dvz_point_alloc","title":"<code>dvz_point_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_point_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.point_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_point_color","title":"<code>dvz_point_color()</code>","text":"<p>Set the point colors.</p> CPython <pre><code>void dvz_point_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.point_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_point_position","title":"<code>dvz_point_position()</code>","text":"<p>Set the point positions.</p> CPython <pre><code>void dvz_point_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.point_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the 3D positions of the items to update : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_point_size","title":"<code>dvz_point_size()</code>","text":"<p>Set the point sizes.</p> CPython <pre><code>void dvz_point_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the sizes of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.point_size(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the sizes of the items to update : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#segment","title":"Segment","text":""},{"location":"reference/api_c/#dvz_segment_alloc","title":"<code>dvz_segment_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_segment_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n);\n</code></pre> <pre><code>dvz.segment_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of items to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_segment_cap","title":"<code>dvz_segment_cap()</code>","text":"<p>Set the segment cap types.</p> CPython <pre><code>void dvz_segment_cap(\n    DvzVisual* visual,  // the visual\n    DvzCapType initial,  // the initial segment cap type\n    DvzCapType terminal,  // the terminal segment cap type\n);\n</code></pre> <pre><code>dvz.segment_cap(\n    visual,  # the visual : DvzVisual*\n    initial,  # the initial segment cap type : DvzCapType\n    terminal,  # the terminal segment cap type : DvzCapType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_segment_color","title":"<code>dvz_segment_color()</code>","text":"<p>Set the segment colors.</p> CPython <pre><code>void dvz_segment_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.segment_color(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the colors of the items to update : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_segment_linewidth","title":"<code>dvz_segment_linewidth()</code>","text":"<p>Set the segment line widths.</p> CPython <pre><code>void dvz_segment_linewidth(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the segment line widths\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.segment_linewidth(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the segment line widths : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_segment_position","title":"<code>dvz_segment_position()</code>","text":"<p>Set the segment positions.</p> CPython <pre><code>void dvz_segment_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* initial,  // the initial 3D positions of the segments\n    vec3* terminal,  // the terminal 3D positions of the segments\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.segment_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    initial,  # the initial 3D positions of the segments : np.ndarray[vec3]\n    terminal,  # the terminal 3D positions of the segments : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_segment_shift","title":"<code>dvz_segment_shift()</code>","text":"<p>Set the segment shift.</p> CPython <pre><code>void dvz_segment_shift(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the dx0,dy0,dx1,dy1 shift quadriplets of the segments to update\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.segment_shift(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    values,  # the dx0,dy0,dx1,dy1 shift quadriplets of the segments to update : np.ndarray[vec4]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#slice","title":"Slice","text":""},{"location":"reference/api_c/#dvz_slice_alloc","title":"<code>dvz_slice_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_slice_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of slices to allocate for this visual\n);\n</code></pre> <pre><code>dvz.slice_alloc(\n    visual,  # the visual : DvzVisual*\n    item_count,  # the total number of slices to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_slice_alpha","title":"<code>dvz_slice_alpha()</code>","text":"<p>Set the slice transparency alpha value.</p> CPython <pre><code>void dvz_slice_alpha(\n    DvzVisual* visual,  // the visual\n    float alpha,  // the alpha value\n);\n</code></pre> <pre><code>dvz.slice_alpha(\n    visual,  # the visual : DvzVisual*\n    alpha,  # the alpha value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_slice_position","title":"<code>dvz_slice_position()</code>","text":"<p>Set the slice positions.</p> CPython <pre><code>void dvz_slice_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* p0,  // the 3D positions of the top left corner\n    vec3* p1,  // the 3D positions of the top right corner\n    vec3* p2,  // the 3D positions of the bottom left corner\n    vec3* p3,  // the 3D positions of the bottom right corner\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.slice_position(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    p0,  # the 3D positions of the top left corner : np.ndarray[vec3]\n    p1,  # the 3D positions of the top right corner : np.ndarray[vec3]\n    p2,  # the 3D positions of the bottom left corner : np.ndarray[vec3]\n    p3,  # the 3D positions of the bottom right corner : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_slice_texcoords","title":"<code>dvz_slice_texcoords()</code>","text":"<p>Set the slice texture coordinates.</p> CPython <pre><code>void dvz_slice_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* uvw0,  // the 3D texture coordinates of the top left corner\n    vec3* uvw1,  // the 3D texture coordinates of the top right corner\n    vec3* uvw2,  // the 3D texture coordinates of the bottom left corner\n    vec3* uvw3,  // the 3D texture coordinates of the bottom right corner\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.slice_texcoords(\n    visual,  # the visual : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    uvw0,  # the 3D texture coordinates of the top left corner : np.ndarray[vec3]\n    uvw1,  # the 3D texture coordinates of the top right corner : np.ndarray[vec3]\n    uvw2,  # the 3D texture coordinates of the bottom left corner : np.ndarray[vec3]\n    uvw3,  # the 3D texture coordinates of the bottom right corner : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_slice_texture","title":"<code>dvz_slice_texture()</code>","text":"<p>Assign a texture to a slice visual.</p> CPython <pre><code>void dvz_slice_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.slice_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#sphere","title":"Sphere","text":""},{"location":"reference/api_c/#dvz_sphere_alloc","title":"<code>dvz_sphere_alloc()</code>","text":"<p>Allocate memory for a visual.</p> CPython <pre><code>void dvz_sphere_alloc(\n    DvzVisual* visual,  // the sphere\n    uint32_t item_count,  // the total number of spheres to allocate for this visual\n);\n</code></pre> <pre><code>dvz.sphere_alloc(\n    visual,  # the sphere : DvzVisual*\n    item_count,  # the total number of spheres to allocate for this visual : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_color","title":"<code>dvz_sphere_color()</code>","text":"<p>Set the sphere colors.</p> CPython <pre><code>void dvz_sphere_color(\n    DvzVisual* visual,  // the sphere\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* color,  // the sphere colors\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.sphere_color(\n    visual,  # the sphere : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    color,  # the sphere colors : DvzColor*\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_emit","title":"<code>dvz_sphere_emit()</code>","text":"<p>Set the sphere surface emission level.</p> CPython <pre><code>void dvz_sphere_emit(\n    DvzVisual* visual,  // the sphere\n    float emit,  // the emission level\n);\n</code></pre> <pre><code>dvz.sphere_emit(\n    visual,  # the sphere : DvzVisual*\n    emit,  # the emission level : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_light_color","title":"<code>dvz_sphere_light_color()</code>","text":"<p>Set the light color.</p> CPython <pre><code>void dvz_sphere_light_color(\n    DvzVisual* visual,  // the sphere\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n    DvzColor rgba,  // the light color (a&gt;0 indicates light is on.)\n);\n</code></pre> <pre><code>dvz.sphere_light_color(\n    visual,  # the sphere : DvzVisual*\n    idx,  # the light index (0, 1, 2, or 3) : int\n    rgba,  # the light color (a&gt;0 indicates light is on.) : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_light_pos","title":"<code>dvz_sphere_light_pos()</code>","text":"<p>Set the sphere light position.</p> CPython <pre><code>void dvz_sphere_light_pos(\n    DvzVisual* visual,  // the sphere\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n    vec4 pos,  // the light position (w=0 indicates it is a direction.)\n);\n</code></pre> <pre><code>dvz.sphere_light_pos(\n    visual,  # the sphere : DvzVisual*\n    idx,  # the light index (0, 1, 2, or 3) : int\n    pos,  # the light position (w=0 indicates it is a direction.) : Tuple[float, float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_material_params","title":"<code>dvz_sphere_material_params()</code>","text":"<p>Set the sphere material parameters.</p> CPython <pre><code>void dvz_sphere_material_params(\n    DvzVisual* visual,  // the sphere\n    uint32_t idx,  // the material index (0, 1, 2, or 3) for (ambient, diffuse, specular, exponent)\n    vec3 params,  // the material parameters (vec3 r, g, b)\n);\n</code></pre> <pre><code>dvz.sphere_material_params(\n    visual,  # the sphere : DvzVisual*\n    idx,  # the material index (0, 1, 2, or 3) for (ambient, diffuse, specular, exponent) : int\n    params,  # the material parameters (vec3 r, g, b) : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_position","title":"<code>dvz_sphere_position()</code>","text":"<p>Set the sphere positions.</p> CPython <pre><code>void dvz_sphere_position(\n    DvzVisual* visual,  // the sphere\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* pos,  // the 3D positions of the sphere centers\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.sphere_position(\n    visual,  # the sphere : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    pos,  # the 3D positions of the sphere centers : np.ndarray[vec3]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_shine","title":"<code>dvz_sphere_shine()</code>","text":"<p>Set the sphere surface shininess.</p> CPython <pre><code>void dvz_sphere_shine(\n    DvzVisual* visual,  // the sphere\n    float shine,  // the surface shininess\n);\n</code></pre> <pre><code>dvz.sphere_shine(\n    visual,  # the sphere : DvzVisual*\n    shine,  # the surface shininess : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_size","title":"<code>dvz_sphere_size()</code>","text":"<p>Set the sphere sizes.</p> CPython <pre><code>void dvz_sphere_size(\n    DvzVisual* visual,  // the sphere\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* size,  // the radius of the spheres\n    int flags,  // the data update flags\n);\n</code></pre> <pre><code>dvz.sphere_size(\n    visual,  # the sphere : DvzVisual*\n    first,  # the index of the first item to update : int\n    count,  # the number of items to update : int\n    size,  # the radius of the spheres : np.ndarray[float]\n    flags,  # the data update flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_sphere_texture","title":"<code>dvz_sphere_texture()</code>","text":"<p>Assign a 2D texture to a sphere visual.</p> CPython <pre><code>void dvz_sphere_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.sphere_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#tex","title":"Tex","text":""},{"location":"reference/api_c/#dvz_tex_slice","title":"<code>dvz_tex_slice()</code>","text":"<p>Create a 3D texture to be used in a slice visual.</p> CPython <pre><code>DvzId dvz_tex_slice(  // returns the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    uint32_t depth,  // the texture depth\n    void* data,  // the texture data to upload\n);\n</code></pre> <pre><code>dvz.tex_slice(  # returns the texture ID : DvzId\n    batch,  # the batch : DvzBatch*\n    format,  # the texture format : DvzFormat\n    width,  # the texture width : int\n    height,  # the texture height : int\n    depth,  # the texture depth : int\n    data,  # the texture data to upload : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#volume","title":"Volume","text":""},{"location":"reference/api_c/#dvz_volume_bounds","title":"<code>dvz_volume_bounds()</code>","text":"<p>Set the volume bounds.</p> CPython <pre><code>void dvz_volume_bounds(\n    DvzVisual* visual,  // the visual\n    vec2 xlim,  // xmin and xmax\n    vec2 ylim,  // ymin and ymax\n    vec2 zlim,  // zmin and zmax\n);\n</code></pre> <pre><code>dvz.volume_bounds(\n    visual,  # the visual : DvzVisual*\n    xlim,  # xmin and xmax : Tuple[float, float]\n    ylim,  # ymin and ymax : Tuple[float, float]\n    zlim,  # zmin and zmax : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_volume_permutation","title":"<code>dvz_volume_permutation()</code>","text":"<p>Set the texture coordinates index permutation.</p> CPython <pre><code>void dvz_volume_permutation(\n    DvzVisual* visual,  // the visual\n    ivec3 ijk,  // index permutation\n);\n</code></pre> <pre><code>dvz.volume_permutation(\n    visual,  # the visual : DvzVisual*\n    ijk,  # index permutation : Tuple[int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_volume_slice","title":"<code>dvz_volume_slice()</code>","text":"<p>Set the bounding box face index on which to slice (showing the texture itself).</p> CPython <pre><code>void dvz_volume_slice(\n    DvzVisual* visual,  // the visual\n    int32_t face_index,  // -1 to disable, or the face index between 0 and 5 included\n);\n</code></pre> <pre><code>dvz.volume_slice(\n    visual,  # the visual : DvzVisual*\n    face_index,  # -1 to disable, or the face index between 0 and 5 included : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_volume_texcoords","title":"<code>dvz_volume_texcoords()</code>","text":"<p>Set the texture coordinates of two corner points.</p> CPython <pre><code>void dvz_volume_texcoords(\n    DvzVisual* visual,  // the visual\n    vec3 uvw0,  // coordinates of one of the corner points\n    vec3 uvw1,  // coordinates of one of the corner points\n);\n</code></pre> <pre><code>dvz.volume_texcoords(\n    visual,  # the visual : DvzVisual*\n    uvw0,  # coordinates of one of the corner points : Tuple[float, float, float]\n    uvw1,  # coordinates of one of the corner points : Tuple[float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_volume_texture","title":"<code>dvz_volume_texture()</code>","text":"<p>Assign a 3D texture to a volume visual.</p> CPython <pre><code>void dvz_volume_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the 3D texture\n);\n</code></pre> <pre><code>dvz.volume_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the 3D texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_volume_transfer","title":"<code>dvz_volume_transfer()</code>","text":"<p>Set the volume size.</p> CPython <pre><code>void dvz_volume_transfer(\n    DvzVisual* visual,  // the visual\n    vec4 transfer,  // transfer function, for now `vec4(x, 0, 0, 0)` where x is a scaling factor\n);\n</code></pre> <pre><code>dvz.volume_transfer(\n    visual,  # the visual : DvzVisual*\n    transfer,  # transfer function, for now `vec4(x, 0, 0, 0)` where x is a scaling factor : Tuple[float, float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#wiggle","title":"Wiggle","text":""},{"location":"reference/api_c/#dvz_wiggle_bounds","title":"<code>dvz_wiggle_bounds()</code>","text":"<p>Set the wiggle bounds.</p> CPython <pre><code>void dvz_wiggle_bounds(\n    DvzVisual* visual,  // the visual\n    vec2 xlim,  // xmin and xmax\n    vec2 ylim,  // ymin and ymax\n);\n</code></pre> <pre><code>dvz.wiggle_bounds(\n    visual,  # the visual : DvzVisual*\n    xlim,  # xmin and xmax : Tuple[float, float]\n    ylim,  # ymin and ymax : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_wiggle_color","title":"<code>dvz_wiggle_color()</code>","text":"<p>Set the color of the negative and positive sections.</p> CPython <pre><code>void dvz_wiggle_color(\n    DvzVisual* visual,  // the visual\n    DvzColor negative_color,  // the color of the negative section\n    DvzColor positive_color,  // the color of the positive section\n);\n</code></pre> <pre><code>dvz.wiggle_color(\n    visual,  # the visual : DvzVisual*\n    negative_color,  # the color of the negative section : Tuple[int, int, int, int]\n    positive_color,  # the color of the positive section : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_wiggle_edgecolor","title":"<code>dvz_wiggle_edgecolor()</code>","text":"<p>Set the edge color.</p> CPython <pre><code>void dvz_wiggle_edgecolor(\n    DvzVisual* visual,  // the visual\n    DvzColor color,  // the edge color\n);\n</code></pre> <pre><code>dvz.wiggle_edgecolor(\n    visual,  # the visual : DvzVisual*\n    color,  # the edge color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_wiggle_scale","title":"<code>dvz_wiggle_scale()</code>","text":"<p>Set the texture scaling factor.</p> CPython <pre><code>void dvz_wiggle_scale(\n    DvzVisual* visual,  // the visual\n    float scale,  // the scaling factor\n);\n</code></pre> <pre><code>dvz.wiggle_scale(\n    visual,  # the visual : DvzVisual*\n    scale,  # the scaling factor : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_wiggle_texture","title":"<code>dvz_wiggle_texture()</code>","text":"<p>Assign a texture to an wiggle visual.</p> CPython <pre><code>void dvz_wiggle_texture(\n    DvzVisual* visual,  // the visual\n    DvzTexture* texture,  // the texture\n);\n</code></pre> <pre><code>dvz.wiggle_texture(\n    visual,  # the visual : DvzVisual*\n    texture,  # the texture : DvzTexture*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_wiggle_xrange","title":"<code>dvz_wiggle_xrange()</code>","text":"<p>Set the range of the wiggle on the x axis, in normalized coordinates ([0, 1]).</p> CPython <pre><code>void dvz_wiggle_xrange(\n    DvzVisual* visual,  // the visual\n    vec2 xrange,  // the x0 and xl in the quad, the channels will be in the interval [x0, xl]\n);\n</code></pre> <pre><code>dvz.wiggle_xrange(\n    visual,  # the visual : DvzVisual*\n    xrange,  # the x0 and xl in the quad, the channels will be in the interval [x0, xl] : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#gui-functions","title":"GUI functions","text":""},{"location":"reference/api_c/#gui","title":"Gui","text":""},{"location":"reference/api_c/#dvz_gui_alpha","title":"<code>dvz_gui_alpha()</code>","text":"<p>Set the alpha transparency of the next GUI dialog.</p> CPython <pre><code>void dvz_gui_alpha(\n    float alpha,  // the alpha transparency value\n);\n</code></pre> <pre><code>dvz.gui_alpha(\n    alpha,  # the alpha transparency value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_begin","title":"<code>dvz_gui_begin()</code>","text":"<p>Start a new dialog.</p> CPython <pre><code>void dvz_gui_begin(\n    char* title,  // the dialog title\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.gui_begin(\n    title,  # the dialog title : str\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_button","title":"<code>dvz_gui_button()</code>","text":"<p>Add a button.</p> CPython <pre><code>bool dvz_gui_button(  // returns whether the button was pressed\n    char* name,  // the button name\n    float width,  // the button width\n    float height,  // the button height\n);\n</code></pre> <pre><code>dvz.gui_button(  # returns whether the button was pressed : bool\n    name,  # the button name : str\n    width,  # the button width : float\n    height,  # the button height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_checkbox","title":"<code>dvz_gui_checkbox()</code>","text":"<p>Add a checkbox.</p> CPython <pre><code>bool dvz_gui_checkbox(  // returns whether the checkbox's state has changed\n    char* name,  // the button name\n    bool* checked,  // whether the checkbox is checked\n);\n</code></pre> <pre><code>dvz.gui_checkbox(  # returns whether the checkbox's state has changed : bool\n    name,  # the button name : str\n    checked,  # whether the checkbox is checked : Out[bool]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_clicked","title":"<code>dvz_gui_clicked()</code>","text":"<p>Close the current tree node.</p> CPython <pre><code>bool dvz_gui_clicked(\n);\n</code></pre> <pre><code>dvz.gui_clicked(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_collapse_changed","title":"<code>dvz_gui_collapse_changed()</code>","text":"<p>Return whether a dialog has just been collapsed or uncollapsed.</p> CPython <pre><code>bool dvz_gui_collapse_changed(  // returns whether the dialog has just been collapsed or uncollapsed.\n);\n</code></pre> <pre><code>dvz.gui_collapse_changed(  # returns whether the dialog has just been collapsed or uncollapsed. : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_collapsed","title":"<code>dvz_gui_collapsed()</code>","text":"<p>Return whether a dialog is collapsed.</p> CPython <pre><code>bool dvz_gui_collapsed(  // returns whether the dialog is collapsed\n);\n</code></pre> <pre><code>dvz.gui_collapsed(  # returns whether the dialog is collapsed : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_color","title":"<code>dvz_gui_color()</code>","text":"<p>Set the color of an element.</p> CPython <pre><code>void dvz_gui_color(\n    int type,  // the element type for which to change the color\n    DvzColor color,  // the color\n);\n</code></pre> <pre><code>dvz.gui_color(\n    type,  # the element type for which to change the color : int\n    color,  # the color : Tuple[int, int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_colorpicker","title":"<code>dvz_gui_colorpicker()</code>","text":"<p>Add a color picker</p> CPython <pre><code>bool dvz_gui_colorpicker(\n    char* name,  // the widget name\n    vec3 color,  // the color\n    int flags,  // the widget flags\n);\n</code></pre> <pre><code>dvz.gui_colorpicker(\n    name,  # the widget name : str\n    color,  # the color : Tuple[float, float, float]\n    flags,  # the widget flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_corner","title":"<code>dvz_gui_corner()</code>","text":"<p>Set the corner position of the next GUI dialog.</p> CPython <pre><code>void dvz_gui_corner(\n    DvzCorner corner,  // which corner\n    vec2 pad,  // the pad\n);\n</code></pre> <pre><code>dvz.gui_corner(\n    corner,  # which corner : DvzCorner\n    pad,  # the pad : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_demo","title":"<code>dvz_gui_demo()</code>","text":"<p>Show the demo GUI.</p> CPython <pre><code>void dvz_gui_demo(\n);\n</code></pre> <pre><code>dvz.gui_demo(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_dragging","title":"<code>dvz_gui_dragging()</code>","text":"<p>Return whether mouse is dragging.</p> CPython <pre><code>bool dvz_gui_dragging(  // returns whether the mouse is dragging\n);\n</code></pre> <pre><code>dvz.gui_dragging(  # returns whether the mouse is dragging : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_dropdown","title":"<code>dvz_gui_dropdown()</code>","text":"<p>Add a dropdown menu.</p> CPython <pre><code>bool dvz_gui_dropdown(\n    char* name,  // the menu name\n    uint32_t count,  // the number of menu items\n    char** items,  // the item labels\n    uint32_t* selected,  // a pointer to the selected index\n    int flags,  // the dropdown menu flags\n);\n</code></pre> <pre><code>dvz.gui_dropdown(\n    name,  # the menu name : str\n    count,  # the number of menu items : int\n    items,  # the item labels : List[str]\n    selected,  # a pointer to the selected index : Out[int]\n    flags,  # the dropdown menu flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_end","title":"<code>dvz_gui_end()</code>","text":"<p>Stop the creation of the dialog.</p> CPython <pre><code>void dvz_gui_end(\n);\n</code></pre> <pre><code>dvz.gui_end(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_fixed","title":"<code>dvz_gui_fixed()</code>","text":"<p>Set a fixed position for a GUI dialog.</p> CPython <pre><code>void dvz_gui_fixed(\n    vec2 pos,  // the dialog position\n    vec2 pivot,  // the pivot\n);\n</code></pre> <pre><code>dvz.gui_fixed(\n    pos,  # the dialog position : Tuple[float, float]\n    pivot,  # the pivot : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_flags","title":"<code>dvz_gui_flags()</code>","text":"<p>Set the flags of the next GUI dialog.</p> CPython <pre><code>int dvz_gui_flags(\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.gui_flags(\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_image","title":"<code>dvz_gui_image()</code>","text":"<p>Add an image in a GUI dialog.</p> CPython <pre><code>void dvz_gui_image(\n    DvzTex* tex,  // the texture\n    float width,  // the image width\n    float height,  // the image height\n);\n</code></pre> <pre><code>dvz.gui_image(\n    tex,  # the texture : DvzTex*\n    width,  # the image width : float\n    height,  # the image height : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_moved","title":"<code>dvz_gui_moved()</code>","text":"<p>Return whether a dialog has just moved.</p> CPython <pre><code>bool dvz_gui_moved(  // returns whether the dialog has just moved\n);\n</code></pre> <pre><code>dvz.gui_moved(  # returns whether the dialog has just moved : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_moving","title":"<code>dvz_gui_moving()</code>","text":"<p>Return whether a dialog is being moved.</p> CPython <pre><code>bool dvz_gui_moving(  // returns whether the dialog is being moved\n);\n</code></pre> <pre><code>dvz.gui_moving(  # returns whether the dialog is being moved : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_node","title":"<code>dvz_gui_node()</code>","text":"<p>Start a new tree node.</p> CPython <pre><code>bool dvz_gui_node(\n    char* name,  // the widget name\n);\n</code></pre> <pre><code>dvz.gui_node(\n    name,  # the widget name : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_pop","title":"<code>dvz_gui_pop()</code>","text":"<p>Close the current tree node.</p> CPython <pre><code>void dvz_gui_pop(\n);\n</code></pre> <pre><code>dvz.gui_pop(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_pos","title":"<code>dvz_gui_pos()</code>","text":"<p>Set the position of the next GUI dialog.</p> CPython <pre><code>void dvz_gui_pos(\n    vec2 pos,  // the dialog position\n    vec2 pivot,  // the pivot\n);\n</code></pre> <pre><code>dvz.gui_pos(\n    pos,  # the dialog position : Tuple[float, float]\n    pivot,  # the pivot : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_progress","title":"<code>dvz_gui_progress()</code>","text":"<p>Add a progress widget.</p> CPython <pre><code>void dvz_gui_progress(\n    float fraction,  // the fraction between 0 and 1\n    float width,  // the widget width\n    float height,  // the widget height\n    char* fmt,  // the format string\n);\n</code></pre> <pre><code>dvz.gui_progress(\n    fraction,  # the fraction between 0 and 1 : float\n    width,  # the widget width : float\n    height,  # the widget height : float\n    fmt,  # the format string : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_resized","title":"<code>dvz_gui_resized()</code>","text":"<p>Return whether a dialog has just been resized.</p> CPython <pre><code>bool dvz_gui_resized(  // returns whether the dialog has just been resized\n);\n</code></pre> <pre><code>dvz.gui_resized(  # returns whether the dialog has just been resized : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_resizing","title":"<code>dvz_gui_resizing()</code>","text":"<p>Return whether a dialog is being resized</p> CPython <pre><code>bool dvz_gui_resizing(  // returns whether the dialog is being resized\n);\n</code></pre> <pre><code>dvz.gui_resizing(  # returns whether the dialog is being resized : bool\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_selectable","title":"<code>dvz_gui_selectable()</code>","text":"<p>Close the current tree node.</p> CPython <pre><code>bool dvz_gui_selectable(\n    char* name,  // the widget name\n);\n</code></pre> <pre><code>dvz.gui_selectable(\n    name,  # the widget name : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_size","title":"<code>dvz_gui_size()</code>","text":"<p>Set the size of the next GUI dialog.</p> CPython <pre><code>void dvz_gui_size(\n    vec2 size,  // the size\n);\n</code></pre> <pre><code>dvz.gui_size(\n    size,  # the size : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider","title":"<code>dvz_gui_slider()</code>","text":"<p>Add a slider.</p> CPython <pre><code>bool dvz_gui_slider(  // returns whether the value has changed\n    char* name,  // the slider name\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    float* value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n    value,  # the pointer to the value : Out[float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_int","title":"<code>dvz_gui_slider_int()</code>","text":"<p>Add an integer slider.</p> CPython <pre><code>bool dvz_gui_slider_int(  // returns whether the value has changed\n    char* name,  // the slider name\n    int vmin,  // the minimum value\n    int vmax,  // the maximum value\n    int* value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_int(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : int\n    vmax,  # the maximum value : int\n    value,  # the pointer to the value : Out[int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_ivec2","title":"<code>dvz_gui_slider_ivec2()</code>","text":"<p>Add an integer slider with 2 values.</p> CPython <pre><code>bool dvz_gui_slider_ivec2(  // returns whether the value has changed\n    char* name,  // the slider name\n    int vmin,  // the minimum value\n    int vmax,  // the maximum value\n    ivec2 value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_ivec2(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : int\n    vmax,  # the maximum value : int\n    value,  # the pointer to the value : Out[Tuple[int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_ivec3","title":"<code>dvz_gui_slider_ivec3()</code>","text":"<p>Add an integer slider with 3 values.</p> CPython <pre><code>bool dvz_gui_slider_ivec3(  // returns whether the value has changed\n    char* name,  // the slider name\n    int vmin,  // the minimum value\n    int vmax,  // the maximum value\n    ivec3 value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_ivec3(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : int\n    vmax,  # the maximum value : int\n    value,  # the pointer to the value : Out[Tuple[int, int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_ivec4","title":"<code>dvz_gui_slider_ivec4()</code>","text":"<p>Add an integer slider with 4 values.</p> CPython <pre><code>bool dvz_gui_slider_ivec4(  // returns whether the value has changed\n    char* name,  // the slider name\n    int vmin,  // the minimum value\n    int vmax,  // the maximum value\n    ivec4 value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_ivec4(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : int\n    vmax,  # the maximum value : int\n    value,  # the pointer to the value : Out[Tuple[int, int, int, int]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_vec2","title":"<code>dvz_gui_slider_vec2()</code>","text":"<p>Add a slider with 2 values.</p> CPython <pre><code>bool dvz_gui_slider_vec2(  // returns whether the value has changed\n    char* name,  // the slider name\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    vec2 value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_vec2(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n    value,  # the pointer to the value : Out[Tuple[float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_vec3","title":"<code>dvz_gui_slider_vec3()</code>","text":"<p>Add a slider with 3 values.</p> CPython <pre><code>bool dvz_gui_slider_vec3(  // returns whether the value has changed\n    char* name,  // the slider name\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    vec3 value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_vec3(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n    value,  # the pointer to the value : Out[Tuple[float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_slider_vec4","title":"<code>dvz_gui_slider_vec4()</code>","text":"<p>Add a slider with 4 values.</p> CPython <pre><code>bool dvz_gui_slider_vec4(  // returns whether the value has changed\n    char* name,  // the slider name\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    vec4 value,  // the pointer to the value\n);\n</code></pre> <pre><code>dvz.gui_slider_vec4(  # returns whether the value has changed : bool\n    name,  # the slider name : str\n    vmin,  # the minimum value : float\n    vmax,  # the maximum value : float\n    value,  # the pointer to the value : Out[Tuple[float, float, float, float]]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_style","title":"<code>dvz_gui_style()</code>","text":"<p>Set the style of an element.</p> CPython <pre><code>void dvz_gui_style(\n    int type,  // the element type for which to change the style\n    float value,  // the value\n);\n</code></pre> <pre><code>dvz.gui_style(\n    type,  # the element type for which to change the style : int\n    value,  # the value : float\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_table","title":"<code>dvz_gui_table()</code>","text":"<p>Display a table with selectable rows.</p> CPython <pre><code>bool dvz_gui_table(  // returns whether the row selection has changed (in the selected array)\n    char* name,  // the widget name\n    uint32_t row_count,  // the number of rows\n    uint32_t column_count,  // the number of columns\n    char** labels,  // all cell labels\n    bool* selected,  // a pointer to an array of boolean indicated which rows are selected\n    int flags,  // the Dear ImGui flags\n);\n</code></pre> <pre><code>dvz.gui_table(  # returns whether the row selection has changed (in the selected array) : bool\n    name,  # the widget name : str\n    row_count,  # the number of rows : int\n    column_count,  # the number of columns : int\n    labels,  # all cell labels : List[str]\n    selected,  # a pointer to an array of boolean indicated which rows are selected : np.ndarray[bool]\n    flags,  # the Dear ImGui flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_text","title":"<code>dvz_gui_text()</code>","text":"<p>Add a text item in a dialog.</p> CPython <pre><code>void dvz_gui_text(\n    char* fmt,  // the format string\n);\n</code></pre> <pre><code>dvz.gui_text(\n    fmt,  # the format string : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_textbox","title":"<code>dvz_gui_textbox()</code>","text":"<p>Add a text box in a dialog.</p> CPython <pre><code>bool dvz_gui_textbox(  // returns whether the text has changed\n    char* label,  // the label\n    uint32_t str_len,  // the size of the str buffer\n    char* str,  // the modified string\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.gui_textbox(  # returns whether the text has changed : bool\n    label,  # the label : str\n    str_len,  # the size of the str buffer : int\n    str,  # the modified string : str\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_tree","title":"<code>dvz_gui_tree()</code>","text":"<p>Display a collapsible tree. Assumes the data is in the right order, with level encoding the depth of each row within the tree. Filtering can be implemented with the \"visible\" parameter. Note that this function automatically propagates the visibility of each node to all its descendents and ascendents, without modifying in-place the \"visible\" array.</p> CPython <pre><code>bool dvz_gui_tree(  // returns whether the selection has changed\n    uint32_t count,  // the number of rows\n    char** ids,  // short id of each row\n    char** labels,  // full label of each row\n    uint32_t* levels,  // a positive integer indicate\n    DvzColor* colors,  // the color of each square in each row\n    bool* folded,  // whether each row is currently folded (modified by this function)\n    bool* selected,  // whether each row is currently selected (modified by this function)\n    bool* visible,  // whether each row is visible (used for filtering)\n);\n</code></pre> <pre><code>dvz.gui_tree(  # returns whether the selection has changed : bool\n    count,  # the number of rows : int\n    ids,  # short id of each row : List[str]\n    labels,  # full label of each row : List[str]\n    levels,  # a positive integer indicate : np.ndarray[uint32_t]\n    colors,  # the color of each square in each row : DvzColor*\n    folded,  # whether each row is currently folded (modified by this function) : np.ndarray[bool]\n    selected,  # whether each row is currently selected (modified by this function) : np.ndarray[bool]\n    visible,  # whether each row is visible (used for filtering) : np.ndarray[bool]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_viewport","title":"<code>dvz_gui_viewport()</code>","text":"<p>Get the position and size of the current dialog.</p> CPython <pre><code>void dvz_gui_viewport(\n    vec4 viewport,  // the x, y, w, h values\n);\n</code></pre> <pre><code>dvz.gui_viewport(\n    viewport,  # the x, y, w, h values : Tuple[float, float, float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_gui_window_capture","title":"<code>dvz_gui_window_capture()</code>","text":"<p>Capture a GUI window.</p> CPython <pre><code>void dvz_gui_window_capture(\n    DvzGuiWindow* gui_window,  // the GUI window\n    bool is_captured,  // whether the windows should be captured\n);\n</code></pre> <pre><code>dvz.gui_window_capture(\n    gui_window,  # the GUI window : DvzGuiWindow*\n    is_captured,  # whether the windows should be captured : bool\n)\n</code></pre>"},{"location":"reference/api_c/#datoviz-rendering-protocol-functions","title":"Datoviz Rendering Protocol functions","text":""},{"location":"reference/api_c/#batch","title":"Batch","text":""},{"location":"reference/api_c/#dvz_batch_add","title":"<code>dvz_batch_add()</code>","text":"<p>Add a request to a batch.</p> CPython <pre><code>void dvz_batch_add(\n    DvzBatch* batch,  // the batch\n    DvzRequest req,  // the request\n);\n</code></pre> <pre><code>dvz.batch_add(\n    batch,  # the batch : DvzBatch*\n    req,  # the request : DvzRequest\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_clear","title":"<code>dvz_batch_clear()</code>","text":"<p>Remove all requests in a batch.</p> CPython <pre><code>void dvz_batch_clear(\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.batch_clear(\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_copy","title":"<code>dvz_batch_copy()</code>","text":"<p>Create a copy of a batch.</p> CPython <pre><code>DvzBatch* dvz_batch_copy(\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.batch_copy(\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_desc","title":"<code>dvz_batch_desc()</code>","text":"<p>Set the description of the last added request.</p> CPython <pre><code>void dvz_batch_desc(\n    DvzBatch* batch,  // the batch\n    char* desc,  // the description\n);\n</code></pre> <pre><code>dvz.batch_desc(\n    batch,  # the batch : DvzBatch*\n    desc,  # the description : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_destroy","title":"<code>dvz_batch_destroy()</code>","text":"<p>Destroy a batch.</p> CPython <pre><code>void dvz_batch_destroy(\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.batch_destroy(\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_dump","title":"<code>dvz_batch_dump()</code>","text":"<p>Dump all batch requests in raw binary file.</p> CPython <pre><code>int dvz_batch_dump(\n    DvzBatch* batch,  // the batch\n    char* filename,  // the dump filename\n);\n</code></pre> <pre><code>dvz.batch_dump(\n    batch,  # the batch : DvzBatch*\n    filename,  # the dump filename : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_load","title":"<code>dvz_batch_load()</code>","text":"<p>Load a dump of batch requests into an existing batch object.</p> CPython <pre><code>void dvz_batch_load(\n    DvzBatch* batch,  // the batch\n    char* filename,  // the dump filename\n);\n</code></pre> <pre><code>dvz.batch_load(\n    batch,  # the batch : DvzBatch*\n    filename,  # the dump filename : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_print","title":"<code>dvz_batch_print()</code>","text":"<p>Display information about all requests in the batch.</p> CPython <pre><code>void dvz_batch_print(\n    DvzBatch* batch,  // the batch\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.batch_print(\n    batch,  # the batch : DvzBatch*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_requests","title":"<code>dvz_batch_requests()</code>","text":"<p>Return a pointer to the array of all requests in the batch.</p> CPython <pre><code>DvzRequest* dvz_batch_requests(\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.batch_requests(\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_size","title":"<code>dvz_batch_size()</code>","text":"<p>Return the number of requests in the batch.</p> CPython <pre><code>uint32_t dvz_batch_size(\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.batch_size(\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_batch_yaml","title":"<code>dvz_batch_yaml()</code>","text":"<p>Export requests in a YAML file.</p> CPython <pre><code>void dvz_batch_yaml(\n    DvzBatch* batch,  // the batch\n    char* filename,  // the YAML filename\n);\n</code></pre> <pre><code>dvz.batch_yaml(\n    batch,  # the batch : DvzBatch*\n    filename,  # the YAML filename : str\n)\n</code></pre>"},{"location":"reference/api_c/#bind","title":"Bind","text":""},{"location":"reference/api_c/#dvz_bind_dat","title":"<code>dvz_bind_dat()</code>","text":"<p>Create a request for associating a dat to a pipe's slot.</p> CPython <pre><code>DvzRequest dvz_bind_dat(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId pipe,  // the id of the pipe\n    uint32_t slot_idx,  // the index of the descriptor slot\n    DvzId dat,  // the id of the dat to bind to the pipe\n    DvzSize offset,  // the offset\n);\n</code></pre> <pre><code>dvz.bind_dat(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    pipe,  # the id of the pipe : DvzId\n    slot_idx,  # the index of the descriptor slot : int\n    dat,  # the id of the dat to bind to the pipe : DvzId\n    offset,  # the offset : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_bind_index","title":"<code>dvz_bind_index()</code>","text":"<p>Create a request for associating an index dat to a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_bind_index(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the id of the graphics pipe\n    DvzId dat,  // the id of the dat with the index data\n    DvzSize offset,  // the offset within the dat\n);\n</code></pre> <pre><code>dvz.bind_index(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the id of the graphics pipe : DvzId\n    dat,  # the id of the dat with the index data : DvzId\n    offset,  # the offset within the dat : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_bind_tex","title":"<code>dvz_bind_tex()</code>","text":"<p>Create a request for associating a tex to a pipe's slot.</p> CPython <pre><code>DvzRequest dvz_bind_tex(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId pipe,  // the id of the pipe\n    uint32_t slot_idx,  // the index of the descriptor slot\n    DvzId tex,  // the id of the tex to bind to the pipe\n    DvzId sampler,  // the id of the sampler\n    uvec3 offset,  // the offset\n);\n</code></pre> <pre><code>dvz.bind_tex(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    pipe,  # the id of the pipe : DvzId\n    slot_idx,  # the index of the descriptor slot : int\n    tex,  # the id of the tex to bind to the pipe : DvzId\n    sampler,  # the id of the sampler : DvzId\n    offset,  # the offset : Tuple[int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_bind_vertex","title":"<code>dvz_bind_vertex()</code>","text":"<p>Create a request for associating a vertex dat to a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_bind_vertex(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the id of the graphics pipe\n    uint32_t binding_idx,  // the vertex binding index\n    DvzId dat,  // the id of the dat with the vertex data\n    DvzSize offset,  // the offset within the dat\n);\n</code></pre> <pre><code>dvz.bind_vertex(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the id of the graphics pipe : DvzId\n    binding_idx,  # the vertex binding index : int\n    dat,  # the id of the dat with the vertex data : DvzId\n    offset,  # the offset within the dat : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#create","title":"Create","text":""},{"location":"reference/api_c/#dvz_create_canvas","title":"<code>dvz_create_canvas()</code>","text":"<p>Create a request for canvas creation. A canvas is a live window on which to render. NOTE: background color not implemented yet</p> CPython <pre><code>DvzRequest dvz_create_canvas(  // returns the request, containing a newly-generated id for the canvas to be created\n    DvzBatch* batch,  // the batch\n    uint32_t width,  // the canvas width (in screen pixels)\n    uint32_t height,  // the canvas height (in screen pixels)\n    cvec4 background,  // the background color\n    int flags,  // the canvas creation flags\n);\n</code></pre> <pre><code>dvz.create_canvas(  # returns the request, containing a newly-generated id for the canvas to be created : DvzRequest\n    batch,  # the batch : DvzBatch*\n    width,  # the canvas width (in screen pixels) : int\n    height,  # the canvas height (in screen pixels) : int\n    background,  # the background color : cvec4\n    flags,  # the canvas creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_create_dat","title":"<code>dvz_create_dat()</code>","text":"<p>Create a request for a dat creation.</p> CPython <pre><code>DvzRequest dvz_create_dat(  // returns the request, containing a newly-generated id for the dat to be created\n    DvzBatch* batch,  // the batch\n    DvzBufferType type,  // the buffer type\n    DvzSize size,  // the dat size, in bytes\n    int flags,  // the dat creation flags\n);\n</code></pre> <pre><code>dvz.create_dat(  # returns the request, containing a newly-generated id for the dat to be created : DvzRequest\n    batch,  # the batch : DvzBatch*\n    type,  # the buffer type : DvzBufferType\n    size,  # the dat size, in bytes : DvzSize\n    flags,  # the dat creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_create_glsl","title":"<code>dvz_create_glsl()</code>","text":"<p>Create a request for GLSL shader creation.</p> CPython <pre><code>DvzRequest dvz_create_glsl(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzShaderType shader_type,  // the shader type\n    char* code,  // an ASCII string with the GLSL code\n);\n</code></pre> <pre><code>dvz.create_glsl(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    shader_type,  # the shader type : DvzShaderType\n    code,  # an ASCII string with the GLSL code : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_create_graphics","title":"<code>dvz_create_graphics()</code>","text":"<p>Create a request for a builtin graphics pipe creation.</p> CPython <pre><code>DvzRequest dvz_create_graphics(  // returns the request, containing a newly-generated id for the graphics pipe to be created\n    DvzBatch* batch,  // the batch\n    DvzGraphicsType type,  // the graphics type\n    int flags,  // the graphics creation flags\n);\n</code></pre> <pre><code>dvz.create_graphics(  # returns the request, containing a newly-generated id for the graphics pipe to be created : DvzRequest\n    batch,  # the batch : DvzBatch*\n    type,  # the graphics type : DvzGraphicsType\n    flags,  # the graphics creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_create_sampler","title":"<code>dvz_create_sampler()</code>","text":"<p>Create a request for a sampler creation.</p> CPython <pre><code>DvzRequest dvz_create_sampler(  // returns the request, containing a newly-generated id for the sampler to be created\n    DvzBatch* batch,  // the batch\n    DvzFilter filter,  // the sampler filter\n    DvzSamplerAddressMode mode,  // the sampler address mode\n);\n</code></pre> <pre><code>dvz.create_sampler(  # returns the request, containing a newly-generated id for the sampler to be created : DvzRequest\n    batch,  # the batch : DvzBatch*\n    filter,  # the sampler filter : DvzFilter\n    mode,  # the sampler address mode : DvzSamplerAddressMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_create_spirv","title":"<code>dvz_create_spirv()</code>","text":"<p>Create a request for SPIR-V shader creation.</p> CPython <pre><code>DvzRequest dvz_create_spirv(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzShaderType shader_type,  // the shader type\n    DvzSize size,  // the size in bytes of the SPIR-V buffer\n    char* buffer,  // pointer to a buffer with the SPIR-V bytecode\n);\n</code></pre> <pre><code>dvz.create_spirv(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    shader_type,  # the shader type : DvzShaderType\n    size,  # the size in bytes of the SPIR-V buffer : DvzSize\n    buffer,  # pointer to a buffer with the SPIR-V bytecode : str\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_create_tex","title":"<code>dvz_create_tex()</code>","text":"<p>Create a request for a tex creation.</p> CPython <pre><code>DvzRequest dvz_create_tex(  // returns the request, containing a newly-generated id for the tex to be created\n    DvzBatch* batch,  // the batch\n    DvzTexDims dims,  // the number of dimensions, 1, 2, or 3\n    DvzFormat format,  // the image format\n    uvec3 shape,  // the texture shape\n    int flags,  // the dat creation flags\n);\n</code></pre> <pre><code>dvz.create_tex(  # returns the request, containing a newly-generated id for the tex to be created : DvzRequest\n    batch,  # the batch : DvzBatch*\n    dims,  # the number of dimensions, 1, 2, or 3 : DvzTexDims\n    format,  # the image format : DvzFormat\n    shape,  # the texture shape : Tuple[int, int, int]\n    flags,  # the dat creation flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#delete","title":"Delete","text":""},{"location":"reference/api_c/#dvz_delete_canvas","title":"<code>dvz_delete_canvas()</code>","text":"<p>Create a request for a canvas deletion.</p> CPython <pre><code>DvzRequest dvz_delete_canvas(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the canvas id\n);\n</code></pre> <pre><code>dvz.delete_canvas(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the canvas id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_delete_dat","title":"<code>dvz_delete_dat()</code>","text":"<p>Create a request for dat deletion.</p> CPython <pre><code>DvzRequest dvz_delete_dat(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the dat id\n);\n</code></pre> <pre><code>dvz.delete_dat(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the dat id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_delete_graphics","title":"<code>dvz_delete_graphics()</code>","text":"<p>Create a request for graphics deletion.</p> CPython <pre><code>DvzRequest dvz_delete_graphics(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the graphics id\n);\n</code></pre> <pre><code>dvz.delete_graphics(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the graphics id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_delete_sampler","title":"<code>dvz_delete_sampler()</code>","text":"<p>Create a request for sampler deletion.</p> CPython <pre><code>DvzRequest dvz_delete_sampler(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the sampler id\n);\n</code></pre> <pre><code>dvz.delete_sampler(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the sampler id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_delete_tex","title":"<code>dvz_delete_tex()</code>","text":"<p>Create a request for tex deletion.</p> CPython <pre><code>DvzRequest dvz_delete_tex(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the tex id\n);\n</code></pre> <pre><code>dvz.delete_tex(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the tex id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#misc_2","title":"Misc","text":""},{"location":"reference/api_c/#dvz_batch","title":"<code>dvz_batch()</code>","text":"<p>Create a batch holding a number of requests.</p> CPython <pre><code>DvzBatch* dvz_batch(\n);\n</code></pre> <pre><code>dvz.batch(\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_mvp","title":"<code>dvz_mvp()</code>","text":"<p>Create a MVP structure.</p> CPython <pre><code>void dvz_mvp(\n    mat4 model,  // the model matrix\n    mat4 view,  // the view matrix\n    mat4 proj,  // the projection matrix\n    DvzMVP* mvp,  // the MVP structure\n);\n</code></pre> <pre><code>dvz.mvp(\n    model,  # the model matrix : mat4\n    view,  # the view matrix : mat4\n    proj,  # the projection matrix : mat4\n    mvp,  # the MVP structure : Out[DvzMVP]\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_requester","title":"<code>dvz_requester()</code>","text":"<p>Create a requester, used to create requests.</p> CPython <pre><code>DvzRequester* dvz_requester(  // returns the requester struct\n);\n</code></pre> <pre><code>dvz.requester(  # returns the requester struct : DvzRequester*\n)\n</code></pre>"},{"location":"reference/api_c/#mvp","title":"Mvp","text":""},{"location":"reference/api_c/#dvz_mvp_default","title":"<code>dvz_mvp_default()</code>","text":"<p>Return a default DvzMVP struct</p> CPython <pre><code>void dvz_mvp_default(\n    DvzMVP* mvp,  // the DvzMVP struct\n);\n</code></pre> <pre><code>dvz.mvp_default(\n    mvp,  # the DvzMVP struct : Out[DvzMVP]\n)\n</code></pre>"},{"location":"reference/api_c/#record","title":"Record","text":""},{"location":"reference/api_c/#dvz_record_begin","title":"<code>dvz_record_begin()</code>","text":"<p>Create a request for starting recording of command buffer.</p> CPython <pre><code>DvzRequest dvz_record_begin(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n);\n</code></pre> <pre><code>dvz.record_begin(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_draw","title":"<code>dvz_record_draw()</code>","text":"<p>Create a request for a direct draw of a graphics during command buffer recording.</p> CPython <pre><code>DvzRequest dvz_record_draw(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n    DvzId graphics,  // the id of the graphics pipe to draw\n    uint32_t first_vertex,  // the index of the first vertex to draw\n    uint32_t vertex_count,  // the number of vertices to draw\n    uint32_t first_instance,  // the index of the first instance to draw\n    uint32_t instance_count,  // the number of instances to draw\n);\n</code></pre> <pre><code>dvz.record_draw(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n    graphics,  # the id of the graphics pipe to draw : DvzId\n    first_vertex,  # the index of the first vertex to draw : int\n    vertex_count,  # the number of vertices to draw : int\n    first_instance,  # the index of the first instance to draw : int\n    instance_count,  # the number of instances to draw : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_draw_indexed","title":"<code>dvz_record_draw_indexed()</code>","text":"<p>Create a request for an indexed draw of a graphics during command buffer recording.</p> CPython <pre><code>DvzRequest dvz_record_draw_indexed(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n    DvzId graphics,  // the id of the graphics pipe to draw\n    uint32_t first_index,  // the index of the first index to draw\n    uint32_t vertex_offset,  // the vertex offset within the vertices indexed by the indexes\n    uint32_t index_count,  // the number of indexes to draw\n    uint32_t first_instance,  // the index of the first instance to draw\n    uint32_t instance_count,  // the number of instances to draw\n);\n</code></pre> <pre><code>dvz.record_draw_indexed(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n    graphics,  # the id of the graphics pipe to draw : DvzId\n    first_index,  # the index of the first index to draw : int\n    vertex_offset,  # the vertex offset within the vertices indexed by the indexes : int\n    index_count,  # the number of indexes to draw : int\n    first_instance,  # the index of the first instance to draw : int\n    instance_count,  # the number of instances to draw : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_draw_indexed_indirect","title":"<code>dvz_record_draw_indexed_indirect()</code>","text":"<p>Create a request for an indexed indirect draw of a graphics during command buffer recording.</p> CPython <pre><code>DvzRequest dvz_record_draw_indexed_indirect(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n    DvzId graphics,  // the id of the graphics pipe to draw\n    DvzId indirect,  // the id of the dat containing the indirect draw data\n    uint32_t draw_count,  // the number of draws to make\n);\n</code></pre> <pre><code>dvz.record_draw_indexed_indirect(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n    graphics,  # the id of the graphics pipe to draw : DvzId\n    indirect,  # the id of the dat containing the indirect draw data : DvzId\n    draw_count,  # the number of draws to make : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_draw_indirect","title":"<code>dvz_record_draw_indirect()</code>","text":"<p>Create a request for an indirect draw of a graphics during command buffer recording.</p> CPython <pre><code>DvzRequest dvz_record_draw_indirect(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n    DvzId graphics,  // the id of the graphics pipe to draw\n    DvzId indirect,  // the id of the dat containing the indirect draw data\n    uint32_t draw_count,  // the number of draws to make\n);\n</code></pre> <pre><code>dvz.record_draw_indirect(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n    graphics,  # the id of the graphics pipe to draw : DvzId\n    indirect,  # the id of the dat containing the indirect draw data : DvzId\n    draw_count,  # the number of draws to make : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_end","title":"<code>dvz_record_end()</code>","text":"<p>Create a request for ending recording of command buffer.</p> CPython <pre><code>DvzRequest dvz_record_end(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n);\n</code></pre> <pre><code>dvz.record_end(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_push","title":"<code>dvz_record_push()</code>","text":"<p>Create a request for sending a push constant value while recording a command buffer.</p> CPython <pre><code>DvzRequest dvz_record_push(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n    DvzId graphics_id,  // the id of the graphics pipeline\n    DvzShaderStageFlags shader_stages,  // the shader stages\n    DvzSize offset,  // the byte offset\n    DvzSize size,  // the size of the data to upload\n    void* data,  // the push constant data to upload\n);\n</code></pre> <pre><code>dvz.record_push(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n    graphics_id,  # the id of the graphics pipeline : DvzId\n    shader_stages,  # the shader stages : DvzShaderStageFlags\n    offset,  # the byte offset : DvzSize\n    size,  # the size of the data to upload : DvzSize\n    data,  # the push constant data to upload : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_record_viewport","title":"<code>dvz_record_viewport()</code>","text":"<p>Create a request for setting the viewport during command buffer recording.</p> CPython <pre><code>DvzRequest dvz_record_viewport(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_id,  // the id of the canvas\n    vec2 offset,  // the viewport offset, in framebuffer pixels\n    vec2 shape,  // the viewport size, in framebuffer pixels\n);\n</code></pre> <pre><code>dvz.record_viewport(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas_id,  # the id of the canvas : DvzId\n    offset,  # the viewport offset, in framebuffer pixels : Tuple[float, float]\n    shape,  # the viewport size, in framebuffer pixels : Tuple[float, float]\n)\n</code></pre>"},{"location":"reference/api_c/#request","title":"Request","text":""},{"location":"reference/api_c/#dvz_request_print","title":"<code>dvz_request_print()</code>","text":"<p>Display information about a request.</p> CPython <pre><code>void dvz_request_print(\n    DvzRequest* req,  // the request\n    int flags,  // the flags\n);\n</code></pre> <pre><code>dvz.request_print(\n    req,  # the request : DvzRequest*\n    flags,  # the flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#requester","title":"Requester","text":""},{"location":"reference/api_c/#dvz_requester_commit","title":"<code>dvz_requester_commit()</code>","text":"<p>Add a batch's requests to a requester.</p> CPython <pre><code>void dvz_requester_commit(\n    DvzRequester* rqr,  // the requester\n    DvzBatch* batch,  // the batch\n);\n</code></pre> <pre><code>dvz.requester_commit(\n    rqr,  # the requester : DvzRequester*\n    batch,  # the batch : DvzBatch*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_requester_destroy","title":"<code>dvz_requester_destroy()</code>","text":"<p>Destroy a requester.</p> CPython <pre><code>void dvz_requester_destroy(\n    DvzRequester* rqr,  // the requester\n);\n</code></pre> <pre><code>dvz.requester_destroy(\n    rqr,  # the requester : DvzRequester*\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_requester_flush","title":"<code>dvz_requester_flush()</code>","text":"<p>Return the requests in the requester and clear it. NOTE: the caller must free the output.</p> CPython <pre><code>DvzBatch* dvz_requester_flush(  // returns an array with all requests in the requester\n    DvzRequester* rqr,  // the requester\n    uint32_t* count,  // pointer to the number of requests, set by this function\n);\n</code></pre> <pre><code>dvz.requester_flush(  # returns an array with all requests in the requester : DvzBatch*\n    rqr,  # the requester : DvzRequester*\n    count,  # pointer to the number of requests, set by this function : Out[int]\n)\n</code></pre>"},{"location":"reference/api_c/#resize","title":"Resize","text":""},{"location":"reference/api_c/#dvz_resize_canvas","title":"<code>dvz_resize_canvas()</code>","text":"<p>Create a request to resize an offscreen canvas (regular canvases are resized by the client).</p> CPython <pre><code>DvzRequest dvz_resize_canvas(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas,  // the canvas id\n    uint32_t width,  // the new canvas width\n    uint32_t height,  // the new canvas height\n);\n</code></pre> <pre><code>dvz.resize_canvas(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    canvas,  # the canvas id : DvzId\n    width,  # the new canvas width : int\n    height,  # the new canvas height : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_resize_dat","title":"<code>dvz_resize_dat()</code>","text":"<p>Create a request to resize a dat.</p> CPython <pre><code>DvzRequest dvz_resize_dat(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId dat,  // the dat id\n    DvzSize size,  // the new dat size, in bytes\n);\n</code></pre> <pre><code>dvz.resize_dat(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    dat,  # the dat id : DvzId\n    size,  # the new dat size, in bytes : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_resize_tex","title":"<code>dvz_resize_tex()</code>","text":"<p>Create a request to resize a tex.</p> CPython <pre><code>DvzRequest dvz_resize_tex(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId tex,  // the tex id\n    uvec3 shape,  // the new tex shape\n);\n</code></pre> <pre><code>dvz.resize_tex(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    tex,  # the tex id : DvzId\n    shape,  # the new tex shape : Tuple[int, int, int]\n)\n</code></pre>"},{"location":"reference/api_c/#set","title":"Set","text":""},{"location":"reference/api_c/#dvz_set_attr","title":"<code>dvz_set_attr()</code>","text":"<p>Create a request for setting a vertex attribute of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_attr(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    uint32_t binding_idx,  // the index of the vertex binding\n    uint32_t location,  // the GLSL attribute location\n    DvzFormat format,  // the attribute format\n    DvzSize offset,  // the byte offset of the attribute within the vertex binding\n);\n</code></pre> <pre><code>dvz.set_attr(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    binding_idx,  # the index of the vertex binding : int\n    location,  # the GLSL attribute location : int\n    format,  # the attribute format : DvzFormat\n    offset,  # the byte offset of the attribute within the vertex binding : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_background","title":"<code>dvz_set_background()</code>","text":"<p>Change the background color of the canvas.</p> CPython <pre><code>DvzRequest dvz_set_background(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the canvas id\n    cvec4 background,  // the background color\n);\n</code></pre> <pre><code>dvz.set_background(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the canvas id : DvzId\n    background,  # the background color : cvec4\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_blend","title":"<code>dvz_set_blend()</code>","text":"<p>Create a request for setting the blend type of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_blend(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzBlendType blend_type,  // the graphics blend type\n);\n</code></pre> <pre><code>dvz.set_blend(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    blend_type,  # the graphics blend type : DvzBlendType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_cull","title":"<code>dvz_set_cull()</code>","text":"<p>Create a request for setting the cull mode of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_cull(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzCullMode cull_mode,  // the cull mode\n);\n</code></pre> <pre><code>dvz.set_cull(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    cull_mode,  # the cull mode : DvzCullMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_depth","title":"<code>dvz_set_depth()</code>","text":"<p>Create a request for setting the depth test of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_depth(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzDepthTest depth_test,  // the graphics depth test\n);\n</code></pre> <pre><code>dvz.set_depth(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    depth_test,  # the graphics depth test : DvzDepthTest\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_front","title":"<code>dvz_set_front()</code>","text":"<p>Create a request for setting the front face of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_front(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzFrontFace front_face,  // the front face\n);\n</code></pre> <pre><code>dvz.set_front(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    front_face,  # the front face : DvzFrontFace\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_mask","title":"<code>dvz_set_mask()</code>","text":"<p>Create a request for setting the color mask of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_mask(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    int32_t mask,  // the mask with RGBA boolean masks on the lower bits\n);\n</code></pre> <pre><code>dvz.set_mask(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    mask,  # the mask with RGBA boolean masks on the lower bits : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_polygon","title":"<code>dvz_set_polygon()</code>","text":"<p>Create a request for setting the polygon mode of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_polygon(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzPolygonMode polygon_mode,  // the polygon mode\n);\n</code></pre> <pre><code>dvz.set_polygon(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    polygon_mode,  # the polygon mode : DvzPolygonMode\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_primitive","title":"<code>dvz_set_primitive()</code>","text":"<p>Create a request for setting the primitive topology of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_primitive(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzPrimitiveTopology primitive,  // the graphics primitive topology\n);\n</code></pre> <pre><code>dvz.set_primitive(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    primitive,  # the graphics primitive topology : DvzPrimitiveTopology\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_push","title":"<code>dvz_set_push()</code>","text":"<p>Create a request for setting a push constant layout for a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_push(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzShaderStageFlags shader_stages,  // the shader stages with the push constant\n    DvzSize offset,  // the byte offset for the push data visibility from the shader\n    DvzSize size,  // how much bytes the shader can see from the push constant\n);\n</code></pre> <pre><code>dvz.set_push(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    shader_stages,  # the shader stages with the push constant : DvzShaderStageFlags\n    offset,  # the byte offset for the push data visibility from the shader : DvzSize\n    size,  # how much bytes the shader can see from the push constant : DvzSize\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_shader","title":"<code>dvz_set_shader()</code>","text":"<p>Create a request for setting a shader a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_shader(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzId shader,  // the id of the shader object\n);\n</code></pre> <pre><code>dvz.set_shader(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    shader,  # the id of the shader object : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_slot","title":"<code>dvz_set_slot()</code>","text":"<p>Create a request for setting a binding slot (descriptor) of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_slot(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    uint32_t slot_idx,  // the index of the GLSL binding slot\n    DvzDescriptorType type,  // the descriptor type\n);\n</code></pre> <pre><code>dvz.set_slot(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    slot_idx,  # the index of the GLSL binding slot : int\n    type,  # the descriptor type : DvzDescriptorType\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_specialization","title":"<code>dvz_set_specialization()</code>","text":"<p>Create a request for setting a specialization constant of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_specialization(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzShaderType shader,  // the shader with the specialization constant\n    uint32_t idx,  // the specialization constant index as specified in the GLSL code\n    DvzSize size,  // the byte size of the value\n    void* value,  // a pointer to the specialization constant value\n);\n</code></pre> <pre><code>dvz.set_specialization(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    shader,  # the shader with the specialization constant : DvzShaderType\n    idx,  # the specialization constant index as specified in the GLSL code : int\n    size,  # the byte size of the value : DvzSize\n    value,  # a pointer to the specialization constant value : np.ndarray\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_set_vertex","title":"<code>dvz_set_vertex()</code>","text":"<p>Create a request for setting a vertex binding of a graphics pipe.</p> CPython <pre><code>DvzRequest dvz_set_vertex(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    uint32_t binding_idx,  // the index of the vertex binding\n    DvzSize stride,  // the binding stride\n    DvzVertexInputRate input_rate,  // the vertex input rate, per-vertex or per-instance\n);\n</code></pre> <pre><code>dvz.set_vertex(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    graphics,  # the graphics pipe id : DvzId\n    binding_idx,  # the index of the vertex binding : int\n    stride,  # the binding stride : DvzSize\n    input_rate,  # the vertex input rate, per-vertex or per-instance : DvzVertexInputRate\n)\n</code></pre>"},{"location":"reference/api_c/#update","title":"Update","text":""},{"location":"reference/api_c/#dvz_update_canvas","title":"<code>dvz_update_canvas()</code>","text":"<p>Create a request for a canvas redraw (command buffer submission).</p> CPython <pre><code>DvzRequest dvz_update_canvas(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the canvas id\n);\n</code></pre> <pre><code>dvz.update_canvas(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    id,  # the canvas id : DvzId\n)\n</code></pre>"},{"location":"reference/api_c/#upload","title":"Upload","text":""},{"location":"reference/api_c/#dvz_upload_dat","title":"<code>dvz_upload_dat()</code>","text":"<p>Create a request for dat upload. NOTE: this function makes a COPY of the buffer to ensure it will live until the upload actually occurs. The copy will be freed automatically as soon as it's safe.</p> CPython <pre><code>DvzRequest dvz_upload_dat(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId dat,  // the id of the dat to upload to\n    DvzSize offset,  // the byte offset of the upload transfer\n    DvzSize size,  // the number of bytes in data to transfer\n    void* data,  // a pointer to the data to upload\n    int flags,  // the upload flags\n);\n</code></pre> <pre><code>dvz.upload_dat(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    dat,  # the id of the dat to upload to : DvzId\n    offset,  # the byte offset of the upload transfer : DvzSize\n    size,  # the number of bytes in data to transfer : DvzSize\n    data,  # a pointer to the data to upload : np.ndarray\n    flags,  # the upload flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#dvz_upload_tex","title":"<code>dvz_upload_tex()</code>","text":"<p>Create a request for tex upload. NOTE: this function makes a COPY of the buffer to ensure it will live until the upload actually occurs. The copy will be freed automatically as soon as it's safe.</p> CPython <pre><code>DvzRequest dvz_upload_tex(  // returns the request\n    DvzBatch* batch,  // the batch\n    DvzId tex,  // the id of the tex to upload to\n    uvec3 offset,  // the offset\n    uvec3 shape,  // the shape\n    DvzSize size,  // the number of bytes in data to transfer\n    void* data,  // a pointer to the data to upload\n    int flags,  // the upload flags\n);\n</code></pre> <pre><code>dvz.upload_tex(  # returns the request : DvzRequest\n    batch,  # the batch : DvzBatch*\n    tex,  # the id of the tex to upload to : DvzId\n    offset,  # the offset : Tuple[int, int, int]\n    shape,  # the shape : Tuple[int, int, int]\n    size,  # the number of bytes in data to transfer : DvzSize\n    data,  # a pointer to the data to upload : np.ndarray\n    flags,  # the upload flags : int\n)\n</code></pre>"},{"location":"reference/api_c/#viewport","title":"Viewport","text":""},{"location":"reference/api_c/#dvz_viewport_default","title":"<code>dvz_viewport_default()</code>","text":"<p>Return a default viewport</p> CPython <pre><code>void dvz_viewport_default(\n    uint32_t width,  // the viewport width, in framebuffer pixels\n    uint32_t height,  // the viewport height, in framebuffer pixels\n    DvzViewport* viewport,  // the viewport\n);\n</code></pre> <pre><code>dvz.viewport_default(\n    width,  # the viewport width, in framebuffer pixels : int\n    height,  # the viewport height, in framebuffer pixels : int\n    viewport,  # the viewport : Out[DvzViewport]\n)\n</code></pre>"},{"location":"reference/api_c/#enumerations","title":"Enumerations","text":""},{"location":"reference/api_c/#dvzalign","title":"<code>DvzAlign</code>","text":"<pre><code>DVZ_ALIGN_NONE = 0\nDVZ_ALIGN_LOW = 1\nDVZ_ALIGN_MIDDLE = 2\nDVZ_ALIGN_HIGH = 3\n</code></pre>"},{"location":"reference/api_c/#dvzappflags","title":"<code>DvzAppFlags</code>","text":"<pre><code>DVZ_APP_FLAGS_NONE = 0x000000\nDVZ_APP_FLAGS_OFFSCREEN = 0x008000\nDVZ_APP_FLAGS_WHITE_BACKGROUND = 0x100000\n</code></pre>"},{"location":"reference/api_c/#dvzarcballflags","title":"<code>DvzArcballFlags</code>","text":"<pre><code>DVZ_ARCBALL_FLAGS_NONE = 0\nDVZ_ARCBALL_FLAGS_CONSTRAIN = 1\n</code></pre>"},{"location":"reference/api_c/#dvzaxisflags","title":"<code>DvzAxisFlags</code>","text":"<pre><code>DVZ_AXIS_FLAGS_NONE = 0x00\nDVZ_AXIS_FLAGS_DARK = 0x01\n</code></pre>"},{"location":"reference/api_c/#dvzblendtype","title":"<code>DvzBlendType</code>","text":"<pre><code>DVZ_BLEND_DISABLE = 0\nDVZ_BLEND_STANDARD = 1\nDVZ_BLEND_DESTINATION = 2\nDVZ_BLEND_OIT = 3\n</code></pre>"},{"location":"reference/api_c/#dvzboxextentstrategy","title":"<code>DvzBoxExtentStrategy</code>","text":"<pre><code>DVZ_BOX_EXTENT_DEFAULT = 0\nDVZ_BOX_EXTENT_FIXED_ASPECT_EXPAND = 1\nDVZ_BOX_EXTENT_FIXED_ASPECT_CONTRACT = 2\n</code></pre>"},{"location":"reference/api_c/#dvzboxmergestrategy","title":"<code>DvzBoxMergeStrategy</code>","text":"<pre><code>DVZ_BOX_MERGE_DEFAULT = 0\nDVZ_BOX_MERGE_CENTER = 1\nDVZ_BOX_MERGE_CORNER = 2\n</code></pre>"},{"location":"reference/api_c/#dvzbuffertype","title":"<code>DvzBufferType</code>","text":"<pre><code>DVZ_BUFFER_TYPE_UNDEFINED = 0\nDVZ_BUFFER_TYPE_STAGING = 1\nDVZ_BUFFER_TYPE_VERTEX = 2\nDVZ_BUFFER_TYPE_INDEX = 3\nDVZ_BUFFER_TYPE_STORAGE = 4\nDVZ_BUFFER_TYPE_UNIFORM = 5\nDVZ_BUFFER_TYPE_INDIRECT = 6\n</code></pre>"},{"location":"reference/api_c/#dvzcameraflags","title":"<code>DvzCameraFlags</code>","text":"<pre><code>DVZ_CAMERA_FLAGS_PERSPECTIVE = 0x00\nDVZ_CAMERA_FLAGS_ORTHO = 0x01\n</code></pre>"},{"location":"reference/api_c/#dvzcanvasflags","title":"<code>DvzCanvasFlags</code>","text":"<pre><code>DVZ_CANVAS_FLAGS_NONE = 0x0000\nDVZ_CANVAS_FLAGS_IMGUI = 0x0001\nDVZ_CANVAS_FLAGS_FPS = 0x0003\nDVZ_CANVAS_FLAGS_MONITOR = 0x0005\nDVZ_CANVAS_FLAGS_FULLSCREEN = 0x0008\nDVZ_CANVAS_FLAGS_VSYNC = 0x0010\nDVZ_CANVAS_FLAGS_PICK = 0x0020\nDVZ_CANVAS_FLAGS_PUSH_SCALE = 0x0040\n</code></pre>"},{"location":"reference/api_c/#dvzcaptype","title":"<code>DvzCapType</code>","text":"<pre><code>DVZ_CAP_NONE = 0\nDVZ_CAP_ROUND = 1\nDVZ_CAP_TRIANGLE_IN = 2\nDVZ_CAP_TRIANGLE_OUT = 3\nDVZ_CAP_SQUARE = 4\nDVZ_CAP_BUTT = 5\nDVZ_CAP_COUNT = 6\n</code></pre>"},{"location":"reference/api_c/#dvzcolormask","title":"<code>DvzColorMask</code>","text":"<pre><code>DVZ_MASK_COLOR_R = 0x00000001\nDVZ_MASK_COLOR_G = 0x00000002\nDVZ_MASK_COLOR_B = 0x00000004\nDVZ_MASK_COLOR_A = 0x00000008\nDVZ_MASK_COLOR_ALL = 0x0000000F\n</code></pre>"},{"location":"reference/api_c/#dvzcolormap","title":"<code>DvzColormap</code>","text":"<pre><code>DVZ_CMAP_BINARY = 0\nDVZ_CMAP_HSV = 1\nDVZ_CMAP_CIVIDIS = 2\nDVZ_CMAP_INFERNO = 3\nDVZ_CMAP_MAGMA = 4\nDVZ_CMAP_PLASMA = 5\nDVZ_CMAP_VIRIDIS = 6\nDVZ_CMAP_BLUES = 7\nDVZ_CMAP_BUGN = 8\nDVZ_CMAP_BUPU = 9\nDVZ_CMAP_GNBU = 10\nDVZ_CMAP_GREENS = 11\nDVZ_CMAP_GREYS = 12\nDVZ_CMAP_ORANGES = 13\nDVZ_CMAP_ORRD = 14\nDVZ_CMAP_PUBU = 15\nDVZ_CMAP_PUBUGN = 16\nDVZ_CMAP_PURPLES = 17\nDVZ_CMAP_RDPU = 18\nDVZ_CMAP_REDS = 19\nDVZ_CMAP_YLGN = 20\nDVZ_CMAP_YLGNBU = 21\nDVZ_CMAP_YLORBR = 22\nDVZ_CMAP_YLORRD = 23\nDVZ_CMAP_AFMHOT = 24\nDVZ_CMAP_AUTUMN = 25\nDVZ_CMAP_BONE = 26\nDVZ_CMAP_COOL = 27\nDVZ_CMAP_COPPER = 28\nDVZ_CMAP_GIST_HEAT = 29\nDVZ_CMAP_GRAY = 30\nDVZ_CMAP_HOT = 31\nDVZ_CMAP_PINK = 32\nDVZ_CMAP_SPRING = 33\nDVZ_CMAP_SUMMER = 34\nDVZ_CMAP_WINTER = 35\nDVZ_CMAP_WISTIA = 36\nDVZ_CMAP_BRBG = 37\nDVZ_CMAP_BWR = 38\nDVZ_CMAP_COOLWARM = 39\nDVZ_CMAP_PIYG = 40\nDVZ_CMAP_PRGN = 41\nDVZ_CMAP_PUOR = 42\nDVZ_CMAP_RDBU = 43\nDVZ_CMAP_RDGY = 44\nDVZ_CMAP_RDYLBU = 45\nDVZ_CMAP_RDYLGN = 46\nDVZ_CMAP_SEISMIC = 47\nDVZ_CMAP_SPECTRAL = 48\nDVZ_CMAP_TWILIGHT_SHIFTED = 49\nDVZ_CMAP_TWILIGHT = 50\nDVZ_CMAP_BRG = 51\nDVZ_CMAP_CMRMAP = 52\nDVZ_CMAP_CUBEHELIX = 53\nDVZ_CMAP_FLAG = 54\nDVZ_CMAP_GIST_EARTH = 55\nDVZ_CMAP_GIST_NCAR = 56\nDVZ_CMAP_GIST_RAINBOW = 57\nDVZ_CMAP_GIST_STERN = 58\nDVZ_CMAP_GNUPLOT2 = 59\nDVZ_CMAP_GNUPLOT = 60\nDVZ_CMAP_JET = 61\nDVZ_CMAP_NIPY_SPECTRAL = 62\nDVZ_CMAP_OCEAN = 63\nDVZ_CMAP_PRISM = 64\nDVZ_CMAP_RAINBOW = 65\nDVZ_CMAP_TERRAIN = 66\nDVZ_CMAP_BKR = 67\nDVZ_CMAP_BKY = 68\nDVZ_CMAP_CET_D10 = 69\nDVZ_CMAP_CET_D11 = 70\nDVZ_CMAP_CET_D8 = 71\nDVZ_CMAP_CET_D13 = 72\nDVZ_CMAP_CET_D3 = 73\nDVZ_CMAP_CET_D1A = 74\nDVZ_CMAP_BJY = 75\nDVZ_CMAP_GWV = 76\nDVZ_CMAP_BWY = 77\nDVZ_CMAP_CET_D12 = 78\nDVZ_CMAP_CET_R3 = 79\nDVZ_CMAP_CET_D9 = 80\nDVZ_CMAP_CWR = 81\nDVZ_CMAP_CET_CBC1 = 82\nDVZ_CMAP_CET_CBC2 = 83\nDVZ_CMAP_CET_CBL1 = 84\nDVZ_CMAP_CET_CBL2 = 85\nDVZ_CMAP_CET_CBTC1 = 86\nDVZ_CMAP_CET_CBTC2 = 87\nDVZ_CMAP_CET_CBTL1 = 88\nDVZ_CMAP_BGY = 89\nDVZ_CMAP_BGYW = 90\nDVZ_CMAP_BMW = 91\nDVZ_CMAP_CET_C1 = 92\nDVZ_CMAP_CET_C1S = 93\nDVZ_CMAP_CET_C2 = 94\nDVZ_CMAP_CET_C4 = 95\nDVZ_CMAP_CET_C4S = 96\nDVZ_CMAP_CET_C5 = 97\nDVZ_CMAP_CET_I1 = 98\nDVZ_CMAP_CET_I3 = 99\nDVZ_CMAP_CET_L10 = 100\nDVZ_CMAP_CET_L11 = 101\nDVZ_CMAP_CET_L12 = 102\nDVZ_CMAP_CET_L16 = 103\nDVZ_CMAP_CET_L17 = 104\nDVZ_CMAP_CET_L18 = 105\nDVZ_CMAP_CET_L19 = 106\nDVZ_CMAP_CET_L4 = 107\nDVZ_CMAP_CET_L7 = 108\nDVZ_CMAP_CET_L8 = 109\nDVZ_CMAP_CET_L9 = 110\nDVZ_CMAP_CET_R1 = 111\nDVZ_CMAP_CET_R2 = 112\nDVZ_CMAP_COLORWHEEL = 113\nDVZ_CMAP_FIRE = 114\nDVZ_CMAP_ISOLUM = 115\nDVZ_CMAP_KB = 116\nDVZ_CMAP_KBC = 117\nDVZ_CMAP_KG = 118\nDVZ_CMAP_KGY = 119\nDVZ_CMAP_KR = 120\nDVZ_CMAP_BLACK_BODY = 121\nDVZ_CMAP_KINDLMANN = 122\nDVZ_CMAP_EXTENDED_KINDLMANN = 123\nDVZ_CPAL256_GLASBEY = CPAL256_OFS\nDVZ_CPAL256_GLASBEY_COOL = 125\nDVZ_CPAL256_GLASBEY_DARK = 126\nDVZ_CPAL256_GLASBEY_HV = 127\nDVZ_CPAL256_GLASBEY_LIGHT = 128\nDVZ_CPAL256_GLASBEY_WARM = 129\nDVZ_CPAL032_ACCENT = CPAL032_OFS\nDVZ_CPAL032_DARK2 = 131\nDVZ_CPAL032_PAIRED = 132\nDVZ_CPAL032_PASTEL1 = 133\nDVZ_CPAL032_PASTEL2 = 134\nDVZ_CPAL032_SET1 = 135\nDVZ_CPAL032_SET2 = 136\nDVZ_CPAL032_SET3 = 137\nDVZ_CPAL032_TAB10 = 138\nDVZ_CPAL032_TAB20 = 139\nDVZ_CPAL032_TAB20B = 140\nDVZ_CPAL032_TAB20C = 141\nDVZ_CPAL032_CATEGORY10_10 = 142\nDVZ_CPAL032_CATEGORY20_20 = 143\nDVZ_CPAL032_CATEGORY20B_20 = 144\nDVZ_CPAL032_CATEGORY20C_20 = 145\nDVZ_CPAL032_COLORBLIND8 = 146\n</code></pre>"},{"location":"reference/api_c/#dvzcontourflags","title":"<code>DvzContourFlags</code>","text":"<pre><code>DVZ_CONTOUR_NONE = 0x00\nDVZ_CONTOUR_EDGES = 0x01\nDVZ_CONTOUR_JOINTS = 0x02\nDVZ_CONTOUR_FULL = 0x04\n</code></pre>"},{"location":"reference/api_c/#dvzcorner","title":"<code>DvzCorner</code>","text":"<pre><code>DVZ_DIALOG_CORNER_TOP_LEFT = 0\nDVZ_DIALOG_CORNER_TOP_RIGHT = 1\nDVZ_DIALOG_CORNER_BOTTOM_LEFT = 2\nDVZ_DIALOG_CORNER_BOTTOM_RIGHT = 3\n</code></pre>"},{"location":"reference/api_c/#dvzcullmode","title":"<code>DvzCullMode</code>","text":"<pre><code>DVZ_CULL_MODE_NONE = 0\nDVZ_CULL_MODE_FRONT = 0x00000001\nDVZ_CULL_MODE_BACK = 0x00000002\n</code></pre>"},{"location":"reference/api_c/#dvzdatflags","title":"<code>DvzDatFlags</code>","text":"<pre><code>DVZ_DAT_FLAGS_NONE = 0x0000\nDVZ_DAT_FLAGS_STANDALONE = 0x0100\nDVZ_DAT_FLAGS_MAPPABLE = 0x0200\nDVZ_DAT_FLAGS_DUP = 0x0400\nDVZ_DAT_FLAGS_KEEP_ON_RESIZE = 0x1000\nDVZ_DAT_FLAGS_PERSISTENT_STAGING = 0x2000\n</code></pre>"},{"location":"reference/api_c/#dvzdepthtest","title":"<code>DvzDepthTest</code>","text":"<pre><code>DVZ_DEPTH_TEST_DISABLE = 0\nDVZ_DEPTH_TEST_ENABLE = 1\n</code></pre>"},{"location":"reference/api_c/#dvzdescriptortype","title":"<code>DvzDescriptorType</code>","text":"<pre><code>DVZ_DESCRIPTOR_TYPE_SAMPLER = 0\nDVZ_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1\nDVZ_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2\nDVZ_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3\nDVZ_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4\nDVZ_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5\nDVZ_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6\nDVZ_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7\nDVZ_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8\nDVZ_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9\n</code></pre>"},{"location":"reference/api_c/#dvzdialogflags","title":"<code>DvzDialogFlags</code>","text":"<pre><code>DVZ_DIALOG_FLAGS_NONE = 0x0000\nDVZ_DIALOG_FLAGS_OVERLAY = 0x0001\nDVZ_DIALOG_FLAGS_BLANK = 0x0004\nDVZ_DIALOG_FLAGS_PANEL = 0x0008\n</code></pre>"},{"location":"reference/api_c/#dvzdim","title":"<code>DvzDim</code>","text":"<pre><code>DVZ_DIM_X = 0x0000\nDVZ_DIM_Y = 0x0001\nDVZ_DIM_Z = 0x0002\nDVZ_DIM_COUNT = 3\n</code></pre>"},{"location":"reference/api_c/#dvzeasing","title":"<code>DvzEasing</code>","text":"<pre><code>DVZ_EASING_NONE = 0\nDVZ_EASING_IN_SINE = 1\nDVZ_EASING_OUT_SINE = 2\nDVZ_EASING_IN_OUT_SINE = 3\nDVZ_EASING_IN_QUAD = 4\nDVZ_EASING_OUT_QUAD = 5\nDVZ_EASING_IN_OUT_QUAD = 6\nDVZ_EASING_IN_CUBIC = 7\nDVZ_EASING_OUT_CUBIC = 8\nDVZ_EASING_IN_OUT_CUBIC = 9\nDVZ_EASING_IN_QUART = 10\nDVZ_EASING_OUT_QUART = 11\nDVZ_EASING_IN_OUT_QUART = 12\nDVZ_EASING_IN_QUINT = 13\nDVZ_EASING_OUT_QUINT = 14\nDVZ_EASING_IN_OUT_QUINT = 15\nDVZ_EASING_IN_EXPO = 16\nDVZ_EASING_OUT_EXPO = 17\nDVZ_EASING_IN_OUT_EXPO = 18\nDVZ_EASING_IN_CIRC = 19\nDVZ_EASING_OUT_CIRC = 20\nDVZ_EASING_IN_OUT_CIRC = 21\nDVZ_EASING_IN_BACK = 22\nDVZ_EASING_OUT_BACK = 23\nDVZ_EASING_IN_OUT_BACK = 24\nDVZ_EASING_IN_ELASTIC = 25\nDVZ_EASING_OUT_ELASTIC = 26\nDVZ_EASING_IN_OUT_ELASTIC = 27\nDVZ_EASING_IN_BOUNCE = 28\nDVZ_EASING_OUT_BOUNCE = 29\nDVZ_EASING_IN_OUT_BOUNCE = 30\nDVZ_EASING_COUNT = 31\n</code></pre>"},{"location":"reference/api_c/#dvzfilter","title":"<code>DvzFilter</code>","text":"<pre><code>DVZ_FILTER_NEAREST = 0\nDVZ_FILTER_LINEAR = 1\nDVZ_FILTER_CUBIC_IMG = 1000015000\n</code></pre>"},{"location":"reference/api_c/#dvzflyflags","title":"<code>DvzFlyFlags</code>","text":"<pre><code>DVZ_FLY_FLAGS_NONE = 0x0000\nDVZ_FLY_FLAGS_INVERT_MOUSE = 0x0001\nDVZ_FLY_FLAGS_FIXED_UP = 0x0002\n</code></pre>"},{"location":"reference/api_c/#dvzfontflags","title":"<code>DvzFontFlags</code>","text":"<pre><code>DVZ_FONT_FLAGS_RGB = 0\nDVZ_FONT_FLAGS_RGBA = 1\n</code></pre>"},{"location":"reference/api_c/#dvzformat","title":"<code>DvzFormat</code>","text":"<pre><code>DVZ_FORMAT_NONE = 0\nDVZ_FORMAT_R8_UNORM = 9\nDVZ_FORMAT_R8_SNORM = 10\nDVZ_FORMAT_R8_UINT = 13\nDVZ_FORMAT_R8_SINT = 14\nDVZ_FORMAT_R8G8_UNORM = 16\nDVZ_FORMAT_R8G8_SNORM = 17\nDVZ_FORMAT_R8G8_UINT = 20\nDVZ_FORMAT_R8G8_SINT = 21\nDVZ_FORMAT_R8G8B8_UNORM = 23\nDVZ_FORMAT_R8G8B8_SNORM = 24\nDVZ_FORMAT_R8G8B8_UINT = 27\nDVZ_FORMAT_R8G8B8_SINT = 28\nDVZ_FORMAT_R8G8B8A8_UNORM = 37\nDVZ_FORMAT_R8G8B8A8_SNORM = 38\nDVZ_FORMAT_R8G8B8A8_UINT = 41\nDVZ_FORMAT_R8G8B8A8_SINT = 42\nDVZ_FORMAT_B8G8R8A8_UNORM = 44\nDVZ_FORMAT_R16_UNORM = 70\nDVZ_FORMAT_R16_SNORM = 71\nDVZ_FORMAT_R32_UINT = 98\nDVZ_FORMAT_R32_SINT = 99\nDVZ_FORMAT_R32_SFLOAT = 100\nDVZ_FORMAT_R32G32_UINT = 101\nDVZ_FORMAT_R32G32_SINT = 102\nDVZ_FORMAT_R32G32_SFLOAT = 103\nDVZ_FORMAT_R32G32B32_UINT = 104\nDVZ_FORMAT_R32G32B32_SINT = 105\nDVZ_FORMAT_R32G32B32_SFLOAT = 106\nDVZ_FORMAT_R32G32B32A32_UINT = 107\nDVZ_FORMAT_R32G32B32A32_SINT = 108\nDVZ_FORMAT_R32G32B32A32_SFLOAT = 109\nDVZ_FORMAT_R64_UINT = 110\nDVZ_FORMAT_R64_SINT = 111\nDVZ_FORMAT_R64_SFLOAT = 112\nDVZ_FORMAT_R64G64_UINT = 113\nDVZ_FORMAT_R64G64_SINT = 114\nDVZ_FORMAT_R64G64_SFLOAT = 115\nDVZ_FORMAT_R64G64B64_UINT = 116\nDVZ_FORMAT_R64G64B64_SINT = 117\nDVZ_FORMAT_R64G64B64_SFLOAT = 118\nDVZ_FORMAT_R64G64B64A64_UINT = 119\nDVZ_FORMAT_R64G64B64A64_SINT = 120\nDVZ_FORMAT_R64G64B64A64_SFLOAT = 121\n</code></pre>"},{"location":"reference/api_c/#dvzfrontface","title":"<code>DvzFrontFace</code>","text":"<pre><code>DVZ_FRONT_FACE_COUNTER_CLOCKWISE = 0\nDVZ_FRONT_FACE_CLOCKWISE = 1\n</code></pre>"},{"location":"reference/api_c/#dvzgraphicsrequestflags","title":"<code>DvzGraphicsRequestFlags</code>","text":"<pre><code>DVZ_GRAPHICS_REQUEST_FLAGS_NONE = 0x0000\nDVZ_GRAPHICS_REQUEST_FLAGS_OFFSCREEN = 0x1000\n</code></pre>"},{"location":"reference/api_c/#dvzgraphicstype","title":"<code>DvzGraphicsType</code>","text":"<pre><code>DVZ_GRAPHICS_NONE = 0\nDVZ_GRAPHICS_POINT = 1\nDVZ_GRAPHICS_TRIANGLE = 2\nDVZ_GRAPHICS_CUSTOM = 3\n</code></pre>"},{"location":"reference/api_c/#dvzguiflags","title":"<code>DvzGuiFlags</code>","text":"<pre><code>DVZ_GUI_FLAGS_NONE = 0x0000\nDVZ_GUI_FLAGS_OFFSCREEN = 0x0001\nDVZ_GUI_FLAGS_DOCKING = 0x0010\n</code></pre>"},{"location":"reference/api_c/#dvzimageflags","title":"<code>DvzImageFlags</code>","text":"<pre><code>DVZ_IMAGE_FLAGS_SIZE_PIXELS = 0x0000\nDVZ_IMAGE_FLAGS_SIZE_NDC = 0x0001\nDVZ_IMAGE_FLAGS_RESCALE_KEEP_RATIO = 0x0004\nDVZ_IMAGE_FLAGS_RESCALE = 0x0008\nDVZ_IMAGE_FLAGS_MODE_RGBA = 0x0000\nDVZ_IMAGE_FLAGS_MODE_COLORMAP = 0x0010\nDVZ_IMAGE_FLAGS_MODE_FILL = 0x0020\nDVZ_IMAGE_FLAGS_BORDER = 0x0080\n</code></pre>"},{"location":"reference/api_c/#dvzjointype","title":"<code>DvzJoinType</code>","text":"<pre><code>DVZ_JOIN_SQUARE = 0\nDVZ_JOIN_ROUND = 1\n</code></pre>"},{"location":"reference/api_c/#dvzkeycode","title":"<code>DvzKeyCode</code>","text":"<pre><code>DVZ_KEY_UNKNOWN = -1\nDVZ_KEY_NONE = +0\nDVZ_KEY_SPACE = 32\nDVZ_KEY_APOSTROPHE = 39\nDVZ_KEY_COMMA = 44\nDVZ_KEY_MINUS = 45\nDVZ_KEY_PERIOD = 46\nDVZ_KEY_SLASH = 47\nDVZ_KEY_0 = 48\nDVZ_KEY_1 = 49\nDVZ_KEY_2 = 50\nDVZ_KEY_3 = 51\nDVZ_KEY_4 = 52\nDVZ_KEY_5 = 53\nDVZ_KEY_6 = 54\nDVZ_KEY_7 = 55\nDVZ_KEY_8 = 56\nDVZ_KEY_9 = 57\nDVZ_KEY_SEMICOLON = 59\nDVZ_KEY_EQUAL = 61\nDVZ_KEY_A = 65\nDVZ_KEY_B = 66\nDVZ_KEY_C = 67\nDVZ_KEY_D = 68\nDVZ_KEY_E = 69\nDVZ_KEY_F = 70\nDVZ_KEY_G = 71\nDVZ_KEY_H = 72\nDVZ_KEY_I = 73\nDVZ_KEY_J = 74\nDVZ_KEY_K = 75\nDVZ_KEY_L = 76\nDVZ_KEY_M = 77\nDVZ_KEY_N = 78\nDVZ_KEY_O = 79\nDVZ_KEY_P = 80\nDVZ_KEY_Q = 81\nDVZ_KEY_R = 82\nDVZ_KEY_S = 83\nDVZ_KEY_T = 84\nDVZ_KEY_U = 85\nDVZ_KEY_V = 86\nDVZ_KEY_W = 87\nDVZ_KEY_X = 88\nDVZ_KEY_Y = 89\nDVZ_KEY_Z = 90\nDVZ_KEY_LEFT_BRACKET = 91\nDVZ_KEY_BACKSLASH = 92\nDVZ_KEY_RIGHT_BRACKET = 93\nDVZ_KEY_GRAVE_ACCENT = 96\nDVZ_KEY_WORLD_1 = 161\nDVZ_KEY_WORLD_2 = 162\nDVZ_KEY_ESCAPE = 256\nDVZ_KEY_ENTER = 257\nDVZ_KEY_TAB = 258\nDVZ_KEY_BACKSPACE = 259\nDVZ_KEY_INSERT = 260\nDVZ_KEY_DELETE = 261\nDVZ_KEY_RIGHT = 262\nDVZ_KEY_LEFT = 263\nDVZ_KEY_DOWN = 264\nDVZ_KEY_UP = 265\nDVZ_KEY_PAGE_UP = 266\nDVZ_KEY_PAGE_DOWN = 267\nDVZ_KEY_HOME = 268\nDVZ_KEY_END = 269\nDVZ_KEY_CAPS_LOCK = 280\nDVZ_KEY_SCROLL_LOCK = 281\nDVZ_KEY_NUM_LOCK = 282\nDVZ_KEY_PRINT_SCREEN = 283\nDVZ_KEY_PAUSE = 284\nDVZ_KEY_F1 = 290\nDVZ_KEY_F2 = 291\nDVZ_KEY_F3 = 292\nDVZ_KEY_F4 = 293\nDVZ_KEY_F5 = 294\nDVZ_KEY_F6 = 295\nDVZ_KEY_F7 = 296\nDVZ_KEY_F8 = 297\nDVZ_KEY_F9 = 298\nDVZ_KEY_F10 = 299\nDVZ_KEY_F11 = 300\nDVZ_KEY_F12 = 301\nDVZ_KEY_F13 = 302\nDVZ_KEY_F14 = 303\nDVZ_KEY_F15 = 304\nDVZ_KEY_F16 = 305\nDVZ_KEY_F17 = 306\nDVZ_KEY_F18 = 307\nDVZ_KEY_F19 = 308\nDVZ_KEY_F20 = 309\nDVZ_KEY_F21 = 310\nDVZ_KEY_F22 = 311\nDVZ_KEY_F23 = 312\nDVZ_KEY_F24 = 313\nDVZ_KEY_F25 = 314\nDVZ_KEY_KP_0 = 320\nDVZ_KEY_KP_1 = 321\nDVZ_KEY_KP_2 = 322\nDVZ_KEY_KP_3 = 323\nDVZ_KEY_KP_4 = 324\nDVZ_KEY_KP_5 = 325\nDVZ_KEY_KP_6 = 326\nDVZ_KEY_KP_7 = 327\nDVZ_KEY_KP_8 = 328\nDVZ_KEY_KP_9 = 329\nDVZ_KEY_KP_DECIMAL = 330\nDVZ_KEY_KP_DIVIDE = 331\nDVZ_KEY_KP_MULTIPLY = 332\nDVZ_KEY_KP_SUBTRACT = 333\nDVZ_KEY_KP_ADD = 334\nDVZ_KEY_KP_ENTER = 335\nDVZ_KEY_KP_EQUAL = 336\nDVZ_KEY_LEFT_SHIFT = 340\nDVZ_KEY_LEFT_CONTROL = 341\nDVZ_KEY_LEFT_ALT = 342\nDVZ_KEY_LEFT_SUPER = 343\nDVZ_KEY_RIGHT_SHIFT = 344\nDVZ_KEY_RIGHT_CONTROL = 345\nDVZ_KEY_RIGHT_ALT = 346\nDVZ_KEY_RIGHT_SUPER = 347\nDVZ_KEY_MENU = 348\nDVZ_KEY_LAST = 348\n</code></pre>"},{"location":"reference/api_c/#dvzkeyboardeventtype","title":"<code>DvzKeyboardEventType</code>","text":"<pre><code>DVZ_KEYBOARD_EVENT_NONE = 0\nDVZ_KEYBOARD_EVENT_PRESS = 1\nDVZ_KEYBOARD_EVENT_REPEAT = 2\nDVZ_KEYBOARD_EVENT_RELEASE = 3\n</code></pre>"},{"location":"reference/api_c/#dvzkeyboardmodifiers","title":"<code>DvzKeyboardModifiers</code>","text":"<pre><code>DVZ_KEY_MODIFIER_NONE = 0x00000000\nDVZ_KEY_MODIFIER_SHIFT = 0x00000001\nDVZ_KEY_MODIFIER_CONTROL = 0x00000002\nDVZ_KEY_MODIFIER_ALT = 0x00000004\nDVZ_KEY_MODIFIER_SUPER = 0x00000008\n</code></pre>"},{"location":"reference/api_c/#dvzmarkeraspect","title":"<code>DvzMarkerAspect</code>","text":"<pre><code>DVZ_MARKER_ASPECT_FILLED = 0\nDVZ_MARKER_ASPECT_STROKE = 1\nDVZ_MARKER_ASPECT_OUTLINE = 2\n</code></pre>"},{"location":"reference/api_c/#dvzmarkermode","title":"<code>DvzMarkerMode</code>","text":"<pre><code>DVZ_MARKER_MODE_NONE = 0\nDVZ_MARKER_MODE_CODE = 1\nDVZ_MARKER_MODE_BITMAP = 2\nDVZ_MARKER_MODE_SDF = 3\nDVZ_MARKER_MODE_MSDF = 4\nDVZ_MARKER_MODE_MTSDF = 5\n</code></pre>"},{"location":"reference/api_c/#dvzmarkershape","title":"<code>DvzMarkerShape</code>","text":"<pre><code>DVZ_MARKER_SHAPE_DISC = 0\nDVZ_MARKER_SHAPE_ASTERISK = 1\nDVZ_MARKER_SHAPE_CHEVRON = 2\nDVZ_MARKER_SHAPE_CLOVER = 3\nDVZ_MARKER_SHAPE_CLUB = 4\nDVZ_MARKER_SHAPE_CROSS = 5\nDVZ_MARKER_SHAPE_DIAMOND = 6\nDVZ_MARKER_SHAPE_ARROW = 7\nDVZ_MARKER_SHAPE_ELLIPSE = 8\nDVZ_MARKER_SHAPE_HBAR = 9\nDVZ_MARKER_SHAPE_HEART = 10\nDVZ_MARKER_SHAPE_INFINITY = 11\nDVZ_MARKER_SHAPE_PIN = 12\nDVZ_MARKER_SHAPE_RING = 13\nDVZ_MARKER_SHAPE_SPADE = 14\nDVZ_MARKER_SHAPE_SQUARE = 15\nDVZ_MARKER_SHAPE_TAG = 16\nDVZ_MARKER_SHAPE_TRIANGLE = 17\nDVZ_MARKER_SHAPE_VBAR = 18\nDVZ_MARKER_SHAPE_ROUNDED_RECT = 19\nDVZ_MARKER_SHAPE_COUNT = 20\n</code></pre>"},{"location":"reference/api_c/#dvzmeshflags","title":"<code>DvzMeshFlags</code>","text":"<pre><code>DVZ_MESH_FLAGS_NONE = 0x0000\nDVZ_MESH_FLAGS_TEXTURED = 0x0001\nDVZ_MESH_FLAGS_LIGHTING = 0x0002\nDVZ_MESH_FLAGS_CONTOUR = 0x0004\nDVZ_MESH_FLAGS_ISOLINE = 0x0008\n</code></pre>"},{"location":"reference/api_c/#dvzmockflags","title":"<code>DvzMockFlags</code>","text":"<pre><code>DVZ_MOCK_FLAGS_NONE = 0x00\nDVZ_MOCK_FLAGS_CLOSED = 0x01\n</code></pre>"},{"location":"reference/api_c/#dvzmousebutton","title":"<code>DvzMouseButton</code>","text":"<pre><code>DVZ_MOUSE_BUTTON_NONE = 0\nDVZ_MOUSE_BUTTON_LEFT = 1\nDVZ_MOUSE_BUTTON_MIDDLE = 2\nDVZ_MOUSE_BUTTON_RIGHT = 3\n</code></pre>"},{"location":"reference/api_c/#dvzmouseeventtype","title":"<code>DvzMouseEventType</code>","text":"<pre><code>DVZ_MOUSE_EVENT_RELEASE = 0\nDVZ_MOUSE_EVENT_PRESS = 1\nDVZ_MOUSE_EVENT_MOVE = 2\nDVZ_MOUSE_EVENT_CLICK = 3\nDVZ_MOUSE_EVENT_DOUBLE_CLICK = 5\nDVZ_MOUSE_EVENT_DRAG_START = 10\nDVZ_MOUSE_EVENT_DRAG = 11\nDVZ_MOUSE_EVENT_DRAG_STOP = 12\nDVZ_MOUSE_EVENT_WHEEL = 20\nDVZ_MOUSE_EVENT_ALL = 255\n</code></pre>"},{"location":"reference/api_c/#dvzmousestate","title":"<code>DvzMouseState</code>","text":"<pre><code>DVZ_MOUSE_STATE_RELEASE = 0\nDVZ_MOUSE_STATE_PRESS = 1\nDVZ_MOUSE_STATE_CLICK = 3\nDVZ_MOUSE_STATE_CLICK_PRESS = 4\nDVZ_MOUSE_STATE_DOUBLE_CLICK = 5\nDVZ_MOUSE_STATE_DRAGGING = 11\n</code></pre>"},{"location":"reference/api_c/#dvzorientation","title":"<code>DvzOrientation</code>","text":"<pre><code>DVZ_ORIENTATION_DEFAULT = 0\nDVZ_ORIENTATION_UP = 1\nDVZ_ORIENTATION_REVERSE = 2\nDVZ_ORIENTATION_DOWN = 3\n</code></pre>"},{"location":"reference/api_c/#dvzpanellinkflags","title":"<code>DvzPanelLinkFlags</code>","text":"<pre><code>DVZ_PANEL_LINK_FLAGS_NONE = 0x00\nDVZ_PANEL_LINK_FLAGS_MODEL = 0x01\nDVZ_PANEL_LINK_FLAGS_VIEW = 0x02\nDVZ_PANEL_LINK_FLAGS_PROJECTION = 0x04\n</code></pre>"},{"location":"reference/api_c/#dvzpanzoomflags","title":"<code>DvzPanzoomFlags</code>","text":"<pre><code>DVZ_PANZOOM_FLAGS_NONE = 0x00\nDVZ_PANZOOM_FLAGS_KEEP_ASPECT = 0x01\nDVZ_PANZOOM_FLAGS_FIXED_X = 0x10\nDVZ_PANZOOM_FLAGS_FIXED_Y = 0x20\n</code></pre>"},{"location":"reference/api_c/#dvzpathflags","title":"<code>DvzPathFlags</code>","text":"<pre><code>DVZ_PATH_FLAGS_OPEN = 0\nDVZ_PATH_FLAGS_CLOSED = 1\n</code></pre>"},{"location":"reference/api_c/#dvzpolygonmode","title":"<code>DvzPolygonMode</code>","text":"<pre><code>DVZ_POLYGON_MODE_FILL = 0\nDVZ_POLYGON_MODE_LINE = 1\nDVZ_POLYGON_MODE_POINT = 2\n</code></pre>"},{"location":"reference/api_c/#dvzprimitivetopology","title":"<code>DvzPrimitiveTopology</code>","text":"<pre><code>DVZ_PRIMITIVE_TOPOLOGY_POINT_LIST = 0\nDVZ_PRIMITIVE_TOPOLOGY_LINE_LIST = 1\nDVZ_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5\n</code></pre>"},{"location":"reference/api_c/#dvzprintflagsflags","title":"<code>DvzPrintFlagsFlags</code>","text":"<pre><code>DVZ_PRINT_FLAGS_NONE = 0x0000\nDVZ_PRINT_FLAGS_ALL = 0x0001\nDVZ_PRINT_FLAGS_SMALL = 0x0003\n</code></pre>"},{"location":"reference/api_c/#dvzrecordercommandtype","title":"<code>DvzRecorderCommandType</code>","text":"<pre><code>DVZ_RECORDER_NONE = 0\nDVZ_RECORDER_BEGIN = 1\nDVZ_RECORDER_DRAW = 2\nDVZ_RECORDER_DRAW_INDEXED = 3\nDVZ_RECORDER_DRAW_INDIRECT = 4\nDVZ_RECORDER_DRAW_INDEXED_INDIRECT = 5\nDVZ_RECORDER_VIEWPORT = 6\nDVZ_RECORDER_PUSH = 7\nDVZ_RECORDER_END = 8\nDVZ_RECORDER_COUNT = 9\n</code></pre>"},{"location":"reference/api_c/#dvzrefflags","title":"<code>DvzRefFlags</code>","text":"<pre><code>DVZ_REF_FLAGS_NONE = 0x00\nDVZ_REF_FLAGS_EQUAL = 0x01\n</code></pre>"},{"location":"reference/api_c/#dvzrequestaction","title":"<code>DvzRequestAction</code>","text":"<pre><code>DVZ_REQUEST_ACTION_NONE = 0\nDVZ_REQUEST_ACTION_CREATE = 1\nDVZ_REQUEST_ACTION_DELETE = 2\nDVZ_REQUEST_ACTION_RESIZE = 3\nDVZ_REQUEST_ACTION_UPDATE = 4\nDVZ_REQUEST_ACTION_BIND = 5\nDVZ_REQUEST_ACTION_RECORD = 6\nDVZ_REQUEST_ACTION_UPLOAD = 7\nDVZ_REQUEST_ACTION_UPFILL = 8\nDVZ_REQUEST_ACTION_DOWNLOAD = 9\nDVZ_REQUEST_ACTION_SET = 10\nDVZ_REQUEST_ACTION_GET = 11\n</code></pre>"},{"location":"reference/api_c/#dvzrequestobject","title":"<code>DvzRequestObject</code>","text":"<pre><code>DVZ_REQUEST_OBJECT_NONE = 0\nDVZ_REQUEST_OBJECT_CANVAS = 101\nDVZ_REQUEST_OBJECT_DAT = 2\nDVZ_REQUEST_OBJECT_TEX = 3\nDVZ_REQUEST_OBJECT_SAMPLER = 4\nDVZ_REQUEST_OBJECT_COMPUTE = 5\nDVZ_REQUEST_OBJECT_PRIMITIVE = 6\nDVZ_REQUEST_OBJECT_DEPTH = 7\nDVZ_REQUEST_OBJECT_BLEND = 8\nDVZ_REQUEST_OBJECT_MASK = 9\nDVZ_REQUEST_OBJECT_POLYGON = 10\nDVZ_REQUEST_OBJECT_CULL = 11\nDVZ_REQUEST_OBJECT_FRONT = 12\nDVZ_REQUEST_OBJECT_SHADER = 13\nDVZ_REQUEST_OBJECT_VERTEX = 14\nDVZ_REQUEST_OBJECT_VERTEX_ATTR = 15\nDVZ_REQUEST_OBJECT_SLOT = 16\nDVZ_REQUEST_OBJECT_PUSH = 17\nDVZ_REQUEST_OBJECT_SPECIALIZATION = 18\nDVZ_REQUEST_OBJECT_GRAPHICS = 19\nDVZ_REQUEST_OBJECT_INDEX = 20\nDVZ_REQUEST_OBJECT_BACKGROUND = 21\nDVZ_REQUEST_OBJECT_RECORD = 22\n</code></pre>"},{"location":"reference/api_c/#dvzsampleraddressmode","title":"<code>DvzSamplerAddressMode</code>","text":"<pre><code>DVZ_SAMPLER_ADDRESS_MODE_REPEAT = 0\nDVZ_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1\nDVZ_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2\nDVZ_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3\nDVZ_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4\n</code></pre>"},{"location":"reference/api_c/#dvzsampleraxis","title":"<code>DvzSamplerAxis</code>","text":"<pre><code>DVZ_SAMPLER_AXIS_U = 0\nDVZ_SAMPLER_AXIS_V = 1\nDVZ_SAMPLER_AXIS_W = 2\n</code></pre>"},{"location":"reference/api_c/#dvzscenefont","title":"<code>DvzSceneFont</code>","text":"<pre><code>DVZ_SCENE_FONT_MONO = 0\nDVZ_SCENE_FONT_LABEL = 1\nDVZ_SCENE_FONT_COUNT = 2\n</code></pre>"},{"location":"reference/api_c/#dvzshaderformat","title":"<code>DvzShaderFormat</code>","text":"<pre><code>DVZ_SHADER_NONE = 0\nDVZ_SHADER_SPIRV = 1\nDVZ_SHADER_GLSL = 2\n</code></pre>"},{"location":"reference/api_c/#dvzshadertype","title":"<code>DvzShaderType</code>","text":"<pre><code>DVZ_SHADER_VERTEX = 0x00000001\nDVZ_SHADER_TESSELLATION_CONTROL = 0x00000002\nDVZ_SHADER_TESSELLATION_EVALUATION = 0x00000004\nDVZ_SHADER_GEOMETRY = 0x00000008\nDVZ_SHADER_FRAGMENT = 0x00000010\nDVZ_SHADER_COMPUTE = 0x00000020\n</code></pre>"},{"location":"reference/api_c/#dvzshapeindexingflags","title":"<code>DvzShapeIndexingFlags</code>","text":"<pre><code>DVZ_INDEXING_NONE = 0x00\nDVZ_INDEXING_EARCUT = 0x10\nDVZ_INDEXING_SURFACE = 0x20\n</code></pre>"},{"location":"reference/api_c/#dvzshapetype","title":"<code>DvzShapeType</code>","text":"<pre><code>DVZ_SHAPE_NONE = 0\nDVZ_SHAPE_SQUARE = 1\nDVZ_SHAPE_DISC = 2\nDVZ_SHAPE_SECTOR = 3\nDVZ_SHAPE_POLYGON = 4\nDVZ_SHAPE_HISTOGRAM = 5\nDVZ_SHAPE_CUBE = 6\nDVZ_SHAPE_SPHERE = 7\nDVZ_SHAPE_CYLINDER = 8\nDVZ_SHAPE_CONE = 9\nDVZ_SHAPE_TORUS = 10\nDVZ_SHAPE_ARROW = 11\nDVZ_SHAPE_TETRAHEDRON = 12\nDVZ_SHAPE_HEXAHEDRON = 13\nDVZ_SHAPE_OCTAHEDRON = 14\nDVZ_SHAPE_DODECAHEDRON = 15\nDVZ_SHAPE_ICOSAHEDRON = 16\nDVZ_SHAPE_SURFACE = 17\nDVZ_SHAPE_OBJ = 18\nDVZ_SHAPE_OTHER = 19\n</code></pre>"},{"location":"reference/api_c/#dvzslottype","title":"<code>DvzSlotType</code>","text":"<pre><code>DVZ_SLOT_DAT = 0\nDVZ_SLOT_TEX = 1\nDVZ_SLOT_COUNT = 2\n</code></pre>"},{"location":"reference/api_c/#dvzsphereflags","title":"<code>DvzSphereFlags</code>","text":"<pre><code>DVZ_SPHERE_FLAGS_NONE = 0x0000\nDVZ_SPHERE_FLAGS_TEXTURED = 0x0001\nDVZ_SPHERE_FLAGS_LIGHTING = 0x0002\nDVZ_SPHERE_FLAGS_SIZE_PIXELS = 0x0004\nDVZ_SPHERE_FLAGS_EQUAL_RECTANGULAR = 0x0008\n</code></pre>"},{"location":"reference/api_c/#dvztexdims","title":"<code>DvzTexDims</code>","text":"<pre><code>DVZ_TEX_NONE = 0\nDVZ_TEX_1D = 1\nDVZ_TEX_2D = 2\nDVZ_TEX_3D = 3\n</code></pre>"},{"location":"reference/api_c/#dvztexflags","title":"<code>DvzTexFlags</code>","text":"<pre><code>DVZ_TEX_FLAGS_NONE = 0x0000\nDVZ_TEX_FLAGS_PERSISTENT_STAGING = 0x2000\n</code></pre>"},{"location":"reference/api_c/#dvzuploadflags","title":"<code>DvzUploadFlags</code>","text":"<pre><code>DVZ_UPLOAD_FLAGS_NOCOPY = 0x0800\n</code></pre>"},{"location":"reference/api_c/#dvzvertexinputrate","title":"<code>DvzVertexInputRate</code>","text":"<pre><code>DVZ_VERTEX_INPUT_RATE_VERTEX = 0\nDVZ_VERTEX_INPUT_RATE_INSTANCE = 1\n</code></pre>"},{"location":"reference/api_c/#dvzviewflags","title":"<code>DvzViewFlags</code>","text":"<pre><code>DVZ_VIEW_FLAGS_NONE = 0x0000\nDVZ_VIEW_FLAGS_STATIC = 0x0010\nDVZ_VIEW_FLAGS_NOCLIP = 0x0020\n</code></pre>"},{"location":"reference/api_c/#dvzviewportclip","title":"<code>DvzViewportClip</code>","text":"<pre><code>DVZ_VIEWPORT_CLIP_INNER = 0x0001\nDVZ_VIEWPORT_CLIP_OUTER = 0x0002\nDVZ_VIEWPORT_CLIP_BOTTOM = 0x0004\nDVZ_VIEWPORT_CLIP_LEFT = 0x0008\n</code></pre>"},{"location":"reference/api_c/#dvzvisualflags","title":"<code>DvzVisualFlags</code>","text":"<pre><code>DVZ_VISUAL_FLAGS_DEFAULT = 0x000000\nDVZ_VISUAL_FLAGS_INDEXED = 0x010000\nDVZ_VISUAL_FLAGS_INDIRECT = 0x020000\nDVZ_VISUAL_FLAGS_FIXED_X = 0x001000\nDVZ_VISUAL_FLAGS_FIXED_Y = 0x002000\nDVZ_VISUAL_FLAGS_FIXED_Z = 0x004000\nDVZ_VISUAL_FLAGS_FIXED_ALL = 0x007000\nDVZ_VISUAL_FLAGS_VERTEX_MAPPABLE = 0x400000\nDVZ_VISUAL_FLAGS_INDEX_MAPPABLE = 0x800000\n</code></pre>"},{"location":"reference/api_c/#dvzvolumeflags","title":"<code>DvzVolumeFlags</code>","text":"<pre><code>DVZ_VOLUME_FLAGS_NONE = 0x0000\nDVZ_VOLUME_FLAGS_RGBA = 0x0001\nDVZ_VOLUME_FLAGS_COLORMAP = 0x0002\nDVZ_VOLUME_FLAGS_BACK_FRONT = 0x0004\n</code></pre>"},{"location":"reference/api_c/#structures","title":"Structures","text":"<p>Note: The information about these structures is provided for reference only, do not use them in production as the structures may change with each release.</p>"},{"location":"reference/api_c/#dvzatlasfont","title":"<code>DvzAtlasFont</code>","text":"<pre><code>struct DvzAtlasFont {\n    long ttf_size;\n    char* ttf_bytes;\n    DvzAtlas* atlas;\n    DvzFont* font;\n    float font_size;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzbatch","title":"<code>DvzBatch</code>","text":"<pre><code>struct DvzBatch {\n    uint32_t capacity;\n    uint32_t count;\n    DvzRequest* requests;\n    DvzList* pointers_to_free;\n    int flags;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzframeevent","title":"<code>DvzFrameEvent</code>","text":"<pre><code>struct DvzFrameEvent {\n    uint64_t frame_idx;\n    double time;\n    double interval;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzguievent","title":"<code>DvzGuiEvent</code>","text":"<pre><code>struct DvzGuiEvent {\n    DvzGuiWindow* gui_window;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzkeyboardevent","title":"<code>DvzKeyboardEvent</code>","text":"<pre><code>struct DvzKeyboardEvent {\n    DvzKeyboardEventType type;\n    DvzKeyCode key;\n    int mods;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzmvp","title":"<code>DvzMVP</code>","text":"<pre><code>struct DvzMVP {\n    mat4 model;\n    mat4 view;\n    mat4 proj;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzmousedragevent","title":"<code>DvzMouseDragEvent</code>","text":"<pre><code>struct DvzMouseDragEvent {\n    vec2 press_pos;\n    vec2 last_pos;\n    vec2 shift;\n    bool is_press_valid;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzmouseevent","title":"<code>DvzMouseEvent</code>","text":"<pre><code>struct DvzMouseEvent {\n    DvzMouseEventType type;\n    DvzMouseEventUnion content;\n    vec2 pos;\n    DvzMouseButton button;\n    int mods;\n    float content_scale;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzmouseeventunion","title":"<code>DvzMouseEventUnion</code>","text":"<pre><code>struct DvzMouseEventUnion {\n    DvzMouseWheelEvent w;\n    DvzMouseDragEvent d;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzmousewheelevent","title":"<code>DvzMouseWheelEvent</code>","text":"<pre><code>struct DvzMouseWheelEvent {\n    vec2 dir;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecordercommand","title":"<code>DvzRecorderCommand</code>","text":"<pre><code>struct DvzRecorderCommand {\n    DvzRecorderCommandType type;\n    DvzId canvas_id;\n    DvzRequestObject object_type;\n    DvzRecorderUnion contents;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderdraw","title":"<code>DvzRecorderDraw</code>","text":"<pre><code>struct DvzRecorderDraw {\n    DvzId pipe_id;\n    uint32_t first_vertex;\n    uint32_t vertex_count;\n    uint32_t first_instance;\n    uint32_t instance_count;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderdrawindexed","title":"<code>DvzRecorderDrawIndexed</code>","text":"<pre><code>struct DvzRecorderDrawIndexed {\n    DvzId pipe_id;\n    uint32_t first_index;\n    uint32_t vertex_offset;\n    uint32_t index_count;\n    uint32_t first_instance;\n    uint32_t instance_count;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderdrawindexedindirect","title":"<code>DvzRecorderDrawIndexedIndirect</code>","text":"<pre><code>struct DvzRecorderDrawIndexedIndirect {\n    DvzId pipe_id;\n    DvzId dat_indirect_id;\n    uint32_t draw_count;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderdrawindirect","title":"<code>DvzRecorderDrawIndirect</code>","text":"<pre><code>struct DvzRecorderDrawIndirect {\n    DvzId pipe_id;\n    DvzId dat_indirect_id;\n    uint32_t draw_count;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderpush","title":"<code>DvzRecorderPush</code>","text":"<pre><code>struct DvzRecorderPush {\n    DvzId pipe_id;\n    DvzShaderStageFlags shader_stages;\n    DvzSize offset;\n    DvzSize size;\n    void* data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderunion","title":"<code>DvzRecorderUnion</code>","text":"<pre><code>struct DvzRecorderUnion {\n    DvzRecorderViewport v;\n    DvzRecorderPush p;\n    DvzRecorderDraw draw;\n    DvzRecorderDrawIndexed draw_indexed;\n    DvzRecorderDrawIndirect draw_indirect;\n    DvzRecorderDrawIndexedIndirect draw_indexed_indirect;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrecorderviewport","title":"<code>DvzRecorderViewport</code>","text":"<pre><code>struct DvzRecorderViewport {\n    vec2 offset;\n    vec2 shape;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequest","title":"<code>DvzRequest</code>","text":"<pre><code>struct DvzRequest {\n    uint32_t version;\n    DvzRequestAction action;\n    DvzRequestObject type;\n    DvzId id;\n    DvzRequestContent content;\n    int tag;\n    int flags;\n    char* desc;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestattr","title":"<code>DvzRequestAttr</code>","text":"<pre><code>struct DvzRequestAttr {\n    uint32_t binding_idx;\n    uint32_t location;\n    DvzFormat format;\n    DvzSize offset;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestbinddat","title":"<code>DvzRequestBindDat</code>","text":"<pre><code>struct DvzRequestBindDat {\n    uint32_t slot_idx;\n    DvzId dat;\n    DvzSize offset;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestbindindex","title":"<code>DvzRequestBindIndex</code>","text":"<pre><code>struct DvzRequestBindIndex {\n    DvzId dat;\n    DvzSize offset;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestbindtex","title":"<code>DvzRequestBindTex</code>","text":"<pre><code>struct DvzRequestBindTex {\n    uint32_t slot_idx;\n    DvzId tex;\n    DvzId sampler;\n    uvec3 offset;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestbindvertex","title":"<code>DvzRequestBindVertex</code>","text":"<pre><code>struct DvzRequestBindVertex {\n    uint32_t binding_idx;\n    DvzId dat;\n    DvzSize offset;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestblend","title":"<code>DvzRequestBlend</code>","text":"<pre><code>struct DvzRequestBlend {\n    DvzBlendType blend;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestboard","title":"<code>DvzRequestBoard</code>","text":"<pre><code>struct DvzRequestBoard {\n    uint32_t width;\n    uint32_t height;\n    cvec4 background;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestcanvas","title":"<code>DvzRequestCanvas</code>","text":"<pre><code>struct DvzRequestCanvas {\n    uint32_t framebuffer_width;\n    uint32_t framebuffer_height;\n    uint32_t screen_width;\n    uint32_t screen_height;\n    bool is_offscreen;\n    cvec4 background;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestcontent","title":"<code>DvzRequestContent</code>","text":"<pre><code>struct DvzRequestContent {\n    DvzRequestCanvas canvas;\n    DvzRequestDat dat;\n    DvzRequestTex tex;\n    DvzRequestSampler sampler;\n    DvzRequestShader shader;\n    DvzRequestDatUpload dat_upload;\n    DvzRequestTexUpload tex_upload;\n    DvzRequestGraphics graphics;\n    DvzRequestPrimitive set_primitive;\n    DvzRequestBlend set_blend;\n    DvzRequestMask set_mask;\n    DvzRequestDepth set_depth;\n    DvzRequestPolygon set_polygon;\n    DvzRequestCull set_cull;\n    DvzRequestFront set_front;\n    DvzRequestShaderSet set_shader;\n    DvzRequestVertex set_vertex;\n    DvzRequestAttr set_attr;\n    DvzRequestSlot set_slot;\n    DvzRequestPush set_push;\n    DvzRequestSpecialization set_specialization;\n    DvzRequestBindVertex bind_vertex;\n    DvzRequestBindIndex bind_index;\n    DvzRequestBindDat bind_dat;\n    DvzRequestBindTex bind_tex;\n    DvzRequestRecord record;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestcull","title":"<code>DvzRequestCull</code>","text":"<pre><code>struct DvzRequestCull {\n    DvzCullMode cull;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestdat","title":"<code>DvzRequestDat</code>","text":"<pre><code>struct DvzRequestDat {\n    DvzBufferType type;\n    DvzSize size;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestdatupload","title":"<code>DvzRequestDatUpload</code>","text":"<pre><code>struct DvzRequestDatUpload {\n    int upload_type;\n    DvzSize offset;\n    DvzSize size;\n    void* data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestdepth","title":"<code>DvzRequestDepth</code>","text":"<pre><code>struct DvzRequestDepth {\n    DvzDepthTest depth;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestfront","title":"<code>DvzRequestFront</code>","text":"<pre><code>struct DvzRequestFront {\n    DvzFrontFace front;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestgraphics","title":"<code>DvzRequestGraphics</code>","text":"<pre><code>struct DvzRequestGraphics {\n    DvzGraphicsType type;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestmask","title":"<code>DvzRequestMask</code>","text":"<pre><code>struct DvzRequestMask {\n    int32_t mask;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestpolygon","title":"<code>DvzRequestPolygon</code>","text":"<pre><code>struct DvzRequestPolygon {\n    DvzPolygonMode polygon;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestprimitive","title":"<code>DvzRequestPrimitive</code>","text":"<pre><code>struct DvzRequestPrimitive {\n    DvzPrimitiveTopology primitive;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestpush","title":"<code>DvzRequestPush</code>","text":"<pre><code>struct DvzRequestPush {\n    DvzShaderStageFlags shader_stages;\n    DvzSize offset;\n    DvzSize size;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestrecord","title":"<code>DvzRequestRecord</code>","text":"<pre><code>struct DvzRequestRecord {\n    DvzRecorderCommand command;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestsampler","title":"<code>DvzRequestSampler</code>","text":"<pre><code>struct DvzRequestSampler {\n    DvzFilter filter;\n    DvzSamplerAddressMode mode;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestshader","title":"<code>DvzRequestShader</code>","text":"<pre><code>struct DvzRequestShader {\n    DvzShaderFormat format;\n    DvzShaderType type;\n    DvzSize size;\n    char* code;\n    uint32_t* buffer;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestshaderset","title":"<code>DvzRequestShaderSet</code>","text":"<pre><code>struct DvzRequestShaderSet {\n    DvzId shader;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestslot","title":"<code>DvzRequestSlot</code>","text":"<pre><code>struct DvzRequestSlot {\n    uint32_t slot_idx;\n    DvzDescriptorType type;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestspecialization","title":"<code>DvzRequestSpecialization</code>","text":"<pre><code>struct DvzRequestSpecialization {\n    DvzShaderType shader;\n    uint32_t idx;\n    DvzSize size;\n    void* value;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequesttex","title":"<code>DvzRequestTex</code>","text":"<pre><code>struct DvzRequestTex {\n    DvzTexDims dims;\n    uvec3 shape;\n    DvzFormat format;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequesttexupload","title":"<code>DvzRequestTexUpload</code>","text":"<pre><code>struct DvzRequestTexUpload {\n    int upload_type;\n    uvec3 offset;\n    uvec3 shape;\n    DvzSize size;\n    void* data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestvertex","title":"<code>DvzRequestVertex</code>","text":"<pre><code>struct DvzRequestVertex {\n    uint32_t binding_idx;\n    DvzSize stride;\n    DvzVertexInputRate input_rate;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequester","title":"<code>DvzRequester</code>","text":"<pre><code>struct DvzRequester {\n    DvzFifo* fifo;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzrequestsevent","title":"<code>DvzRequestsEvent</code>","text":"<pre><code>struct DvzRequestsEvent {\n    DvzBatch* batch;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzshape","title":"<code>DvzShape</code>","text":"<pre><code>struct DvzShape {\n    mat4 transform;\n    uint32_t first;\n    uint32_t count;\n    DvzShapeType type;\n    uint32_t vertex_count;\n    uint32_t index_count;\n    vec3* pos;\n    vec3* normal;\n    DvzColor* color;\n    vec4* texcoords;\n    float* isoline;\n    vec3* d_left;\n    vec3* d_right;\n    cvec4* contour;\n    DvzIndex* index;\n};\n</code></pre>"},{"location":"reference/api_c/#dvztime","title":"<code>DvzTime</code>","text":"<pre><code>struct DvzTime {\n    uint64_t seconds;\n    uint64_t nanoseconds;\n};\n</code></pre>"},{"location":"reference/api_c/#dvztimerevent","title":"<code>DvzTimerEvent</code>","text":"<pre><code>struct DvzTimerEvent {\n    uint32_t timer_idx;\n    DvzTimerItem* timer_item;\n    uint64_t step_idx;\n    double time;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzviewport","title":"<code>DvzViewport</code>","text":"<pre><code>struct DvzViewport {\n    _VkViewport viewport;\n    vec4 margins;\n    uvec2 offset_screen;\n    uvec2 size_screen;\n    uvec2 offset_framebuffer;\n    uvec2 size_framebuffer;\n    int flags;\n};\n</code></pre>"},{"location":"reference/api_c/#dvzwindowevent","title":"<code>DvzWindowEvent</code>","text":"<pre><code>struct DvzWindowEvent {\n    uint32_t framebuffer_width;\n    uint32_t framebuffer_height;\n    uint32_t screen_width;\n    uint32_t screen_height;\n    int flags;\n    void* user_data;\n};\n</code></pre>"},{"location":"reference/api_c/#_vkviewport","title":"<code>_VkViewport</code>","text":"<pre><code>struct _VkViewport {\n    float x;\n    float y;\n    float width;\n    float height;\n    float minDepth;\n    float maxDepth;\n};\n</code></pre>"},{"location":"reference/api_py/","title":"Main classes","text":"<p>Warning</p> <p>The Python API reference documentation is still a work-in-progress. Please feel free to contribute.</p>"},{"location":"reference/api_py/#datoviz._app.App","title":"datoviz._app.App","text":"<pre><code>App(\n    c_flags: int = 0,\n    offscreen: bool = False,\n    background: Optional[str] = None,\n)\n</code></pre> <p>Main application class for managing figures, textures, visuals, and events.</p> <p>Initialize the App instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_flags</code> <code>int</code> <p>Datoviz flags for the application, by default 0.</p> <code>0</code> <code>offscreen</code> <code>bool</code> <p>Whether to run in offscreen mode, by default False.</p> <code>False</code> <code>background</code> <code>str or None</code> <p>Background color ('white' or None), by default None (black).</p> <code>None</code> Warnings <p>The <code>background</code> parameter is likely to change in future versions.</p>"},{"location":"reference/api_py/#datoviz._app.App.basic","title":"basic","text":"<pre><code>basic(\n    topology: str = None,\n    position: ndarray = None,\n    color: ndarray = None,\n    group: ndarray = None,\n    size: float = None,\n    shape: ShapeCollection = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Basic\n</code></pre> <p>Create a basic visual.</p> <p>Parameters:</p> Name Type Description Default <code>topology</code> <code>str</code> <p>Topology type: <code>point_list</code>, <code>line_list</code>, <code>line_strip</code>, <code>triangle_list</code>, <code>triangle_strip</code>.</p> <code>None</code> <code>position</code> <code>ndarray</code> <p>Point 3D positions in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Point RGBA colors in range 0\u2013255.</p> <code>None</code> <code>group</code> <code>ndarray</code> <p>Group indices of all points (optional).</p> <code>None</code> <code>size</code> <code>float</code> <p>Point size in pixels, when using the <code>point_list</code> topology.</p> <code>None</code> <code>shape</code> <code>ShapeCollection</code> <p>Create a basic visual from a shape collection.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Basic</code> <p>The created basic visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.clear_timers","title":"clear_timers","text":"<pre><code>clear_timers()\n</code></pre> <p>Stop and clear all timers.</p>"},{"location":"reference/api_py/#datoviz._app.App.connect","title":"connect","text":"<pre><code>connect(figure: Figure) -&gt; tp.Callable\n</code></pre> <p>Connect an event handler to the given figure, using the decorated function name to determine the event to attach it to. The name of the decorated function can be <code>on_mouse</code>, <code>on_keyboard</code>, or <code>on_gui</code>.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to connect handlers to.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for event handlers.</p>"},{"location":"reference/api_py/#datoviz._app.App.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> <p>Destroy the application and release resources.</p>"},{"location":"reference/api_py/#datoviz._app.App.figure","title":"figure","text":"<pre><code>figure(\n    width: int = cst.DEFAULT_WIDTH,\n    height: int = cst.DEFAULT_HEIGHT,\n    c_flags: int = 0,\n    gui: bool = False,\n    fullscreen: bool = False,\n) -&gt; Figure\n</code></pre> <p>Create a new figure.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>Width of the figure, by default cst.DEFAULT_WIDTH.</p> <code>DEFAULT_WIDTH</code> <code>height</code> <code>int</code> <p>Height of the figure, by default cst.DEFAULT_HEIGHT.</p> <code>DEFAULT_HEIGHT</code> <code>c_flags</code> <code>int</code> <p>Flags for the figure, by default 0.</p> <code>0</code> <code>gui</code> <code>bool</code> <p>Whether to enable GUI, by default False.</p> <code>False</code> <code>fullscreen</code> <code>bool</code> <p>Open figure in fullscreen mode.</p> <code>False</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The created figure instance.</p> Warnings <p>The <code>gui</code> parameter must be <code>True</code> when a GUI is used in the figure, and must be <code>False</code> otherwise. This may change in versions.</p>"},{"location":"reference/api_py/#datoviz._app.App.glyph","title":"glyph","text":"<pre><code>glyph(\n    font_size: int = cst.DEFAULT_FONT_SIZE,\n    position: ndarray = None,\n    axis: ndarray = None,\n    size: ndarray = None,\n    anchor: ndarray = None,\n    shift: ndarray = None,\n    texcoords: ndarray = None,\n    group_size: ndarray = None,\n    scale: ndarray = None,\n    angle: ndarray = None,\n    color: ndarray = None,\n    bgcolor: Optional[Tuple[int, int, int, int]] = None,\n    texture: Optional[Texture] = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Glyph\n</code></pre> <p>Create a glyph visual.</p> <p>Parameters:</p> Name Type Description Default <code>font_size</code> <code>int</code> <p>Font size for the glyph, by default cst.DEFAULT_FONT_SIZE.</p> <code>DEFAULT_FONT_SIZE</code> <code>position</code> <code>ndarray</code> <p>Glyph 3D positions in normalized device coordinates.</p> <code>None</code> <code>axis</code> <code>ndarray</code> <p>Glyph axes in 3D space, used for rotation (not implemented yet).</p> <code>None</code> <code>size</code> <code>ndarray</code> <p>Glyph sizes in pixels, each row contains the width and height of each glyph.</p> <code>None</code> <code>anchor</code> <code>ndarray</code> <p>Glyph anchor points in pixels, each row contains the x and y anchor of each glyph.</p> <code>None</code> <code>shift</code> <code>ndarray</code> <p>Glyph shifts in pixels, each row contains the x and y shift of each glyph.</p> <code>None</code> <code>texcoords</code> <code>ndarray</code> <p>Glyph texture coordinates, each row contains the u0,v0,u1,v1 coordinates of each glyph within the font atlas texture.</p> <code>None</code> <code>group_size</code> <code>ndarray</code> <p>Glyph group sizes, each row contains the width and height of the string (i.e., the group of glyphs) the glyph belongs to.</p> <code>None</code> <code>scale</code> <code>ndarray</code> <p>Glyph scales, each row contains the scale factor for each glyph.</p> <code>None</code> <code>angle</code> <code>ndarray</code> <p>Glyph rotation angles in radians, each row contains the angle for each glyph.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Glyph RGBA colors in range 0\u2013255.</p> <code>None</code> <code>bgcolor</code> <code>Tuple[int, int, int, int]</code> <p>Background color for the glyph, in RGBA format.</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the glyph, typically a font atlas texture.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Glyph</code> <p>The created glyph visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.image","title":"image","text":"<pre><code>image(\n    position: ndarray = None,\n    size: ndarray = None,\n    anchor: ndarray = None,\n    texcoords: ndarray = None,\n    facecolor: ndarray = None,\n    edgecolor: Optional[Tuple[int, int, int, int]] = None,\n    permutation: Tuple[int, int] = None,\n    linewidth: float = None,\n    radius: float = None,\n    colormap: Optional[str] = None,\n    texture: Optional[Texture] = None,\n    unit: str = None,\n    mode: str = None,\n    rescale: str = None,\n    border: bool = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Image\n</code></pre> <p>Create an image visual.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray</code> <p>Image 3D positions in normalized device coordinates.</p> <code>None</code> <code>size</code> <code>ndarray</code> <p>Image sizes in pixels or NDC, each row contains the width and height of each image.</p> <code>None</code> <code>anchor</code> <code>ndarray</code> <p>Image anchor in normalized coordinates.</p> <code>None</code> <code>texcoords</code> <code>ndarray</code> <p>Image texture coordinates, each row contains the u0,v0,u1,v1 coordinates of each image within the texture.</p> <code>None</code> <code>facecolor</code> <code>ndarray</code> <p>Image face colors in RGBA format, each row contains the RGBA color of each image.</p> <code>None</code> <code>edgecolor</code> <code>Tuple[int, int, int, int]</code> <p>Image edge color in RGBA format, used for the border.</p> <code>None</code> <code>permutation</code> <code>Tuple[int, int]</code> <p>Permutation of the image texture coordinates, e.g., (0, 1) for normal orientation.</p> <code>None</code> <code>linewidth</code> <code>float</code> <p>Line width for the image border, in pixels.</p> <code>None</code> <code>radius</code> <code>float</code> <p>Radius for the image border, in pixels, or 0 for a square border.</p> <code>None</code> <code>colormap</code> <code>str</code> <p>Colormap to apply to the image, when using the <code>colormap</code> mode.</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the image, typically a 2D texture containing the image data.</p> <code>None</code> <code>unit</code> <code>str</code> <p>Specifies the unit for the image size. Can be:</p> <ul> <li><code>pixels</code> (default): Image size is specified in pixels.</li> <li><code>ndc</code>: Image size depends on the normalized device coordinates (NDC) of the panel.</li> </ul> <code>None</code> <code>mode</code> <code>str</code> <p>Specifies the image mode. Can be:</p> <ul> <li><code>rgba</code> (default): RGBA image mode.</li> <li><code>colormap</code>: Single-channel image with a colormap applied.</li> <li><code>fill</code>: Uniform color fill mode.</li> </ul> <code>None</code> <code>rescale</code> <code>str</code> <p>Specifies how the image should be rescaled with transformations. Can be:</p> <ul> <li><code>None</code> (default): No rescaling.</li> <li><code>rescale</code>: Rescale the image with the panel size.</li> <li><code>keep_ratio</code>: Rescale the image while maintaining its aspect ratio.</li> </ul> <code>None</code> <code>border</code> <code>bool</code> <p>Indicates whether to display a border around the image. Defaults to <code>False</code>.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Image</code> <p>The created image visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.marker","title":"marker","text":"<pre><code>marker(\n    position: ndarray = None,\n    color: ndarray = None,\n    size: ndarray = None,\n    angle: ndarray = None,\n    edgecolor: Tuple[int, int, int, int] = None,\n    linewidth: float = None,\n    tex_scale: float = None,\n    mode: str = None,\n    aspect: str = None,\n    shape: str = None,\n    texture: Optional[Texture] = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Marker\n</code></pre> <p>Create a marker visual.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray</code> <p>Marker 3D positions in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Marker RGBA colors in range 0\u2013255.</p> <code>None</code> <code>size</code> <code>ndarray</code> <p>Marker size in pixels.</p> <code>None</code> <code>angle</code> <code>ndarray</code> <p>Marker rotation angle in radians.</p> <code>None</code> <code>edgecolor</code> <code>cvec4</code> <p>Marker edge color in RGBA format.</p> <code>None</code> <code>linewidth</code> <code>float</code> <p>Marker edge line width in pixels.</p> <code>None</code> <code>tex_scale</code> <code>float</code> <p>Marker texture scale.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Marker mode, one of <code>code</code>, <code>bitmap</code>, <code>sdf</code>, <code>msdf</code>.</p> <code>None</code> <code>aspect</code> <code>str</code> <p>Marker aspect, one of <code>fill</code>, <code>stroke</code>, <code>outline</code>.</p> <code>None</code> <code>shape</code> <code>str</code> <p>Marker shape, when using the <code>code</code> mode, one of <code>disc</code>, <code>asterisk</code>, etc. See the documentation for the full list.</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the marker when using another mode than <code>code</code>.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Marker</code> <p>The created marker visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.mesh","title":"mesh","text":"<pre><code>mesh(\n    shape: ShapeCollection = None,\n    position: ndarray = None,\n    color: ndarray = None,\n    texcoords: ndarray = None,\n    normal: ndarray = None,\n    isoline: ndarray = None,\n    left: ndarray = None,\n    right: ndarray = None,\n    contour: Union[ndarray, bool] = None,\n    index: ndarray = None,\n    light_pos: Tuple[float, float, float, float] = None,\n    light_color: Tuple[int, int, int, int] = None,\n    ambient_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    diffuse_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    specular_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    emission_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    shine: float = None,\n    emit: float = None,\n    edgecolor: Optional[Tuple[int, int, int, int]] = None,\n    linewidth: float = None,\n    density: int = None,\n    texture: Optional[Texture] = None,\n    indexed: Optional[bool] = None,\n    lighting: Optional[bool] = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Mesh\n</code></pre> <p>Create a mesh visual.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>ShapeCollection</code> <p>Create a mesh from a shape collection.</p> <code>None</code> <code>position</code> <code>ndarray</code> <p>Vertex 3D positions in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Vertex RGBA colors in range 0\u2013255.</p> <code>None</code> <code>texcoords</code> <code>ndarray</code> <p>Vertex texture coordinates, each row contains the u0,v0,u1,v1 coordinates of each vertex within the texture.</p> <code>None</code> <code>normal</code> <code>ndarray</code> <p>Vertex normals in normalized device coordinates.</p> <code>None</code> <code>isoline</code> <code>ndarray</code> <p>Scalar field, one value per vertex, is showing isolines.</p> <code>None</code> <code>left</code> <code>ndarray</code> <p>Left values for contours (not documented yet).</p> <code>None</code> <code>right</code> <code>ndarray</code> <p>Right values for contours (not documented yet).</p> <code>None</code> <code>contour</code> <code>ndarray or bool</code> <p>Contour values for the mesh (not documented yet), or a boolean indicating whether to use contours.</p> <code>None</code> <code>index</code> <code>ndarray</code> <p>Vertex indices for indexed meshes (three integers per triangle).</p> <code>None</code> <code>light_pos</code> <code>Tuple[float, float, float, float]</code> <p>Light position in normalized device coordinates, in the form (x, y, z, w). If <code>w</code> is 0, the light is directional; if <code>w</code> is 1, the light is positional.</p> <code>None</code> <code>light_color</code> <code>Tuple[int, int, int, int]</code> <p>Light color in RGBA format, in the form (r, g, b, a).</p> <code>None</code> <code>ambient_params</code> <code>Tuple[float, float, float]</code> <p>Material ambient parameters for the mesh, in the form (r, g, b).</p> <code>None</code> <code>diffuse_params</code> <code>Tuple[float, float, float]</code> <p>Material diffuse parameters for the mesh, in the form (r, g, b).</p> <code>None</code> <code>specular_params</code> <code>Tuple[float, float, float]</code> <p>Material specular parameters for the mesh, in the form (r, g, b).</p> <code>None</code> <code>emission_params</code> <code>Tuple[float, float, float]</code> <p>Material emission parameters for the mesh, in the form (r, g, b).</p> <code>None</code> <code>shine</code> <code>float</code> <p>Material shine factor for the mesh, in the range [0, 1].</p> <code>None</code> <code>emit</code> <code>float</code> <p>Material emission factor for the mesh, in the range [0, 1].</p> <code>None</code> <code>edgecolor</code> <code>Tuple[int, int, int, int]</code> <p>Edge color for the mesh, in RGBA format, when showing contours or isolines.</p> <code>None</code> <code>linewidth</code> <code>float</code> <p>Line width for the mesh edges, in pixels, when showing contours or isolines.</p> <code>None</code> <code>density</code> <code>int</code> <p>Density of isolines, in pixels, when showing isolines.</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the mesh, when using textured mesh.</p> <code>None</code> <code>indexed</code> <code>bool</code> <p>Whether the mesh is indexed. If <code>True</code>, the mesh will use indices for vertices.</p> <code>None</code> <code>lighting</code> <code>bool</code> <p>Whether lighting is enabled.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Mesh</code> <p>The created mesh visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.on_frame","title":"on_frame","text":"<pre><code>on_frame(figure: Figure) -&gt; tp.Callable\n</code></pre> <p>Register a frame event handler for the given figure.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to attach the handler to.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for the frame event handler.</p>"},{"location":"reference/api_py/#datoviz._app.App.on_gui","title":"on_gui","text":"<pre><code>on_gui(figure: Figure) -&gt; tp.Callable\n</code></pre> <p>Register a GUI event handler for the given figure.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to attach the handler to.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for the GUI event handler.</p>"},{"location":"reference/api_py/#datoviz._app.App.on_keyboard","title":"on_keyboard","text":"<pre><code>on_keyboard(figure: Figure) -&gt; tp.Callable\n</code></pre> <p>Register a keyboard event handler for the given figure.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to attach the handler to.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for the keyboard event handler.</p>"},{"location":"reference/api_py/#datoviz._app.App.on_mouse","title":"on_mouse","text":"<pre><code>on_mouse(figure: Figure) -&gt; tp.Callable\n</code></pre> <p>Register a mouse event handler for the given figure.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to attach the handler to.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for the mouse event handler.</p>"},{"location":"reference/api_py/#datoviz._app.App.on_resize","title":"on_resize","text":"<pre><code>on_resize(figure: Figure) -&gt; tp.Callable\n</code></pre> <p>Register a resize event handler for the given figure.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to attach the handler to.</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for the resize event handler.</p>"},{"location":"reference/api_py/#datoviz._app.App.path","title":"path","text":"<pre><code>path(\n    position: ndarray = None,\n    color: ndarray = None,\n    linewidth: ndarray = None,\n    cap: str = None,\n    join: str = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Path\n</code></pre> <p>Create a path visual.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray, or list of ndarray</code> <p>An array of positions, or a list of arrays representing the positions of the paths.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Point RGBA colors in range 0\u2013255.</p> <code>None</code> <code>linewidth</code> <code>ndarray</code> <p>Uniform or varying line width for each path point.</p> <code>None</code> <code>cap</code> <code>str</code> <p>Cap style for all paths, one of <code>butt</code>, <code>round</code>, <code>square</code>, <code>triangle_in</code>, <code>triangle_out</code>.</p> <code>None</code> <code>join</code> <code>str</code> <p>Join style for all paths, one of <code>square</code>, <code>round</code>.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>The created path visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.pixel","title":"pixel","text":"<pre><code>pixel(\n    position: ndarray = None,\n    color: ndarray = None,\n    size: float = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Pixel\n</code></pre> <p>Create a pixel visual.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray</code> <p>Point 3D positions in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Point RGBA colors in range 0\u2013255.</p> <code>None</code> <code>size</code> <code>float</code> <p>Point size in pixels, when using the <code>point_list</code> topology.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Pixel</code> <p>The created pixel visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.point","title":"point","text":"<pre><code>point(\n    position: ndarray = None,\n    color: ndarray = None,\n    size: ndarray = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Point\n</code></pre> <p>Create a point visual.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray</code> <p>Point 3D positions in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Point RGBA colors in range 0\u2013255.</p> <code>None</code> <code>size</code> <code>ndarray</code> <p>Point size in pixels.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Point</code> <p>The created point visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.run","title":"run","text":"<pre><code>run(frame_count: int = 0) -&gt; None\n</code></pre> <p>Run the application.</p> <p>Parameters:</p> Name Type Description Default <code>frame_count</code> <code>int</code> <p>Number of frames to run. 0 for infinite, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz._app.App.screenshot","title":"screenshot","text":"<pre><code>screenshot(figure: Figure, png_path: str) -&gt; None\n</code></pre> <p>Take a screenshot of the given figure.</p> <p>This function first runs one frame before saving the screenshot.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to capture.</p> required <code>png_path</code> <code>str</code> <p>Path to save the screenshot.</p> required"},{"location":"reference/api_py/#datoviz._app.App.segment","title":"segment","text":"<pre><code>segment(\n    initial: ndarray = None,\n    terminal: ndarray = None,\n    shift: ndarray = None,\n    color: ndarray = None,\n    linewidth: ndarray = None,\n    cap: str = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Segment\n</code></pre> <p>Create a segment visual.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>ndarray</code> <p>3D positions of the initial end of each segment, in normalized device coordinates.</p> <code>None</code> <code>terminal</code> <code>ndarray</code> <p>3D positions of the terminal end of each segment, in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Segment RGBA colors in range 0\u2013255.</p> <code>None</code> <code>shift</code> <code>ndarray</code> <p>Shift vector for each segment, in pixels. Each row of this 2D array contains the pixel shift of the initial and terminal end of each segment (x0,y0,x1,y1), in framebuffer coordinates.</p> <code>None</code> <code>linewidth</code> <code>ndarray</code> <p>Line width for each segment, in pixels.</p> <code>None</code> <code>cap</code> <code>str</code> <p>Cap style for the segment, one of <code>butt</code>, <code>round</code>, <code>square</code>, <code>triangle_in</code>, <code>triangle_out</code>.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Segment</code> <p>The created segment visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.slice","title":"slice","text":"<pre><code>slice() -&gt; vs.Slice\n</code></pre> <p>Not implemented yet.</p>"},{"location":"reference/api_py/#datoviz._app.App.sphere","title":"sphere","text":"<pre><code>sphere(\n    position: ndarray = None,\n    color: ndarray = None,\n    size: ndarray = None,\n    light_pos: Optional[\n        Tuple[float, float, float, float]\n    ] = None,\n    light_color: Optional[Tuple[int, int, int, int]] = None,\n    ambient_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    diffuse_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    specular_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    emission_params: Optional[\n        Tuple[float, float, float]\n    ] = None,\n    shine: Optional[float] = None,\n    emit: Optional[float] = None,\n    texture: Optional[Texture] = None,\n    equal_rectangular: Optional[bool] = None,\n    lighting: Optional[bool] = None,\n    size_pixels: Optional[bool] = None,\n    depth_test: bool = None,\n    cull: str = None,\n) -&gt; vs.Sphere\n</code></pre> <p>Create a sphere visual.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray</code> <p>Sphere 3D positions in normalized device coordinates.</p> <code>None</code> <code>color</code> <code>ndarray</code> <p>Sphere RGBA colors in range 0\u2013255.</p> <code>None</code> <code>size</code> <code>ndarray</code> <p>Sphere sizes in pixels or NDC, depending on <code>size_pixels</code>.</p> <code>None</code> <code>light_pos</code> <code>Tuple[float, float, float, float]</code> <p>Light position in normalized device coordinates, in the form (x, y, z, w). If <code>w</code> is 0, the light is directional; if <code>w</code> is 1, the light is positional.</p> <code>None</code> <code>light_color</code> <code>Tuple[int, int, int, int]</code> <p>Light color in RGBA format, in the form (r, g, b, a).</p> <code>None</code> <code>ambient_params</code> <code>Tuple[float, float, float]</code> <p>Material ambient parameters for the sphere, in the form (r, g, b).</p> <code>None</code> <code>diffuse_params</code> <code>Tuple[float, float, float]</code> <p>Material diffuse parameters for the sphere, in the form (r, g, b).</p> <code>None</code> <code>specular_params</code> <code>Tuple[float, float, float]</code> <p>Material specular parameters for the sphere, in the form (r, g, b).</p> <code>None</code> <code>emission_params</code> <code>Tuple[float, float, float]</code> <p>Material emission parameters for the sphere, in the form (r, g, b).</p> <code>None</code> <code>shine</code> <code>float</code> <p>Material shine factor for the sphere, in the range [0, 1].</p> <code>None</code> <code>emit</code> <code>float</code> <p>Material emission factor for the sphere, in the range [0, 1].</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the sphere, when using a textured sphere.</p> <code>None</code> <code>equal_rectangular</code> <code>bool</code> <p>Texture is equal rectangular.</p> <code>None</code> <code>lighting</code> <code>bool</code> <p>Whether lighting is enabled.</p> <code>None</code> <code>size_pixels</code> <code>bool</code> <p>Whether to specify the sphere size in pixels rather than NDC.</p> <code>None</code> <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Sphere</code> <p>The created sphere visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the application.</p>"},{"location":"reference/api_py/#datoviz._app.App.texture","title":"texture","text":"<pre><code>texture(\n    image: Optional[ndarray] = None,\n    ndim: int = 2,\n    shape: Optional[Tuple[int, ...]] = None,\n    n_channels: Optional[int] = None,\n    dtype: Optional[dtype] = None,\n    interpolation: Optional[str] = None,\n    address_mode: Optional[str] = None,\n) -&gt; Texture\n</code></pre> <p>Create a texture, either with or without initial image data. If without, all texture parameters must be specified.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Image data for the texture, by default None.</p> <code>None</code> <code>ndim</code> <code>int</code> <p>Number of texture dimensions (1, 2, or 3), by default 2.</p> <code>2</code> <code>shape</code> <code>tuple of int</code> <p>Shape of the texture, inferred from <code>image</code> if set.</p> <code>None</code> <code>n_channels</code> <code>int</code> <p>Number of color channels, inferred from <code>image</code> if set.</p> <code>None</code> <code>dtype</code> <code>dtype</code> <p>Data type of the texture, inferred from <code>image</code> if set.</p> <code>None</code> <code>interpolation</code> <code>str</code> <p>Interpolation mode, <code>nearest</code> (default) or <code>linear</code>.</p> <code>None</code> <code>address_mode</code> <code>str</code> <p>Address mode: <code>repeat</code>, <code>mirrored_repeat</code>, <code>clamp_to_edge</code>, <code>clamp_to_border</code> (default), <code>mirror_clamp_to_edge</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Texture</code> <p>The created texture instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.texture_1D","title":"texture_1D","text":"<pre><code>texture_1D(\n    data: ndarray,\n    interpolation: Optional[str] = None,\n    address_mode: Optional[str] = None,\n) -&gt; Texture\n</code></pre> <p>Create a 1D texture.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Data for the texture.</p> required <code>interpolation</code> <code>str</code> <p>Interpolation mode (see <code>texture()</code>)</p> <code>None</code> <code>address_mode</code> <code>str</code> <p>Address mode (see <code>texture()</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Texture</code> <p>The created 1D texture instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.texture_2D","title":"texture_2D","text":"<pre><code>texture_2D(\n    image: ndarray,\n    interpolation: Optional[str] = None,\n    address_mode: Optional[str] = None,\n) -&gt; Texture\n</code></pre> <p>Create a 2D texture.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Image data for the texture.</p> required <code>interpolation</code> <code>str</code> <p>Interpolation mode (see <code>texture()</code>)</p> <code>None</code> <code>address_mode</code> <code>str</code> <p>Address mode (see <code>texture()</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Texture</code> <p>The created 2D texture instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.texture_3D","title":"texture_3D","text":"<pre><code>texture_3D(\n    volume: ndarray,\n    shape: Optional[Tuple[int, ...]] = None,\n    interpolation: Optional[str] = None,\n    address_mode: Optional[str] = None,\n) -&gt; Texture\n</code></pre> <p>Create a 3D texture.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>ndarray</code> <p>Volume data for the texture.</p> required <code>shape</code> <code>tuple of int</code> <p>Shape of the texture, by default None.</p> <code>None</code> <code>interpolation</code> <code>str</code> <p>Interpolation mode (see <code>texture()</code>)</p> <code>None</code> <code>address_mode</code> <code>str</code> <p>Address mode (see <code>texture()</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Texture</code> <p>The created 3D texture instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.timer","title":"timer","text":"<pre><code>timer(\n    delay: float = 0.0,\n    period: float = 1.0,\n    max_count: int = 0,\n) -&gt; tp.Callable\n</code></pre> <p>Register a timer event.</p> <p>Parameters:</p> Name Type Description Default <code>delay</code> <code>float</code> <p>Initial delay before the timer starts, by default 0.0.</p> <code>0.0</code> <code>period</code> <code>float</code> <p>Period of the timer in seconds, by default 1.0 second.</p> <code>1.0</code> <code>max_count</code> <code>int</code> <p>Maximum number of timer events, or 0 for unlimited timer ticks, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator for the timer event handler.</p>"},{"location":"reference/api_py/#datoviz._app.App.timestamps","title":"timestamps","text":"<pre><code>timestamps(\n    figure: Figure, count: int\n) -&gt; Tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Get presentation timestamps for the given figure.</p> <p>Parameters:</p> Name Type Description Default <code>figure</code> <code>Figure</code> <p>The figure to get timestamps for.</p> required <code>count</code> <code>int</code> <p>Number of timestamps.</p> required <p>Returns:</p> Type Description <code>tuple of np.ndarray</code> <p>Seconds and nanoseconds arrays.</p>"},{"location":"reference/api_py/#datoviz._app.App.volume","title":"volume","text":"<pre><code>volume(\n    bounds: Tuple[\n        Tuple[float, float],\n        Tuple[float, float],\n        Tuple[float, float],\n    ] = None,\n    permutation: Tuple[int, int, int] = None,\n    slice: int = None,\n    transfer: Tuple[float, float, float, float] = None,\n    texture: Optional[Texture] = None,\n    mode: str = \"colormap\",\n) -&gt; vs.Volume\n</code></pre> <p>Create a volume visual.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]</code> <p>Bounds of the volume in normalized device coordinates, as three tuples (xmin, xmax), (ymin, ymax), (zmin, zmax).</p> <code>None</code> <code>permutation</code> <code>Tuple[int, int, int]</code> <p>Permutation of the volume axes, e.g., (0, 1, 2) for normal orientation.</p> <code>None</code> <code>slice</code> <code>int</code> <p>Slice index to display (not implemented yet).</p> <code>None</code> <code>transfer</code> <code>Tuple[float, float, float, float]</code> <p>Transfer function parameters for the volume (only the first value is used for now).</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the volume, typically a 3D texture containing the volume data.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Volume mode ('rgba', 'colormap'), by default 'colormap'.</p> <code>'colormap'</code> <p>Returns:</p> Type Description <code>Volume</code> <p>The created volume visual instance.</p>"},{"location":"reference/api_py/#datoviz._app.App.wiggle","title":"wiggle","text":"<pre><code>wiggle(\n    bounds: Optional[\n        Tuple[Tuple[float, float], Tuple[float, float]]\n    ] = None,\n    negative_color: Optional[\n        Tuple[int, int, int, int]\n    ] = None,\n    positive_color: Optional[\n        Tuple[int, int, int, int]\n    ] = None,\n    edgecolor: Optional[Tuple[int, int, int, int]] = None,\n    xrange: Optional[Tuple[float, float]] = None,\n    scale: Optional[float] = None,\n    texture: Optional[Texture] = None,\n) -&gt; vs.Wiggle\n</code></pre> <p>Create a Wiggle visual.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>tuple of tuples</code> <p>Bounds for the wiggle plot, in the form ((xmin, xmax), (ymin, ymax)).</p> <code>None</code> <code>negative_color</code> <code>Tuple[int, int, int, int]</code> <p>Color for the negative wiggle values, in RGBA format.</p> <code>None</code> <code>positive_color</code> <code>Tuple[int, int, int, int]</code> <p>Color for the positive wiggle values, in RGBA format.</p> <code>None</code> <code>edgecolor</code> <code>Tuple[int, int, int, int]</code> <p>Line color in RGBA format.</p> <code>None</code> <code>xrange</code> <code>tuple of float</code> <p>Range of the x-axis for the wiggle plot, in the form (x0, xl).</p> <code>None</code> <code>scale</code> <code>float</code> <p>Scale factor for the wiggle plot, applied to the wiggle values.</p> <code>None</code> <code>texture</code> <code>Texture</code> <p>Texture for the wiggle, a 2D texture containing the data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Wiggle</code> <p>The created wiggle visual instance.</p>"},{"location":"reference/api_py/#datoviz._figure.Figure","title":"datoviz._figure.Figure","text":"<pre><code>Figure(c_figure: DvzFigure, app: Optional[App] = None)\n</code></pre> <p>Represents a figure, which is a container for panels.</p> <p>Initialize a Figure instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_figure</code> <code>DvzFigure</code> <p>The underlying C figure object.</p> required <code>app</code> <code>App</code> <p>The App instance.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz._figure.Figure.colorbar","title":"colorbar","text":"<pre><code>colorbar(\n    cmap: str = \"hsv\", dmin: float = 0, dmax: float = 1\n)\n</code></pre> <p>Create a colorbar in the figure.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>The colormap name.</p> <code>'hsv'</code> <code>dmin</code> <code>float</code> <p>Minimum data value.</p> <code>0</code> <code>dmax</code> <code>float</code> <p>Maximum data value.</p> <code>1</code> <p>Returns:</p> Type Description <code>Colorbar</code> <p>The created colorbar instance.</p>"},{"location":"reference/api_py/#datoviz._figure.Figure.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> <p>Destroy the figure.</p>"},{"location":"reference/api_py/#datoviz._figure.Figure.figure_id","title":"figure_id","text":"<pre><code>figure_id() -&gt; int\n</code></pre> <p>Get the Datoviz internal ID of the figure.</p> <p>Returns:</p> Type Description <code>int</code> <p>The ID of the figure.</p>"},{"location":"reference/api_py/#datoviz._figure.Figure.panel","title":"panel","text":"<pre><code>panel(\n    offset: Tuple[float, float] = None,\n    size: Tuple[float, float] = None,\n    background: Tuple[\n        Tuple[int, int, int, int],\n        Tuple[int, int, int, int],\n        Tuple[int, int, int, int],\n        Tuple[int, int, int, int],\n    ] = None,\n) -&gt; Panel\n</code></pre> <p>Create a new panel in the figure.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y) offset of the panel, in pixels, by default (0, 0).</p> <code>None</code> <code>size</code> <code>tuple of float</code> <p>The (width, height) size of the panel, by default the entire window size.</p> <code>None</code> <code>background</code> <code>tuple or boolean</code> <p>If True, show a default gradient background. Otherwise, a tuple of four RGBA colors, for each corner of the panel (top-left, top-right, bottom-left, bottom-right).</p> <code>None</code> <p>Returns:</p> Type Description <code>Panel</code> <p>The created panel instance.</p>"},{"location":"reference/api_py/#datoviz._figure.Figure.set_fullscreen","title":"set_fullscreen","text":"<pre><code>set_fullscreen(fullscreen: bool) -&gt; None\n</code></pre> <p>Set figure to fullscreen mode.</p> <p>Parameters:</p> Name Type Description Default <code>is_fullscreen</code> <code>True for fullscreen mode, False for window mode.</code> required"},{"location":"reference/api_py/#datoviz._figure.Figure.size","title":"size","text":"<pre><code>size()\n</code></pre> <p>Get the size of the figure in pixels.</p> <p>Returns:</p> Type Description <code>tuple of int</code> <p>The (width, height) of the figure.</p>"},{"location":"reference/api_py/#datoviz._figure.Figure.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the figure.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel","title":"datoviz._panel.Panel","text":"<pre><code>Panel(c_panel: DvzPanel, figure: Optional[Figure] = None)\n</code></pre> <p>Represents a panel in a figure, which can contain visuals and interactivity.</p> <p>Initialize a Panel instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_panel</code> <code>DvzPanel</code> <p>The underlying C panel object.</p> required <code>figure</code> <code>Figure</code> <p>The figure to which the panel belongs, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz._panel.Panel.add","title":"add","text":"<pre><code>add(visual: Visual) -&gt; None\n</code></pre> <p>Add a visual to the panel.</p> <p>Parameters:</p> Name Type Description Default <code>visual</code> <code>Visual</code> <p>The visual to add.</p> required"},{"location":"reference/api_py/#datoviz._panel.Panel.arcball","title":"arcball","text":"<pre><code>arcball(\n    initial: Optional[Vec3] = None, c_flags: int = 0\n) -&gt; Arcball\n</code></pre> <p>Add arcball interactivity to the panel.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>Vec3</code> <p>Initial position of the arcball, by default None.</p> <code>None</code> <code>c_flags</code> <code>int</code> <p>Datoviz flags for the arcball interactivity, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Arcball</code> <p>The arcball interactivity instance.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.arcball_gui","title":"arcball_gui","text":"<pre><code>arcball_gui() -&gt; None\n</code></pre> <p>Attach an arcball GUI to a panel.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.axes","title":"axes","text":"<pre><code>axes(\n    xlim: Tuple[float, float] = None,\n    ylim: Tuple[float, float] = None,\n)\n</code></pre> <p>Add 2D axes to the panel.</p> <p>Parameters:</p> Name Type Description Default <code>xlim</code> <code>Tuple[float, float]</code> <p>The limits for the x-axis, by default None.</p> <code>None</code> <code>ylim</code> <code>Tuple[float, float]</code> <p>The limits for the y-axis, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz._panel.Panel.camera","title":"camera","text":"<pre><code>camera(\n    initial: Optional[Vec3] = None,\n    initial_lookat: Optional[Vec3] = None,\n    initial_up: Optional[Vec3] = None,\n    c_flags: int = 0,\n) -&gt; Camera\n</code></pre> <p>Add 3D camera interactivity to the panel.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>Vec3</code> <p>Initial camera position, by default None.</p> <code>None</code> <code>initial_lookat</code> <code>Vec3</code> <p>Initial look-at position, by default None.</p> <code>None</code> <code>initial_up</code> <code>Vec3</code> <p>Initial up vector, by default None.</p> <code>None</code> <code>c_flags</code> <code>int</code> <p>Datoviz flags for the camera interactivity, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Camera</code> <p>The camera interactivity instance.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.demo_2D","title":"demo_2D","text":"<pre><code>demo_2D() -&gt; Visual\n</code></pre> <p>Add a 2D demo visual to the panel.</p> <p>Returns:</p> Type Description <code>Visual</code> <p>The 2D demo visual instance.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.demo_3D","title":"demo_3D","text":"<pre><code>demo_3D() -&gt; Visual\n</code></pre> <p>Add a 3D demo visual to the panel.</p> <p>Returns:</p> Type Description <code>Visual</code> <p>The 3D demo visual instance.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.fly","title":"fly","text":"<pre><code>fly(\n    initial: Optional[Vec3] = None,\n    initial_lookat: Optional[Vec3] = None,\n    c_flags: int = 0,\n) -&gt; Fly\n</code></pre> <p>Add fly camera controller to the panel.</p> <p>Similar to first-person camera controls in 3D video games:</p> <ul> <li>Left mouse drag: Look around (yaw/pitch)</li> <li>Right mouse drag: Orbit around a dynamic center (in front of the camera)</li> <li>Middle mouse drag: Move the camera left/right and up/down</li> <li>Arrow keys: Move in view direction (up/down) or strafe (left/right)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>tuple</code> <p>Initial x, y, z coordinates of the fly camera.</p> <code>None</code> <code>initial_lookat</code> <code>Vec3</code> <p>Initial look-at position, by default None.</p> <code>None</code> <code>c_flags</code> <code>int</code> <p>Flags for the fly controller, by default 0</p> <ul> <li>DVZ_FLY_FLAGS_NONE: No special behavior</li> <li>DVZ_FLY_FLAGS_INVERT_MOUSE: Invert mouse look controls</li> </ul> <code>0</code> <p>Returns:</p> Type Description <code>Fly</code> <p>The fly camera controller instance</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.gizmo","title":"gizmo","text":"<pre><code>gizmo() -&gt; None\n</code></pre> <p>Add a 3D gizmo to a 3D panel with an arcball.</p> <p>This function displays at the bottom right of the panel three 3D arrows representing the X (red), Y (green), and Z (blue) axes, which rotate with the arcball.</p> <p>Warning</p> <p>This feature is still experimental. A known issue is that the gizmo may be obscured by other visuals in the scene if they are rendered in front of it. This will be fixed in version 0.4.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.gui","title":"gui","text":"<pre><code>gui(title: Optional[str] = None, c_flags: int = 0) -&gt; None\n</code></pre> <p>Convert a standard Datoviz panel to a movable GUI panel.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the GUI, by default 'Panel'.</p> <code>None</code> <code>c_flags</code> <code>int</code> <p>Datoviz flags for the GUI, by default 0.</p> <code>0</code> Warnings <p>This functionality is still experimental.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.horizontal_grid","title":"horizontal_grid","text":"<pre><code>horizontal_grid(elevation: float = 0)\n</code></pre> <p>Add a horizontal grid texture on the y=0 plane, using a repeating pattern.</p> <p>Parameters:</p> Name Type Description Default <code>elevation</code> <code>float</code> <p>Elevation of the grid on the Y axis.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz._panel.Panel.link","title":"link","text":"<pre><code>link(\n    target: Panel,\n    model: bool = False,\n    view: bool = False,\n    projection: bool = False,\n) -&gt; None\n</code></pre> <p>Link the current panel to another panel.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Panel</code> <p>The target panel to link to.</p> required <code>model</code> <code>bool</code> <p>Whether to link the model matrix, by default False.</p> <code>False</code> <code>view</code> <code>bool</code> <p>Whether to link the view matrix, by default False.</p> <code>False</code> <code>projection</code> <code>bool</code> <p>Whether to link the projection matrix, by default False.</p> <code>False</code>"},{"location":"reference/api_py/#datoviz._panel.Panel.margins","title":"margins","text":"<pre><code>margins(\n    top: float = 0,\n    right: float = 0,\n    bottom: float = 0,\n    left: float = 0,\n) -&gt; None\n</code></pre> <p>Set the margins of the panel.</p> <p>Parameters:</p> Name Type Description Default <code>top</code> <code>float</code> <p>Top margin in pixels, by default 0.</p> <code>0</code> <code>right</code> <code>float</code> <p>Right margin in pixels, by default 0.</p> <code>0</code> <code>bottom</code> <code>float</code> <p>Bottom margin in pixels, by default 0.</p> <code>0</code> <code>left</code> <code>float</code> <p>Left margin in pixels, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz._panel.Panel.orbit","title":"orbit","text":"<pre><code>orbit(\n    center: Tuple[float, float, float] = (0, 0, 0),\n    axis: Tuple[float, float, float] = (0, 1, 0),\n    period: float = 5.0,\n)\n</code></pre> <p>Continuously orbits the camera around a fixed center point.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float, float]</code> <p>The point around which the camera orbits.</p> <code>(0, 0, 0)</code> <code>axis</code> <code>Tuple[float, float, float]</code> <p>The axis around which the camera orbits.</p> <code>(0, 1, 0)</code> <code>period</code> <code>float</code> <p>Duration of one full orbit in seconds.</p> <code>5.0</code>"},{"location":"reference/api_py/#datoviz._panel.Panel.ortho","title":"ortho","text":"<pre><code>ortho(c_flags: int = 0) -&gt; Ortho\n</code></pre> <p>Add orthographic interactivity to the panel.</p> <p>Parameters:</p> Name Type Description Default <code>c_flags</code> <code>int</code> <p>Datoviz flags for the orthographic interactivity, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Ortho</code> <p>The orthographic interactivity instance.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.panzoom","title":"panzoom","text":"<pre><code>panzoom(\n    c_flags: int = 0, fixed: Optional[str] = None\n) -&gt; Panzoom\n</code></pre> <p>Add panzoom interactivity to the panel.</p> <p>Parameters:</p> Name Type Description Default <code>c_flags</code> <code>int</code> <p>Datoviz flags for the panzoom interactivity, by default 0.</p> <code>0</code> <code>fixed</code> <code>str</code> <p>'x' or 'y' to fix the panzoom interactivity along a given axis.</p> <code>None</code> <p>Returns:</p> Type Description <code>Panzoom</code> <p>The panzoom interactivity instance.</p>"},{"location":"reference/api_py/#datoviz._panel.Panel.remove","title":"remove","text":"<pre><code>remove(visual: Visual) -&gt; None\n</code></pre> <p>Remove a visual from the panel.</p> <p>Parameters:</p> Name Type Description Default <code>visual</code> <code>Visual</code> <p>The visual to remove.</p> required"},{"location":"reference/api_py/#datoviz._panel.Panel.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the panel.</p>"},{"location":"reference/api_py/#datoviz._axes.Axes","title":"datoviz._axes.Axes","text":"<pre><code>Axes(\n    c_axes: DvzAxes,\n    c_ref: DvzRef,\n    c_panzoom: DvzPanzoom,\n    c_panel: DvzPanel,\n)\n</code></pre> <p>Represents 2D axes.</p> <p>Initialize an Axes instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_axes</code> <code>DvzAxes</code> <p>The underlying C axes object.</p> required <code>c_ref</code> <code>DvzRef</code> <p>The underlying C ref object.</p> required <code>c_panzoom</code> <code>DvzPanzoom</code> <p>The underlying C panzoom object.</p> required <code>c_panel</code> <code>DvzPanel</code> <p>The underlying C panel object.</p> required"},{"location":"reference/api_py/#datoviz._axes.Axes.bounds","title":"bounds","text":"<pre><code>bounds()\n</code></pre> <p>Return the bounds of the panzoom area.</p> <p>This method computes the minimum and maximum bounds for both the x-axis and y-axis of the panzoom area.</p> <p>Returns:</p> Type Description <code>tuple of xlim (xmin, xmax) and ylim (ymin, ymax)</code>"},{"location":"reference/api_py/#datoviz._axes.Axes.normalize","title":"normalize","text":"<pre><code>normalize(x: ndarray, y: ndarray = None, z: ndarray = None)\n</code></pre> <p>Normalize input coordinates to a standard range.</p> <p>This function normalizes 1D, 2D, or 3D input coordinates using a reference normalization method. The input can be provided as a single array or as separate arrays for each dimension.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The array representing the x-coordinates. If <code>y</code> and <code>z</code> are not provided, this is treated as the full input array.</p> required <code>y</code> <code>ndarray</code> <p>The array representing the y-coordinates. If not provided, the input is assumed to be 1D.</p> <code>None</code> <code>z</code> <code>ndarray</code> <p>The array representing the z-coordinates. If not provided, the input is assumed to be 2D.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A normalized array of shape <code>(n, 3)</code> where <code>n</code> is the number of input points. The output is always 3D, with unused dimensions filled with zeros.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the input array does not have the correct dimensions.</p> <code>NotImplementedError</code> <p>If the input dimensionality is not 1D, 2D, or 3D.</p> Notes <p>This function uses <code>dvz.ref_normalize_1D</code>, <code>dvz.ref_normalize_2D</code>, or <code>dvz.ref_normalize_3D</code> for normalization, depending on the dimensionality of the input.</p>"},{"location":"reference/api_py/#datoviz._axes.Axes.normalize_polygon","title":"normalize_polygon","text":"<pre><code>normalize_polygon(points: ndarray)\n</code></pre> <p>Normalize a polygon by transforming its points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>A 2D array of shape (n, 2) containing the coordinates of the polygon's points. The array must have a dtype of <code>np.float64</code>.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A 2D array of shape (n, 2) containing the normalized coordinates of the polygon's points.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>points</code> is not a 2D array or does not have a shape of (n, 2).</p>"},{"location":"reference/api_py/#datoviz._axes.Axes.xlim","title":"xlim","text":"<pre><code>xlim(xmin: float, xmax: float)\n</code></pre> <p>Set the xlim of the axes.</p> <p>Parameters:</p> Name Type Description Default <code>xmin</code> <code>float</code> <p>The minimal x in data coordinates.</p> required <code>xmax</code> <code>float</code> <p>The maximal x in data coordinates.</p> required"},{"location":"reference/api_py/#datoviz._axes.Axes.ylim","title":"ylim","text":"<pre><code>ylim(ymin: float, ymax: float)\n</code></pre> <p>Set the ylim of the axes.</p> <p>Parameters:</p> Name Type Description Default <code>ymin</code> <code>float</code> <p>The minimal y in data coordinates.</p> required <code>ymax</code> <code>float</code> <p>The maximal y in data coordinates.</p> required"},{"location":"reference/api_py/#datoviz.interact.Panzoom","title":"datoviz.interact.Panzoom","text":"<pre><code>Panzoom(c_panzoom: DvzPanzoom, c_panel: DvzPanel = None)\n</code></pre> <p>Represents panzoom interactivity for a panel.</p> <p>Initialize a Panzoom instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_panzoom</code> <code>DvzPanzoom</code> <p>The underlying C panzoom object.</p> required <code>c_panel</code> <code>DvzPanel</code> <p>The panel to which the panzoom interactivity is attached, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.interact.Panzoom.zoom","title":"zoom","text":"<pre><code>zoom(zx: float = 1.0, zy: float = 1.0)\n</code></pre> <p>Set the zoom factor.</p> <p>Parameters:</p> Name Type Description Default <code>zx</code> <code>float</code> <p>The zoom factor along the X axis.</p> <code>1.0</code> <code>zy</code> <code>float</code> <p>The zoom factor along the Y axis.</p> <code>1.0</code>"},{"location":"reference/api_py/#datoviz.interact.Arcball","title":"datoviz.interact.Arcball","text":"<pre><code>Arcball(c_arcball: DvzArcball, c_panel: DvzPanel = None)\n</code></pre> <p>Represents arcball interactivity for a panel.</p> <p>Initialize an Arcball instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_arcball</code> <code>DvzArcball</code> <p>The underlying C arcball object.</p> required <code>c_panel</code> <code>DvzPanel</code> <p>The panel to which the arcball interactivity is attached, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.interact.Arcball.get","title":"get","text":"<pre><code>get() -&gt; Tuple[float, float, float]\n</code></pre> <p>Get the current angles of the arcball.</p> <p>Returns:</p> Type Description <code>tuple of float</code> <p>The (x, y, z) angles of the arcball.</p>"},{"location":"reference/api_py/#datoviz.interact.Arcball.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the arcball to its initial state.</p>"},{"location":"reference/api_py/#datoviz.interact.Arcball.set","title":"set","text":"<pre><code>set(angles: Tuple[float, float, float]) -&gt; None\n</code></pre> <p>Set the angles of the arcball.</p> <p>Parameters:</p> Name Type Description Default <code>angles</code> <code>tuple of float</code> <p>The (x, y, z) angles to set.</p> required"},{"location":"reference/api_py/#datoviz._texture.Texture","title":"datoviz._texture.Texture","text":"<pre><code>Texture(\n    c_texture: DvzTexture,\n    c_batch: DvzApp = None,\n    ndim: int = None,\n)\n</code></pre> <p>Represents a texture in the application.</p> <p>Initialize a Texture instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_texture</code> <code>DvzTexture</code> <p>The underlying C texture object.</p> required <code>c_batch</code> <code>DvzBatch</code> <p>The underlying C app object.</p> <code>None</code> <code>ndim</code> <code>int</code> <p>The number of dimensions in the texture.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz._texture.Texture.data","title":"data","text":"<pre><code>data(image: ndarray, offset: Tuple[int, int, int] = None)\n</code></pre> <p>Upload an image to the texture with an optional offset.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>The image data to upload.</p> required <code>offset</code> <code>Tuple[int, int, int]</code> <p>The offset at which to upload the image in the texture. Defaults to (0, 0, 0).</p> <code>None</code> Notes <p>The function determines the width, height, and depth of the image based on its shape. It then uploads the image data to the texture using the <code>dvz.upload_tex</code> function.</p>"},{"location":"reference/api_py/#datoviz._event.Event","title":"datoviz._event.Event","text":"<pre><code>Event(c_ev: Any, event_type: str)\n</code></pre> <p>Represents an event in the application, such as mouse or keyboard input.</p> <p>Initialize an Event instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_ev</code> <code>Any</code> <p>The underlying C event object.</p> required <code>event_type</code> <code>str</code> <p>The type of the event (e.g., 'mouse', 'keyboard', 'timer').</p> required"},{"location":"reference/api_py/#datoviz._event.Event.type","title":"type  <code>property</code>","text":"<pre><code>type: int\n</code></pre> <p>Get the C event type.</p> <p>Returns:</p> Type Description <code>int</code> <p>The C event type as an integer.</p>"},{"location":"reference/api_py/#datoviz._event.Event.button","title":"button","text":"<pre><code>button() -&gt; Optional[int]\n</code></pre> <p>Get the mouse button C enumeration associated with the event.</p> <p>Returns:</p> Type Description <code>int or None</code> <p>The mouse button, or None if not a mouse event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.button_name","title":"button_name","text":"<pre><code>button_name() -&gt; Optional[str]\n</code></pre> <p>Get the name of the mouse button.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>The name of the mouse button (<code>left</code>, <code>right</code> or <code>middle</code>), or None if not a mouse event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.frame_idx","title":"frame_idx","text":"<pre><code>frame_idx()\n</code></pre> <p>Return the current frame index of a frame event.</p> <p>Returns:</p> Type Description <code>int</code> <p>The frame index, starting from 0.</p>"},{"location":"reference/api_py/#datoviz._event.Event.is_frame","title":"is_frame","text":"<pre><code>is_frame() -&gt; bool\n</code></pre> <p>Return whether the event is a frame event.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the event is a frame event, False otherwise.</p>"},{"location":"reference/api_py/#datoviz._event.Event.is_keyboard","title":"is_keyboard","text":"<pre><code>is_keyboard() -&gt; bool\n</code></pre> <p>Return whether the event is a keyboard event.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the event is a keyboard event, False otherwise.</p>"},{"location":"reference/api_py/#datoviz._event.Event.is_mouse","title":"is_mouse","text":"<pre><code>is_mouse() -&gt; bool\n</code></pre> <p>Return whether the event is a mouse event.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the event is a mouse event, False otherwise.</p>"},{"location":"reference/api_py/#datoviz._event.Event.is_resize","title":"is_resize","text":"<pre><code>is_resize() -&gt; bool\n</code></pre> <p>Return whether the event is a resize event.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the event is a resize event, False otherwise.</p>"},{"location":"reference/api_py/#datoviz._event.Event.is_timer","title":"is_timer","text":"<pre><code>is_timer() -&gt; bool\n</code></pre> <p>Return whether the event is a timer event.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the event is a timer event, False otherwise.</p>"},{"location":"reference/api_py/#datoviz._event.Event.key","title":"key","text":"<pre><code>key() -&gt; Optional[int]\n</code></pre> <p>Get the key C enumeration associated with the keyboard event.</p> <p>Returns:</p> Type Description <code>int or None</code> <p>The key code, or None if not a keyboard event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.key_event","title":"key_event","text":"<pre><code>key_event(prettify: bool = True) -&gt; Optional[str]\n</code></pre> <p>Get the keyboard event type.</p> <p>Parameters:</p> Name Type Description Default <code>prettify</code> <code>bool</code> <p>Whether to return a prettified string representation, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str or None</code> <p>The keyboard event type, or None if not a keyboard event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.key_name","title":"key_name","text":"<pre><code>key_name() -&gt; Optional[str]\n</code></pre> <p>Get the name of the key associated with the keyboard event.</p> <p>Returns:</p> Type Description <code>str or None</code> <p>The name of the key, or None if not a keyboard event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.mouse_event","title":"mouse_event","text":"<pre><code>mouse_event(prettify: bool = True) -&gt; Optional[str]\n</code></pre> <p>Get the mouse event type.</p> <p>Parameters:</p> Name Type Description Default <code>prettify</code> <code>bool</code> <p>Whether to return a prettified string representation, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str or None</code> <p>The mouse event type (<code>click</code>, <code>double_click</code>, <code>drag</code>, <code>drag_start</code>, <code>drag_stop</code>, <code>move</code>, <code>press</code>, <code>release</code>, <code>wheel</code>), or None if not a mouse event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.pos","title":"pos","text":"<pre><code>pos() -&gt; Optional[Tuple[float, float]]\n</code></pre> <p>Get the position of the mouse event.</p> <p>Returns:</p> Type Description <code>tuple of float or None</code> <p>The (x, y) position of the mouse event, or None if not a mouse event.</p>"},{"location":"reference/api_py/#datoviz._event.Event.press_pos","title":"press_pos","text":"<pre><code>press_pos() -&gt; Optional[Tuple[float, float]]\n</code></pre> <p>Get the position where the mouse was pressed during a drag event.</p> <p>Returns:</p> Type Description <code>tuple of float or None</code> <p>The (x, y) position of the press event, or None if not applicable.</p>"},{"location":"reference/api_py/#datoviz._event.Event.screen_height","title":"screen_height","text":"<pre><code>screen_height()\n</code></pre> <p>Return the current screen height of a resize event.</p> <p>Returns:</p> Type Description <code>int</code> <p>The screen height.</p>"},{"location":"reference/api_py/#datoviz._event.Event.screen_width","title":"screen_width","text":"<pre><code>screen_width()\n</code></pre> <p>Return the current screen width of a resize event.</p> <p>Returns:</p> Type Description <code>int</code> <p>The screen width.</p>"},{"location":"reference/api_py/#datoviz._event.Event.tick","title":"tick","text":"<pre><code>tick()\n</code></pre> <p>Return the current tick index of a timer event.</p> <p>Returns:</p> Type Description <code>int</code> <p>The tick index, starting from 0.</p>"},{"location":"reference/api_py/#datoviz._event.Event.time","title":"time","text":"<pre><code>time()\n</code></pre> <p>Return the current time of the event in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>The time in seconds since the start of the timer.</p>"},{"location":"reference/api_py/#datoviz._event.Event.wheel","title":"wheel","text":"<pre><code>wheel() -&gt; Optional[float]\n</code></pre> <p>Get the wheel scroll amount (in vertical direction).</p> <p>Returns:</p> Type Description <code>float or None</code> <p>The scroll amount, or None if not a wheel event.</p>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection","title":"datoviz.shape_collection.ShapeCollection","text":"<pre><code>ShapeCollection()\n</code></pre> <p>A collection of shapes that can be transformed, merged, and rendered.</p> <p>Initialize an empty ShapeCollection.</p>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add","title":"add","text":"<pre><code>add(\n    c_shape: Shape,\n    offset: Tuple[float, float, float] = None,\n    scale: Union[float, Tuple[float, float, float]] = None,\n    transform: Mat4 = None,\n) -&gt; None\n</code></pre> <p>Add a shape to the collection with optional transformations.</p> <p>Parameters:</p> Name Type Description Default <code>c_shape</code> <code>Shape</code> <p>The shape to add.</p> required <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float or tuple of float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_arrow","title":"add_arrow","text":"<pre><code>add_arrow(\n    count: int = None,\n    head_length: float = None,\n    head_radius: float = None,\n    shaft_radius: float = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a 3D arrow (a cylinder and a cone), total length is 1.</p> <p>Use offset, scale, transform to modify its size.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of edges.</p> <code>None</code> <code>head_length</code> <code>float</code> <p>The head length.</p> <code>None</code> <code>head_radius</code> <code>float</code> <p>The head radius.</p> <code>None</code> <code>shaft_radius</code> <code>float</code> <p>The shaft length.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the cone, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_cone","title":"add_cone","text":"<pre><code>add_cone(\n    count: int = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a cone shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of edges.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the cone, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_cube","title":"add_cube","text":"<pre><code>add_cube(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a cube shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the cube, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_custom","title":"add_custom","text":"<pre><code>add_custom(\n    positions: ndarray,\n    normals: ndarray = None,\n    colors: ndarray = None,\n    texcoords: ndarray = None,\n    indices: ndarray = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n)\n</code></pre> <p>Add a custom shape to the collection with optional transformations.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>An (N, 3) array with the vertex positions.</p> required <code>normals</code> <code>ndarray</code> <p>An (N, 3) array with the vertex normal vectors.</p> <code>None</code> <code>colors</code> <code>ndarray</code> <p>An (N, 4) array with the vertex colors.</p> <code>None</code> <code>texcoords</code> <code>ndarray</code> <p>An (N, 4) array with the vertex texture coordinates.</p> <code>None</code> <code>indices</code> <code>ndarray</code> <p>An (M,) array with the face indices.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_cylinder","title":"add_cylinder","text":"<pre><code>add_cylinder(\n    count: int = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a cylinder shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of edges.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the cylinder, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_disc","title":"add_disc","text":"<pre><code>add_disc(\n    count: int = DEFAULT_SIZE,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a disc shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of sides in the disc.</p> <code>DEFAULT_SIZE</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the disc, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_dodecahedron","title":"add_dodecahedron","text":"<pre><code>add_dodecahedron(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a dodecahedron shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the dodecahedron, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_gizmo","title":"add_gizmo","text":"<pre><code>add_gizmo(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n) -&gt; None\n</code></pre> <p>Add a gizmo shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_hexahedron","title":"add_hexahedron","text":"<pre><code>add_hexahedron(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a hexahedron shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the hexahedron, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_icosahedron","title":"add_icosahedron","text":"<pre><code>add_icosahedron(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add an icosahedron shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the icosahedron, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_obj","title":"add_obj","text":"<pre><code>add_obj(\n    file_path: str,\n    contour: str = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n) -&gt; None\n</code></pre> <p>Add a shape from an OBJ file to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the OBJ file.</p> required <code>contour</code> <code>str</code> <p>The contour type to apply, by default None.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_octahedron","title":"add_octahedron","text":"<pre><code>add_octahedron(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add an octahedron shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the octahedron, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_polygon","title":"add_polygon","text":"<pre><code>add_polygon(\n    points: ndarray,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n    contour: str = None,\n    indexing: str = None,\n) -&gt; None\n</code></pre> <p>Add a polygon shape to the collection.</p> <p>This function uses earcut to triangulate the polygon. More sophisticated triangulations methods will be added in a future version.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>ndarray</code> <p>The points defining the polygon.</p> required <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the polygon, by default None.</p> <code>None</code> <code>contour</code> <code>str</code> <p>The contour type to apply, by default None.</p> <code>None</code> <code>indexing</code> <code>str</code> <p>The indexing type to apply, by default None.</p> <code>None</code> Warnings: <p>Polygon contour is still experimental, it may not work well in some instances.</p>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_sector","title":"add_sector","text":"<pre><code>add_sector(\n    count: int = DEFAULT_SIZE,\n    angle_start: float = 0,\n    angle_stop: float = 2 * np.pi,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a disc shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of sides in the disc.</p> <code>DEFAULT_SIZE</code> <code>angle_start</code> <code>float</code> <p>The start angle, in radians.</p> <code>0</code> <code>angle_stop</code> <code>float</code> <p>The stop angle, in radians.</p> <code>2 * pi</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the disc, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_sphere","title":"add_sphere","text":"<pre><code>add_sphere(\n    rows: int = None,\n    cols: int = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a sphere shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>The number of rows in the sphere, by default None.</p> <code>None</code> <code>cols</code> <code>int</code> <p>The number of columns in the sphere, by default None.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the sphere, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_square","title":"add_square","text":"<pre><code>add_square(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a square shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the square, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_surface","title":"add_surface","text":"<pre><code>add_surface(\n    heights: ndarray,\n    colors: ndarray,\n    contour: str = None,\n    indexing: str = None,\n    u: Tuple[float, float, float] = None,\n    v: Tuple[float, float, float] = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n) -&gt; None\n</code></pre> <p>Add a surface shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>heights</code> <code>ndarray</code> <p>The height values of the surface.</p> required <code>colors</code> <code>ndarray</code> <p>The color values of the surface.</p> required <code>contour</code> <code>str</code> <p>The contour type to apply, by default None.</p> <code>None</code> <code>indexing</code> <code>str</code> <p>The indexing type to apply, by default None.</p> <code>None</code> <code>u</code> <code>tuple of float</code> <p>The u vector for the surface, by default None.</p> <code>None</code> <code>v</code> <code>tuple of float</code> <p>The v vector for the surface, by default None.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_tetrahedron","title":"add_tetrahedron","text":"<pre><code>add_tetrahedron(\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a tetrahedron shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the tetrahedron, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.add_torus","title":"add_torus","text":"<pre><code>add_torus(\n    count_radial: int = None,\n    count_tubular: int = None,\n    tube_radius: float = None,\n    offset: Tuple[float, float, float] = None,\n    scale: float = None,\n    transform: Mat4 = None,\n    color: Color = None,\n) -&gt; None\n</code></pre> <p>Add a torus shape to the collection.</p> <p>Parameters:</p> Name Type Description Default <code>count_radial</code> <code>int</code> <p>The number of edges.</p> <code>None</code> <code>count_tubular</code> <code>int</code> <p>The number of edges around a circular cross-section.</p> <code>None</code> <code>tube_radius</code> <code>float</code> <p>The radius of the tube, in NDC.</p> <code>None</code> <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code> <code>color</code> <code>Color</code> <p>The color of the cylinder, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.destroy","title":"destroy","text":"<pre><code>destroy() -&gt; None\n</code></pre> <p>Destroy all shapes in the collection and release resources.</p>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.index_count","title":"index_count","text":"<pre><code>index_count() -&gt; int\n</code></pre> <p>Get the total number of indices in the collection.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total index count across all shapes in the collection.</p>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.merge","title":"merge","text":"<pre><code>merge() -&gt; None\n</code></pre> <p>Merge all shapes in the collection into a single shape.</p>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.transform","title":"transform","text":"<pre><code>transform(\n    offset: Tuple[float, float, float] = None,\n    scale: Union[float, Tuple[float, float, float]] = None,\n    transform: Mat4 = None,\n)\n</code></pre> <p>Transform the shape collection.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple of float</code> <p>The (x, y, z) offset to apply, by default None.</p> <code>None</code> <code>scale</code> <code>float or tuple of float</code> <p>The scale factor to apply, by default None.</p> <code>None</code> <code>transform</code> <code>Mat4</code> <p>A 4x4 transformation matrix, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.shape_collection.ShapeCollection.vertex_count","title":"vertex_count","text":"<pre><code>vertex_count() -&gt; int\n</code></pre> <p>Get the total number of vertices in the collection.</p> <p>Returns:</p> Type Description <code>int</code> <p>The total vertex count across all shapes in the collection.</p>"},{"location":"reference/api_py/#datoviz.visuals.Basic","title":"datoviz.visuals.Basic","text":"<pre><code>Basic(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A basic visual using the default graphical primitives (points, lines, triangles).</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Basic.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Basic.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Basic.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Basic.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Basic.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of the visual's elements.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_group","title":"set_group","text":"<pre><code>set_group(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the groups.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The group array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the group, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of the visual's elements.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Basic.set_size","title":"set_size","text":"<pre><code>set_size(value: float) -&gt; None\n</code></pre> <p>Set the common size of the visual's elements.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The size value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Basic.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Basic.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Pixel","title":"datoviz.visuals.Pixel","text":"<pre><code>Pixel(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering individual pixels.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Pixel.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Pixel.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Pixel.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.set_size","title":"set_size","text":"<pre><code>set_size(value: float) -&gt; None\n</code></pre> <p>Set the size of the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The size value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Pixel.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Pixel.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Point","title":"datoviz.visuals.Point","text":"<pre><code>Point(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering points.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Point.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Point.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Point.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Point.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Point.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Point.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of points.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Point.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Point.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Point.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of points.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Point.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Point.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Point.set_size","title":"set_size","text":"<pre><code>set_size(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the size of points.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The size array, in pixels.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the size, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Point.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Point.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Marker","title":"datoviz.visuals.Marker","text":"<pre><code>Marker(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering markers.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Marker.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_angle","title":"set_angle","text":"<pre><code>set_angle(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the angle of the markers.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The angle array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the angle, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_aspect","title":"set_aspect","text":"<pre><code>set_aspect(value: str) -&gt; None\n</code></pre> <p>Set the rendering style of the marker.</p> <p>This controls how the marker uses color, edgecolor, and linewidth.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>One of: - 'filled': fill only (no border) - 'stroke': border only (transparent interior) - 'outline': fill with border</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of the markers.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_edgecolor","title":"set_edgecolor","text":"<pre><code>set_edgecolor(value: tuple) -&gt; None\n</code></pre> <p>Set the common edge color of the markers.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The edge color value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_linewidth","title":"set_linewidth","text":"<pre><code>set_linewidth(value: float) -&gt; None\n</code></pre> <p>Set the common linewidth of the markers.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The linewidth value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_mode","title":"set_mode","text":"<pre><code>set_mode(value: str) -&gt; None\n</code></pre> <p>Set the marker mode.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The mode value: - <code>code</code> (the shape is defined in the shader code) - <code>bitmap</code> (the marker is defined in a bitmap texture) - <code>sdf</code> (the marker shape is defined as a signed distance field) - <code>msdf</code> (the marker shaped is defined as a multichannel signed distance field)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of the markers.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_shape","title":"set_shape","text":"<pre><code>set_shape(value: str) -&gt; None\n</code></pre> <p>Set the shape of the visual's elements.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The shape value, one of: - <code>disc</code> - <code>asterisk</code> - <code>chevron</code> - <code>clover</code> - <code>club</code> - <code>cross</code> - <code>diamond</code> - <code>arrow</code> - <code>ellipse</code> - <code>hbar</code> - <code>heart</code> - <code>infinity</code> - <code>pin</code> - <code>ring</code> - <code>spade</code> - <code>square</code> - <code>tag</code> - <code>triangle</code> - <code>vbar</code> - <code>rounded_rect</code></p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_size","title":"set_size","text":"<pre><code>set_size(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the size of the markers.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The size array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the size, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_tex_scale","title":"set_tex_scale","text":"<pre><code>set_tex_scale(value: float) -&gt; None\n</code></pre> <p>Set the common texture scale.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The texture scale value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the texture with the bitmap, SDF, or MSDF data.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Marker.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Marker.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Segment","title":"datoviz.visuals.Segment","text":"<pre><code>Segment(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering line segments.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Segment.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Segment.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Segment.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Segment.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_cap","title":"set_cap","text":"<pre><code>set_cap(initial: str, terminal: str = None) -&gt; None\n</code></pre> <p>Set the cap of line segments:</p> <ul> <li><code>round</code></li> <li><code>triangle_in</code></li> <li><code>triangle_out</code></li> <li><code>square</code></li> <li><code>butt</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>str</code> <p>The initial cap.</p> required <code>terminal</code> <code>str</code> <p>The terminal cap.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of line segments.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_linewidth","title":"set_linewidth","text":"<pre><code>set_linewidth(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the linewidth of line segments.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The linewidth array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the linewidth, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_position","title":"set_position","text":"<pre><code>set_position(\n    initial: ndarray,\n    terminal: ndarray = None,\n    offset: int = 0,\n) -&gt; None\n</code></pre> <p>Set the position of the line segments.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>ndarray</code> <p>The initial positions.</p> required <code>terminal</code> <code>ndarray</code> <p>The terminal positions.</p> <code>None</code> <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the property classes for the segment visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Segment.set_shift","title":"set_shift","text":"<pre><code>set_shift(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the pixel shift of line segments.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The shift array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the shift, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Segment.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Path","title":"datoviz.visuals.Path","text":"<pre><code>Path(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering paths.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Path.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Path.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Path.set_cap","title":"set_cap","text":"<pre><code>set_cap(value: str) -&gt; None\n</code></pre> <p>Set the common cap style of all paths, one of the following:</p> <ul> <li><code>round</code></li> <li><code>triangle_in</code></li> <li><code>triangle_out</code></li> <li><code>square</code></li> <li><code>butt</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The cap style.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of the individual points in each path.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Path.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Path.set_join","title":"set_join","text":"<pre><code>set_join(value: str) -&gt; None\n</code></pre> <p>Set the common join style of all paths, one of the following:</p> <ul> <li><code>square</code></li> <li><code>round</code></li> </ul> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The join style.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.set_linewidth","title":"set_linewidth","text":"<pre><code>set_linewidth(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the linewidth of the individual points in each path.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The linewidth array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the linewidth, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Path.set_position","title":"set_position","text":"<pre><code>set_position(\n    position: Union[ndarray, List[ndarray]],\n    groups: Union[int, ndarray] = 0,\n    offset: int = 0,\n) -&gt; None\n</code></pre> <p>Set the position of the paths.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>ndarray, or list of ndarray</code> <p>A list of arrays representing the positions of the paths.</p> required <code>groups</code> <code>int or ndarray</code> <p>The number of uniformly-sized groups, by default 0, or the sizes of each group.</p> <code>0</code> <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Path.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Path.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Path.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Path.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Glyph","title":"datoviz.visuals.Glyph","text":"<pre><code>Glyph(*args, font_size: int = None, **kwargs)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering glyphs.</p> <p>Initialize a Glyph visual.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple</code> <p>Positional arguments for the parent class <code>Visual</code>.</p> <code>()</code> <code>font_size</code> <code>int</code> <p>The font size, by default None.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>Keyword arguments for the parent class <code>Visual</code>.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_anchor","title":"set_anchor","text":"<pre><code>set_anchor(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the anchor of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The anchor array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the anchor, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_angle","title":"set_angle","text":"<pre><code>set_angle(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the angle of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The angle array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the angle, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_axis","title":"set_axis","text":"<pre><code>set_axis(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the 3D rotation axis of the glyphs.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The axis array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the axis, by default 0.</p> <code>0</code> Warnings: <p>This is not implemented yet.</p>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_bgcolor","title":"set_bgcolor","text":"<pre><code>set_bgcolor(value: tuple) -&gt; None\n</code></pre> <p>Set the common background color for all glyphs.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The background color value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_group_size","title":"set_group_size","text":"<pre><code>set_group_size(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the string size of each glyph (the value should be the same across all glyphs of each string).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The group size array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the group size, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_scale","title":"set_scale","text":"<pre><code>set_scale(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the scale of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The scale array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the scale, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_shift","title":"set_shift","text":"<pre><code>set_shift(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the pixel shift of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The shift array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the shift, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_size","title":"set_size","text":"<pre><code>set_size(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the size of each glyph.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The size array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the size, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_strings","title":"set_strings","text":"<pre><code>set_strings(\n    strings: List[str],\n    string_pos: ndarray = None,\n    scales: ndarray = None,\n    color: tuple = cst.DEFAULT_GLYPH_COLOR,\n    anchor: tuple = (0, 0),\n    offset: tuple = (0, 0),\n) -&gt; None\n</code></pre> <p>Set the strings to render as glyphs.</p> <p>This is a helper function to set several strings at different locations and scales but with the same color, anchor, and offset. To use different values for each string, use the other methods.</p> <p>Parameters:</p> Name Type Description Default <code>strings</code> <code>list of str</code> <p>The list of strings to render.</p> required <code>string_pos</code> <code>ndarray</code> <p>The positions of each string, by default None.</p> <code>None</code> <code>scales</code> <code>ndarray</code> <p>The scales of each string, by default None.</p> <code>None</code> <code>color</code> <code>tuple</code> <p>The common color of all glyphs, by default cst.DEFAULT_GLYPH_COLOR.</p> <code>DEFAULT_GLYPH_COLOR</code> <code>anchor</code> <code>tuple</code> <p>The common anchor point of all strings, by default (0, 0).</p> <code>(0, 0)</code> <code>offset</code> <code>tuple</code> <p>The common offset of all strings, by default (0, 0).</p> <code>(0, 0)</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_texcoords","title":"set_texcoords","text":"<pre><code>set_texcoords(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the texture coordinates of each glyph (relative to the font atlas texture).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The texture coordinates array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the texture coordinates, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the texture with the font atlas.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Glyph.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Glyph.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Image","title":"datoviz.visuals.Image","text":"<pre><code>Image(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for displaying images.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Image.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_anchor","title":"set_anchor","text":"<pre><code>set_anchor(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the anchor of each image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The anchor array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the anchor, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_colormap","title":"set_colormap","text":"<pre><code>set_colormap(value: str) -&gt; None\n</code></pre> <p>Set the colormap of the image when using the <code>colormap</code> image mode.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The colormap value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_edgecolor","title":"set_edgecolor","text":"<pre><code>set_edgecolor(value: tuple) -&gt; None\n</code></pre> <p>Set the common edge color of all images.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The edge color value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_facecolor","title":"set_facecolor","text":"<pre><code>set_facecolor(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the face color of the image (when using a fill mode instead of texture mode).</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The face color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the face color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_linewidth","title":"set_linewidth","text":"<pre><code>set_linewidth(value: float) -&gt; None\n</code></pre> <p>Set the common linewidth of all images when using an image border.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The linewidth value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_permutation","title":"set_permutation","text":"<pre><code>set_permutation(value: tuple) -&gt; None\n</code></pre> <p>Set the permutation axes of the image.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The permutation value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of each image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_radius","title":"set_radius","text":"<pre><code>set_radius(value: float) -&gt; None\n</code></pre> <p>Set the common border radius of all images when using an image border.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The radius value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.set_size","title":"set_size","text":"<pre><code>set_size(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the pixel size of each image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The size array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the size, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_texcoords","title":"set_texcoords","text":"<pre><code>set_texcoords(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the texture coordinates of each image.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The texture coordinates array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the texture coordinates, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the image texture.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Image.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Image.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Mesh","title":"datoviz.visuals.Mesh","text":"<pre><code>Mesh(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering meshes.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.allocate","title":"allocate","text":"<pre><code>allocate(count: int, index_count: int = None) -&gt; None\n</code></pre> <p>Allocate memory for the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of vertices to allocate.</p> required <code>index_count</code> <code>int</code> <p>The number of indices to allocate, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.get_index_count","title":"get_index_count","text":"<pre><code>get_index_count() -&gt; int\n</code></pre> <p>Get the number of indices in the mesh.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of indices.</p>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_ambient_params","title":"set_ambient_params","text":"<pre><code>set_ambient_params(value: tuple) -&gt; None\n</code></pre> <p>Set the ambient parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material ambient parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of the mesh vertices.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_count","title":"set_count","text":"<pre><code>set_count(count: int, index_count: int = None) -&gt; None\n</code></pre> <p>Set the number of vertices and indices in the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of vertices.</p> required <code>index_count</code> <code>int</code> <p>The number of indices, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_data","title":"set_data","text":"<pre><code>set_data(\n    vertex_count: int = None,\n    index_count: int = None,\n    compute_normals: bool = None,\n    **kwargs,\n) -&gt; None\n</code></pre> <p>Set data for the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>vertex_count</code> <code>int</code> <p>The number of vertices, by default None.</p> <code>None</code> <code>index_count</code> <code>int</code> <p>The number of indices, by default None.</p> <code>None</code> <code>compute_normals</code> <code>bool</code> <p>Whether to compute normals, by default None.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_density","title":"set_density","text":"<pre><code>set_density(value: int) -&gt; None\n</code></pre> <p>Set the density of the isolines, if showing isolines.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The density value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_diffuse_params","title":"set_diffuse_params","text":"<pre><code>set_diffuse_params(value: tuple) -&gt; None\n</code></pre> <p>Set the diffuse parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material diffuse parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_edgecolor","title":"set_edgecolor","text":"<pre><code>set_edgecolor(value: tuple) -&gt; None\n</code></pre> <p>Set the edge color of the contour, if showing a contour.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The edge color value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_emission_params","title":"set_emission_params","text":"<pre><code>set_emission_params(value: tuple) -&gt; None\n</code></pre> <p>Set the emission parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material emission parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_emit","title":"set_emit","text":"<pre><code>set_emit(value: float) -&gt; None\n</code></pre> <p>Set the surface emission level.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The emit value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_index","title":"set_index","text":"<pre><code>set_index(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the indices of the mesh.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The indices array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the indices, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_isoline","title":"set_isoline","text":"<pre><code>set_isoline(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the isolines of the mesh vertices.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The isolines array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the isolines, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_light_color","title":"set_light_color","text":"<pre><code>set_light_color(value: tuple, idx: int = 0) -&gt; None\n</code></pre> <p>Set the color of the light.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The light color value.</p> required <code>idx</code> <code>int</code> <p>The index of the light, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_light_pos","title":"set_light_pos","text":"<pre><code>set_light_pos(value: tuple, idx: int = 0) -&gt; None\n</code></pre> <p>Set the direction of the light.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The light direction value.</p> required <code>idx</code> <code>int</code> <p>The index of the light, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_linewidth","title":"set_linewidth","text":"<pre><code>set_linewidth(value: float) -&gt; None\n</code></pre> <p>Set the line width of the contour, if showing a contour.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The linewidth value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_normal","title":"set_normal","text":"<pre><code>set_normal(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the normals of the mesh vertices.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The normals array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the normals, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of the mesh vertices.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the property classes for the mesh visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_shine","title":"set_shine","text":"<pre><code>set_shine(value: float) -&gt; None\n</code></pre> <p>Set the surface shininess.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The shine value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_specular_params","title":"set_specular_params","text":"<pre><code>set_specular_params(value: tuple) -&gt; None\n</code></pre> <p>Set the specular parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material specular parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_texcoords","title":"set_texcoords","text":"<pre><code>set_texcoords(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the texture coordinates of the mesh vertices.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The texture coordinates array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the texture coordinates, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the mesh texture.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Mesh.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Mesh.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Sphere","title":"datoviz.visuals.Sphere","text":"<pre><code>Sphere(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering spheres.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_ambient_params","title":"set_ambient_params","text":"<pre><code>set_ambient_params(value: tuple) -&gt; None\n</code></pre> <p>Set the ambient parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material ambient parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_color","title":"set_color","text":"<pre><code>set_color(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the color of the spheres.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The color array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the color, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_diffuse_params","title":"set_diffuse_params","text":"<pre><code>set_diffuse_params(value: tuple) -&gt; None\n</code></pre> <p>Set the diffuse parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material diffuse parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_emission_params","title":"set_emission_params","text":"<pre><code>set_emission_params(value: tuple) -&gt; None\n</code></pre> <p>Set the emission parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material emission parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_emit","title":"set_emit","text":"<pre><code>set_emit(value) -&gt; None\n</code></pre> <p>Set the size of the spheres.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The amount of surface light emission.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_light_color","title":"set_light_color","text":"<pre><code>set_light_color(value: tuple, idx: int = 0) -&gt; None\n</code></pre> <p>Set the color of the light idx.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The light color value.</p> required <code>idx</code> <code>int</code> <p>The index of the light, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_light_pos","title":"set_light_pos","text":"<pre><code>set_light_pos(value: tuple, idx: int = 0) -&gt; None\n</code></pre> <p>Set the position of light idx.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The light position value.</p> required <code>idx</code> <code>int</code> <p>The index of the light, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of the spheres.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_shine","title":"set_shine","text":"<pre><code>set_shine(value) -&gt; None\n</code></pre> <p>Set the size of the spheres.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The amount of surface shininess.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_size","title":"set_size","text":"<pre><code>set_size(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the size of the spheres.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The size array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the size, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_specular_params","title":"set_specular_params","text":"<pre><code>set_specular_params(value: tuple) -&gt; None\n</code></pre> <p>Set the specular parameters of the material.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The material specular parameters (r, g, b).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the sphere texture.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Sphere.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Sphere.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Volume","title":"datoviz.visuals.Volume","text":"<pre><code>Volume(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering volumetric data.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Volume.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Volume.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_bounds","title":"set_bounds","text":"<pre><code>set_bounds(\n    xlim: tuple, ylim: tuple = None, zlim: tuple = None\n) -&gt; None\n</code></pre> <p>Set the bounds of the volume.</p> <p>Parameters:</p> Name Type Description Default <code>xlim</code> <code>tuple</code> <p>The x-axis bounds.</p> required <code>ylim</code> <code>tuple</code> <p>The y-axis bounds.</p> <code>None</code> <code>zlim</code> <code>tuple</code> <p>The z-axis bounds.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_permutation","title":"set_permutation","text":"<pre><code>set_permutation(value: tuple) -&gt; None\n</code></pre> <p>Set the axis permutation of the volume 3D array.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The permutation of the axes, by default (0, 1, 2) (corresponding to u, v, w).</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_slice","title":"set_slice","text":"<pre><code>set_slice(value: int) -&gt; None\n</code></pre> <p>Set the slice index for the volume.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The slice index.</p> required Warnings: <p>This is not implemented yet.</p>"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_texcoords","title":"set_texcoords","text":"<pre><code>set_texcoords(uvw0: tuple, uvw1: tuple) -&gt; None\n</code></pre> <p>Set the texture coordinates of the volume.</p> <p>Parameters:</p> Name Type Description Default <code>uvw0</code> <code>tuple</code> <p>The texture coordinates of the point <code>(xlim[0], ylim[0], zlim[0])</code>.</p> required <code>uvw1</code> <code>tuple</code> <p>The texture coordinates of the point <code>(xlim[1], ylim[1], zlim[1])</code>.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the texture for the volume.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.set_transfer","title":"set_transfer","text":"<pre><code>set_transfer(value: tuple) -&gt; None\n</code></pre> <p>Set the transfer function for the volume.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>tuple</code> <p>The transfer function parameters.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Volume.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Volume.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Slice","title":"datoviz.visuals.Slice","text":"<pre><code>Slice(c_visual: DvzVisual, visual_name: str = None)\n</code></pre> <p>               Bases: <code>Visual</code></p> <p>A visual for rendering 2D slices of volumetric data.</p> <p>Initialize a Visual instance.</p> <p>Parameters:</p> Name Type Description Default <code>c_visual</code> <code>DvzVisual</code> <p>The underlying C visual object.</p> required <code>visual_name</code> <code>str</code> <p>The name of the visual, by default None.</p> <code>None</code>"},{"location":"reference/api_py/#datoviz.visuals.Slice.allocate","title":"allocate","text":"<pre><code>allocate(count: int) -&gt; None\n</code></pre> <p>Allocate memory for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements to allocate.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.clip","title":"clip","text":"<pre><code>clip(clip: str) -&gt; None\n</code></pre> <p>Set the clipping mode for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>str</code> <p>The clipping mode: - <code>inner</code> (clip everything inside the internal viewport) - <code>outer</code> (clip everything outside the interval viewport) - <code>bottom</code> (clip everything below the inferior border of the internal viewport) - <code>left</code> (clip everything to the left of the internal viewport)</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.fixed","title":"fixed","text":"<pre><code>fixed(fixed: Union[bool, str]) -&gt; None\n</code></pre> <p>Set whether the visual is fixed along certain axes.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>Use True to fix all x, y, z dimensions, or <code>x</code> or <code>x,y</code> etc to fix only some of the axes.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.get_count","title":"get_count","text":"<pre><code>get_count() -&gt; int\n</code></pre> <p>Get the number of elements in the visual.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of elements.</p>"},{"location":"reference/api_py/#datoviz.visuals.Slice.hide","title":"hide","text":"<pre><code>hide() -&gt; None\n</code></pre> <p>Hide the visual.</p>"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_alpha","title":"set_alpha","text":"<pre><code>set_alpha(value: float) -&gt; None\n</code></pre> <p>Set the alpha transparency of the slice.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The alpha transparency value.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_count","title":"set_count","text":"<pre><code>set_count(count: int) -&gt; None\n</code></pre> <p>Set the number of elements in the visual.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>The number of elements.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_data","title":"set_data","text":"<pre><code>set_data(\n    depth_test: bool = None, cull: str = None, **kwargs\n) -&gt; None\n</code></pre> <p>Set data for the visual.</p> <p>Parameters:</p> Name Type Description Default <code>depth_test</code> <code>bool</code> <p>Whether to enable depth testing.</p> <code>None</code> <code>cull</code> <code>str</code> <p>The culling mode, <code>None</code>, <code>front</code>, or <code>back</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional data to set.</p> <code>{}</code>"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_position","title":"set_position","text":"<pre><code>set_position(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the position of the slice.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The position array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the position, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_prop_class","title":"set_prop_class","text":"<pre><code>set_prop_class(prop_name: str, prop_cls: type) -&gt; None\n</code></pre> <p>Set the class for a property.</p> <p>Parameters:</p> Name Type Description Default <code>prop_name</code> <code>str</code> <p>The name of the property.</p> required <code>prop_cls</code> <code>type</code> <p>The class of the property.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_prop_classes","title":"set_prop_classes","text":"<pre><code>set_prop_classes() -&gt; None\n</code></pre> <p>Set the classes for all properties.</p>"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_texcoords","title":"set_texcoords","text":"<pre><code>set_texcoords(array: ndarray, offset: int = 0) -&gt; None\n</code></pre> <p>Set the texture coordinates of the slice.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The texture coordinates array.</p> required <code>offset</code> <code>int</code> <p>The offset at which to start setting the texture coordinates, by default 0.</p> <code>0</code>"},{"location":"reference/api_py/#datoviz.visuals.Slice.set_texture","title":"set_texture","text":"<pre><code>set_texture(texture: Texture) -&gt; None\n</code></pre> <p>Set the texture for the slice.</p> <p>Parameters:</p> Name Type Description Default <code>texture</code> <code>Texture</code> <p>The texture object.</p> required"},{"location":"reference/api_py/#datoviz.visuals.Slice.show","title":"show","text":"<pre><code>show(is_visible: bool = True) -&gt; None\n</code></pre> <p>Show or hide the visual.</p> <p>Parameters:</p> Name Type Description Default <code>is_visible</code> <code>bool</code> <p>Whether to show the visual, by default True.</p> <code>True</code>"},{"location":"reference/api_py/#datoviz.visuals.Slice.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the visual.</p>"},{"location":"reference/api_py/#utils","title":"Utils","text":""},{"location":"reference/api_py/#datoviz.utils","title":"datoviz.utils","text":"<p>Copyright (c) 2021 Cyrille Rossant and contributors. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for details. SPDX-License-Identifier: MIT</p>"},{"location":"reference/api_py/#datoviz.utils.array_pointer","title":"array_pointer","text":"<pre><code>array_pointer(\n    x: ndarray, dtype: dtype = None\n) -&gt; ctypes.POINTER\n</code></pre> <p>Convert a NumPy array to a C pointer.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The NumPy array to convert.</p> required <code>dtype</code> <code>dtype</code> <p>The desired data type, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>POINTER</code> <p>A C pointer to the array data.</p>"},{"location":"reference/api_py/#datoviz.utils.button_name","title":"button_name","text":"<pre><code>button_name(button: int) -&gt; str\n</code></pre> <p>Get the name of a mouse button from its button code.</p> <p>Parameters:</p> Name Type Description Default <code>button</code> <code>int</code> <p>The button code.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the mouse button.</p>"},{"location":"reference/api_py/#datoviz.utils.char_pointer","title":"char_pointer","text":"<pre><code>char_pointer(s: Union[str, List[str]]) -&gt; ctypes.POINTER\n</code></pre> <p>Convert a string or list of strings to a C char pointer.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str or list of str</code> <p>The string or list of strings to convert.</p> required <p>Returns:</p> Type Description <code>POINTER</code> <p>A C char pointer.</p>"},{"location":"reference/api_py/#datoviz.utils.cmap","title":"cmap","text":"<pre><code>cmap(\n    cm: Union[str, int],\n    values: ndarray,\n    vmin: float = 0.0,\n    vmax: float = 1.0,\n) -&gt; np.ndarray\n</code></pre> <p>Apply a colormap to an array of values.</p> <p>Parameters:</p> Name Type Description Default <code>cm</code> <code>str or int</code> <p>The colormap identifier, either as a string name or an integer.</p> required <code>values</code> <code>ndarray</code> <p>The array of values to map.</p> required <code>vmin</code> <code>float</code> <p>The minimum value for normalization, by default 0.0.</p> <code>0.0</code> <code>vmax</code> <code>float</code> <p>The maximum value for normalization, by default 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of RGBA colors.</p>"},{"location":"reference/api_py/#datoviz.utils.dtype_to_format","title":"dtype_to_format","text":"<pre><code>dtype_to_format(dtype: str, n_channels: int) -&gt; int\n</code></pre> <p>Get the format identifier for a given data type and number of channels.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>str</code> <p>The data type.</p> required <code>n_channels</code> <code>int</code> <p>The number of channels.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The format identifier.</p>"},{"location":"reference/api_py/#datoviz.utils.from_enum","title":"from_enum","text":"<pre><code>from_enum(\n    enum_cls: type, value: int, prettify: bool = True\n) -&gt; Optional[str]\n</code></pre> <p>Convert an enum value to its string representation.</p> <p>Parameters:</p> Name Type Description Default <code>enum_cls</code> <code>type</code> <p>The enum class.</p> required <code>value</code> <code>int</code> <p>The enum value.</p> required <code>prettify</code> <code>bool</code> <p>Whether to prettify the string representation, by default True.</p> <code>True</code> <p>Returns:</p> Type Description <code>str or None</code> <p>The string representation of the enum value, or None if not found.</p>"},{"location":"reference/api_py/#datoviz.utils.get_fixed_flag","title":"get_fixed_flag","text":"<pre><code>get_fixed_flag(fixed: Union[bool, str]) -&gt; int\n</code></pre> <p>Get the fixed parameters for a visual on all three dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>fixed</code> <code>bool or str</code> <p>The fixed parameters.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The visual fixed flag.</p>"},{"location":"reference/api_py/#datoviz.utils.get_size","title":"get_size","text":"<pre><code>get_size(\n    idx: Union[slice, int],\n    value: ndarray,\n    total_size: int = 0,\n) -&gt; int\n</code></pre> <p>Get the size of a slice or array.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>slice or int</code> <p>The slice or index.</p> required <code>value</code> <code>ndarray</code> <p>The array.</p> required <code>total_size</code> <code>int</code> <p>The total size of the array, by default 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>int</code> <p>The size of the slice or array.</p>"},{"location":"reference/api_py/#datoviz.utils.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; Dict[str, str]\n</code></pre> <p>Get the version information for the library.</p> <p>Returns:</p> Type Description <code>dict of str</code> <p>A dictionary containing the version of the ctypes wrapper and the Datoviz library.</p>"},{"location":"reference/api_py/#datoviz.utils.image_flags","title":"image_flags","text":"<pre><code>image_flags(\n    unit: str = None,\n    mode: str = None,\n    rescale: str = None,\n    border: bool = None,\n) -&gt; int\n</code></pre> <p>Compute the image flags for rendering based on the provided options.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>str</code> <p>Specifies the unit for the image size. Can be: - <code>pixels</code> (default): Image size is specified in pixels. - <code>ndc</code>: Image size depends on the normalized device coordinates (NDC) of the panel.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Specifies the image mode. Can be: - <code>rgba</code> (default): RGBA image mode. - <code>colormap</code>: Single-channel image with a colormap applied. - <code>fill</code>: Uniform color fill mode.</p> <code>None</code> <code>rescale</code> <code>str</code> <p>Specifies how the image should be rescaled with transformations. Can be: - <code>None</code> (default): No rescaling. - <code>rescale</code>: Rescale the image with the panel size. - <code>keep_ratio</code>: Rescale the image while maintaining its aspect ratio.</p> <code>None</code> <code>border</code> <code>bool</code> <p>Indicates whether to display a border around the image. Defaults to <code>False</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The computed image flags as an integer bitmask.</p>"},{"location":"reference/api_py/#datoviz.utils.is_enumerable","title":"is_enumerable","text":"<pre><code>is_enumerable(x) -&gt; bool\n</code></pre> <p>Return whether a variable is an enumerable.</p>"},{"location":"reference/api_py/#datoviz.utils.key_name","title":"key_name","text":"<pre><code>key_name(key_code: int) -&gt; str\n</code></pre> <p>Get the name of a key from its key code.</p> <p>Parameters:</p> Name Type Description Default <code>key_code</code> <code>int</code> <p>The key code.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the key.</p>"},{"location":"reference/api_py/#datoviz.utils.mesh_flags","title":"mesh_flags","text":"<pre><code>mesh_flags(\n    indexed: bool = None,\n    textured: bool = None,\n    lighting: bool = None,\n    contour: bool = None,\n    isoline: bool = None,\n) -&gt; int\n</code></pre> <p>Compute the C mesh flags based on the given options.</p> <p>Parameters:</p> Name Type Description Default <code>indexed</code> <code>bool</code> <p>Whether the mesh is indexed.</p> <code>None</code> <code>textured</code> <code>bool</code> <p>Whether to use a texture for the mesh.</p> <code>None</code> <code>lighting</code> <code>bool</code> <p>Whether lighting is enabled.</p> <code>None</code> <code>contour</code> <code>bool</code> <p>Whether contour is enabled.</p> <code>None</code> <code>isoline</code> <code>bool</code> <p>Whether to show isolines.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The computed mesh flags.</p>"},{"location":"reference/api_py/#datoviz.utils.pointer_array","title":"pointer_array","text":"<pre><code>pointer_array(\n    pointer: POINTER,\n    length: int,\n    n_components: int,\n    dtype: dtype = np.float32,\n) -&gt; np.ndarray\n</code></pre> <p>Convert a C pointer to a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>pointer</code> <code>POINTER</code> <p>The C pointer to convert.</p> required <code>length</code> <code>int</code> <p>The length of the array.</p> required <code>n_components</code> <code>int</code> <p>The number of components per element.</p> required <code>dtype</code> <code>dtype</code> <p>The desired data type, by default np.float32.</p> <code>float32</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The resulting NumPy array.</p>"},{"location":"reference/api_py/#datoviz.utils.pointer_image","title":"pointer_image","text":"<pre><code>pointer_image(\n    rgb: POINTER,\n    width: int,\n    height: int,\n    n_channels: int = 3,\n) -&gt; np.ndarray\n</code></pre> <p>Convert a C pointer to an image buffer into a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>rgb</code> <code>POINTER</code> <p>The C pointer to the image buffer.</p> required <code>width</code> <code>int</code> <p>The width of the image.</p> required <code>height</code> <code>int</code> <p>The height of the image.</p> required <code>n_channels</code> <code>int</code> <p>The number of channels in the image, by default 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>A NumPy array representing the image.</p>"},{"location":"reference/api_py/#datoviz.utils.prepare_data_array","title":"prepare_data_array","text":"<pre><code>prepare_data_array(\n    name: str,\n    dtype: str,\n    shape: Tuple[int, ...],\n    value: ndarray,\n) -&gt; np.ndarray\n</code></pre> <p>Prepare a data array for use in a visual.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property.</p> required <code>dtype</code> <code>str</code> <p>The data type of the array.</p> required <code>shape</code> <code>tuple of int</code> <p>The expected shape of the array.</p> required <code>value</code> <code>ndarray</code> <p>The array to prepare.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The prepared array.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the array shape is incorrect.</p>"},{"location":"reference/api_py/#datoviz.utils.prepare_data_scalar","title":"prepare_data_scalar","text":"<pre><code>prepare_data_scalar(\n    name: str, dtype: str, size: int, value: float\n) -&gt; np.ndarray\n</code></pre> <p>Prepare a scalar value for use in a visual.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the property.</p> required <code>dtype</code> <code>str</code> <p>The data type of the scalar.</p> required <code>size</code> <code>int</code> <p>The size of the array to create.</p> required <code>value</code> <code>float</code> <p>The scalar value.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array filled with the scalar value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the size is zero.</p>"},{"location":"reference/api_py/#datoviz.utils.sphere_flags","title":"sphere_flags","text":"<pre><code>sphere_flags(\n    textured: bool = None,\n    equal_rectangular: bool = None,\n    lighting: bool = None,\n    size_pixels: bool = None,\n) -&gt; int\n</code></pre> <p>Compute the C mesh flags based on the given options.</p> <p>Parameters:</p> Name Type Description Default <code>textured</code> <code>bool</code> <p>Whether to use a texture for the sphere.</p> <code>None</code> <code>equal_rectangular</code> <code>bool</code> <p>Whether texture is equal rectangular or front/back tiled.</p> <code>None</code> <code>lighting</code> <code>bool</code> <p>Whether lighting is enabled.</p> <code>None</code> <code>size_pixels</code> <code>bool</code> <p>Whether to specify the sphere size in pixels rather than NDC.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The computed sphere flags.</p>"},{"location":"reference/api_py/#datoviz.utils.to_byte","title":"to_byte","text":"<pre><code>to_byte(\n    arr: ndarray, vmin: float = None, vmax: float = None\n) -&gt; np.ndarray\n</code></pre> <p>Normalize an array to the range [0, 255] and convert to uint8.</p> <p>Parameters:</p> Name Type Description Default <code>arr</code> <code>ndarray</code> <p>The array to normalize.</p> required <code>vmin</code> <code>float</code> <p>The minimum value for normalization, by default None.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>The maximum value for normalization, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The normalized array as uint8.</p>"},{"location":"reference/api_py/#datoviz.utils.to_cvec4_array","title":"to_cvec4_array","text":"<pre><code>to_cvec4_array(colors)\n</code></pre> <p>Convert a list of RGBA colors to a C array of cvec4.</p>"},{"location":"reference/api_py/#datoviz.utils.to_enum","title":"to_enum","text":"<pre><code>to_enum(enumstr: Union[str, int]) -&gt; int\n</code></pre> <p>Convert an enum string to its corresponding value.</p> <p>Parameters:</p> Name Type Description Default <code>enumstr</code> <code>str or int</code> <p>The enum string or value (no-op).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The enum value.</p>"},{"location":"reference/colormaps/","title":"Colormaps","text":"<p>Datoviz includes a built-in collection of common colormaps (continuous) and color palettes (discrete), sourced from Matplotlib, Bokeh, Colorcet, and Kenneth Moreland's color advice page.</p> <p>Note</p> <p>Colormaps and palettes are internally stored in a 256\u00d7256 texture. Each one is located by the row and column of its first element, though this detail can be ignored in most cases.</p> Name Row, Col Colormap <code>binary</code> 0, 0 <code>hsv</code> 1, 0 <code>cividis</code> 2, 0 <code>inferno</code> 3, 0 <code>magma</code> 4, 0 <code>plasma</code> 5, 0 <code>viridis</code> 6, 0 <code>blues</code> 7, 0 <code>bugn</code> 8, 0 <code>bupu</code> 9, 0 <code>gnbu</code> 10, 0 <code>greens</code> 11, 0 <code>greys</code> 12, 0 <code>oranges</code> 13, 0 <code>orrd</code> 14, 0 <code>pubu</code> 15, 0 <code>pubugn</code> 16, 0 <code>purples</code> 17, 0 <code>rdpu</code> 18, 0 <code>reds</code> 19, 0 <code>ylgn</code> 20, 0 <code>ylgnbu</code> 21, 0 <code>ylorbr</code> 22, 0 <code>ylorrd</code> 23, 0 <code>afmhot</code> 24, 0 <code>autumn</code> 25, 0 <code>bone</code> 26, 0 <code>cool</code> 27, 0 <code>copper</code> 28, 0 <code>gist_heat</code> 29, 0 <code>gray</code> 30, 0 <code>hot</code> 31, 0 <code>pink</code> 32, 0 <code>spring</code> 33, 0 <code>summer</code> 34, 0 <code>winter</code> 35, 0 <code>wistia</code> 36, 0 <code>brbg</code> 37, 0 <code>bwr</code> 38, 0 <code>coolwarm</code> 39, 0 <code>piyg</code> 40, 0 <code>prgn</code> 41, 0 <code>puor</code> 42, 0 <code>rdbu</code> 43, 0 <code>rdgy</code> 44, 0 <code>rdylbu</code> 45, 0 <code>rdylgn</code> 46, 0 <code>seismic</code> 47, 0 <code>spectral</code> 48, 0 <code>twilight_shifted</code> 49, 0 <code>twilight</code> 50, 0 <code>brg</code> 51, 0 <code>cmrmap</code> 52, 0 <code>cubehelix</code> 53, 0 <code>flag</code> 54, 0 <code>gist_earth</code> 55, 0 <code>gist_ncar</code> 56, 0 <code>gist_rainbow</code> 57, 0 <code>gist_stern</code> 58, 0 <code>gnuplot2</code> 59, 0 <code>gnuplot</code> 60, 0 <code>jet</code> 61, 0 <code>nipy_spectral</code> 62, 0 <code>ocean</code> 63, 0 <code>prism</code> 64, 0 <code>rainbow</code> 65, 0 <code>terrain</code> 66, 0 <code>bkr</code> 67, 0 <code>bky</code> 68, 0 <code>cet_d10</code> 69, 0 <code>cet_d11</code> 70, 0 <code>cet_d8</code> 71, 0 <code>cet_d13</code> 72, 0 <code>cet_d3</code> 73, 0 <code>cet_d1a</code> 74, 0 <code>bjy</code> 75, 0 <code>gwv</code> 76, 0 <code>bwy</code> 77, 0 <code>cet_d12</code> 78, 0 <code>cet_r3</code> 79, 0 <code>cet_d9</code> 80, 0 <code>cwr</code> 81, 0 <code>cet_cbc1</code> 82, 0 <code>cet_cbc2</code> 83, 0 <code>cet_cbl1</code> 84, 0 <code>cet_cbl2</code> 85, 0 <code>cet_cbtc1</code> 86, 0 <code>cet_cbtc2</code> 87, 0 <code>cet_cbtl1</code> 88, 0 <code>bgy</code> 89, 0 <code>bgyw</code> 90, 0 <code>bmw</code> 91, 0 <code>cet_c1</code> 92, 0 <code>cet_c1s</code> 93, 0 <code>cet_c2</code> 94, 0 <code>cet_c4</code> 95, 0 <code>cet_c4s</code> 96, 0 <code>cet_c5</code> 97, 0 <code>cet_i1</code> 98, 0 <code>cet_i3</code> 99, 0 <code>cet_l10</code> 100, 0 <code>cet_l11</code> 101, 0 <code>cet_l12</code> 102, 0 <code>cet_l16</code> 103, 0 <code>cet_l17</code> 104, 0 <code>cet_l18</code> 105, 0 <code>cet_l19</code> 106, 0 <code>cet_l4</code> 107, 0 <code>cet_l7</code> 108, 0 <code>cet_l8</code> 109, 0 <code>cet_l9</code> 110, 0 <code>cet_r1</code> 111, 0 <code>cet_r2</code> 112, 0 <code>colorwheel</code> 113, 0 <code>fire</code> 114, 0 <code>isolum</code> 115, 0 <code>kb</code> 116, 0 <code>kbc</code> 117, 0 <code>kg</code> 118, 0 <code>kgy</code> 119, 0 <code>kr</code> 120, 0 <code>black_body</code> 121, 0 <code>kindlmann</code> 122, 0 <code>extended_kindlmann</code> 123, 0 <code>glasbey</code> 176, 0 <code>glasbey_cool</code> 177, 0 <code>glasbey_dark</code> 178, 0 <code>glasbey_hv</code> 179, 0 <code>glasbey_light</code> 180, 0 <code>glasbey_warm</code> 181, 0 <code>accent</code> 240, 0 <code>dark2</code> 240, 32 <code>paired</code> 240, 64 <code>pastel1</code> 240, 96 <code>pastel2</code> 240, 128 <code>set1</code> 240, 160 <code>set2</code> 240, 192 <code>set3</code> 240, 224 <code>tab10</code> 241, 0 <code>tab20</code> 241, 32 <code>tab20b</code> 241, 64 <code>tab20c</code> 241, 96 <code>category10_10</code> 241, 128 <code>category20_20</code> 241, 160 <code>category20b_20</code> 241, 192 <code>category20c_20</code> 241, 224 <code>colorblind8</code> 242, 0"},{"location":"visuals/basic/","title":"Basic Visual","text":"<p>The basic visual in Datoviz provides direct access to low-level GPU rendering using core Vulkan primitives.</p> <p>This visual is well suited for rendering large-scale data as points, thin non-antialiased lines, or triangles, with one color per vertex.</p> <p>Note</p> <p>Crude antialiasing techniques may be added in a future version. In the meantime, these visuals are heavily aliased but remain highly efficient.</p>"},{"location":"visuals/basic/#overview","title":"Overview","text":"<ul> <li>Uses core Vulkan primitive topologies: <code>point</code>, <code>line_strip</code>, <code>line_list</code>, <code>triangle_list</code>, and <code>triangle_strip</code></li> <li>Accepts 3D NDC positions</li> <li>Supports per-vertex color</li> <li>Supports uniform size but not per-vertex size</li> <li>Supports a <code>group</code> attribute to separate primitives within a single visual</li> </ul>"},{"location":"visuals/basic/#when-to-use","title":"When to use","text":"<p>Use the basic visual when you need:</p> <ul> <li>Large-scale, uniform visual primitives</li> <li>Full control over rendering topology</li> <li>Minimal overhead and high performance</li> </ul>"},{"location":"visuals/basic/#properties","title":"Properties","text":""},{"location":"visuals/basic/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Vertex positions in NDC <code>color</code> <code>(N, 4) uint8</code> RGBA color per vertex <code>group</code> <code>(N,) float32</code> Group ID used to separate primitives (<code>line_strip</code> and <code>triangle_strip</code>)"},{"location":"visuals/basic/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>size</code> <code>float</code> Pixel size for <code>point</code> topology"},{"location":"visuals/basic/#grouping","title":"Grouping","text":"<p>The <code>group</code> attribute allows you to encode multiple disconnected geometries in one visual.</p> <p>For example, rendering many time series as separate line strips:</p> <pre><code>visual = app.basic('line_strip', position=position, color=color, group=group)\n</code></pre> <ul> <li>Each group must be identified by a consecutive integer ID: <code>0, 0, ..., 1, 1, ..., 2, 2, ...</code></li> <li>Transitions between groups break the connection in line-based topologies.</li> </ul> <p>This approach is memory-efficient and avoids multiple draw calls.</p>"},{"location":"visuals/basic/#topologies","title":"Topologies","text":"<p>Here, we show the different primitive topologies for the Basic visual using the same set of positions, colors, and groups.</p> <p>The 2D points alternate between a lower and upper sine curves. The points are split in two groups with equal size (the <code>group</code> is 0 if <code>i &lt; N/2</code> and 1 if <code>i &gt;= N/2</code>).</p>"},{"location":"visuals/basic/#points","title":"Points","text":"<p>Renders one dot per vertex. Similar to the Pixel visual.</p> <pre><code>visual = app.basic('point_list', position=position, color=color, size=5)\n</code></pre>"},{"location":"visuals/basic/#line-list","title":"Line list","text":"<p>Each pair of vertices forms a separate segment: <code>A-B</code>, <code>C-D</code>, <code>E-F</code>, etc.</p> <pre><code>visual = app.basic('line_list', position=position, color=color)\n</code></pre>"},{"location":"visuals/basic/#line-strip","title":"Line strip","text":"<p>Connects vertices into a continuous path: <code>A-B-C-D</code> becomes a single polyline.</p> <pre><code>visual = app.basic('line_strip', position=position, color=color, group=group)\n</code></pre> <p>Note</p> <p>The optional <code>group</code> attribute can be used to draw multiple line strips in one call, which is best for performance. Note the gap in the middle, corresponding to the transition between the two groups.</p>"},{"location":"visuals/basic/#triangle-list","title":"Triangle list","text":"<p>Each group of 3 vertices forms a triangle: <code>A-B-C</code>, <code>D-E-F</code>, etc.</p> <pre><code>visual = app.basic('triangle_list', position=position, color=color)\n</code></pre>"},{"location":"visuals/basic/#triangle-strip","title":"Triangle strip","text":"<p>Renders connected triangles using a strip pattern: <code>A-B-C</code>, <code>B-C-D</code>, <code>C-D-E</code>, etc.</p> <pre><code>visual = app.basic('triangle_strip', position=position, color=color, group=group)\n</code></pre> <p>Note</p> <p>The optional <code>group</code> attribute can be used to draw multiple triangle strips in one call, which is best for performance. Note the gap in the middle, corresponding to the transition between the two groups.</p>"},{"location":"visuals/basic/#dynamic-topology-change","title":"Dynamic topology change","text":"<p>This example displays a GUI to change the topology of the Basic visual.</p> <p>Warning</p> <p>Changing visual options dynamically is not fully supported yet, so we use a workaround that involves deleting and recreating the visual. This will be improved in Datoviz v0.4.</p> Source <pre><code>import sys\n\nimport numpy as np\n\nimport datoviz as dvz\n\nOPTIONS = dvz.TOPOLOGY_OPTIONS\n\nN = 30\nt2 = np.linspace(-1.0, +1.0, 2 * N)\ny1 = -0.1 + 0.25 * np.sin(2 * 2 * np.pi * t2[0::2])\ny2 = +0.1 + 0.25 * np.sin(2 * 2 * np.pi * t2[1::2])\n\ny = np.c_[y1, y2].ravel()\n\nposition = np.c_[t2, y, np.zeros(2 * N)]\ngroup = np.repeat([0, 1], N)\ncolor = dvz.cmap('hsv', t2, vmin=-1, vmax=+1)\n\napp = dvz.App()\nfigure = app.figure(gui=True)\npanel = figure.panel()\npanzoom = panel.panzoom()\nvisual = None\n\n\ndef set_primitive(primitive):\n    global visual\n    if visual:\n        panel.remove(visual)\n    visual = app.basic(primitive, position=position, color=color, group=group, size=5)\n    panel.add(visual)\n\n\nset_primitive(sys.argv[1] if len(sys.argv) &gt;= 2 else 'point_list')\n\nselected = dvz.Out(0)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_pos(dvz.vec2(10, 10), dvz.vec2(0, 0))\n    dvz.gui_size(dvz.vec2(300, 80))\n    dvz.gui_begin('Primitive topology', 0)\n    if dvz.gui_dropdown('Topology', len(OPTIONS), list(OPTIONS), selected, 0):\n        primitive = OPTIONS[selected.value]\n        set_primitive(primitive)\n    dvz.gui_end()\n\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/basic/#example","title":"Example","text":"<pre><code>import matplotlib.colors as mcolors\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    \"\"\"Return N, positions (N,3) float32, colors (N,4) uint8\"\"\"\n    # Parameters\n    n_arms = 5\n    n_particles_per_arm = 200_000\n    n_total = n_arms * n_particles_per_arm\n\n    rng = np.random.default_rng(seed=42)\n\n    # Radius from center, with more points toward center\n    r = rng.power(2.0, size=n_total)  # values in [0, 1), biased toward 0\n\n    # Angle with swirl per arm and some noise\n    base_theta = np.repeat(np.linspace(0, 2 * np.pi, n_arms, endpoint=False), n_particles_per_arm)\n    swirl = r * 3  # spiral effect\n    noise = rng.normal(scale=0.2, size=n_total)\n    theta = base_theta + swirl + noise\n\n    # Convert polar to Cartesian\n    x = r * np.cos(theta) * 6.0 / 8.0  # HACK: window aspect ratio\n    y = r * np.sin(theta)\n    z = np.zeros_like(x)\n\n    positions = np.stack([x, y, z], axis=1).astype(np.float32)\n\n    # Colors based on radius and angle \u2014 create a vibrant, cosmic feel\n    hue = (theta % (2 * np.pi)) / (2 * np.pi)  # hue from angle\n    saturation = np.clip(r * 1.5, 0.2, 1.0)  # more saturated at edges\n    value = np.ones_like(hue)\n\n    # Convert HSV to RGB\n\n    rgb = mcolors.hsv_to_rgb(np.stack([hue, saturation, value], axis=1))\n    rgb_u8 = (rgb * 255).astype(np.uint8)\n\n    # Alpha: slight fade with radius\n    alpha = np.clip(128 * (1.0 - r), 1, 255).astype(np.uint8)\n    alpha = (200 * np.exp(-5 * r * r)).astype(np.uint8)\n\n    colors = np.concatenate([rgb_u8, alpha[:, None]], axis=1)\n\n    return n_total, positions, colors\n\n\nN, position, color = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.pixel(position=position, color=color)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/basic/#summary","title":"Summary","text":"<p>The <code>basic</code> visual provides direct access to the core rendering capabilities of Datoviz. It's powerful, fast, and flexible \u2014 ideal for high-volume data when you don\u2019t need complex styling.</p> <p>For advanced visuals with lighting, texturing, or custom shapes, see the other visuals.</p>"},{"location":"visuals/glyph/","title":"Glyph Visual","text":"<p>The Glyph visual provides low-level, high-performance text rendering using individual positioned glyphs. It supports fine control over placement, scaling, color, and layout \u2014 ideal for custom labeling, annotations, or scientific overlays where flexibility matters.</p> <p>This visual operates at the glyph level and can render multiple strings using groups of glyphs.</p> <p>This visual is currently implemented with multichannel signed distance fields.</p>"},{"location":"visuals/glyph/#overview","title":"Overview","text":"<ul> <li>Renders glyphs as positioned 2D quads in 3D NDC space</li> <li>Supports per-glyph: color, size, position, shift, rotation, scaling</li> <li>Strings are created by grouping glyphs with the same position</li> <li>Anchoring is relative to the entire string, not each glyph</li> <li>Highly flexible, low-level control \u2014 not a high-level text API</li> <li>Uses a builtin texture font atlas \u2014 font and atlas customization will be implemented and documented later</li> </ul>"},{"location":"visuals/glyph/#when-to-use","title":"When to use","text":"<p>Use the glyph visual when:</p> <ul> <li>You want fine-grained control over text rendering (e.g. per-character styling)</li> <li>You need rotated, scaled, or colored strings at arbitrary 3D positions</li> <li>You\u2019re rendering structured labels, not paragraphs</li> </ul>"},{"location":"visuals/glyph/#properties","title":"Properties","text":""},{"location":"visuals/glyph/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Anchor position for each glyph (in NDC) <code>axis</code> <code>(N, 3) float32</code> Not implemented yet <code>size</code> <code>(N, 2) float32</code> Glyph size in framebuffer pixels <code>shift</code> <code>(N, 2) float32</code> Offset of each glyph in framebuffer pixels (layout) <code>texcoords</code> <code>(N, 4) float32</code> Texture UV for each glyph <code>group_size</code> <code>(N, 2) float32</code> Size of the full string the glyph belongs to <code>scale</code> <code>(N,) float32</code> Per-glyph scaling factor <code>angle</code> <code>(N,) float32</code> Rotation angle (radians) per glyph <code>color</code> <code>(N, 4) uint8</code> Glyph fill color"},{"location":"visuals/glyph/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>bgcolor</code> <code>vec4</code> Background color behind each glyph <code>texture</code> texture Glyph atlas texture"},{"location":"visuals/glyph/#grouping-and-string-layout","title":"Grouping and string layout","text":"<p>Glyphs are grouped into strings by sharing the same anchor <code>position</code>. They are placed using:</p> <ul> <li><code>shift</code>: pixel offset of the glyph relative to its anchor</li> <li><code>size</code>: glyph quad size in pixels</li> <li><code>group_size</code>: size of the entire string, used for anchor alignment</li> </ul> <p>Anchoring is applied relative to the full string, not each glyph \u2014 for example, <code>anchor = [0, 0]</code> centers the full string at the anchor point.</p>"},{"location":"visuals/glyph/#helper-set_strings","title":"Helper: <code>set_strings()</code>","text":"<p>To simplify text rendering, use <code>set_strings()</code> to define multiple strings at once:</p> <pre><code>visual.set_strings(\n    strings=['Hello', 'World'],\n    string_pos=positions,      # (M, 3) array of anchor points\n    scales=scales,             # (M,) array of scale factors\n    color=(255, 255, 255, 255),# RGBA\n    anchor=(0, 0),             # center anchor\n    offset=(0, 0)              # optional pixel offset\n)\n</code></pre> <p>After calling <code>set_strings()</code>, you can still customize glyph-level attributes using:</p> <pre><code>visual.set_color(per_glyph_colors)\nvisual.set_angle(per_glyph_angles)\n...\n</code></pre> <p>This provides an efficient way to define structured text and then refine it per glyph if needed.</p>"},{"location":"visuals/glyph/#font-and-msdf-rendering","title":"Font and MSDF Rendering","text":"<p>Datoviz uses MSDF (Multi-channel Signed Distance Field) rendering for high-quality, scalable glyph rendering. A pre-generated MSDF glyph atlas is bundled with the library.</p> <ul> <li>The default font is Roboto</li> <li>The atlas is generated using msdfgen</li> <li>When calling <code>app.glyph()</code>, you can specify the <code>font_size</code> keyword to select the glyph atlas resolution</li> </ul> <pre><code>visual = app.glyph(font_size=30)\n</code></pre>"},{"location":"visuals/glyph/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\n# Define the strings and string parameters.\nstrings = ['Hello world'] * 8\nstring_count = len(strings)\nglyph_count = sum(map(len, strings))\nstring_pos = np.zeros((string_count, 3), dtype=np.float32)\nstring_pos[:, 0] = -0.8\nstring_pos[:, 1] = 1 - 1.8 * np.linspace(0.3, 1, string_count) ** 2\nscales = np.linspace(1, 4, string_count).astype(np.float32)\n\n# Per-glyph parameters.\ncolors = dvz.cmap('hsv', np.mod(np.linspace(0, 2, glyph_count), 1))\n\nvisual = app.glyph(font_size=30)\nvisual.set_strings(strings, string_pos=string_pos, scales=scales)\nvisual.set_color(colors)\n\npanel.add(visual)\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/glyph/#summary","title":"Summary","text":"<p>The glyph visual gives you total control over text rendering at the glyph level.</p> <ul> <li>\u2714\ufe0f Precise 2D/3D placement and styling</li> <li>\u2714\ufe0f Per-glyph color, rotation, shift, and size</li> <li>\u2714\ufe0f Grouping into strings with anchor-aware layout</li> <li>\u274c No automatic layout, alignment, or wrapping</li> </ul> <p>See also:</p> <ul> <li>Image for 2D raster overlays</li> <li>Marker for symbolic shapes with rotation</li> </ul>"},{"location":"visuals/image/","title":"Image Visual","text":"<p>The Image visual displays 2D colored or single-channel images (with colormaps) anchored at a position in 3D space. It supports flexible anchoring, sizing in pixels or normalized device coordinates (NDC), rescaling behavior, and optional square or rounded borders.</p>"},{"location":"visuals/image/#overview","title":"Overview","text":"<ul> <li>Displays RGBA or single-channel images in a 2D panel</li> <li>Anchored at a 3D NDC position using a configurable alignment point</li> <li>Size can be set in either pixels or NDC units</li> <li>Supports borders, round corners, and rescaling behavior</li> <li>Image data can be full color or colormapped from single-channel textures</li> </ul>"},{"location":"visuals/image/#when-to-use","title":"When to use","text":"<p>Use the image visual when:</p> <ul> <li>You need to overlay 2D raster data (e.g. camera frames, microscope images)</li> <li>You want precise control over alignment and size</li> <li>You need to visualize single-channel arrays with a colormap</li> </ul>"},{"location":"visuals/image/#properties","title":"Properties","text":"<p>Each item in the visual is a single image. Multiple images can be efficiently displayed at different positions in the same visual.</p> <p>Warning</p> <p>Currently, all images in a given visual must share the same texture image, though they can use different texture coordinates.</p>"},{"location":"visuals/image/#options","title":"Options","text":"Option Type Description <code>unit</code> <code>enum</code> Unit of the image size <code>mode</code> <code>enum</code> Color mode <code>rescale</code> <code>enum</code> Rescale mode"},{"location":"visuals/image/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Anchor point for the image (in NDC coordinates) <code>size</code> <code>(N, 2) float32</code> Image width and height <code>anchor</code> <code>(N, 2) float32</code> Relative point in the image attached to position <code>texcoords</code> <code>(N, 4) float32</code> Texture coordinates (default is <code>(0, 0, 1, 1)</code>) <code>facecolor</code> <code>(N, 4) uint8</code> Fill color (used in <code>fill</code> mode)"},{"location":"visuals/image/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>border</code> <code>bool</code> Show or hide a border around the image <code>edgecolor</code> <code>cvec4</code> Color of the border edge <code>linewidth</code> <code>float</code> Width of the border in pixels <code>radius</code> <code>float</code> Border corner radius (for rounded edges) <code>colormap</code> <code>enum</code> Colormap used in <code>colormap</code> mode <code>permutation</code> <code>ivec2</code> Axis swizzle for texture sampling (e.g. <code>(1, 0)</code>) <code>texture</code> texture Texture object (RGBA or single-channel)"},{"location":"visuals/image/#image-unit","title":"Image unit","text":"<p>Use the <code>unit</code> attribute to specify the unit in which the image sizes are expressed:</p> Unit Description <code>pixels</code> (default) Size is in framebuffer pixels <code>ndc</code> Size is relative to panel NDC coordinates"},{"location":"visuals/image/#color-mode","title":"Color mode","text":"<p>Use the <code>mode</code> attribute to define how the image is rendered:</p> Mode Description <code>rgba</code> (default) Full RGBA image <code>colormap</code> Single-channel image with a colormap <code>fill</code> Fill with uniform <code>facecolor</code> (no texture needed)"},{"location":"visuals/image/#rescale-mode","title":"Rescale mode","text":"<p>Use the <code>rescale</code> attribute to define how the image is resized:</p> Mode Description <code>None</code> (default) Fixed size, no scaling <code>rescale</code> Image scales with pan-zoom <code>keep_ratio</code> Image scales while maintaining its aspect ratio"},{"location":"visuals/image/#border","title":"Border","text":"<p>Use the <code>border</code> attribute to indicate whether a border should be shown. If enabled, the following attributes can be used to customize the image border:</p> Parameter Description <code>edgecolor</code> Color of the border <code>linewidth</code> Thickness in pixels <code>radius</code> Corner rounding radius"},{"location":"visuals/image/#anchor-point","title":"Anchor point","text":"<p>The <code>anchor</code> attribute defines which part of the image rectangle is attached to the <code>position</code> coordinate in NDC space.</p> <p>The anchor is specified as a 2D vector in the range <code>[-1, +1]</code>.</p> <p></p> <p>Image anchor point</p> <p>Here are a few examples:</p> Anchor Description <code>[-1, -1]</code> bottom-left corner <code>[0, 0]</code> center of the image <code>[+1, +1]</code> top-right corner <p>This allows precise placement of the image relative to your coordinate system.</p> <p>Info</p> <p>The anchor feature example illustrates how the behavior of the anchor in the Image visual.</p>"},{"location":"visuals/image/#texture-swizzling","title":"Texture swizzling","text":"<p>The <code>permutation</code> attribute controls how texture axes are interpreted. For example, <code>(0, 1)</code> is the default (UV); <code>(1, 0)</code> uses VU instead.</p> <p>This can be useful when image data is stored with flipped or transposed axes.</p>"},{"location":"visuals/image/#example","title":"Example","text":"<pre><code>import imageio.v3 as iio\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_image():\n    filepath = dvz.download_data('textures/image.png')\n    arr = iio.imread(filepath)\n    h, w, _ = arr.shape\n    return np.dstack((arr, np.full((h, w), 255))).astype(np.uint8)\n\n\nimage = load_image()\nheight, width, _ = image.shape\n\nposition = np.array([[0, 0, 0]], dtype=np.float32)\nsize = np.array([[width, height]], dtype=np.float32)\nanchor = np.array([[0, 0]], dtype=np.float32)\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.image(\n    rescale='keep_ratio',\n    position=position,\n    size=size,\n    anchor=anchor,\n    texcoords=texcoords,\n    #\n    # Image border\n    linewidth=10,\n    edgecolor=(255, 255, 255, 255),\n    radius=50,\n)\ntexture = app.texture_2D(image, interpolation='linear')  # by default, no interpolation\nvisual.set_texture(texture)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/image/#summary","title":"Summary","text":"<p>The image visual provides flexible placement and styling of 2D textures.</p> <ul> <li>\u2714\ufe0f Position, anchor, and size control</li> <li>\u2714\ufe0f Borders, round corners, and rescaling</li> <li>\u2714\ufe0f Support for colormaps and single-channel data</li> </ul> <p>See also:</p> <ul> <li>Pixel: for sparse or point-based raster plots</li> <li>Volume: for 3D scalar field visualization</li> </ul>"},{"location":"visuals/marker/","title":"Marker Visual","text":"<p>The Marker visual is a versatile and customizable point visual that supports symbolic shapes, rotation, borders, and texture-based rendering. It is ideal for labeled scatter plots, categorized data points, or any visualization that needs distinct marker styles.</p>"},{"location":"visuals/marker/#overview","title":"Overview","text":"<ul> <li>Renders symbolic shapes (e.g., disc, triangle, square)</li> <li>Supports custom SVGs, bitmap textures, and SDF/MSDF formats</li> <li>Each marker has per-vertex position, color, size, and rotation</li> <li>Can be filled, bordered, or outlined-only</li> <li>Supports uniform control of border width, edge color, and texture scaling</li> </ul> <p>Note</p> <p>Currently, all markers within a single visual share the same shape. To display multiple shapes, use a separate visual for each marker type and group the points accordingly.</p>"},{"location":"visuals/marker/#when-to-use","title":"When to use","text":"<p>Use the marker visual when:</p> <ul> <li>You want distinct shapes for different data categories</li> <li>You need rotation, border, or outline styling per marker</li> <li>You want to use custom textures (SVG, bitmap, SDF/MSDF)</li> <li>You need high flexibility for scatter or symbol-based plots</li> </ul>"},{"location":"visuals/marker/#properties","title":"Properties","text":""},{"location":"visuals/marker/#options","title":"Options","text":"Option Type Description <code>shape</code> enum Marker shape (only used when <code>mode='code'</code>) <code>mode</code> enum Rendering mode (<code>code</code>, <code>bitmap</code>, <code>sdf</code>, <code>msdf</code>) <code>aspect</code> enum Aspect ratio behavior"},{"location":"visuals/marker/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Marker position in NDC <code>color</code> <code>(N, 4) uint8</code> Fill color per marker <code>size</code> <code>(N,) float32</code> Diameter in framebuffer pixels <code>angle</code> <code>(N,) float32</code> Rotation angle in radians"},{"location":"visuals/marker/#per-visual-uniform","title":"Per-visual (uniform)","text":"Attribute Type Description <code>linewidth</code> float Outline width in pixels <code>edgecolor</code> cvec4 Outline color (applied uniformly) <code>tex_scale</code> float Global scaling factor for all markers <code>texture</code> texture Texture object for bitmap/SDF/MSDF modes"},{"location":"visuals/marker/#rendering-modes","title":"Rendering modes","text":"<p>The visual supports four rendering modes:</p> Mode Description <code>code</code> Uses GPU-coded built-in shapes (fastest) <code>bitmap</code> Uses a bitmap texture <code>sdf</code> Uses a signed distance field texture <code>msdf</code> Uses a multichannel signed distance field <p>Note</p> <p>For SDF and MSDF, Datoviz bundles the Multi-channel signed distance field generator C++ library.</p>"},{"location":"visuals/marker/#code","title":"Code","text":"<p>The following predefined marker shapes, implemented on the GPU, are supported when using <code>mode='code'</code>:</p> Marker Value Image <code>disc</code> 0 <code>asterisk</code> 1 <code>chevron</code> 2 <code>clover</code> 3 <code>club</code> 4 <code>cross</code> 5 <code>diamond</code> 6 <code>arrow</code> 7 <code>ellipse</code> 8 <code>hbar</code> 9 <code>heart</code> 10 <code>infinity</code> 11 <code>pin</code> 12 <code>ring</code> 13 <code>spade</code> 14 <code>square</code> 15 <code>tag</code> 16 <code>triangle</code> 17 <code>vbar</code> 18"},{"location":"visuals/marker/#bitmap","title":"Bitmap","text":"<p>A bitmap texture with the marker to render.</p>"},{"location":"visuals/marker/#sdf","title":"SDF","text":"<p>The SDF mode (Signed Distance Field) encodes the distance from the marker's outline in a single channel. This allows for resolution-independent rendering with crisp edges and efficient antialiasing.</p>"},{"location":"visuals/marker/#msdf","title":"MSDF","text":"<p>The MSDF mode (Multi-channel Signed Distance Field) encodes distance separately in RGB channels, enabling sharper rendering of complex shapes (e.g. icons) with fewer artifacts.</p> <p>Warning</p> <p>The documentation for the rendering modes above is incomplete. Contributions are welcome.</p>"},{"location":"visuals/marker/#aspect","title":"Aspect","text":"<p>The <code>aspect</code> attribute controls how each marker is rendered, using <code>aspect='filled'</code> for example:</p> Aspect value Description Image <code>filled</code> Fill only, no border (default) <code>stroke</code> Border only, transparent interior <code>outline</code> Fill with border (filled + stroke combined) <p>These aspects are customized with the following properties:</p> <ul> <li><code>color</code>: fill color (per marker)</li> <li><code>edgecolor</code>: outline color (uniform)</li> <li><code>linewidth</code>: outline thickness (uniform, in pixels)</li> </ul>"},{"location":"visuals/marker/#example","title":"Example","text":"<pre><code>from pathlib import Path\n\nimport imageio.v3 as iio\nimport numpy as np\n\nimport datoviz as dvz\n\nROOT_DIR = Path(__file__).resolve().parent.parent.parent\nW, H = 800, 600\nHW, HH = W / 2.0, H / 2.0\nsvg_path = 'M50,10 L61.8,35.5 L90,42 L69,61 L75,90 L50,75 L25,90 L31,61 L10,42 L38.2,35.5 Z'\n\n\ndef generate_data():\n    grid_x = 6\n    grid_y = 5\n    N = grid_x * grid_y\n\n    # Grid coordinates in [-1, 1]\n    x = np.linspace(-1, 1, grid_x)\n    y = np.linspace(-1, 1, grid_y)\n    X, Y = np.meshgrid(x, y)\n    x_flat = X.flatten()\n    y_flat = Y.flatten()\n    z_flat = np.zeros_like(x_flat)\n\n    positions = np.stack([x_flat, y_flat, z_flat], axis=1).astype(np.float32)\n    positions *= 0.8  # margin\n\n    # Hue along x-axis\n    hue = (x_flat + 1) / 2\n    colors = dvz.cmap('hsv', hue)\n\n    # Size: exponential growth from 10px to 50px along y-axis\n    y_norm = (y_flat + 1) / 2\n    sizes = 25 * 2.0**y_norm\n    sizes = sizes.astype(np.float32)\n\n    return N, positions, colors, sizes\n\n\ndef load_texture_rgba(path):\n    arr = iio.imread(path)\n    return arr\n\n\ndef make_texture(image):\n    assert image.ndim == 3\n    assert image.shape[2] == 4\n    assert image.dtype == np.uint8\n    return app.texture(image)\n\n\ndef make_svg_msdf_texture(svg_path, size=64):\n    msdf = dvz.msdf_from_svg(svg_path, size, size)\n    msdf_alpha = np.empty((size, size, 4), dtype=np.float32)\n    dvz.rgb_to_rgba_float(size * size, msdf, msdf_alpha.ravel())\n    return app.texture(msdf_alpha)\n\n\ndef make_visual(panel):\n    N, position, color, size = generate_data()\n    angle = np.linspace(0, 2 * np.pi, N)\n    visual = app.marker(\n        position=position,\n        color=color,\n        size=size,\n        angle=angle,\n        edgecolor=(255, 255, 255, 255),\n        linewidth=2.0,\n    )\n    panel.add(visual)\n    return visual\n\n\napp = dvz.App()\nfigure = app.figure()\n\n# Code Outline\npanel = figure.panel(offset=(0, 0), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_mode('code')\nvisual.set_aspect('outline')\nvisual.set_shape('club')  # pre-defined shapes coded in the shaders\n\n# Bitmap\npanel = figure.panel(offset=(HW, 0), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_mode('bitmap')\nvisual.set_aspect('filled')\nvisual.set_shape('club')\nimage = load_texture_rgba(dvz.download_data('textures/pushpin.png'))\ntexture = make_texture(image)\nvisual.set_texture(texture)  # bitmap textures\n\n# Code Stroke\npanel = figure.panel(offset=(0, HH), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_mode('code')\nvisual.set_aspect('stroke')\nvisual.set_shape('spade')\n\n# SVG\npanel = figure.panel(offset=(HW, HH), size=(HW, HH))\nvisual = make_visual(panel)\nvisual.set_tex_scale(100)  # Important: let the visual know about the texture size\nvisual.set_mode('msdf')\nvisual.set_aspect('outline')\nmsdf = make_svg_msdf_texture(svg_path, size=100)\nvisual.set_texture(msdf)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/marker/#summary","title":"Summary","text":"<p>The marker visual combines flexibility, performance, and clarity for symbolic point visualization.</p> <ul> <li>\u2714\ufe0f Custom shapes and rotation</li> <li>\u2714\ufe0f Support for vector or bitmap textures</li> <li>\u2714\ufe0f Per-marker styling and global controls</li> <li>\u274c Not intended for ultra-dense clouds (use Point or Pixel for that)</li> </ul> <p>See also:</p> <ul> <li>Point: simple discs with per-point size and color</li> <li>Basic: raw primitives without symbolic shapes</li> </ul>"},{"location":"visuals/mesh/","title":"Mesh Visual","text":"<p>The Mesh visual renders 3D surfaces composed of triangles. It supports flat shading, lighting, texturing, contours, and experimental isolines.</p>"},{"location":"visuals/mesh/#overview","title":"Overview","text":"<ul> <li>Supports both indexed and non-indexed triangle geometry</li> <li>Can be constructed manually or from predefined 2D/3D shapes</li> <li>Optional features include: lighting, texture mapping, wireframe contours, and isolines</li> <li>Ideal for surface meshes, geometry visualization, anatomical data, and simulation output</li> </ul>"},{"location":"visuals/mesh/#construction","title":"Construction","text":"<p>There are two ways to create a mesh visual:</p> <ul> <li>Supply raw mesh data manually with <code>visual = app.mesh(position=..., color=..., normal=..., index=...)</code></li> <li>Supply a <code>ShapeCollection</code> with <code>visual = app.mesh(shape_collection, ...)</code>.</li> </ul> <p>A <code>ShapeCollection</code> can be created with:</p> <ul> <li>Built-in 2D/3D primitives (rectangles, cubes, spheres, etc.)</li> <li>OBJ models</li> </ul> <p>See Advanced \u2192 Shapes for more on creating <code>ShapeCollection</code> instances.</p>"},{"location":"visuals/mesh/#properties","title":"Properties","text":""},{"location":"visuals/mesh/#options","title":"Options","text":"Option Type Description <code>indexed</code> <code>bool</code> Whether the mesh uses indexing <code>textured</code> <code>bool</code> Whether to use a texture for rendering <code>lighting</code> <code>bool</code> Whether to use lighting <code>contour</code> <code>bool</code> Whether to show contour or wireframes <code>isoline</code> <code>bool</code> Whether to show isolines"},{"location":"visuals/mesh/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Vertex positions (in NDC) <code>normal</code> <code>(N, 3) float32</code> Vertex normals (required for lighting) <code>color</code> <code>(N, 4) uint8</code> Vertex color (RGBA) <code>texcoords</code> <code>(N, 4) float32</code> Texture coordinates (only if textured) <code>isoline</code> <code>(N,) float32</code> Scalar values for isoline rendering <code>contour</code> <code>(N, 4) uint8</code> Optional triangle contour color"},{"location":"visuals/mesh/#index-buffer","title":"Index buffer","text":"<p>When <code>indexed=True</code>, the optional <code>index</code> argument is a 1D array of <code>uint32</code> values, where each group of three consecutive integers represents indices into the <code>position</code> array, defining the vertices of a triangle.</p>"},{"location":"visuals/mesh/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>light_pos</code> <code>vec4</code> Light position/direction <code>light_color</code> <code>cvec4</code> Light color <code>material_params</code> <code>vec4</code> Material parameters <code>shine</code> <code>float</code> Shine value <code>emit</code> <code>float</code> Emission value <code>edgecolor</code> <code>cvec4</code> Color of contour edges <code>linewidth</code> <code>float</code> Width of contour lines <code>density</code> <code>int</code> Isoline density <code>texture</code> texture Texture used when <code>textured=True</code>"},{"location":"visuals/mesh/#texturing","title":"Texturing","text":"<p>When <code>textured=True</code>, a texture can be applied to the mesh surface.</p> <ul> <li>Supply <code>texcoords</code> per vertex</li> <li>Assign a texture using <code>visual.set_texture(...)</code></li> </ul> <p>Texturing is compatible with lighting and contour rendering.</p>"},{"location":"visuals/mesh/#lighting","title":"Lighting","text":"<p>Enable lighting by passing <code>lighting=True</code> when creating the mesh. Per-vertex normals are required for lighting to have an effect.</p> <p>Currently, up to four different lights are supported.</p>"},{"location":"visuals/mesh/#light-position-and-direction","title":"Light position and direction","text":"<p>This can represent either the 3D position of a point light (<code>w=1</code>) or the 3D direction of a directional light (<code>w=0</code>), depending on the fourth component <code>w</code> of the <code>vec4</code> vector.</p> <pre><code>visual.set_light_pos(pos, index=0)  # index=0..3 is the light index\n</code></pre>"},{"location":"visuals/mesh/#light-color","title":"Light color","text":"<p>This is the RGBA color of the light source.</p> <pre><code>visual.set_light_color(rgba, index=0)  # index=0..3 is the light index\n</code></pre>"},{"location":"visuals/mesh/#material","title":"Material","text":"<p>These are the mesh material RGB values, for four different sets of parameters:</p> Index Parameter Description 0 ambient ambient 1 diffuse diffuse 2 specular specular 3 exponent exponent <pre><code>visual.set_material_params(rgb, index=0)  # index=0..3 is the material type index\n</code></pre> <p>Additional parameters are:</p> <pre><code>visual.set_shine(value)\nvisual.set_amit(value)\n</code></pre> <p>Warning</p> <p>This section of the documentation is not yet complete.</p> <p>Note</p> <p>Lighting is currently basic (flat/Phong-style). Support for more advanced materials is under development.</p>"},{"location":"visuals/mesh/#contour","title":"Contour","text":"<p>When <code>contour=True</code>, triangle edges are drawn as outlines (wireframe-like effect).</p> <ul> <li>Use <code>edgecolor</code> to define contour color</li> <li>Use <code>linewidth</code> to define stroke width</li> </ul> <p>Contours help reveal mesh structure and polygon boundaries.</p> <p>Note</p> <p>Contours can be set per triangle or for a subset of triangles, such as quads or polygon boundaries. This feature is not fully documented yet.</p>"},{"location":"visuals/mesh/#isoline-experimental","title":"Isoline (experimental)","text":"<p>The mesh visual supports experimental isoline rendering, i.e., drawing level curves over the surface.</p> <ul> <li>Provide a per-vertex scalar field via <code>isoline</code></li> <li>Set <code>density</code> to control the number of isolines</li> </ul> <p>This feature is still in development and may change in future versions.</p>"},{"location":"visuals/mesh/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\nN = 5\ncolors = dvz.cmap('spring', np.linspace(0, 1, N))\nscale = 0.35\n\nsc = dvz.ShapeCollection()\nsc.add_tetrahedron(offset=(-1, 0, 0.5), scale=scale, color=colors[0])\nsc.add_hexahedron(offset=(0, 0, 0.5), scale=scale, color=colors[1])\nsc.add_octahedron(offset=(1, 0, 0.5), scale=scale, color=colors[2])\nsc.add_dodecahedron(offset=(-0.5, 0, -0.5), scale=scale, color=colors[3])\nsc.add_icosahedron(offset=(+0.5, 0, -0.5), scale=scale, color=colors[4])\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\narcball = panel.arcball(initial=(-2, 0, 0))\n\nvisual = app.mesh(sc, lighting=True)\n\npanel.add(visual)\n\napp.run()\napp.destroy()\n\nsc.destroy()\n</code></pre>"},{"location":"visuals/mesh/#summary","title":"Summary","text":"<p>The mesh visual supports versatile rendering of surface geometry with optional enhancements.</p> <ul> <li>\u2714\ufe0f Lighting and normals</li> <li>\u2714\ufe0f Texturing and UV mapping</li> <li>\u2714\ufe0f Wireframe and isolines</li> <li>\u2714\ufe0f Indexed and unindexed triangles</li> </ul> <p>See also:</p> <ul> <li>Volume for volumetric fields</li> <li>Image for flat texture overlays</li> <li>Shapes for building reusable geometry</li> </ul>"},{"location":"visuals/path/","title":"Path Visual","text":"<p>The Path visual renders continuous polylines \u2014 sequences of connected line segments that form a single open or closed path. It supports batch rendering with multiple disconnected paths per visual, per-vertex styling and optional variable thickness, making it well-suited for contours, trajectories, and line-based annotations.</p> <p>Note</p> <p>This visual is powerful and high-quality, but not optimized or scalable to millions of points. For very large datasets, use the lower-quality but more scalable Basic visual instead, with the <code>line_strip</code> primitive and groups.</p>"},{"location":"visuals/path/#overview","title":"Overview","text":"<ul> <li>Renders connected polylines from vertex sequences</li> <li>Supports per-vertex color and linewidth</li> <li>Each group of vertices forms an independent path</li> <li>Optional cap and join styles for line ends and corners</li> </ul> <p>Warning</p> <p>Dashed paths are not yet implemented.</p>"},{"location":"visuals/path/#when-to-use","title":"When to use","text":"<p>Use the path visual when:</p> <ul> <li>You want to draw 2D or 3D trajectories or contours</li> <li>You need continuous, styled polylines with thickness</li> <li>You want to render multiple independent paths in one visual</li> </ul>"},{"location":"visuals/path/#properties","title":"Properties","text":""},{"location":"visuals/path/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Vertex positions in NDC <code>color</code> <code>(N, 4) uint8</code> RGBA color per vertex <code>linewidth</code> <code>(N,) float32</code> Line thickness in pixels"},{"location":"visuals/path/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>cap</code> enum Cap style at the start/end of each path <code>join</code> enum Join style between connected segments <p>Cap and join styles are defined by enums from the Vulkan line rendering system.</p>"},{"location":"visuals/path/#cap-types","title":"Cap types","text":"<p>Each path endpoint can be rendered with a custom cap style:</p> Cap Name Image <code>round</code> <code>triangle_in</code> <code>triangle_out</code> <code>square</code> <code>butt</code>"},{"location":"visuals/path/#joint-styles","title":"Joint styles","text":"Cap Name <code>square</code> <code>round</code>"},{"location":"visuals/path/#grouping-paths","title":"Grouping paths","text":"<p>Each visual can include multiple independent paths. Use <code>visual.set_position()</code> to specify how the data is grouped. You can pass either:</p> <ul> <li>A list of arrays, where each array defines one path</li> <li> <p>A single position array, and an additional argument <code>groups</code> which is either:</p> <ul> <li><code>int</code>: number of paths (the position array is split in that number of equal size sub-paths)</li> <li><code>np.ndarray</code>: an array of group size integers</li> </ul> </li> </ul> <p>Each group becomes a separate, continuous polyline.</p>"},{"location":"visuals/path/#large-scale-paths","title":"Large-scale paths","text":"<p>For very large paths (e.g. time series with millions of points), you may prefer the Basic visual with <code>line_strip</code> topology. This will be more efficient but offers no line width or styling.</p>"},{"location":"visuals/path/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data(n_groups=20, n_samples=10_000):\n    N = n_groups * n_samples\n\n    t = np.linspace(-1, 1, n_samples)\n    group_indices = np.arange(n_groups)\n    y_base = np.linspace(-1, 1, n_groups)\n\n    positions = np.zeros((N, 3), dtype=np.float32)\n    linewidths = np.zeros(N, dtype=np.float32)\n\n    for i, g in enumerate(group_indices):\n        freq = 1 + 1.5 * np.exp(0.1 * i)\n        phase = g * np.pi / 4\n        y_offset = y_base[i]\n        y = y_offset + 0.1 * np.sin(2 * np.pi * freq * (t + 1) / 2 + phase)\n\n        start = i * n_samples\n        end = (i + 1) * n_samples\n        positions[start:end, 0] = t\n        positions[start:end, 1] = y\n        positions[start:end, 2] = 0.0\n\n    t = np.linspace(0, n_groups - 0.25, N).astype(np.float32)\n    t = np.mod(t, 1)\n    colors = dvz.cmap('hsv', t, 0, 1)\n\n    positions[:, 0] *= 0.9\n    positions[:, 1] *= 0.8\n\n    linewidths = np.linspace(0, 1, N)\n    linewidths = 8 + 6 * np.sin(2 * (n_groups - 1) * np.pi * linewidths)\n    linewidths = linewidths.astype(np.float32)\n\n    return N, positions, colors, linewidths\n\n\nn_groups = 20\nn_samples = 1_000\nN = n_groups * n_samples\nN, position, color, linewidth = generate_data(n_groups=n_groups, n_samples=n_samples)\nlengths = np.full(n_groups, n_samples, dtype=np.uint32)\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.path()\nvisual.set_position(position, groups=n_groups)\nvisual.set_data(color=color, linewidth=linewidth, cap='round', join='round')\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/path/#summary","title":"Summary","text":"<p>The path visual is ideal for rendering styled, continuous line sequences.</p> <ul> <li>\u2714\ufe0f Variable thickness and color</li> <li>\u2714\ufe0f Multiple independent paths per visual</li> <li>\u2714\ufe0f Custom caps and joins</li> <li>\u274c No dashed line support yet</li> </ul> <p>See also:</p> <ul> <li>Segment for unconnected lines</li> <li>Basic for large 1-pixel polylines</li> </ul>"},{"location":"visuals/pixel/","title":"Pixel Visual","text":"<p>The Pixel visual renders individual square-shaped pixels at arbitrary positions. Each pixel has a given size (shared by all vertices in the visual) and a color.</p> <p>This visual is ideal for raster-style plots or large-scale point clouds, where millions of points can be displayed efficiently with minimal styling.</p>"},{"location":"visuals/pixel/#overview","title":"Overview","text":"<ul> <li>Renders square, filled pixels at 3D NDC positions</li> <li>Per-vertex: position and color</li> <li>Uniform: pixel size (applies to all vertices)</li> <li>Supports depth testing for 3D layering</li> <li>Efficient for dense, unstructured data</li> </ul>"},{"location":"visuals/pixel/#when-to-use","title":"When to use","text":"<p>Use the pixel visual when:</p> <ul> <li>You want to display raw 2D or 3D data points without borders or variable sizing</li> <li>You need to visualize millions of points efficiently</li> </ul>"},{"location":"visuals/pixel/#properties","title":"Properties","text":""},{"location":"visuals/pixel/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> 3D positions in NDC <code>color</code> <code>(N, 4) uint8</code> RGBA color per pixel"},{"location":"visuals/pixel/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>size</code> float Side length of each pixel in framebuffer pixels"},{"location":"visuals/pixel/#basic-usage","title":"Basic usage","text":"<pre><code>visual = app.pixel(position=position, color=color, size=5)\n</code></pre> <ul> <li><code>position</code>: a <code>(N, 3)</code> array in Normalized Device Coordinates (NDC)</li> <li><code>color</code>: a <code>(N, 4)</code> array of <code>uint8</code> RGBA values</li> <li><code>size</code>: a scalar integer for pixel size in framebuffer pixels</li> </ul>"},{"location":"visuals/pixel/#example","title":"Example","text":"<pre><code>import matplotlib.colors as mcolors\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    \"\"\"Return N, positions (N,3) float32, colors (N,4) uint8\"\"\"\n    # Parameters\n    n_arms = 5\n    n_particles_per_arm = 200_000\n    n_total = n_arms * n_particles_per_arm\n\n    rng = np.random.default_rng(seed=42)\n\n    # Radius from center, with more points toward center\n    r = rng.power(2.0, size=n_total)  # values in [0, 1), biased toward 0\n\n    # Angle with swirl per arm and some noise\n    base_theta = np.repeat(np.linspace(0, 2 * np.pi, n_arms, endpoint=False), n_particles_per_arm)\n    swirl = r * 3  # spiral effect\n    noise = rng.normal(scale=0.2, size=n_total)\n    theta = base_theta + swirl + noise\n\n    # Convert polar to Cartesian\n    x = r * np.cos(theta) * 6.0 / 8.0  # HACK: window aspect ratio\n    y = r * np.sin(theta)\n    z = np.zeros_like(x)\n\n    positions = np.stack([x, y, z], axis=1).astype(np.float32)\n\n    # Colors based on radius and angle \u2014 create a vibrant, cosmic feel\n    hue = (theta % (2 * np.pi)) / (2 * np.pi)  # hue from angle\n    saturation = np.clip(r * 1.5, 0.2, 1.0)  # more saturated at edges\n    value = np.ones_like(hue)\n\n    # Convert HSV to RGB\n\n    rgb = mcolors.hsv_to_rgb(np.stack([hue, saturation, value], axis=1))\n    rgb_u8 = (rgb * 255).astype(np.uint8)\n\n    # Alpha: slight fade with radius\n    alpha = np.clip(128 * (1.0 - r), 1, 255).astype(np.uint8)\n    alpha = (200 * np.exp(-5 * r * r)).astype(np.uint8)\n\n    colors = np.concatenate([rgb_u8, alpha[:, None]], axis=1)\n\n    return n_total, positions, colors\n\n\nN, position, color = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.pixel(position=position, color=color)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/pixel/#summary","title":"Summary","text":"<p>The pixel visual is a fast, lightweight way to display large datasets as colored squares in 2D or 3D space.</p> <ul> <li>\u2714\ufe0f Per-point position and color</li> <li>\u2714\ufe0f Efficient rendering of millions of points</li> <li>\u2714\ufe0f Optional depth testing for 3D control</li> <li>\u274c No per-point size or shape variation</li> </ul> <p>For symbolic or styled points, see the Point or Marker visuals.</p>"},{"location":"visuals/point/","title":"Point Visual","text":"<p>The Point visual renders circular, borderless filled discs at 2D or 3D positions. It provides a simple and efficient way to visualize large sets of unstyled points.</p>"},{"location":"visuals/point/#overview","title":"Overview","text":"<ul> <li>Renders filled circular discs</li> <li>Per-vertex: position, color, size</li> <li>No border, shape, or texture</li> </ul>"},{"location":"visuals/point/#when-to-use","title":"When to use","text":"<p>Use the point visual when:</p> <ul> <li>You need basic, fast scatter plots with custom colors and sizes</li> <li>You don\u2019t need symbolic shapes or outlines (use Marker for that)</li> <li>You want simple 3D point clouds with minimal overhead (but more overhead than Pixel)</li> </ul>"},{"location":"visuals/point/#properties","title":"Properties","text":""},{"location":"visuals/point/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> 3D positions in NDC space <code>color</code> <code>(N, 4) uint8</code> Per-point RGBA color <code>size</code> <code>(N,) float32</code> Per-point diameter in pixels <p>All attributes are per-vertex and required.</p>"},{"location":"visuals/point/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    grid_x = 16\n    grid_y = 12\n    N = grid_x * grid_y\n\n    # Grid coordinates in [-1, 1]\n    x = np.linspace(-1, 1, grid_x)\n    y = np.linspace(-1, 1, grid_y)\n    X, Y = np.meshgrid(x, y)\n    x_flat = X.flatten()\n    y_flat = Y.flatten()\n    z_flat = np.zeros_like(x_flat)\n\n    positions = np.stack([x_flat, y_flat, z_flat], axis=1).astype(np.float32)\n    positions *= 0.90  # margin\n\n    # Hue along x-axis\n    hue = (x_flat + 1) / 2\n    colors = dvz.cmap('hsv', hue)\n\n    # Size: exponential growth from 10px to 50px along y-axis\n    y_norm = (y_flat + 1) / 2\n    sizes = 10 * 4.0**y_norm\n    sizes = sizes.astype(np.float32)\n\n    return N, positions, colors, sizes\n\n\nN, position, color, size = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.point(position=position, color=color, size=size)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/point/#summary","title":"Summary","text":"<p>The point visual is the fastest way to render a large number of colored, sized circular points.</p> <ul> <li>\u2714\ufe0f Efficient for scatter plots and point clouds</li> <li>\u2714\ufe0f Fully GPU-accelerated</li> <li>\u274c No support for borders, shapes, or textures (use Marker instead)</li> </ul>"},{"location":"visuals/segment/","title":"Segment Visual","text":"<p>The Segment visual renders independent line segments between pairs of 3D positions. Each segment can have its own color, thickness, shift.</p>"},{"location":"visuals/segment/#overview","title":"Overview","text":"<ul> <li>Each segment is defined by an initial and terminal 3D point</li> <li>Supports per-segment color, linewidth, and shift</li> <li>Customizable caps: round, square, triangle, butt, etc.</li> <li>Fast and flexible for disconnected line data</li> </ul> <p>Note</p> <p>2D arrows are not yet supported in the segment visual. For now, consider using the Marker visual with an <code>arrow</code> shape, or the 3D Shape API to generate 3D arrows, which can be rendered using the Mesh visual.</p>"},{"location":"visuals/segment/#when-to-use","title":"When to use","text":"<p>Use the segment visual when:</p> <ul> <li>You want to render many disjoint lines or vectors</li> <li>You need variable width, style, or shift per segment</li> </ul>"},{"location":"visuals/segment/#properties","title":"Properties","text":""},{"location":"visuals/segment/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3)</code> x 2 Initial and terminal 3D points (NDC) <code>color</code> <code>(N, 4) uint8</code> RGBA color per segment <code>linewidth</code> <code>(N,) float32</code> Line thickness in pixels <code>shift</code> <code>(N, 4) float32</code> Pixel offset applied to both endpoints"},{"location":"visuals/segment/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>cap</code> <code>enum</code> x 2 Cap type (for both ends)"},{"location":"visuals/segment/#cap-types","title":"Cap types","text":"<p>Each segment endpoint can be rendered with a custom cap style:</p> Cap Name Image <code>round</code> <code>triangle_in</code> <code>triangle_out</code> <code>square</code> <code>butt</code> <p>Use <code>visual.set_cap(initial, terminal)</code> to set cap styles.</p>"},{"location":"visuals/segment/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_data():\n    N = 16\n\n    x = np.linspace(-1, 1, N).astype(np.float32) * 0.9\n    y0 = -0.5\n    y1 = 0.5\n    z = 0.0\n\n    initial = np.stack([x, np.full(N, y0), np.full(N, z)], axis=1).astype(np.float32)\n    terminal = np.stack([x, np.full(N, y1), np.full(N, z)], axis=1).astype(np.float32)\n\n    linewidths = np.linspace(2, 30, N).astype(np.float32)\n\n    t = np.linspace(0, 1, N).astype(np.float32)\n    colors = dvz.cmap('hsv', t, 0.0, 1.0)\n\n    return N, initial, terminal, colors, linewidths\n\n\nN, initial, terminal, color, linewidth = generate_data()\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.segment(\n    initial=initial,\n    terminal=terminal,\n    color=color,\n    linewidth=linewidth,\n    cap=('round', 'round'),\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/segment/#summary","title":"Summary","text":"<p>The segment visual is ideal for rendering many disconnected lines with full styling control per segment.</p> <ul> <li>\u2714\ufe0f Initial and terminal points</li> <li>\u2714\ufe0f Per-segment color and thickness</li> <li>\u2714\ufe0f Uniform cap</li> <li>\u2714\ufe0f Supports pixel shifting for layering or emphasis</li> <li>\u274c Not suitable for continuous paths (see Path instead)</li> </ul> <p>See also:</p> <ul> <li>Path for polylines</li> <li>Basic for low-level lines with no per-segment styling</li> </ul>"},{"location":"visuals/slice/","title":"Slice Visual","text":"<p>The Slice visual is designed to render 2D slices extracted from a 3D volume. It is useful for inspecting cross-sections of volumetric data such as MRI, CT, or simulation fields.</p>"},{"location":"visuals/slice/#status","title":"Status","text":"<p>Warning</p> <p>The slice visual is implemented in the Datoviz C library, but is not yet available in the Python API.</p> <p>Python bindings will be added in a future release. Once available, this visual will support slicing along arbitrary axes with customizable placement, size, and texture coordinates.</p>"},{"location":"visuals/slice/#planned-features","title":"Planned features","text":"<ul> <li>Display 2D cross-sections of 3D volumes</li> <li>Support for slicing along X, Y, or Z or tilted axes</li> <li>Compatible with the same 3D textures used by the Volume visual</li> </ul>"},{"location":"visuals/slice/#see-also","title":"See also","text":"<ul> <li>Volume: full 3D scalar field rendering</li> <li>Image: for 2D texture display</li> </ul>"},{"location":"visuals/sphere/","title":"Sphere Visual","text":"<p>The Sphere visual renders 3D spheres using GPU impostors \u2014 efficient 2D quads that simulate shaded spheres in the fragment shader using raymarching. This allows rendering of thousands of spheres with realistic lighting and minimal geometry overhead.</p>"},{"location":"visuals/sphere/#overview","title":"Overview","text":"<ul> <li>Each sphere is a screen-aligned quad rendered as a shaded 3D sphere</li> <li>Positions are in 3D NDC space</li> <li>Sizes are specified in NDC units or pixels</li> <li>Lighting parameters are customizable per visual (light support will be improved in a future version)</li> </ul>"},{"location":"visuals/sphere/#when-to-use","title":"When to use","text":"<p>Use the sphere visual when:</p> <ul> <li>You want efficient rendering of thousands of 3D spheres</li> <li>You don't need true mesh geometry (no collisions or wireframes)</li> <li>You want adjustable lighting and shading</li> </ul>"},{"location":"visuals/sphere/#properties","title":"Properties","text":""},{"location":"visuals/sphere/#options","title":"Options","text":"Option Type Description <code>textured</code> <code>bool</code> Whether to use a texture for rendering <code>lighting</code> <code>bool</code> Whether to use lighting <code>size_pixels</code> <code>bool</code> Whether to specify sphere size in pixels"},{"location":"visuals/sphere/#per-item","title":"Per-item","text":"Attribute Type Description <code>position</code> <code>(N, 3) float32</code> Center of the sphere (in NDC) <code>color</code> <code>(N, 4) uint8</code> RGBA color <code>size</code> <code>(N,) float32</code> Diameter in NDC or pixels"},{"location":"visuals/sphere/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>light_pos</code> <code>vec4</code> Light position/direction <code>light_color</code> <code>cvec4</code> Light color <code>material_params</code> <code>vec4</code> Material parameters <code>shine</code> <code>float</code> Shine value <code>emit</code> <code>float</code> Emission value"},{"location":"visuals/sphere/#lighting","title":"Lighting","text":"<p>The lighting system is the same as in the Mesh visual.</p>"},{"location":"visuals/sphere/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef generate_ndc_grid(n):\n    lin = np.linspace(-1, 1, n)\n    x, y, z = np.meshgrid(lin, lin, lin, indexing='ij')\n    positions = np.stack([x, y, z], axis=-1).reshape(-1, 3)\n\n    # Normalize each coordinate to [0, 1] for radius/color mapping\n    x_norm = (x + 1) / 2\n    y_norm = (y + 1) / 2\n    z_norm = (z + 1) / 2\n\n    # Radius increases linearly in all directions (can be tuned)\n    size = 0.01 + 0.01 * np.exp(1 * (x_norm + y_norm + z_norm))\n    size = size.flatten()\n\n    r = x_norm.flatten()\n    g = y_norm.flatten()\n    b = z_norm.flatten()\n    a = np.ones_like(r)\n    rgb = np.stack([r[::-1], g[::-1], b, a], axis=1)\n    rgb = (255 * rgb).astype(np.uint8)\n\n    return positions.shape[0], positions, rgb, size\n\n\nN, position, color, size = generate_ndc_grid(8)\n\nwidth, height = 800, 600\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel(offset=(0, 0), size=(width, height))\narcball = panel.arcball()\n\nvisual = app.sphere(\n    position=position,\n    color=color,\n    size=size,\n    lighting=True,\n    shine=0.8,\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/sphere/#summary","title":"Summary","text":"<p>The sphere visual provides efficient, realistic rendering of many shaded spheres using fragment-shader raymarching.</p> <ul> <li>\u2714\ufe0f High performance, low geometry cost</li> <li>\u2714\ufe0f Adjustable lighting and shading</li> <li>\u2714\ufe0f Ideal for molecular visualization, 3D scatter plots</li> <li>\u274c No physical mesh geometry or edge outlines</li> </ul> <p>See also:</p> <ul> <li>Point for flat, 2D discs</li> <li>Marker for symbolic shapes with borders</li> <li>Mesh for full 3D geometry</li> </ul>"},{"location":"visuals/volume/","title":"Volume Visual","text":"<p>The volume visual displays 3D scalar fields using ray-based volume rendering. It supports NDC-aligned bounding boxes, axis permutation, basic colormapping, and limited transfer functions.</p>"},{"location":"visuals/volume/#overview","title":"Overview","text":"<ul> <li>Renders 3D scalar data in a box defined by NDC bounds</li> <li>Basic support for colormapping and transfer functions</li> <li>Texture-based rendering with customizable axis permutation</li> <li>Useful for initial previews of volumetric data</li> </ul> <p>Warning</p> <p>Volume rendering is currently a basic implementation. It is neither highly efficient nor visually polished yet. Slicing, advanced transfer functions, and performance improvements are planned for future versions.</p>"},{"location":"visuals/volume/#when-to-use","title":"When to use","text":"<p>Use the volume visual when:</p> <ul> <li>You want to visualize 3D data like MRI, CT, simulations</li> <li>You need a fast volumetric rendering preview</li> <li>You are working within NDC and want basic shading support</li> </ul>"},{"location":"visuals/volume/#properties","title":"Properties","text":""},{"location":"visuals/volume/#options","title":"Options","text":"Option Type Description <code>mode</code> <code>enum</code> Color mode"},{"location":"visuals/volume/#per-item","title":"Per-item","text":"Attribute Type Description <code>bounds</code> 3 \u00d7 <code>(2,) float</code> Bounding box in NDC: <code>xlim</code>, <code>ylim</code>, <code>zlim</code> <code>texcoords</code> 2 \u00d7 <code>(3,) float</code> UVW texture coordinates at volume corners"},{"location":"visuals/volume/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>permutation</code> <code>(3,) int</code> Axis order of the 3D volume texture (default <code>(0,1,2)</code>) <code>slice</code> <code>int</code> Slice index (not implemented yet) <code>transfer</code> <code>vec4</code> Transfer function parameters (limited) <code>texture</code> texture 3D volume data (e.g. density, intensity)"},{"location":"visuals/volume/#creation","title":"Creation","text":"<p>To create a volume visual:</p> <pre><code>visual = app.volume(mode='colormap')\n</code></pre> <p>Supported modes:</p> Mode Description <code>colormap</code> Apply a colormap to a single-channel 3D texture <code>rgba</code> Use a 4D texture (RGBA channels for each voxel)"},{"location":"visuals/volume/#bounds-and-texture-mapping","title":"Bounds and texture mapping","text":"<p>You must define the bounds of the volume in NDC:</p> <pre><code>visual.set_bounds(xlim, ylim, zlim)\n</code></pre> <p>Then set the texture coordinates:</p> <pre><code>visual.set_texcoords(uvw0, uvw1)\n</code></pre> <p>This maps the 3D texture onto the NDC bounding box.</p>"},{"location":"visuals/volume/#axis-permutation","title":"Axis permutation","text":"<p>To reorder the axes of the 3D texture (e.g. for <code>wvu</code>-ordered data), set:</p> <pre><code>visual.set_permutation((2, 1, 0))  # wvu\n</code></pre> <p>This ensures correct alignment of the volume with your data orientation.</p>"},{"location":"visuals/volume/#transfer-function","title":"Transfer function","text":"<p>You can supply a transfer function parameter (currently very limited):</p> <pre><code>visual.set_transfer((0.3, 0.5, 0.8, 1.0))  # placeholder values\n</code></pre> <p>More expressive transfer functions (e.g. opacity maps, histograms) are planned.</p>"},{"location":"visuals/volume/#example","title":"Example","text":"<pre><code>import gzip\n\nimport numpy as np\n\nimport datoviz as dvz\n\n\ndef load_mouse_brain():\n    filepath = dvz.download_data('volumes/allen_mouse_brain_rgba.npy.gz')\n    with gzip.open(filepath, 'rb') as f:\n        return np.load(f)\n\n\nvolume = load_mouse_brain()\nshape = volume.shape\ndtype = volume.dtype\nD, H, W = shape[:3]\nscaling = 1.0 / D\nx, y, z = W * scaling, H * scaling, 1\n\napp = dvz.App()\nfigure = app.figure()\npanel = figure.panel()\narcball = panel.arcball(initial=(-2.25, 0.65, 1.5))\ncamera = panel.camera(initial=(0, 0, 3))\n\ntexture = app.texture_3D(volume, shape=(W, H, D), interpolation='linear')\nvisual = app.volume(\n    bounds=((-x, +x), (-y, +y), (-z, +z)), texture=texture, mode='rgba', transfer=(0.2, 0, 0, 0)\n)\npanel.add(visual)\n\napp.run()\napp.destroy()\n</code></pre>"},{"location":"visuals/volume/#summary","title":"Summary","text":"<p>The volume visual provides a starting point for 3D scalar field rendering.</p> <ul> <li>\u2714\ufe0f Bounding box in NDC</li> <li>\u2714\ufe0f Texture mapping with colormap</li> <li>\u2714\ufe0f Axis reordering support</li> <li>\u274c No slicing or rich transfer functions (yet)</li> </ul> <p>See also:</p> <ul> <li>Slice: for 2D views of 3D data</li> <li>Mesh: for explicit 3D geometry</li> </ul>"},{"location":"visuals/wiggle/","title":"Wiggle Visual","text":"<p>The Wiggle visual displays multichannel time series data (such as seismic traces) using a traditional wiggle plot format. Each channel is plotted as a waveform offset vertically, with filled positive and/or negative areas.</p>"},{"location":"visuals/wiggle/#overview","title":"Overview","text":"<ul> <li>Displays multichannel time series (e.g. seismograms, electrophysiology)</li> <li>Encoded as a 2D texture: <code>(channels, samples)</code></li> <li>Each row is rendered as a horizontally-scaled waveform</li> <li>Positive and negative areas can be filled with separate colors</li> <li>Highly efficient GPU rendering using a single texture</li> </ul>"},{"location":"visuals/wiggle/#when-to-use","title":"When to use","text":"<p>Use the wiggle visual when:</p> <ul> <li>You want to render dense multichannel waveform data (e.g., seismic traces)</li> <li>You need a compact and interactive time series overview</li> <li>You want to distinguish positive/negative lobes with color fill</li> <li>You prefer classic geophysical wiggle plotting</li> </ul>"},{"location":"visuals/wiggle/#properties","title":"Properties","text":""},{"location":"visuals/wiggle/#per-visual-uniform","title":"Per-visual (uniform)","text":"Parameter Type Description <code>bounds</code> <code>((float, float), (float, float))</code> 2D bounds in NDC coordinates <code>(xmin, xmax), (ymin, ymax)</code> <code>xrange</code> <code>(float, float)</code> Horizontal range <code>scale</code> <code>float</code> Scale factor for amplitude <code>negative_color</code> <code>(4,) uint8</code> Fill color for negative lobes in RGBA <code>positive_color</code> <code>(4,) uint8</code> Fill color for positive lobes in RGBA <code>edgecolor</code> <code>(4,) uint8</code> Line color for outlines in RGBA <code>texture</code> <code>Texture</code> 2D float32 texture with shape <code>(channels, samples)</code> <p>Note</p> <p>The visual expects the input texture to be a 2D array of shape <code>(channels, samples)</code>. Each channel corresponds to a vertically aligned trace. Linear interpolation leads to smoother wiggle plots.</p>"},{"location":"visuals/wiggle/#bounds-and-xrange","title":"Bounds and xrange","text":"<p>Use <code>bounds</code> to control the position and size of the wiggle plot in Normalized Device Coordinates (NDC). Internally, the plot is rendered on a rectangular quad (composed of two triangles and six vertices), with the wiggle waveform computed in real time by the fragment shader\u2014executed in parallel for each pixel. The <code>bounds</code> define the full 2D extent of the visual on screen.</p> <p>Use <code>xrange</code> to specify the horizontal domain of the time series, in normalized coordinates (e.g., <code>(0, 1)</code> spans the entire width of the plot).</p>"},{"location":"visuals/wiggle/#colors","title":"Colors","text":"<p>The wiggle visual can fill waveform lobes with distinct colors depending on polarity.</p> <ul> <li><code>positive_color</code>: used to fill regions above zero</li> <li><code>negative_color</code>: used to fill regions below zero</li> <li><code>edgecolor</code>: optional line trace on top of filled wiggle</li> </ul>"},{"location":"visuals/wiggle/#scale","title":"Scale","text":"<p>The <code>scale</code> attribute controls the amplitude of the waveforms. Using <code>scale = 1</code> means a texture value of 1 will correspond to the horizontal spacing between two consecutive channels.</p>"},{"location":"visuals/wiggle/#example","title":"Example","text":"<pre><code>import numpy as np\n\nimport datoviz as dvz\n\n\ndef load_data(channels, samples):\n    \"\"\"Create a texture with the given number of channels and samples.\"\"\"\n    c0 = channels / 2.0\n    alpha = 2 * np.pi * 8\n    beta = 1.0\n\n    s = np.linspace(0, 1, samples)\n    x = s - 0.5\n    y = np.sinc(alpha * x / np.pi)\n\n    c = np.arange(channels).reshape(-1, 1)\n    gamma = np.exp(-beta * ((2 * (c - c0) / c0) ** 2))\n\n    texdata = gamma * y\n    return texdata.astype(np.float32).reshape((channels, samples))\n\n\nchannels = 16\nsamples = 1024\n\ndata = load_data(channels, samples)\nheight, width = data.shape\n\nposition = np.array([[0, 0, 0]], dtype=np.float32)\nsize = np.array([[width, height]], dtype=np.float32)\nanchor = np.array([[0, 0]], dtype=np.float32)\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\n\napp = dvz.App()\nfigure = app.figure(gui=True)\npanel = figure.panel()\npanzoom = panel.panzoom()\n\nvisual = app.wiggle(\n    scale=1.0,\n    negative_color=(128, 128, 128, 255),\n    positive_color=(0, 0, 0, 255),\n    edgecolor=(0, 0, 0, 255),\n)\ntexture = app.texture_2D(data, interpolation='linear')\nvisual.set_texture(texture)\npanel.add(visual)\n\n\nscale = dvz.Out(1.0)\n\n\n@app.connect(figure)\ndef on_gui(ev):\n    dvz.gui_pos(dvz.vec2(10, 10), dvz.vec2(0, 0))\n    dvz.gui_size(dvz.vec2(200, 70))\n    dvz.gui_begin('Change the scale', 0)\n    has_changed = False\n    has_changed |= dvz.gui_slider('scale', 0.1, 5, scale)\n    dvz.gui_end()\n\n    if has_changed:\n        visual.set_scale(scale.value)\n\n\napp.run()\napp.destroy()\n</code></pre> <p>This example creates a synthetic dataset with 16 channels and 1024 samples, maps it to a texture, and displays the wiggle visual with GUI control for scale.</p>"},{"location":"visuals/wiggle/#summary","title":"Summary","text":"<p>The Wiggle visual provides an efficient and interactive way to visualize dense multichannel time series using the classic wiggle plot style.</p> <ul> <li>\u2714\ufe0f Fast GPU rendering from 2D textures</li> <li>\u2714\ufe0f Separate fill colors for positive/negative values</li> <li>\u2714\ufe0f Adjustable scale, range, and bounds</li> <li>\u2714\ufe0f Ideal for seismic or electrophysiology data</li> </ul> <p>See also:</p> <ul> <li>Basic: for drawing low-level primitives</li> <li>Segment: for individual lines with custom caps</li> <li>Image: for displaying 2D raster textures</li> </ul>"}]}