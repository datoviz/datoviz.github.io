{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Datoviz: high-performance GPU scientific data visualization C/C++ library","text":"<p>[Installation] [Usage] [User guide] [Examples] [API reference] </p> <p>\u26a1\ufe0f Datoviz is a cross-platform, open-source, high-performance GPU scientific data visualization library written in C/C++ on top of the Khronos Vulkan graphics API and the glfw window library. It provides raw ctypes bindings in Python \ud83d\udc0d. In the long term, Datoviz will mostly be used as a VisPy 2.0 backend.</p> <p>Designed for speed, visual quality, and scalability to datasets comprising millions of points, it supports 2D/3D interactive rendering and minimal GUIs via Dear ImGui.</p> <p>\u26a0\ufe0f Warning: Although Datoviz has been years in the making, it is still in its early stages and would greatly benefit from increased community feedback, particularly concerning package and hardware compatibility. The API is still evolving, so expect regular (though hopefully minimal) breaking changes for now. The current version is v0.2. The previous v0.1 version is now deprecated.</p> <p>\ud83d\udd50 Roadmap. In the medium term: increasing OS and hardware compatibility, providing more visuals, interactivity patterns, and GUI controls. In the long term: picking, custom visuals and shaders, nonlinear transforms, WebGPU/WebAssembly compatibility, integration with IPython, Jupyter and Qt.</p>"},{"location":"#screenshots-from-the-v01-version","title":"\ud83d\uddbc\ufe0f Screenshots from the v0.1 version","text":"<p> Credits: mouse brain volume: Allen SDK. France: Natural Earth. Molecule: Crystal structure of S. pyogenes Cas9 from PDB (thanks to Eric for conversion to OBJ mesh). Earth: Pixabay. Raster plot: IBL. 3D human brain: Anneke Alkemade et al. 2020, thanks to Pierre-Louis Bazin and Julia Huntenburg.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udcca High-quality antialiased 2D visuals: markers, lines, paths, glyphs</li> <li>\ud83c\udf10 3D visuals: meshes, volumes, volume slices</li> <li>\ud83c\udf08 150 colormaps included (from matplotlib, colorcet, MATLAB)</li> <li>\ud83d\uddb1\ufe0f High-level interactivity: pan &amp; zoom for 2D, arcball for 3D (more later)</li> <li>\ud83c\udfa5 Manual control of cameras: custom interactivity</li> <li>\ud80c\ude08 Figure subplots (aka \"panels\")</li> <li>\ud83d\udda5\ufe0f Minimal GUIs using Dear ImGui</li> </ul>"},{"location":"#list-of-visuals","title":"List of visuals","text":""},{"location":"#work-in-progress","title":"Work in progress","text":"<p>These features are currently planned for v0.3:</p> <ul> <li>\u2795 Axes: ticks, grids, labels</li> <li>\ud83c\udfa8 Colorbars</li> <li>\ud83d\uddb1\ufe0f More interactivity patterns</li> <li>\ud83d\udcd6 More documentation</li> </ul>"},{"location":"#future-work","title":"Future work","text":"<p>These features are currently planned for v0.4 and later:</p> <ul> <li>\ud83d\udcd0 More visuals: arrows, polygons, planar straight-line graphs (PSLG), histograms, areas, graphs</li> <li>\ud83c\udfaf Picking</li> <li>\ud83d\udcc8 Nonlinear transforms</li> <li>\ud83d\udd8c\ufe0f Dynamic shaders</li> <li>\ud83c\udf10 WebGPU/WebAssembly compatibility</li> <li>\ud83e\uddee Compute shaders</li> <li>\ud83d\udc0d IPython, Jupyter, Qt integration</li> </ul>"},{"location":"#installation-instructions","title":"\ud83d\udee0\ufe0f Installation instructions","text":"<p>Requirements:</p> <ul> <li>A supported OS (Linux, macOS 12+, Windows 10+)</li> <li>A Vulkan-capable graphics chipset (either integrated or dedicated graphics process unit)</li> <li>Python and NumPy</li> </ul> <p>Note: You no longer need to install the Vulkan SDK or to manually build the library. Precompiled wheels for Linux, Windows, and macOS have been uploaded to PyPI.</p> <pre><code>pip install datoviz\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":"<p>Simple scatter plot example (points with random positions, colors, and sizes) in Python, which closely follow the C API.</p> <pre><code>import numpy as np\nimport datoviz as dvz\n\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\nfigure = dvz.figure(scene, 800, 600, 0)\npanel = dvz.panel_default(figure)\ndvz.panel_panzoom(panel)\nvisual = dvz.point(batch, 0)\n\nn = 100_000\ndvz.point_alloc(visual, n)\n\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.point_position(visual, 0, n, pos, 0)\n\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ndvz.point_color(visual, 0, n, color, 0)\n\nsize = np.random.uniform(size=(n,), low=10, high=30).astype(np.float32)\ndvz.point_size(visual, 0, n, size, 0)\n\ndvz.panel_visual(panel, visual, 0)\ndvz.scene_run(scene, app, 0)\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre> <p></p> <p>Check out the examples documentation for more usage examples.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>\ud83d\udcd6 User guide</li> <li>\ud83d\udc0d Examples</li> <li>\ud83d\udcda API reference</li> <li>\ud83c\udfdb\ufe0f Architecture overview</li> <li>\ud83c\udfd7\ufe0f Build instructions</li> <li>\ud83d\udc65 Contributors instructions</li> <li>\ud83d\udee0\ufe0f Maintainers instructions</li> </ul>"},{"location":"#history-and-current-status","title":"\ud83d\udd70\ufe0f History and current status","text":"<p>In 2012, developers of various GPU scientific visualization libraries (Galry, Glumpy, pyqtgraph, visvis) collaborated to create VisPy, an OpenGL-based scientific visualization library for Python.</p> <p>In 2015, Vulkan, the successor to OpenGL, was announced by Khronos, sparking the idea of a future Vulkan-based visualization library.</p> <p>In 2019, Cyrille Rossant, one of the original VisPy developers, began experimenting with Vulkan.</p> <p>In 2021, the first experimental version of Datoviz v0.1 was released. This initial release laid the groundwork for further development.</p> <p>Over the next three years, the technology matured, aided by a Chan Zuckerberg Initiative (CZI) grant awarded to VisPy in 2021.</p> <p>In 2024, Datoviz v0.2 is released. This version is redesigned from the ground up to enhance modularity and stability, ensuring it can keep pace with the continuous advancements in GPU hardware and graphics rendering APIs. It features a modular architecture that will allow the porting of Datoviz technology to non-Vulkan environments, such as WebGPU-enabled web browsers (thanks to a second CZI grant).</p> <p>Datoviz is closely related to VisPy, as it is being developed by one of the VisPy cofounders. VisPy 2.0, initiated by Cyrille Rossant and Nicolas Rougier, will offer a high-level scientific API on top of Datoviz, matplotlib, and other renderers via a common medium-level visualization layer called \"graphics server protocol (GSP)\".</p> <p>The long-term vision is for high-performance GPU-based 2D/3D scientific visualization to be uniformly available across multiple platforms, environments (desktop, web, cloud-based remote visualization), and programming languages (C/C++, Python, Julia, Rust, etc.).</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>See the contributing notes.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>See the MIT license.</p>"},{"location":"#credits","title":"\ud83d\ude4f Credits","text":"<p>Datoviz is developed by Cyrille Rossant at the International Brain Laboratory, a consortium of neuroscience research labs around the world.</p> <p>It is funded notably by Chan Zuckerberg Initiative's Essential Open Source Software for Science program.</p>"},{"location":"ARCHITECTURE/","title":"Architecture","text":"<p>This document provides a high-level overview of the Datoviz v0.2x code architecture.</p>"},{"location":"ARCHITECTURE/#main-components","title":"Main components","text":"<p>The main components are:</p> <ul> <li>vklite (<code>include/datoviz/vklite.h</code>): A lightweight C Vulkan wrapper that provides essential GPU compute and visualization functionality for scientific visualization.</li> <li>Renderer (<code>include/datoviz/renderer.h</code>): A C/C++ Vulkan-based GPU visualization engine that offers a GLFW-based event loop, processing visualization requests in real time.</li> <li>Requests (<code>include/datoviz/requests.h</code>): A C API that generates real-time visualization requests to be sent to the renderer.</li> <li>Visuals (<code>includes/datoviz/scene/visuals/</code>): A comprehensive C/GLSL library of high-quality GPU graphical primitives, including points, markers, paths, images, glyphs, meshes, and volumes.</li> <li>Scene (<code>include/datoviz.h</code>): A C/C++ library providing scientific visualization functionality that generates requests to be sent to the renderer.</li> </ul> <p>These components are organized around the Datoviz Intermediate Protocol, an intermediate-level, message-based visualization protocol that decouples high-level scientific visualization logic from low-level Vulkan rendering implementation.</p> <p>While the former can be developed and maintained by research software engineers and scientists, the latter requires deep technical expertise, more commonly found in the video game industry and among game engine developers than in scientific fields.</p> <p>This architecture also ensures that high-level scientific visualization logic can evolve independently from ongoing innovations in graphics hardware and APIs (OpenGL, Vulkan, Metal, DirectX, WebGPU, wgpu, etc.). Notably, with support from a generous Chan Zuckerberg Initiative (CZI) grant awarded to the VisPy project in 2024, this architecture will enable us to port Datoviz technology to non-Vulkan environments, such as WebGPU-enabled web browsers, in the coming years.</p> <p>This will help us achieve a long-term vision where high-performance GPU-based 2D/3D scientific visualization is accessible across local and remote multi-platform environments (distributed rendering, web-based visualization), capable of working with both local and cloud-based data, and supporting language-agnostic visualization code (C/C++, Python, Julia, Rust, etc.).</p>"},{"location":"ARCHITECTURE/#renderer","title":"Renderer","text":"<p>The bottomest layer is the raw Vulkan C API, which is known for its extreme verbosity and complexity.</p>"},{"location":"ARCHITECTURE/#vklite","title":"vklite","text":"<p>We built vklite, a thin wrapper on top of the Vulkan C API, that provides the most essential Vulkan functionality (<code>vklite.h</code>):</p> <ul> <li>Device control and event loops:<ul> <li>Device discovery (<code>dvz_gpu</code>)</li> <li>Swapchain presentation (<code>dvz_swapchain</code>, <code>dvz_renderpass</code>, <code>dvz_framebuffers</code>, <code>dvz_surface</code>)</li> <li>Synchronization primitives (<code>dvz_barrier</code>, <code>dvz_semaphores</code>, <code>dvz_fences</code>)</li> </ul> </li> <li>GPU memory:<ul> <li>GPU data buffers (<code>dvz_buffers</code>)</li> <li>GPU images (<code>dvz_images</code>)</li> <li>Samplers (<code>dvz_sampler</code>)</li> </ul> </li> <li>Pipelines and shaders:<ul> <li>Compute pipelines (<code>dvz_compute</code>)</li> <li>Graphics pipelines (<code>dvz_graphics</code>) with fixed pipeline and custom shaders</li> <li>Slots and bindings or descriptors (<code>dvz_slots</code>, <code>dvz_descriptors</code>)</li> </ul> </li> <li>Command buffers:<ul> <li>Command buffer creation and submission (<code>dvz_commands</code>, <code>dvz_submit</code>)</li> <li>Command buffer recording (<code>dvz_cmd</code>)</li> </ul> </li> </ul> <p>Broadly speaking, these low-level functions allow one to create objects on the GPU, mostly data buffers and textures (images and samplers), to define GPU compute and graphics pipelines via custom SPIR-V shaders (compiled from GLSL), and to send compute and rendering jobs to the GPU by asynchronously submitting recorded command buffers to a dedicated event loop displaying graphics on screen.</p>"},{"location":"ARCHITECTURE/#gpu-resources-and-data-transfers","title":"GPU resources and data transfers","text":"<p>A major part of the renderer is device management of GPU-stored data and CPU-GPU data transfers (<code>resources.h</code>, <code>context.h</code>, <code>alloc.h</code>, <code>transfers.h</code>...).</p> <p>Vulkan and vklite support two main types of data: buffers (linear contiguous blocks of memory) and images (1D, 2D, or 3D).</p> <p>Buffers store vertex positions and other attributes, as well as shader parameters. Arbitrary GPU buffers may also be created for direct access from the shaders (storage buffers).</p> <p>Images typically store textures or rendered images.</p> <p>Vulkan only provides low-level primitives for CPU-GPU data transfers (creation and deletion of buffers and images, memory mapping techniques, submission of command buffers with buffer/image copy operations...). Datoviz provides a dedicated data transfer engine that provides a simpler interface that mostly deals with \"upload\" (CPU-&gt;GPU), \"download\" (GPU-&gt;CPU), and \"copy\" (GPU-&gt;GPU) of buffers and images.</p> <p>Datoviz also implements a custom memory allocator that avoids the overhead of creating and managing a large number of GPU buffers when handling small amounts of data. It is indeed good practice in Vulkan to define a few large buffers of different types and manually handle chunks of data in these buffers, although this comes with a somewhat increased internal complexity.</p> <p>Datoviz simply defines dats (chunks of data on the GPU) and texs (images on the GPU) that can be created, resized, deleted, and to which one can upload/download data.</p>"},{"location":"ARCHITECTURE/#datoviz-intermediate-protocol-renderer","title":"Datoviz Intermediate Protocol Renderer","text":"<p>The Renderer processes Datoviz Intermediate Protocol requests using the low-level components discussed earlier (vklite, data transfers...).</p> <p>It implements an object hash table mapping unique IDs identifiying each object created in the requests, to the actual underlying objects.</p>"},{"location":"ARCHITECTURE/#client","title":"Client","text":"<p>Datoviz implements a GPU-agnostic glfw-based client providing basic interactive event loop functionality: window creation and management, mouse and keyboard interactivity (<code>window.h</code>, <code>client.h</code>, <code>fifo.h</code>, <code>mouse.h</code>, <code>keyboard.h</code>, <code>input.h</code>...).</p> <p>The client provides a thread-safe FIFO queue on which window and input events are sent.</p> <p>The GPU-agnostic client and the client-agnostic (static) renderer are linked together via the presenter, which allows dynamic processing of the incoming requests by the renderer and appropriate event loop synchronization.</p>"},{"location":"ARCHITECTURE/#datoviz-intermediate-protocol","title":"Datoviz Intermediate Protocol","text":"<p>The Datoviz Intermediate Protocol is entirely defined in <code>datoviz_protocol.h</code>.</p> <p>It provides a generic intermediate-level GPU visualization library that is somewhat similar to the WebGPU API. It deals exclusively with GPU objects, NOT visual objects. The protocol comes with NO graphical primitives, it supports arbitrary shaders and graphics pipelines. Graphical primitives and higher-level visualization constructs are implemented in the Visuals library and the Scene API described below</p> <p>Note: although compute shaders are already mostly supported in the renderer, they are not yet implemented in the Datoviz Intermediate Protocol. They will be in the future, depending on user feedback. This should be fairly straightforward (adding functions in <code>requests.h</code>, implementing them in <code>renderer.cpp</code>, writing tests and documentation...).</p> <p>Requests are linearly collected in a batch, which is then sent to the renderer for dynamic processing at the next event loop iteration.</p> <p>The main objects and notions defined in the Datoviz Intermediate Protocol are:</p> <ul> <li>canvas: a window associated to a Vulkan surface for GPU rendering and presentation</li> <li>board: an offscreen canvas for static rendering independently from the event loop</li> <li>dat: a GPU memory buffer (actually implemented as a data chunk of a larger Datoviz-handled buffer)</li> <li>tex: a GPU image buffer (1D, 2D, or 3D)</li> <li>sampler: a GPU object providing nearest or linear filtering on a tex</li> <li>shader: a SPIR-V shader</li> <li>graphics: a graphics pipeline defined by a fixed state pipeline, a vertex shader, a fragment shader...</li> <li>bindings: bindings between dats and shader uniforms</li> <li>command buffer recording: essentially viewport definition and graphics pipeline drawing commands (compute buffers to come later)</li> </ul>"},{"location":"ARCHITECTURE/#scene-api","title":"Scene API","text":"<p>The Scene API provides higher-level scientific visualization constructs that are directly exposed to users of the Datoviz C API (contrary to the underlying machinery).</p>"},{"location":"ARCHITECTURE/#visuals-api","title":"Visuals API","text":"<p>A Visual is an abstraction representing a graphical object, or a collection of similar objects, and encapsulating a graphics pipeline defined by pair of vertex and fragment shaders, along with descriptor bindings for uniform buffers, an associated vertex buffer, and custom visual-specific logic for CPU-based data \"baking\".</p> <p>Visuals typically support natively collections of objects: points, markers, glyphs, images, meshes, and so on (see the Visuals library below for more details). This is a crucially important notion: batch-rendering of many objects of the same type, but with various data attributes (positions, colors, sizes...), is the key to achieving high-performance rendering on the GPU.</p> <p>Each visual comes with a pair of custom shaders (vertex shader and fragment shader), originally contributed by Nicolas Rougier's research in computer graphics (rendering high-quality visual primitives efficiently on the GPU is an active area of research). The vertex shader typically requires preprocessing of the data to make it amenable to GPU rendering: this is the so-called \"baking\" of the data.</p> <p>A visual involves several consecutive abstractions:</p> <ul> <li>The array holds a 1D data buffer on the CPU. It has a data type (scalar or multiple components, floating-point or integer) and a size.</li> <li>The dual associates a CPU-based array with a GPU-based dat (chunk of a GPU buffer). It handles synchronization between the two and emits a data upload request when the CPU part of the array changes.</li> <li>The baker provides facilities for generating one (or several) multiplexed vertex buffer(s) from the original user-supplied visual data (positions, colors, other attributes).</li> <li>The generic visual provides facilities for creating a visual bundling together a graphics primitive, shaders, a baker, a vertex buffer, optional uniform-based parameters.</li> <li>The custom visual leverages the generic visual to define a dedicated visual API to create a specific visual (marker, image, mesh...), set its data, and render it when rendering a command buffer.</li> </ul>"},{"location":"ARCHITECTURE/#visuals-library","title":"Visuals library","text":"<p>Datoviz comes with a built-in library of visuals commonly used in scientific rendering:</p> <ul> <li>Basic visuals rely on the built-in OpenGL/Vulkan graphical primitives:</li> <li>Basic point: pixel or plain square</li> <li>Basic line: aliased thin lines: line list, line strip</li> <li> <p>Basic triangle: aliased triangles: triangle list, triangle strip, triangle fan (warning: not supported on macOS)</p> </li> <li> <p>0D visuals represent points in a 2D or 3D space:</p> <ul> <li>Pixel: collection of pixels (position, color)</li> <li>Point: collection of discs (position, color, size)</li> <li>Marker: collection of markers (position, color, size, angle, shape, filled/stroke/outline, edge color, edge width)</li> <li>Glyph: collection of text glyphs (position, color, size, angle...)</li> </ul> </li> <li> <p>1D visuals represent lines:</p> <ul> <li>Segment: collection of rigid line segments (initial and terminal position, color, line width, cap type)</li> <li>Path: collection of variable-size curved paths (position, line width, color)</li> </ul> </li> <li> <p>2D visuals represent images:</p> <ul> <li>Image: collection of textured squares (corner positions, sampler filtering, texture image)</li> </ul> </li> <li> <p>3D visuals represent meshes (or \"fake\" meshes, volumes):</p> <ul> <li>Mesh: triangular meshes (vertex position, normal, color, texture coordinates, face indices, light position and parameters)</li> <li>Sphere: collection of \"fake\" spheres rendered as 2D sprites with 3D illusion (position, color, size, light position)</li> <li>Volume: volume rendering</li> <li>Slice: images in 3D space showing slices of a 3D volume (corner position, texture coordinates)</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/#transforms","title":"Transforms","text":"<p>Datoviz provides a basic transform system, currently limited to standard matrix-view-projection linear transforms (this is still a work in progress, support for more complex, e.g. nonlinear, transforms may be implemented later).</p> <p>The system provides standalone components implementing pan-zoom (2D) and arcball (3D rotations) interactivity. Future components may implement a subjective camera (e.g. fly mode, FPS-type camera).</p>"},{"location":"ARCHITECTURE/#scene","title":"Scene","text":"<p>The Scene puts all components together in the main public API of Datoviz:</p> <ul> <li>The Scene is the root object.</li> <li>The Figure represents a scene-aware window.</li> <li>The Panel represents a full or partial rectangular portion of a Figure (subplot).</li> <li>The Panel is specified a transform and interactivity mode (panzoom, arcball).</li> <li>One or several visuals are added to a Panel.</li> </ul> <p>The viewset takes care of tracking all of these objects and building a command buffer for drawing all visuals in all panels.</p>"},{"location":"ARCHITECTURE/#specialized-components","title":"Specialized components","text":"<p>The Scene API also comes with a set of specialized components that are used by some visuals or transforms.</p> <ul> <li> <p>Text components:</p> <ul> <li>The Font wraps the freetype library to handle text composition on the basis of a builtin or custom TTF font.</li> <li>The Atlas wraps Viktor Chlumsk\u00fd's msdfgen-atlas library to generate an atlas texture with multi-channel signed distance field (MSDF) representing font glyphs to be rendered on the GPU in the fragment shader.</li> </ul> </li> <li> <p>GUI components:</p> <ul> <li>The GUI wraps Omar Cornut's Dear ImGui library to provide basic interactive GUI components. It should be straightforward to support the entire Dear ImGui API when using Datoviz in C++ (testing required).</li> </ul> </li> <li> <p>Axis components: (note: work in progress)</p> <ul> <li>Ticks: implement an automatic tick positioning system (extended Wilkinson algorithm)</li> <li>Labels: generate tick labels</li> <li>Axis: handle an axis with ticks and labels</li> <li>Axes: handle multiple Axis components</li> </ul> </li> </ul>"},{"location":"BUILD/","title":"Building instructions","text":"<p>If packages are not available on your system, you can build Datoviz yourself.</p> <p>Note: Datoviz is currently built and tested with the Vulkan LunarG SDK v1.3.280 (you normally don't need to install it to build Datoviz on Linux and macOS, only on Windows). We'll regularly update this version.</p>"},{"location":"BUILD/#ubuntu-2404","title":"Ubuntu 24.04","text":"<pre><code># Install the build and system dependencies.\nsudo apt install build-essential cmake gcc ccache ninja-build xorg-dev clang-format patchelf tree libtinyxml2-dev libfreetype-dev\n\n# Install just, see https://github.com/casey/just\ncurl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash\n\n# Clone the Datoviz repo and build.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"BUILD/#macos-arm64","title":"macOS (arm64)","text":"<pre><code># Install brew if you don't have it already.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n    eval \"$(/opt/homebrew/bin/brew shellenv)\"\n\n# Install build dependencies.\nbrew install just cmake ccache ninja freetype clang-format tree cloc jq\n\n# Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"BUILD/#macos-intel-x86-64","title":"macOS (Intel x86-64)","text":"<pre><code># Install brew if you don't have it already.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n    eval \"$(/opt/homebrew/bin/brew shellenv)\"\n\n# Install build dependencies.\nbrew install just cmake ccache ninja freetype clang-format tree cloc jq\n\n# Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"BUILD/#windows","title":"Windows","text":"<p>Requirements:</p> <ul> <li>Git for Windows.</li> <li>WinLibs: Download and install the latest gcc UCRT version with POSIX threads.</li> <li>LunarG Vulkan SDK for Windows.</li> <li>vcpkg: The <code>VCPKG_ROOT</code> environment variable should be set and should be in the <code>PATH</code>.</li> <li>just: Extract the just.exe file into C:\\mingw64\\bin (created by WinLibs).`</li> <li>jq: For example, with winget, use <code>winget install jqlang.jq</code></li> <li>Python.</li> </ul> <p>Instructions:</p> <ol> <li>Install the above dependencies.</li> <li>Open Windows git-bash terminal at the directory location for the datoviz build.</li> </ol> <pre><code># Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing notes","text":"<p>This document is a work in progress.</p>"},{"location":"CONTRIBUTING/#management-commands","title":"Management commands","text":"<p>We use the just tool for all management commands. The commands are implemented in <code>justfile</code>.</p>"},{"location":"CONTRIBUTING/#branches","title":"Branches","text":"<ul> <li>The <code>main</code> branch is reserved to stable releases.</li> <li>Development occurs in the <code>dev</code> branch.</li> </ul>"},{"location":"CONTRIBUTING/#python-bindings","title":"Python bindings","text":"<p>The Python (ctypes) bindings are automatically generated into <code>datoviz/__init__.py</code> which is commmitted in the repository, but should not be manually edited.</p>"},{"location":"CONTRIBUTING/#continuous-integrationcontinuous-delivery","title":"Continuous integration/continuous delivery","text":"<p>GitHub Actions-based CI/CD is not yet active in this repository. In the near future, we intend to activate it for:</p> <ul> <li>cross-platform automated testing of the C library and Python bindings ;</li> <li>automated build of the Python wheels on all supported platforms ;</li> <li>automated build of the documentation and gallery.</li> </ul>"},{"location":"CONTRIBUTING/#debugging","title":"Debugging","text":""},{"location":"CONTRIBUTING/#console-logging","title":"Console logging","text":"<p>Set this environment variable:</p> <ul> <li><code>DVZ_LOG_LEVEL=2</code>: info logging level, default</li> <li><code>DVZ_LOG_LEVEL=1</code>: debug logging level</li> <li><code>DVZ_LOG_LEVEL=0</code>: trace logging level (caution: extremely verbose)</li> </ul>"},{"location":"CONTRIBUTING/#datoviz-intermediate-protocol-requests","title":"Datoviz Intermediate Protocol requests","text":"<p>User-exposed Datoviz commands generate an internal stream of rendering requests which are processed in real time by the Datoviz Vulkan renderer. You can inspect these commands for debugging purposes, and depending on whether the requests are correct, determine whether the bug occurs in the high-level code generating these requests (most frequent case), or in the Vulkan renderer.</p> <ul> <li><code>DVZ_VERBOSE=prt</code>: print a YAML representation of the requests to the standard output.</li> </ul>"},{"location":"CONTRIBUTING/#screenshot","title":"Screenshot","text":"<p>Set this environment variable to force offscreen rendering of all Datoviz applications:</p> <ul> <li><code>DVZ_CAPTURE_PNG=path/to/image.png</code>: save the figure to a PNG file.</li> </ul>"},{"location":"CONTRIBUTING/#performance","title":"Performance","text":"<p>Set these environment variable to display some performance statistics</p> <ul> <li><code>DVZ_FPS=1</code>: display an FPS counter (frames per second).</li> <li><code>DVZ_MONITOR=1</code>: display a memory monitor (allocated GPU memory).</li> </ul> <p>Note: the FPS computation algorithm is currently suboptimal, it will be improved later. Contributions welcome.</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021-2024 Cyrille Rossant</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"MAINTAINERS/","title":"Maintainers instructions","text":""},{"location":"MAINTAINERS/#release-checklist-for-datoviz-maintainers","title":"Release checklist for Datoviz maintainers","text":"<p>Development happens on <code>dev</code> whereas <code>main</code> is stable.</p> <p>Release checklist from a Linux development machine:</p> <ol> <li>Preparation.<ul> <li><code>git branch</code>: check that you are on the <code>dev</code> branch.</li> <li>Write the <code>CHANGELOG.md</code> for the new version.</li> </ul> </li> <li>Cross-platform release build and test.<ul> <li>For each of Linux, macOS arm64, macOS x86_64, Windows, do:</li> <li><code>just clean release api</code>: rebuild in release mode.</li> <li><code>just test</code>: run the C testing suite.</li> <li><code>just pytest</code>: run the Python testing suite.</li> <li><code>just act test-linux</code>: on Linux only, simulate the GitHub Actions tests locally.</li> </ul> </li> <li>Version bump.<ul> <li><code>version=x.y.z</code>: set up the new version.</li> <li><code>just bump $version</code>: bump the codebase to the new version.</li> <li><code>just release</code>: recompile with the new version.</li> <li><code>git diff</code>: check the changes to commit.</li> <li><code>git commit -am \"Bump version to v$version\" &amp;&amp; git push</code>: commit the new version.</li> </ul> </li> <li>Wheel build and test.<ul> <li><code>just wheels</code>: build the wheels on GitHub Actions.</li> <li>Wait until the wheels have been successfully built on all supported platforms. This will take about 15 minutes (the Windows build is currently much longer than macOS and Linux builds because GitHub Actions does not support Windows Docker containers yet).</li> <li>For each of Linux, macOS arm64, macOS x86_64, Windows, do:</li> <li><code>just checkartifact</code></li> <li>Fix and go back to (2) if there is any problem.</li> </ul> </li> <li>Release.<ul> <li><code>git fetch --all &amp;&amp; git status</code> : check we're up to date and on the <code>dev</code> branch.</li> <li><code>git checkout main &amp;&amp; git pull</code> : switch to <code>main</code> before merging.</li> <li><code>git merge dev</code>: merge <code>dev</code> to <code>main</code>.</li> <li><code>just tag $version</code>: once on <code>main</code>, tag with the new version.</li> <li><code>git push origin --tags</code>: push the tag.</li> <li><code>just draft</code>: create a new GitHub Release draft with the built wheels.</li> <li>Edit and publish the GitHub Release.</li> <li><code>just upload</code>: upload the wheels to PyPI.</li> <li><code>just bump a.b.c-dev</code>: bump to the new development version (replace with the next expected version number).</li> <li><code>git commit -am \"Bump to development version\" &amp;&amp; git push</code>: bump to the development version.</li> <li>Announce the new release on the various communication channels.</li> </ul> </li> </ol>"},{"location":"MAINTAINERS/#packaging-instructions-advanced-users","title":"Packaging instructions (advanced users)","text":"<p>This section provides instructions for Datoviz maintainers who'd like to create binary packages and Python wheels.</p>"},{"location":"MAINTAINERS/#ubuntu-2404","title":"Ubuntu 24.04","text":"<p>Requirements:</p> <ul> <li>Docker</li> <li>just</li> <li><code>sudo apt-get install dpkg-dev fakeroot nvidia-container-toolkit</code></li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.deb</code> Debian installable package for development (with C headers and shared libraries):</p> <pre><code>just deb\n</code></pre> <p>To test the <code>.deb</code> package in an isolated Docker container:</p> <pre><code>just testdeb\n</code></pre> <p>To build a <code>manylinux</code> wheel (using <code>manylinux_2_28_x86_64</code>, based on AlmaLinux 8):</p> <pre><code># Build Datoviz in the manylinux container.\njust buildmany\n\n# Build a Python wheel in that container (saved in dist/).\njust wheelmany\n</code></pre> <p>To test the <code>manylinux</code> wheel:</p> <pre><code>just testwheel\n</code></pre>"},{"location":"MAINTAINERS/#macos-arm64","title":"macOS (arm64)","text":"<p>Requirements:</p> <ul> <li>Homebrew</li> <li>just</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.pkg</code> macOS installable package for development (with C headers and shared libraries):</p> <pre><code>just pkg\n</code></pre> <p>To build a macOS Python wheel:</p> <pre><code>just wheel\n</code></pre> <p>To test the macOS package in an isolated environment:</p> <ol> <li> <p>Install sshpass:</p> <pre><code>brew install sshpass\n</code></pre> </li> <li> <p>Install UTM.</p> </li> <li>Create a new macOS virtual machine (VM) with at least 64 GB storage (for Xcode).</li> <li>Install macOS in the virtual machine. For simplicity, use your <code>$USER</code> as the login and password.</li> <li>Once installed, find the IP address in the VM macOS system preferences and write it down (for example, <code>192.168.64.4</code>).</li> <li>Set up remote access via SSH in the VM macOS system preferences to set up a SSH server.</li> <li> <p>Open a terminal in the VM and type:</p> <pre><code>type: xcode-select --install\n</code></pre> </li> </ol> <p>Go back to the host machine and type:</p> <pre><code># Test the .pkg installation in an UTM virtual machine, using the IP address you wrote down earlier.\njust testpkg 192.168.64.4\n</code></pre> <p>The virtual machine should show the Datoviz demo in a window.</p> <p>To test the macOS wheel, you can either test in a virtual Python environment, or in a virtual machine using UTM.</p> <p>To test the macOS wheel in a virtual Python environment:</p> <pre><code>just testwheel\n</code></pre> <p>To test the macOS wheel in a virtual machine, set up the virtual machine as indicated above, then run (replacing the IP address with your virtual machine's IP):</p> <pre><code>just testwheel 192.168.64.4\n</code></pre>"},{"location":"MAINTAINERS/#macos-intel-x86-64","title":"macOS (Intel x86-64)","text":"<p>Requirements:</p> <ul> <li>Homebrew</li> <li>just</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.pkg</code> macOS installable package for development (with C headers and shared libraries):</p> <pre><code>just pkg\n</code></pre> <p>To build a macOS Python wheel:</p> <pre><code>just wheel\n</code></pre>"},{"location":"MAINTAINERS/#windows","title":"Windows","text":"<p>Requirements:</p> <ul> <li>Git for Windows</li> <li>WinLibs</li> <li>just</li> <li>LunarG Vulkan SDK for Windows</li> <li>WSL2</li> <li>vcpkg</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just release\n</code></pre> <p>To build a Windows Python wheel, open a Git Bash and type:</p> <pre><code># see https://stackoverflow.com/a/36530750/1595060\necho \"alias python='winpty python.exe'\" &gt;&gt; ~/.bash_profile\njust pydev\njust wheel\n</code></pre> <p>To test the wheel in a Python virtual environment:</p> <pre><code>just testwheel\n</code></pre>"},{"location":"MAINTAINERS/#github-actions-notes","title":"GitHub Actions notes","text":"<p>Datoviz relies on GitHub Actions for cross-platform automated testing and wheel building.</p>"},{"location":"MAINTAINERS/#testing","title":"Testing","text":"<p>This workflow is defined in <code>test.yml</code></p>"},{"location":"MAINTAINERS/#linux","title":"Linux","text":"<p>The <code>test-linux</code> job relies on the custom Docker image <code>rossant/datoviz_ubuntu</code> (see the Dockerfile). This image has all build and run dependencies, as well as the Swiftshader software Vulkan renderer, and xvfb to run graphical applications on a headless server.</p>"},{"location":"MAINTAINERS/#macos","title":"macOS","text":"<p>Docker seems to be not supported on GitHub Actions macOS servers. The <code>test_macos</code> job installs build dependencies with Homebrew, Python dependencies, it builds Datoviz and it run the test suite.</p> <p>Note that there is a workaround to remove Mono's freetype library which conflicts with Homebrew's one.</p>"},{"location":"MAINTAINERS/#windows_1","title":"Windows","text":"<p>There is a custom Docker image <code>rossant/datoviz_windows</code> which is however unused at the moment because GitHub Actions Windows servers to not seem to support custom Docker images at the moment.</p> <p>Instead, the job installs dependencies with Chocolatey, vcpkg, the Vulkan SDK, and it extracts the Swiftshader dynamic library. Note that the Swiftshader Windows library is very large (&gt;100 MB) so it is stored as a compressed zip file in the <code>datoviz/data</code> submodule.</p>"},{"location":"MAINTAINERS/#wheel-building","title":"Wheel building","text":"<p>This workflow is defined in <code>wheels.yml</code></p> <p>For each supported platform, this workflow builds the library in release mode, builds the wheel, renames it for the current platform, and uploads it as a GitHub Actions build artifact.</p> <p>Refer to the Testing workflow for more information about the building process, which is mostly replicated in this workflow.</p>"},{"location":"MAINTAINERS/#linux-notes","title":"Linux notes","text":"<p>For improved compatibility with Linux Python wheels uploaded to PyPI, it is necessary to build Datoviz on a particular Linux distribution based on AlmaLinux (based on Red Hat Enterprise Linux, REHL).</p> <p>There is a custom Docker image <code>rossant/datoviz_manylinux</code> based on <code>quay.io/pypa/manylinux_2_28_x86_64</code> (see the Dockerfile) with all build dependencies. It also has Swiftshader compiled for this platform.</p>"},{"location":"MAINTAINERS/#macos-notes","title":"macOS notes","text":"<p>There are two separate jobs for x86_64 and amd64 architectures.</p>"},{"location":"api/","title":"C API Reference","text":""},{"location":"api/#main-functions","title":"Main functions","text":""},{"location":"api/#dvz_arcball_angles","title":"<code>dvz_arcball_angles()</code>","text":"<p>Get the current arcball angles.</p> <pre><code>void dvz_arcball_angles(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_constrain","title":"<code>dvz_arcball_constrain()</code>","text":"<p>Add arcball constraints.</p> <pre><code>void dvz_arcball_constrain(\n    DvzArcball* arcball,  // the arcball\n    vec3 constrain,  // the constrain values\n)\n</code></pre>"},{"location":"api/#dvz_arcball_end","title":"<code>dvz_arcball_end()</code>","text":"<p>Finalize arcball position update.</p> <pre><code>void dvz_arcball_end(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_flags","title":"<code>dvz_arcball_flags()</code>","text":"<p>Set the arcball flags.</p> <pre><code>void dvz_arcball_flags(\n    DvzArcball* arcball,  // the arcball\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_arcball_gui","title":"<code>dvz_arcball_gui()</code>","text":"<p>Show a GUI with sliders controlling the three arcball angles.</p> <pre><code>void dvz_arcball_gui(\n    DvzArcball* arcball,  // the arcball\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas (or figure) ID\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_arcball_initial","title":"<code>dvz_arcball_initial()</code>","text":"<p>Set the initial arcball angles.</p> <pre><code>void dvz_arcball_initial(\n    DvzArcball* arcball,  // the arcball\n    vec3 angles,  // the initial angles\n)\n</code></pre>"},{"location":"api/#dvz_arcball_model","title":"<code>dvz_arcball_model()</code>","text":"<p>Return the model matrix of an arcball.</p> <pre><code>void dvz_arcball_model(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_mvp","title":"<code>dvz_arcball_mvp()</code>","text":"<p>Apply an MVP matrix to an arcball (only the model matrix).</p> <pre><code>void dvz_arcball_mvp(\n    DvzArcball* arcball,  // the arcball\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_arcball_print","title":"<code>dvz_arcball_print()</code>","text":"<p>Display information about an arcball.</p> <pre><code>void dvz_arcball_print(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_reset","title":"<code>dvz_arcball_reset()</code>","text":"<p>Reset an arcball to its initial position.</p> <pre><code>void dvz_arcball_reset(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_resize","title":"<code>dvz_arcball_resize()</code>","text":"<p>Inform an arcball of a panel resize.</p> <pre><code>void dvz_arcball_resize(\n    DvzArcball* arcball,  // the arcball\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_arcball_rotate","title":"<code>dvz_arcball_rotate()</code>","text":"<p>Apply a rotation to an arcball.</p> <pre><code>void dvz_arcball_rotate(\n    DvzArcball* arcball,  // the arcball\n    vec2 cur_pos,  // the initial position\n    vec2 last_pos,  // the final position\n)\n</code></pre>"},{"location":"api/#dvz_arcball_set","title":"<code>dvz_arcball_set()</code>","text":"<p>Set the arcball angles.</p> <pre><code>void dvz_arcball_set(\n    DvzArcball* arcball,  // the arcball\n    vec3 angles,  // the angles\n)\n</code></pre>"},{"location":"api/#dvz_atlas_destroy","title":"<code>dvz_atlas_destroy()</code>","text":"<p>Destroy an atlas.</p> <pre><code>void dvz_atlas_destroy(\n    DvzAtlas* atlas,  // the atlas\n)\n</code></pre>"},{"location":"api/#dvz_atlas_font","title":"<code>dvz_atlas_font()</code>","text":"<p>Load the default atlas and font.</p> <pre><code>DvzAtlasFont dvz_atlas_font(  // returns: a DvzAtlasFont struct with DvzAtlas and DvzFont objects.\n    double font_size,  // the font size\n)\n</code></pre>"},{"location":"api/#dvz_basic","title":"<code>dvz_basic()</code>","text":"<p>Create a basic visual using the few GPU visual primitives (point, line, triangles).</p> <pre><code>DvzVisual* dvz_basic(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    DvzPrimitiveTopology topology,  // the primitive topology\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_basic_alloc","title":"<code>dvz_basic_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_basic_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_basic_color","title":"<code>dvz_basic_color()</code>","text":"<p>Set the vertex colors.</p> <pre><code>void dvz_basic_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_basic_group","title":"<code>dvz_basic_group()</code>","text":"<p>Set the vertex group index.</p> <pre><code>void dvz_basic_group(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the group index of each vertex\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_basic_position","title":"<code>dvz_basic_position()</code>","text":"<p>Set the vertex positions.</p> <pre><code>void dvz_basic_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_basic_size","title":"<code>dvz_basic_size()</code>","text":"<p>Set the point size (for POINT_LIST topology only).</p> <pre><code>void dvz_basic_size(\n    DvzVisual* visual,  // the visual\n    float size,  // the point size in pixels\n)\n</code></pre>"},{"location":"api/#dvz_box","title":"<code>dvz_box()</code>","text":"<p>Create a box.</p> <pre><code>DvzBox dvz_box(  // returns: the box\n    double xmin,  // minimum x value\n    double xmax,  // maximum x value\n    double ymin,  // minimum y value\n    double ymax,  // maximum y value\n    double zmin,  // minimum z value\n    double zmax,  // maximum z value\n)\n</code></pre>"},{"location":"api/#dvz_box_aspect","title":"<code>dvz_box_aspect()</code>","text":"<p>Return the aspect ratio of a box.</p> <pre><code>double dvz_box_aspect(  // returns: the aspect ratio width/height\n    DvzBox box,  // the box\n)\n</code></pre>"},{"location":"api/#dvz_box_center","title":"<code>dvz_box_center()</code>","text":"<p>Return the box center.</p> <pre><code>void dvz_box_center(\n    DvzBox box,  // the box\n)\n</code></pre>"},{"location":"api/#dvz_box_extent","title":"<code>dvz_box_extent()</code>","text":"<p>Return the extent of a box, in the same coordinate system, depending on the aspect ratio.</p> <pre><code>DvzBox dvz_box_extent(  // returns: the extent box\n    DvzBox box,  // the original box\n    float width,  // the viewport width\n    float height,  // the viewport height\n    DvzBoxExtentStrategy strategy,  // indicates how the extent box should be computed\n)\n</code></pre>"},{"location":"api/#dvz_box_inverse","title":"<code>dvz_box_inverse()</code>","text":"<p>Perform an inverse transformation of a position from a target box to a source box.</p> <pre><code>void dvz_box_inverse(\n\n)\n</code></pre>"},{"location":"api/#dvz_box_merge","title":"<code>dvz_box_merge()</code>","text":"<p>Merge a number of boxes into a single box.</p> <pre><code>DvzBox dvz_box_merge(  // returns: the merged box\n    uint32_t box_count,  // the number of boxes to merge\n    DvzBox* boxes,  // the boxes to merge\n    DvzBoxMergeStrategy strategy,  // the merge strategy\n)\n</code></pre>"},{"location":"api/#dvz_box_normalize","title":"<code>dvz_box_normalize()</code>","text":"<p>Normalize 3D input positions into a target box.</p> <pre><code>void dvz_box_normalize(\n    DvzBox source,  // the source box, in data coordinates\n    DvzBox target,  // the target box, typically in normalized coordinates\n    uint32_t count,  // the number of positions to normalize\n    dvec3* pos,  // the positions to normalize (double precision)\n)\n</code></pre>"},{"location":"api/#dvz_box_normalize_2d","title":"<code>dvz_box_normalize_2D()</code>","text":"<p>Normalize 2D input positions into a target box.</p> <pre><code>void dvz_box_normalize_2D(\n    DvzBox source,  // the source box, in data coordinates\n    DvzBox target,  // the target box, typically in normalized coordinates\n    uint32_t count,  // the number of positions to normalize\n    dvec2* pos,  // the positions to normalize (double precision)\n)\n</code></pre>"},{"location":"api/#dvz_box_print","title":"<code>dvz_box_print()</code>","text":"<p>Display information about a box.</p> <pre><code>void dvz_box_print(\n\n)\n</code></pre>"},{"location":"api/#dvz_camera_initial","title":"<code>dvz_camera_initial()</code>","text":"<p>Set the initial camera parameters.</p> <pre><code>void dvz_camera_initial(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the initial position\n    vec3 lookat,  // the lookat position\n    vec3 up,  // the up vector\n)\n</code></pre>"},{"location":"api/#dvz_camera_lookat","title":"<code>dvz_camera_lookat()</code>","text":"<p>Set a camera lookat position.</p> <pre><code>void dvz_camera_lookat(\n    DvzCamera* camera,  // the camera\n    vec3 lookat,  // the lookat position\n)\n</code></pre>"},{"location":"api/#dvz_camera_mvp","title":"<code>dvz_camera_mvp()</code>","text":"<p>Apply an MVP to a camera.</p> <pre><code>void dvz_camera_mvp(\n    DvzCamera* camera,  // the camera\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_camera_ortho","title":"<code>dvz_camera_ortho()</code>","text":"<p>Make an orthographic camera.</p> <pre><code>void dvz_camera_ortho(\n    DvzCamera* camera,  // the camera\n    float left,  // the left value\n    float right,  // the right value\n    float bottom,  // the bottom value\n    float top,  // the top value\n)\n</code></pre>"},{"location":"api/#dvz_camera_perspective","title":"<code>dvz_camera_perspective()</code>","text":"<p>Set a camera perspective.</p> <pre><code>void dvz_camera_perspective(\n    DvzCamera* camera,  // the camera\n    float fov,  // the field of view angle (in radians)\n)\n</code></pre>"},{"location":"api/#dvz_camera_position","title":"<code>dvz_camera_position()</code>","text":"<p>Set a camera position.</p> <pre><code>void dvz_camera_position(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the pos\n)\n</code></pre>"},{"location":"api/#dvz_camera_print","title":"<code>dvz_camera_print()</code>","text":"<p>Display information about a camera.</p> <pre><code>void dvz_camera_print(\n    DvzCamera* camera,  // the camera\n)\n</code></pre>"},{"location":"api/#dvz_camera_reset","title":"<code>dvz_camera_reset()</code>","text":"<p>Reset a camera.</p> <pre><code>void dvz_camera_reset(\n    DvzCamera* camera,  // the camera\n)\n</code></pre>"},{"location":"api/#dvz_camera_resize","title":"<code>dvz_camera_resize()</code>","text":"<p>Inform a camera of a panel resize.</p> <pre><code>void dvz_camera_resize(\n    DvzCamera* camera,  // the camera\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_camera_up","title":"<code>dvz_camera_up()</code>","text":"<p>Set a camera up vector.</p> <pre><code>void dvz_camera_up(\n    DvzCamera* camera,  // the camera\n    vec3 up,  // the up vector\n)\n</code></pre>"},{"location":"api/#dvz_camera_viewproj","title":"<code>dvz_camera_viewproj()</code>","text":"<p>Return the view and proj matrices of the camera.</p> <pre><code>void dvz_camera_viewproj(\n    DvzCamera* camera,  // the camera\n)\n</code></pre>"},{"location":"api/#dvz_camera_zrange","title":"<code>dvz_camera_zrange()</code>","text":"<p>Set the camera zrange.</p> <pre><code>void dvz_camera_zrange(\n    DvzCamera* camera,  // the camera\n    float near,  // the near value\n    float far,  // the far value\n)\n</code></pre>"},{"location":"api/#dvz_circular_2d","title":"<code>dvz_circular_2D()</code>","text":"<p>Generate a 2D circular motion.</p> <pre><code>void dvz_circular_2D(\n    vec2 center,  // the circle center\n    float radius,  // the circle radius\n    float angle,  // the initial angle\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_circular_3d","title":"<code>dvz_circular_3D()</code>","text":"<p>Generate a 3D circular motion.</p> <pre><code>void dvz_circular_3D(\n    vec3 center,  // the circle center\n    vec3 u,  // the first 3D vector defining the plane containing the circle\n    vec3 v,  // the second 3D vector defining the plane containing the circle\n    float radius,  // the circle radius\n    float angle,  // the initial angle\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_colormap","title":"<code>dvz_colormap()</code>","text":"<p>Fetch a color from a colormap and a value (either 8-bit or float, depending on DVZ_COLOR_CVEC4).</p> <pre><code>void dvz_colormap(\n    DvzColormap cmap,  // the colormap\n    uint8_t value,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_colormap_8bit","title":"<code>dvz_colormap_8bit()</code>","text":"<p>Fetch a color from a colormap and a value (8-bit version).</p> <pre><code>void dvz_colormap_8bit(\n    DvzColormap cmap,  // the colormap\n    uint8_t value,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_colormap_array","title":"<code>dvz_colormap_array()</code>","text":"<p>Fetch colors from a colormap and an array of values.</p> <pre><code>void dvz_colormap_array(\n    DvzColormap cmap,  // the colormap\n    uint32_t count,  // the number of values\n    float* values,  // pointer to the array of float numbers\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n)\n</code></pre>"},{"location":"api/#dvz_colormap_scale","title":"<code>dvz_colormap_scale()</code>","text":"<p>Fetch a color from a colormap and an interpolated value.</p> <pre><code>void dvz_colormap_scale(\n    DvzColormap cmap,  // the colormap\n    float value,  // the value\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n)\n</code></pre>"},{"location":"api/#dvz_compute_normals","title":"<code>dvz_compute_normals()</code>","text":"<p>Compute face normals.</p> <pre><code>void dvz_compute_normals(\n    uint32_t vertex_count,  // number of vertices\n    uint32_t index_count,  // number of indices (triple of the number of faces)\n    vec3* pos,  // array of vec3 positions\n    DvzIndex* index,  // pos array of uint32_t indices\n)\n</code></pre>"},{"location":"api/#dvz_demo","title":"<code>dvz_demo()</code>","text":"<p>Run a demo.</p> <pre><code>void dvz_demo(\n\n)\n</code></pre>"},{"location":"api/#dvz_easing","title":"<code>dvz_easing()</code>","text":"<p>Apply an easing function to a normalized value.</p> <pre><code>double dvz_easing(  // returns: the eased value\n    DvzEasing easing,  // the easing mode\n    double t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_error_callback","title":"<code>dvz_error_callback()</code>","text":"<p>Register an error callback, a C function taking as input a string.</p> <pre><code>void dvz_error_callback(\n    DvzErrorCallback cb,  // the error callback\n)\n</code></pre>"},{"location":"api/#dvz_figure","title":"<code>dvz_figure()</code>","text":"<p>Create a figure, a desktop window with panels and visuals.</p> <pre><code>DvzFigure* dvz_figure(  // returns: the figure\n    DvzScene* scene,  // the scene\n    uint32_t width,  // the window width\n    uint32_t height,  // the window height\n    int flags,  // the figure creation flags (not yet stabilized)\n)\n</code></pre>"},{"location":"api/#dvz_figure_destroy","title":"<code>dvz_figure_destroy()</code>","text":"<p>Destroy a figure.</p> <pre><code>void dvz_figure_destroy(\n    DvzFigure* figure,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_figure_id","title":"<code>dvz_figure_id()</code>","text":"<p>Return a figure ID.</p> <pre><code>DvzId dvz_figure_id(  // returns: the figure ID\n    DvzFigure* figure,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_figure_resize","title":"<code>dvz_figure_resize()</code>","text":"<p>Resize a figure.</p> <pre><code>void dvz_figure_resize(\n    DvzFigure* fig,  // the figure\n    uint32_t width,  // the window width\n    uint32_t height,  // the window height\n)\n</code></pre>"},{"location":"api/#dvz_figure_update","title":"<code>dvz_figure_update()</code>","text":"<p>Update a figure after the composition of the panels and visuals has changed.</p> <pre><code>void dvz_figure_update(\n    DvzFigure* figure,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_font","title":"<code>dvz_font()</code>","text":"<p>Create a font.</p> <pre><code>DvzFont* dvz_font(  // returns: the font\n    long ttf_size,  // size in bytes of a TTF font raw buffer\n    char* ttf_bytes,  // TTF font raw buffer\n)\n</code></pre>"},{"location":"api/#dvz_font_ascii","title":"<code>dvz_font_ascii()</code>","text":"<p>Compute the shift of each glyph in an ASCII string, using the Freetype library.</p> <pre><code>vec4* dvz_font_ascii(  // returns: an array of (x,y,w,h) shifts\n    DvzFont* font,  // the font\n    char* string,  // the ASCII string\n)\n</code></pre>"},{"location":"api/#dvz_font_destroy","title":"<code>dvz_font_destroy()</code>","text":"<p>Destroy a font.</p> <pre><code>void dvz_font_destroy(\n    DvzFont* font,  // the font\n)\n</code></pre>"},{"location":"api/#dvz_font_draw","title":"<code>dvz_font_draw()</code>","text":"<p>Render a string using Freetype.</p> <pre><code>uint8_t* dvz_font_draw(  // returns: an RGBA array allocated by this function and that MUST be freed by the caller\n    DvzFont* font,  // the font\n    uint32_t length,  // the number of glyphs\n    uint32_t* codepoints,  // the Unicode codepoints of the glyphs\n    vec4* xywh,  // an array of (x,y,w,h) shifts, returned by dvz_font_layout()\n    int flags,  // the font flags\n)\n</code></pre>"},{"location":"api/#dvz_font_layout","title":"<code>dvz_font_layout()</code>","text":"<p>Compute the shift of each glyph in a Unicode string, using the Freetype library.</p> <pre><code>vec4* dvz_font_layout(  // returns: an array of (x,y,w,h) shifts\n    DvzFont* font,  // the font\n    uint32_t length,  // the number of glyphs\n    uint32_t* codepoints,  // the Unicode codepoints of the glyphs\n)\n</code></pre>"},{"location":"api/#dvz_font_size","title":"<code>dvz_font_size()</code>","text":"<p>Set the font size.</p> <pre><code>void dvz_font_size(\n    DvzFont* font,  // the font\n    double size,  // the font size\n)\n</code></pre>"},{"location":"api/#dvz_font_texture","title":"<code>dvz_font_texture()</code>","text":"<p>Generate a texture with a rendered text.</p> <pre><code>DvzId dvz_font_texture(  // returns: a tex ID\n    DvzFont* font,  // the font\n    DvzBatch* batch,  // the batch\n    uint32_t length,  // the number of Unicode codepoints\n    uint32_t* codepoints,  // the Unicode codepoints\n)\n</code></pre>"},{"location":"api/#dvz_glyph","title":"<code>dvz_glyph()</code>","text":"<p>Create a glyph visual.</p> <pre><code>DvzVisual* dvz_glyph(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_alloc","title":"<code>dvz_glyph_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_glyph_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_glyph_anchor","title":"<code>dvz_glyph_anchor()</code>","text":"<p>Set the glyph anchors.</p> <pre><code>void dvz_glyph_anchor(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the anchors (x and y) of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_angle","title":"<code>dvz_glyph_angle()</code>","text":"<p>Set the glyph angles.</p> <pre><code>void dvz_glyph_angle(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the angles of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_ascii","title":"<code>dvz_glyph_ascii()</code>","text":"<p>Set the glyph ascii characters.</p> <pre><code>void dvz_glyph_ascii(\n    DvzVisual* visual,  // the visual\n    char* string,  // the characters\n)\n</code></pre>"},{"location":"api/#dvz_glyph_atlas","title":"<code>dvz_glyph_atlas()</code>","text":"<p>Associate an atlas with a glyph visual.</p> <pre><code>void dvz_glyph_atlas(\n    DvzVisual* visual,  // the visual\n    DvzAtlas* atlas,  // the atlas\n)\n</code></pre>"},{"location":"api/#dvz_glyph_axis","title":"<code>dvz_glyph_axis()</code>","text":"<p>Set the glyph axes.</p> <pre><code>void dvz_glyph_axis(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D axis vectors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_bgcolor","title":"<code>dvz_glyph_bgcolor()</code>","text":"<p>Set the glyph background color.</p> <pre><code>void dvz_glyph_bgcolor(\n    DvzVisual* visual,  // the visual\n    vec4 bgcolor,  // the background color\n)\n</code></pre>"},{"location":"api/#dvz_glyph_color","title":"<code>dvz_glyph_color()</code>","text":"<p>Set the glyph colors.</p> <pre><code>void dvz_glyph_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_groupsize","title":"<code>dvz_glyph_groupsize()</code>","text":"<p>Set the glyph group size.</p> <pre><code>void dvz_glyph_groupsize(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the glyph group sizes\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_position","title":"<code>dvz_glyph_position()</code>","text":"<p>Set the glyph positions.</p> <pre><code>void dvz_glyph_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_shift","title":"<code>dvz_glyph_shift()</code>","text":"<p>Set the glyph shifts.</p> <pre><code>void dvz_glyph_shift(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the shifts (x and y) of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_size","title":"<code>dvz_glyph_size()</code>","text":"<p>Set the glyph sizes.</p> <pre><code>void dvz_glyph_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the sizes (width and height) of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_texcoords","title":"<code>dvz_glyph_texcoords()</code>","text":"<p>Set the glyph texture coordinates.</p> <pre><code>void dvz_glyph_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* coords,  // the x,y,w,h texture coordinates\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_texture","title":"<code>dvz_glyph_texture()</code>","text":"<p>Assign a texture to a glyph visual.</p> <pre><code>void dvz_glyph_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n)\n</code></pre>"},{"location":"api/#dvz_glyph_unicode","title":"<code>dvz_glyph_unicode()</code>","text":"<p>Set the glyph unicode code points.</p> <pre><code>void dvz_glyph_unicode(\n    DvzVisual* visual,  // the visual\n    uint32_t count,  // the number of glyphs\n    uint32_t* codepoints,  // the unicode codepoints\n)\n</code></pre>"},{"location":"api/#dvz_glyph_xywh","title":"<code>dvz_glyph_xywh()</code>","text":"<p>Set the xywh parameters of each glyph.</p> <pre><code>void dvz_glyph_xywh(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the xywh values of each glyph\n    vec2 offset,  // the xy offsets of each glyph\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_alpha","title":"<code>dvz_gui_alpha()</code>","text":"<p>Set the alpha transparency of the next GUI dialog.</p> <pre><code>void dvz_gui_alpha(\n    float alpha,  // the alpha transparency value\n)\n</code></pre>"},{"location":"api/#dvz_gui_begin","title":"<code>dvz_gui_begin()</code>","text":"<p>Start a new dialog.</p> <pre><code>void dvz_gui_begin(\n    char* title,  // the dialog title\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_button","title":"<code>dvz_gui_button()</code>","text":"<p>Add a button.</p> <pre><code>bool dvz_gui_button(  // returns: whether the button was pressed\n    char* name,  // the button name\n    float width,  // the button width\n    float height,  // the button height\n)\n</code></pre>"},{"location":"api/#dvz_gui_checkbox","title":"<code>dvz_gui_checkbox()</code>","text":"<p>Add a checkbox.</p> <pre><code>bool dvz_gui_checkbox(  // returns: whether the checkbox's state has changed\n    char* name,  // the button name\n)\n</code></pre>"},{"location":"api/#dvz_gui_clicked","title":"<code>dvz_gui_clicked()</code>","text":"<p>Close the current tree node.</p> <pre><code>bool dvz_gui_clicked(\n\n)\n</code></pre>"},{"location":"api/#dvz_gui_colorpicker","title":"<code>dvz_gui_colorpicker()</code>","text":"<p>Add a color picker</p> <pre><code>bool dvz_gui_colorpicker(\n    char* name,  // the widget name\n    vec3 color,  // the color\n    int flags,  // the widget flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_corner","title":"<code>dvz_gui_corner()</code>","text":"<p>Set the corner position of the next GUI dialog.</p> <pre><code>void dvz_gui_corner(\n    DvzCorner corner,  // which corner\n    vec2 pad,  // the pad\n)\n</code></pre>"},{"location":"api/#dvz_gui_demo","title":"<code>dvz_gui_demo()</code>","text":"<p>Show the demo GUI.</p> <pre><code>void dvz_gui_demo(\n\n)\n</code></pre>"},{"location":"api/#dvz_gui_end","title":"<code>dvz_gui_end()</code>","text":"<p>Stop the creation of the dialog.</p> <pre><code>void dvz_gui_end(\n\n)\n</code></pre>"},{"location":"api/#dvz_gui_flags","title":"<code>dvz_gui_flags()</code>","text":"<p>Set the flags of the next GUI dialog.</p> <pre><code>int dvz_gui_flags(\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_image","title":"<code>dvz_gui_image()</code>","text":"<p>Add an image in a GUI dialog.</p> <pre><code>void dvz_gui_image(\n    DvzTex* tex,  // the texture\n    float width,  // the image width\n    float height,  // the image height\n)\n</code></pre>"},{"location":"api/#dvz_gui_node","title":"<code>dvz_gui_node()</code>","text":"<p>Start a new tree node.</p> <pre><code>bool dvz_gui_node(\n    char* name,  // the widget name\n)\n</code></pre>"},{"location":"api/#dvz_gui_pop","title":"<code>dvz_gui_pop()</code>","text":"<p>Close the current tree node.</p> <pre><code>void dvz_gui_pop(\n\n)\n</code></pre>"},{"location":"api/#dvz_gui_pos","title":"<code>dvz_gui_pos()</code>","text":"<p>Set the position of the next GUI dialog.</p> <pre><code>void dvz_gui_pos(\n    vec2 pos,  // the dialog position\n    vec2 pivot,  // the pivot\n)\n</code></pre>"},{"location":"api/#dvz_gui_selectable","title":"<code>dvz_gui_selectable()</code>","text":"<p>Close the current tree node.</p> <pre><code>bool dvz_gui_selectable(\n    char* name,  // the widget name\n)\n</code></pre>"},{"location":"api/#dvz_gui_size","title":"<code>dvz_gui_size()</code>","text":"<p>Set the size of the next GUI dialog.</p> <pre><code>void dvz_gui_size(\n    vec2 size,  // the size\n)\n</code></pre>"},{"location":"api/#dvz_gui_slider","title":"<code>dvz_gui_slider()</code>","text":"<p>Add a slider.</p> <pre><code>bool dvz_gui_slider(  // returns: whether the value has changed\n    char* name,  // the slider name\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    float* value,  // the pointer to the value\n)\n</code></pre>"},{"location":"api/#dvz_gui_table","title":"<code>dvz_gui_table()</code>","text":"<p>Display a table with selectable rows.</p> <pre><code>bool dvz_gui_table(  // returns: whether the row selection has changed (in the selected array)\n    char* name,  // the widget name\n    uint32_t row_count,  // the number of rows\n    uint32_t column_count,  // the number of columns\n    char** labels,  // all cell labels\n    bool* selected,  // a pointer to an array of boolean indicated which rows are selected\n    int flags,  // the Dear ImGui flags\n)\n</code></pre>"},{"location":"api/#dvz_image","title":"<code>dvz_image()</code>","text":"<p>Create an image visual.</p> <pre><code>DvzVisual* dvz_image(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_image_alloc","title":"<code>dvz_image_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_image_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of images to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_image_anchor","title":"<code>dvz_image_anchor()</code>","text":"<p>Set the image anchors.</p> <pre><code>void dvz_image_anchor(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the relative anchors of each image, (0,0 = position pertains to top left corner)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_color","title":"<code>dvz_image_color()</code>","text":"<p>Set the image colors (only when using DVZ_IMAGE_FLAGS_FILL).</p> <pre><code>void dvz_image_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the image colors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_edge_color","title":"<code>dvz_image_edge_color()</code>","text":"<p>Set the edge color.</p> <pre><code>void dvz_image_edge_color(\n    DvzVisual* visual,  // the visual\n    DvzColor color,  // the edge color\n)\n</code></pre>"},{"location":"api/#dvz_image_edge_width","title":"<code>dvz_image_edge_width()</code>","text":"<p>Set the edge width.</p> <pre><code>void dvz_image_edge_width(\n    DvzVisual* visual,  // the visual\n    float width,  // the edge width\n)\n</code></pre>"},{"location":"api/#dvz_image_position","title":"<code>dvz_image_position()</code>","text":"<p>Set the image positions.</p> <pre><code>void dvz_image_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the top left corner\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_radius","title":"<code>dvz_image_radius()</code>","text":"<p>Use a rounded rectangle for images, with a given radius in pixels.</p> <pre><code>void dvz_image_radius(\n    DvzVisual* visual,  // the visual\n    float radius,  // the rounded corner radius, in pixel\n)\n</code></pre>"},{"location":"api/#dvz_image_size","title":"<code>dvz_image_size()</code>","text":"<p>Set the image sizes.</p> <pre><code>void dvz_image_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the sizes of each image, in pixels\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_texcoords","title":"<code>dvz_image_texcoords()</code>","text":"<p>Set the image texture coordinates.</p> <pre><code>void dvz_image_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* tl_br,  // the tex coordinates of the top left and bottom right corners (vec4 u0,v0,u1,v1)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_texture","title":"<code>dvz_image_texture()</code>","text":"<p>Assign a texture to an image visual.</p> <pre><code>void dvz_image_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_interpolate","title":"<code>dvz_interpolate()</code>","text":"<p>Make a linear interpolation between two scalar value.</p> <pre><code>float dvz_interpolate(  // returns: the interpolated value\n    float p0,  // the first value\n    float p1,  // the second value\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_interpolate_2d","title":"<code>dvz_interpolate_2D()</code>","text":"<p>Make a linear interpolation between two 2D points.</p> <pre><code>void dvz_interpolate_2D(  // returns: the interpolated point\n    vec2 p0,  // the first point\n    vec2 p1,  // the second point\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_interpolate_3d","title":"<code>dvz_interpolate_3D()</code>","text":"<p>Make a linear interpolation between two 3D points.</p> <pre><code>void dvz_interpolate_3D(  // returns: the interpolated point\n    vec3 p0,  // the first point\n    vec3 p1,  // the second point\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_marker","title":"<code>dvz_marker()</code>","text":"<p>Create a marker visual.</p> <pre><code>DvzVisual* dvz_marker(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_alloc","title":"<code>dvz_marker_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_marker_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_marker_angle","title":"<code>dvz_marker_angle()</code>","text":"<p>Set the marker angles.</p> <pre><code>void dvz_marker_angle(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the angles of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_aspect","title":"<code>dvz_marker_aspect()</code>","text":"<p>Set the marker aspect.</p> <pre><code>void dvz_marker_aspect(\n    DvzVisual* visual,  // the visual\n    DvzMarkerAspect aspect,  // the marker aspect, one of DVZ_MARKER_ASPECT_FILLED, DVZ_MARKER_ASPECT_STROKE,\n)\n</code></pre>"},{"location":"api/#dvz_marker_color","title":"<code>dvz_marker_color()</code>","text":"<p>Set the marker colors.</p> <pre><code>void dvz_marker_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_edge_color","title":"<code>dvz_marker_edge_color()</code>","text":"<p>Set the marker edge color.</p> <pre><code>void dvz_marker_edge_color(\n    DvzVisual* visual,  // the visual\n    DvzColor color,  // the edge color\n)\n</code></pre>"},{"location":"api/#dvz_marker_edge_width","title":"<code>dvz_marker_edge_width()</code>","text":"<p>Set the marker edge width.</p> <pre><code>void dvz_marker_edge_width(\n    DvzVisual* visual,  // the visual\n    float width,  // the edge width\n)\n</code></pre>"},{"location":"api/#dvz_marker_mode","title":"<code>dvz_marker_mode()</code>","text":"<p>Set the marker mode.</p> <pre><code>void dvz_marker_mode(\n    DvzVisual* visual,  // the visual\n    DvzMarkerMode mode,  // the marker mode, one of DVZ_MARKER_MODE_CODE, DVZ_MARKER_MODE_BITMAP,\n)\n</code></pre>"},{"location":"api/#dvz_marker_position","title":"<code>dvz_marker_position()</code>","text":"<p>Set the marker positions.</p> <pre><code>void dvz_marker_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_shape","title":"<code>dvz_marker_shape()</code>","text":"<p>Set the marker shape.</p> <pre><code>void dvz_marker_shape(\n    DvzVisual* visual,  // the visual\n    DvzMarkerShape shape,  // the marker shape\n)\n</code></pre>"},{"location":"api/#dvz_marker_size","title":"<code>dvz_marker_size()</code>","text":"<p>Set the marker sizes.</p> <pre><code>void dvz_marker_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_tex","title":"<code>dvz_marker_tex()</code>","text":"<p>Set the marker texture.</p> <pre><code>void dvz_marker_tex(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzId sampler,  // the sampler ID\n)\n</code></pre>"},{"location":"api/#dvz_marker_tex_scale","title":"<code>dvz_marker_tex_scale()</code>","text":"<p>Set the texture scale.</p> <pre><code>void dvz_marker_tex_scale(\n    DvzVisual* visual,  // the visual\n    float scale,  // the texture scale\n)\n</code></pre>"},{"location":"api/#dvz_mesh","title":"<code>dvz_mesh()</code>","text":"<p>Create a mesh visual.</p> <pre><code>DvzVisual* dvz_mesh(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_alloc","title":"<code>dvz_mesh_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_mesh_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices\n)\n</code></pre>"},{"location":"api/#dvz_mesh_color","title":"<code>dvz_mesh_color()</code>","text":"<p>Set the mesh colors.</p> <pre><code>void dvz_mesh_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the vertex colors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_contour","title":"<code>dvz_mesh_contour()</code>","text":"<p>Set the contour information for polygon contours.</p> <pre><code>void dvz_mesh_contour(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // for vertex A, B, C, the least significant bit is 1 if the opposite edge is a\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_density","title":"<code>dvz_mesh_density()</code>","text":"<p>Set the number of isolines</p> <pre><code>void dvz_mesh_density(\n    DvzVisual* visual,  // the mesh\n    uint32_t count,  // the number of isolines\n)\n</code></pre>"},{"location":"api/#dvz_mesh_index","title":"<code>dvz_mesh_index()</code>","text":"<p>Set the mesh indices.</p> <pre><code>void dvz_mesh_index(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzIndex* values,  // the face indices (three vertex indices per triangle)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_isoline","title":"<code>dvz_mesh_isoline()</code>","text":"<p>Set the isolines values.</p> <pre><code>void dvz_mesh_isoline(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the scalar field for which to draw isolines\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_left","title":"<code>dvz_mesh_left()</code>","text":"<p>Set the distance between the current vertex to the left edge at corner A, B, or C in triangle</p> <pre><code>void dvz_mesh_left(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the distance to the left edge adjacent to each triangle vertex\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_light_color","title":"<code>dvz_mesh_light_color()</code>","text":"<p>Set the light color.</p> <pre><code>void dvz_mesh_light_color(\n    DvzVisual* visual,  // the mesh\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n     color,  // the light color (rgba, but the a component is ignored)\n)\n</code></pre>"},{"location":"api/#dvz_mesh_light_dir","title":"<code>dvz_mesh_light_dir()</code>","text":"<p>Set the light direction.</p> <pre><code>void dvz_mesh_light_dir(\n    DvzVisual* visual,  // the mesh\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n    vec3 dir,  // the light direction\n)\n</code></pre>"},{"location":"api/#dvz_mesh_light_params","title":"<code>dvz_mesh_light_params()</code>","text":"<p>Set the light parameters.</p> <pre><code>void dvz_mesh_light_params(\n    DvzVisual* visual,  // the mesh\n    uint32_t idx,  // the light index (0, 1, 2, or 3)\n    vec4 params,  // the light parameters (vec4 ambient, diffuse, specular, exponent)\n)\n</code></pre>"},{"location":"api/#dvz_mesh_linewidth","title":"<code>dvz_mesh_linewidth()</code>","text":"<p>Set the stroke linewidth (wireframe or isoline).</p> <pre><code>void dvz_mesh_linewidth(\n    DvzVisual* visual,  // the mesh\n    float linewidth,  // the line width\n)\n</code></pre>"},{"location":"api/#dvz_mesh_normal","title":"<code>dvz_mesh_normal()</code>","text":"<p>Set the mesh normals.</p> <pre><code>void dvz_mesh_normal(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the vertex normal vectors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_position","title":"<code>dvz_mesh_position()</code>","text":"<p>Set the mesh vertex positions.</p> <pre><code>void dvz_mesh_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D vertex positions\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_reshape","title":"<code>dvz_mesh_reshape()</code>","text":"<p>Update a mesh once a shape has been updated.</p> <pre><code>void dvz_mesh_reshape(\n    DvzVisual* visual,  // the mesh\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_mesh_right","title":"<code>dvz_mesh_right()</code>","text":"<p>Set the distance between the current vertex to the right edge at corner A, B, or C in triangle</p> <pre><code>void dvz_mesh_right(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the distance to the right edge adjacent to each triangle vertex\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_shape","title":"<code>dvz_mesh_shape()</code>","text":"<p>Create a mesh out of a shape.</p> <pre><code>DvzVisual* dvz_mesh_shape(  // returns: the mesh\n    DvzBatch* batch,  // the batch\n    DvzShape* shape,  // the shape\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_stroke","title":"<code>dvz_mesh_stroke()</code>","text":"<p>Set the stroke color.</p> <pre><code>void dvz_mesh_stroke(\n    DvzVisual* visual,  // the mesh\n     stroke,  // the rgba components\n)\n</code></pre>"},{"location":"api/#dvz_mesh_texcoords","title":"<code>dvz_mesh_texcoords()</code>","text":"<p>Set the mesh texture coordinates.</p> <pre><code>void dvz_mesh_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the vertex texture coordinates (vec4 u,v,*,alpha)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_texture","title":"<code>dvz_mesh_texture()</code>","text":"<p>Assign a 2D texture to a mesh visual.</p> <pre><code>void dvz_mesh_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph","title":"<code>dvz_monoglyph()</code>","text":"<p>Create a monoglyph visual.</p> <pre><code>DvzVisual* dvz_monoglyph(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_alloc","title":"<code>dvz_monoglyph_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_monoglyph_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_anchor","title":"<code>dvz_monoglyph_anchor()</code>","text":"<p>Set the glyph anchor (relative to the glyph size).</p> <pre><code>void dvz_monoglyph_anchor(\n    DvzVisual* visual,  // the visual\n    vec2 anchor,  // the anchor\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_color","title":"<code>dvz_monoglyph_color()</code>","text":"<p>Set the glyph colors.</p> <pre><code>void dvz_monoglyph_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_glyph","title":"<code>dvz_monoglyph_glyph()</code>","text":"<p>Set the text.</p> <pre><code>void dvz_monoglyph_glyph(\n    DvzVisual* visual,  // the visual\n    char* text,  // the ASCII test (string length without the null terminal byte = number of glyphs)\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_offset","title":"<code>dvz_monoglyph_offset()</code>","text":"<p>Set the glyph offsets.</p> <pre><code>void dvz_monoglyph_offset(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    ivec2* values,  // the glyph offsets (ivec2 integers: row,column)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_position","title":"<code>dvz_monoglyph_position()</code>","text":"<p>Set the glyph positions.</p> <pre><code>void dvz_monoglyph_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_size","title":"<code>dvz_monoglyph_size()</code>","text":"<p>Set the glyph size (relative to the initial glyph size).</p> <pre><code>void dvz_monoglyph_size(\n    DvzVisual* visual,  // the visual\n    float size,  // the glyph size\n)\n</code></pre>"},{"location":"api/#dvz_monoglyph_textarea","title":"<code>dvz_monoglyph_textarea()</code>","text":"<p>All-in-one function for multiline text.</p> <pre><code>void dvz_monoglyph_textarea(\n    DvzVisual* visual,  // the visual\n    vec3 pos,  // the text position\n    DvzColor color,  // the text color\n    float size,  // the glyph size\n    char* text,  // the text, can contain `\\n` new lines\n)\n</code></pre>"},{"location":"api/#dvz_mvp","title":"<code>dvz_mvp()</code>","text":"<p>Create a MVP structure.</p> <pre><code>DvzMVP dvz_mvp(  // returns: the MVP structure\n    mat4 model,  // the model matrix\n    mat4 view,  // the view matrix\n    mat4 proj,  // the projection matrix\n)\n</code></pre>"},{"location":"api/#dvz_ortho_end","title":"<code>dvz_ortho_end()</code>","text":"<p>End an ortho interaction.</p> <pre><code>void dvz_ortho_end(\n    DvzOrtho* ortho,  // the ortho\n)\n</code></pre>"},{"location":"api/#dvz_ortho_flags","title":"<code>dvz_ortho_flags()</code>","text":"<p>Set the ortho flags.</p> <pre><code>void dvz_ortho_flags(\n    DvzOrtho* ortho,  // the ortho\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_ortho_mvp","title":"<code>dvz_ortho_mvp()</code>","text":"<p>Apply an MVP matrix to an ortho.</p> <pre><code>void dvz_ortho_mvp(\n    DvzOrtho* ortho,  // the ortho\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_ortho_pan","title":"<code>dvz_ortho_pan()</code>","text":"<p>Apply a pan value to an ortho.</p> <pre><code>void dvz_ortho_pan(\n    DvzOrtho* ortho,  // the ortho\n    vec2 pan,  // the pan, in NDC\n)\n</code></pre>"},{"location":"api/#dvz_ortho_pan_shift","title":"<code>dvz_ortho_pan_shift()</code>","text":"<p>Apply a pan shift to an ortho.</p> <pre><code>void dvz_ortho_pan_shift(\n    DvzOrtho* ortho,  // the ortho\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_ortho_reset","title":"<code>dvz_ortho_reset()</code>","text":"<p>Reset an ortho.</p> <pre><code>void dvz_ortho_reset(\n    DvzOrtho* ortho,  // the ortho\n)\n</code></pre>"},{"location":"api/#dvz_ortho_resize","title":"<code>dvz_ortho_resize()</code>","text":"<p>Inform an ortho of a panel resize.</p> <pre><code>void dvz_ortho_resize(\n    DvzOrtho* ortho,  // the ortho\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_ortho_zoom","title":"<code>dvz_ortho_zoom()</code>","text":"<p>Apply a zoom value to an ortho.</p> <pre><code>void dvz_ortho_zoom(\n    DvzOrtho* ortho,  // the ortho\n    float zoom,  // the zoom level\n)\n</code></pre>"},{"location":"api/#dvz_ortho_zoom_shift","title":"<code>dvz_ortho_zoom_shift()</code>","text":"<p>Apply a zoom shift to an ortho.</p> <pre><code>void dvz_ortho_zoom_shift(\n    DvzOrtho* ortho,  // the ortho\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_ortho_zoom_wheel","title":"<code>dvz_ortho_zoom_wheel()</code>","text":"<p>Apply a wheel zoom to an ortho.</p> <pre><code>void dvz_ortho_zoom_wheel(\n    DvzOrtho* ortho,  // the ortho\n    vec2 dir,  // the wheel direction\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel","title":"<code>dvz_panel()</code>","text":"<p>Create a panel in a figure (partial or complete rectangular portion of a figure).</p> <pre><code>DvzPanel* dvz_panel(\n    DvzFigure* fig,  // the figure\n    float x,  // the x coordinate of the top left corner, in pixels\n    float y,  // the y coordinate of the top left corner, in pixels\n    float width,  // the panel width, in pixels\n    float height,  // the panel height, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel_arcball","title":"<code>dvz_panel_arcball()</code>","text":"<p>Set arcball interactivity for a panel.</p> <pre><code>DvzArcball* dvz_panel_arcball(  // returns: the arcball\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_at","title":"<code>dvz_panel_at()</code>","text":"<p>Return the panel containing a given point.</p> <pre><code>DvzPanel* dvz_panel_at(  // returns: the panel containing the point, or NULL if there is none\n    DvzFigure* figure,  // the figure\n    vec2 pos,  // the position\n)\n</code></pre>"},{"location":"api/#dvz_panel_camera","title":"<code>dvz_panel_camera()</code>","text":"<p>Set a camera for a panel.</p> <pre><code>DvzCamera* dvz_panel_camera(  // returns: the camera\n    DvzPanel* panel,  // the panel\n    int flags,  // the camera flags\n)\n</code></pre>"},{"location":"api/#dvz_panel_contains","title":"<code>dvz_panel_contains()</code>","text":"<p>Return whether a point is inside a panel.</p> <pre><code>bool dvz_panel_contains(  // returns: true if the position lies within the panel\n    DvzPanel* panel,  // the panel\n    vec2 pos,  // the position\n)\n</code></pre>"},{"location":"api/#dvz_panel_default","title":"<code>dvz_panel_default()</code>","text":"<p>Return the default full panel spanning an entire figure.</p> <pre><code>DvzPanel* dvz_panel_default(  // returns: the panel spanning the entire figure\n    DvzFigure* fig,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_panel_destroy","title":"<code>dvz_panel_destroy()</code>","text":"<p>Destroy a panel.</p> <pre><code>void dvz_panel_destroy(\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_margins","title":"<code>dvz_panel_margins()</code>","text":"<p>Set the margins of a panel.</p> <pre><code>void dvz_panel_margins(\n    DvzPanel* panel,  // the panel\n    float top,  // the top margin, in pixels\n    float right,  // the right margin, in pixels\n    float bottom,  // the bottom margin, in pixels\n    float left,  // the left margin, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel_mvp","title":"<code>dvz_panel_mvp()</code>","text":"<p>Assign a MVP structure to a panel.</p> <pre><code>void dvz_panel_mvp(\n    DvzPanel* panel,  // the panel\n    DvzMVP* mvp,  // a pointer to the MVP structure\n)\n</code></pre>"},{"location":"api/#dvz_panel_mvpmat","title":"<code>dvz_panel_mvpmat()</code>","text":"<p>Assign the model-view-proj matrices to a panel.</p> <pre><code>void dvz_panel_mvpmat(\n    DvzPanel* panel,  // the panel\n    mat4 model,  // the model matrix\n    mat4 view,  // the view matrix\n    mat4 proj,  // the projection matrix\n)\n</code></pre>"},{"location":"api/#dvz_panel_ortho","title":"<code>dvz_panel_ortho()</code>","text":"<p>Set ortho interactivity for a panel.</p> <pre><code>DvzOrtho* dvz_panel_ortho(  // returns: the ortho\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_panzoom","title":"<code>dvz_panel_panzoom()</code>","text":"<p>Set panzoom interactivity for a panel.</p> <pre><code>DvzPanzoom* dvz_panel_panzoom(  // returns: the panzoom\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_resize","title":"<code>dvz_panel_resize()</code>","text":"<p>Resize a panel.</p> <pre><code>void dvz_panel_resize(\n    DvzPanel* panel,  // the panel\n    float x,  // the x coordinate of the top left corner, in pixels\n    float y,  // the y coordinate of the top left corner, in pixels\n    float width,  // the panel width, in pixels\n    float height,  // the panel height, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel_transform","title":"<code>dvz_panel_transform()</code>","text":"<p>Assign a transform to a panel.</p> <pre><code>void dvz_panel_transform(\n    DvzPanel* panel,  // the panel\n    DvzTransform* tr,  // the transform\n)\n</code></pre>"},{"location":"api/#dvz_panel_update","title":"<code>dvz_panel_update()</code>","text":"<p>Trigger a panel update.</p> <pre><code>void dvz_panel_update(\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_visual","title":"<code>dvz_panel_visual()</code>","text":"<p>Add a visual to a panel.</p> <pre><code>void dvz_panel_visual(\n    DvzPanel* panel,  // the panel\n    DvzVisual* visual,  // the visual\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_end","title":"<code>dvz_panzoom_end()</code>","text":"<p>End a panzoom interaction.</p> <pre><code>void dvz_panzoom_end(\n    DvzPanzoom* pz,  // the panzoom\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_extent","title":"<code>dvz_panzoom_extent()</code>","text":"<p>Get the extent box.</p> <pre><code>DvzBox dvz_panzoom_extent(  // returns: the extent box in normalized coordinates\n    DvzPanzoom* pz,  // the panzoom\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_flags","title":"<code>dvz_panzoom_flags()</code>","text":"<p>Set the panzoom flags.</p> <pre><code>void dvz_panzoom_flags(\n    DvzPanzoom* pz,  // the panzoom\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_mvp","title":"<code>dvz_panzoom_mvp()</code>","text":"<p>Apply an MVP matrix to a panzoom.</p> <pre><code>void dvz_panzoom_mvp(\n    DvzPanzoom* pz,  // the panzoom\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_pan","title":"<code>dvz_panzoom_pan()</code>","text":"<p>Apply a pan value to a panzoom.</p> <pre><code>void dvz_panzoom_pan(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 pan,  // the pan, in NDC\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_pan_shift","title":"<code>dvz_panzoom_pan_shift()</code>","text":"<p>Apply a pan shift to a panzoom.</p> <pre><code>void dvz_panzoom_pan_shift(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_reset","title":"<code>dvz_panzoom_reset()</code>","text":"<p>Reset a panzoom.</p> <pre><code>void dvz_panzoom_reset(\n    DvzPanzoom* pz,  // the panzoom\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_resize","title":"<code>dvz_panzoom_resize()</code>","text":"<p>Inform a panzoom of a panel resize.</p> <pre><code>void dvz_panzoom_resize(\n    DvzPanzoom* pz,  // the panzoom\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_set","title":"<code>dvz_panzoom_set()</code>","text":"<p>Set the extent box.</p> <pre><code>void dvz_panzoom_set(\n    DvzPanzoom* pz,  // the panzoom\n    DvzBox extent,  // the extent box\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_xlim","title":"<code>dvz_panzoom_xlim()</code>","text":"<p>Set a panzoom x limits.</p> <pre><code>void dvz_panzoom_xlim(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 xlim,  // the xlim (FLOAT_MIN/MAX=no lim)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_ylim","title":"<code>dvz_panzoom_ylim()</code>","text":"<p>Set a panzoom y limits.</p> <pre><code>void dvz_panzoom_ylim(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 ylim,  // the ylim (FLOAT_MIN/MAX=no lim)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zlim","title":"<code>dvz_panzoom_zlim()</code>","text":"<p>Set a panzoom z limits.</p> <pre><code>void dvz_panzoom_zlim(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 zlim,  // the zlim (FLOAT_MIN/MAX=no lim)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zoom","title":"<code>dvz_panzoom_zoom()</code>","text":"<p>Apply a zoom value to a panzoom.</p> <pre><code>void dvz_panzoom_zoom(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 zoom,  // the zoom, in NDC\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zoom_shift","title":"<code>dvz_panzoom_zoom_shift()</code>","text":"<p>Apply a zoom shift to a panzoom.</p> <pre><code>void dvz_panzoom_zoom_shift(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zoom_wheel","title":"<code>dvz_panzoom_zoom_wheel()</code>","text":"<p>Apply a wheel zoom to a panzoom.</p> <pre><code>void dvz_panzoom_zoom_wheel(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 dir,  // the wheel direction\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_path","title":"<code>dvz_path()</code>","text":"<p>Create a path visual.</p> <pre><code>DvzVisual* dvz_path(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_path_alloc","title":"<code>dvz_path_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_path_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t total_point_count,  // the total number of points to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_path_cap","title":"<code>dvz_path_cap()</code>","text":"<p>Set the path cap.</p> <pre><code>void dvz_path_cap(\n    DvzVisual* visual,  // the visual\n    DvzCapType cap,  // the cap\n)\n</code></pre>"},{"location":"api/#dvz_path_color","title":"<code>dvz_path_color()</code>","text":"<p>Set the path colors.</p> <pre><code>void dvz_path_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_path_join","title":"<code>dvz_path_join()</code>","text":"<p>Set the path join.</p> <pre><code>void dvz_path_join(\n    DvzVisual* visual,  // the visual\n    DvzJoinType join,  // the join\n)\n</code></pre>"},{"location":"api/#dvz_path_linewidth","title":"<code>dvz_path_linewidth()</code>","text":"<p>Set the path line width.</p> <pre><code>void dvz_path_linewidth(\n    DvzVisual* visual,  // the visual\n    float width,  // the line width\n)\n</code></pre>"},{"location":"api/#dvz_path_position","title":"<code>dvz_path_position()</code>","text":"<p>Set the path positions. Note: all path point positions must be updated at once for now.</p> <pre><code>void dvz_path_position(\n    DvzVisual* visual,  // the visual\n     vertex_count,  // the total number of points across all paths\n    vec3* positions,  // the path point positions\n    uint32_t path_count,  // the number of different paths\n    uint32_t* path_lengths,  // the number of points in each path\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_pixel","title":"<code>dvz_pixel()</code>","text":"<p>Create a pixel visual.</p> <pre><code>DvzVisual* dvz_pixel(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_pixel_alloc","title":"<code>dvz_pixel_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_pixel_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_pixel_color","title":"<code>dvz_pixel_color()</code>","text":"<p>Set the pixel colors.</p> <pre><code>void dvz_pixel_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_pixel_position","title":"<code>dvz_pixel_position()</code>","text":"<p>Set the pixel positions.</p> <pre><code>void dvz_pixel_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_point","title":"<code>dvz_point()</code>","text":"<p>Create a point visual.</p> <pre><code>DvzVisual* dvz_point(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_point_alloc","title":"<code>dvz_point_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_point_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_point_color","title":"<code>dvz_point_color()</code>","text":"<p>Set the point colors.</p> <pre><code>void dvz_point_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_point_position","title":"<code>dvz_point_position()</code>","text":"<p>Set the point positions.</p> <pre><code>void dvz_point_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_point_size","title":"<code>dvz_point_size()</code>","text":"<p>Set the point sizes.</p> <pre><code>void dvz_point_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the sizes of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_resample","title":"<code>dvz_resample()</code>","text":"<p>Normalize a value in an interval.</p> <pre><code>double dvz_resample(  // returns: the normalized value between 0 and 1\n    double t0,  // the interval start\n    double t1,  // the interval end\n    double t,  // the value within the interval\n)\n</code></pre>"},{"location":"api/#dvz_scene","title":"<code>dvz_scene()</code>","text":"<p>Create a scene.</p> <pre><code>DvzScene* dvz_scene(  // returns: the scene\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_scene_destroy","title":"<code>dvz_scene_destroy()</code>","text":"<p>Destroy a scene.</p> <pre><code>void dvz_scene_destroy(\n    DvzScene* scene,  // the scene\n)\n</code></pre>"},{"location":"api/#dvz_scene_figure","title":"<code>dvz_scene_figure()</code>","text":"<p>Get a figure from its id.</p> <pre><code>DvzFigure* dvz_scene_figure(  // returns: the figure\n    DvzScene* scene,  // the scene\n    DvzId id,  // the figure id\n)\n</code></pre>"},{"location":"api/#dvz_scene_run","title":"<code>dvz_scene_run()</code>","text":"<p>Start the event loop and render the scene in a window.</p> <pre><code>void dvz_scene_run(\n    DvzScene* scene,  // the scene\n    DvzApp* app,  // the app\n    uint64_t n_frames,  // the maximum number of frames, 0 for infinite loop\n)\n</code></pre>"},{"location":"api/#dvz_segment","title":"<code>dvz_segment()</code>","text":"<p>Create a segment visual.</p> <pre><code>DvzVisual* dvz_segment(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_alloc","title":"<code>dvz_segment_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_segment_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_segment_cap","title":"<code>dvz_segment_cap()</code>","text":"<p>Set the segment cap types.</p> <pre><code>void dvz_segment_cap(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzCapType* initial,  // the initial segment cap types\n    DvzCapType* terminal,  // the terminal segment cap types\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_color","title":"<code>dvz_segment_color()</code>","text":"<p>Set the segment colors.</p> <pre><code>void dvz_segment_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_linewidth","title":"<code>dvz_segment_linewidth()</code>","text":"<p>Set the segment line widths.</p> <pre><code>void dvz_segment_linewidth(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the segment line widths\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_position","title":"<code>dvz_segment_position()</code>","text":"<p>Set the segment positions.</p> <pre><code>void dvz_segment_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* initial,  // the initial 3D positions of the segments\n    vec3* terminal,  // the terminal 3D positions of the segments\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_shift","title":"<code>dvz_segment_shift()</code>","text":"<p>Set the segment shift.</p> <pre><code>void dvz_segment_shift(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the dx0,dy0,dx1,dy1 shift quadriplets of the segments to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_shape_begin","title":"<code>dvz_shape_begin()</code>","text":"<p>Start a transformation sequence.</p> <pre><code>void dvz_shape_begin(\n    DvzShape* shape,  // the shape\n    uint32_t first,  // the first vertex to modify\n    uint32_t count,  // the number of vertices to modify\n)\n</code></pre>"},{"location":"api/#dvz_shape_cone","title":"<code>dvz_shape_cone()</code>","text":"<p>Create a cone shape.</p> <pre><code>DvzShape dvz_shape_cone(  // returns: the shape\n    uint32_t count,  // the number of points along the disc border\n    DvzColor color,  // the cone color\n)\n</code></pre>"},{"location":"api/#dvz_shape_cube","title":"<code>dvz_shape_cube()</code>","text":"<p>Create a cube shape.</p> <pre><code>DvzShape dvz_shape_cube(  // returns: the shape\n    DvzColor* colors,  // the colors of the six faces\n)\n</code></pre>"},{"location":"api/#dvz_shape_cylinder","title":"<code>dvz_shape_cylinder()</code>","text":"<p>Create a cylinder shape.</p> <pre><code>DvzShape dvz_shape_cylinder(  // returns: the shape\n    uint32_t count,  // the number of points along the cylinder border\n    DvzColor color,  // the cylinder color\n)\n</code></pre>"},{"location":"api/#dvz_shape_destroy","title":"<code>dvz_shape_destroy()</code>","text":"<p>Destroy a shape.</p> <pre><code>void dvz_shape_destroy(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_disc","title":"<code>dvz_shape_disc()</code>","text":"<p>Create a disc shape.</p> <pre><code>DvzShape dvz_shape_disc(  // returns: the shape\n    uint32_t count,  // the number of points along the disc border\n    DvzColor color,  // the disc color\n)\n</code></pre>"},{"location":"api/#dvz_shape_end","title":"<code>dvz_shape_end()</code>","text":"<p>Apply the transformation sequence and reset it.</p> <pre><code>void dvz_shape_end(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_merge","title":"<code>dvz_shape_merge()</code>","text":"<p>Merge several shapes.</p> <pre><code>DvzShape dvz_shape_merge(  // returns: the merged shape\n    uint32_t count,  // the number of shapes to merge\n    DvzShape* shapes,  // the shapes to merge\n)\n</code></pre>"},{"location":"api/#dvz_shape_normalize","title":"<code>dvz_shape_normalize()</code>","text":"<p>Normalize a shape.</p> <pre><code>void dvz_shape_normalize(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_normals","title":"<code>dvz_shape_normals()</code>","text":"<p>Recompute the face normals.</p> <pre><code>void dvz_shape_normals(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_obj","title":"<code>dvz_shape_obj()</code>","text":"<p>Load a .obj shape.</p> <pre><code>DvzShape dvz_shape_obj(  // returns: the shape\n    char* file_path,  // the path to the .obj file\n)\n</code></pre>"},{"location":"api/#dvz_shape_polygon","title":"<code>dvz_shape_polygon()</code>","text":"<p>Create a polygon shape using the simple earcut polygon triangulation algorithm.</p> <pre><code>DvzShape dvz_shape_polygon(  // returns: the shape\n    uint32_t count,  // the number of points along the polygon border\n    dvec2* points,  // the points 2D coordinates\n    DvzColor color,  // the polygon color\n)\n</code></pre>"},{"location":"api/#dvz_shape_print","title":"<code>dvz_shape_print()</code>","text":"<p>Show information about a shape.</p> <pre><code>void dvz_shape_print(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_rescaling","title":"<code>dvz_shape_rescaling()</code>","text":"<p>Compute the rescaling factor to renormalize a shape.</p> <pre><code>float dvz_shape_rescaling(\n    DvzShape* shape,  // the shape\n    int flags,  // the rescaling flags\n)\n</code></pre>"},{"location":"api/#dvz_shape_rotate","title":"<code>dvz_shape_rotate()</code>","text":"<p>Append a rotation to a shape.</p> <pre><code>void dvz_shape_rotate(\n    DvzShape* shape,  // the shape\n    float angle,  // the rotation angle\n    vec3 axis,  // the rotation axis\n)\n</code></pre>"},{"location":"api/#dvz_shape_scale","title":"<code>dvz_shape_scale()</code>","text":"<p>Append a scaling transform to a shape.</p> <pre><code>void dvz_shape_scale(\n    DvzShape* shape,  // the shape\n    vec3 scale,  // the scaling factors\n)\n</code></pre>"},{"location":"api/#dvz_shape_sphere","title":"<code>dvz_shape_sphere()</code>","text":"<p>Create a sphere shape.</p> <pre><code>DvzShape dvz_shape_sphere(  // returns: the shape\n    uint32_t rows,  // the number of rows\n    uint32_t cols,  // the number of columns\n    DvzColor color,  // the sphere color\n)\n</code></pre>"},{"location":"api/#dvz_shape_square","title":"<code>dvz_shape_square()</code>","text":"<p>Create a square shape.</p> <pre><code>DvzShape dvz_shape_square(  // returns: the shape\n    DvzColor color,  // the square color\n)\n</code></pre>"},{"location":"api/#dvz_shape_surface","title":"<code>dvz_shape_surface()</code>","text":"<p>Create a grid shape.</p> <pre><code>DvzShape dvz_shape_surface(  // returns: the shape\n    uint32_t row_count,  // number of rows\n    uint32_t col_count,  // number of cols\n    float* heights,  // a pointer to row_count*col_count height values (floats)\n    DvzColor* colors,  // a pointer to row_count*col_count color values (cvec4 or vec4)\n    vec3 o,  // the origin\n    vec3 u,  // the unit vector parallel to each column\n    vec3 v,  // the unit vector parallel to each row\n    int flags,  // the grid creation flags\n)\n</code></pre>"},{"location":"api/#dvz_shape_transform","title":"<code>dvz_shape_transform()</code>","text":"<p>Append an arbitrary transformation.</p> <pre><code>void dvz_shape_transform(\n    DvzShape* shape,  // the shape\n    mat4 transform,  // the transform mat4 matrix\n)\n</code></pre>"},{"location":"api/#dvz_shape_translate","title":"<code>dvz_shape_translate()</code>","text":"<p>Append a translation to a shape.</p> <pre><code>void dvz_shape_translate(\n    DvzShape* shape,  // the shape\n    vec3 translate,  // the translation vector\n)\n</code></pre>"},{"location":"api/#dvz_shape_unindex","title":"<code>dvz_shape_unindex()</code>","text":"<p>Convert an indexed shape to a non-indexed one by duplicating the vertex values according</p> <pre><code>void dvz_shape_unindex(\n    DvzShape* shape,  // the shape\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_slice","title":"<code>dvz_slice()</code>","text":"<p>Create a slice visual (multiple 2D images with slices of a 3D texture).</p> <pre><code>DvzVisual* dvz_slice(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_slice_alloc","title":"<code>dvz_slice_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_slice_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of slices to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_slice_alpha","title":"<code>dvz_slice_alpha()</code>","text":"<p>Set the slice transparency alpha value.</p> <pre><code>void dvz_slice_alpha(\n    DvzVisual* visual,  // the visual\n    float alpha,  // the alpha value\n)\n</code></pre>"},{"location":"api/#dvz_slice_position","title":"<code>dvz_slice_position()</code>","text":"<p>Set the slice positions.</p> <pre><code>void dvz_slice_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* p0,  // the 3D positions of the top left corner\n    vec3* p1,  // the 3D positions of the top right corner\n    vec3* p2,  // the 3D positions of the bottom left corner\n    vec3* p3,  // the 3D positions of the bottom right corner\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_slice_texcoords","title":"<code>dvz_slice_texcoords()</code>","text":"<p>Set the slice texture coordinates.</p> <pre><code>void dvz_slice_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* uvw0,  // the 3D texture coordinates of the top left corner\n    vec3* uvw1,  // the 3D texture coordinates of the top right corner\n    vec3* uvw2,  // the 3D texture coordinates of the bottom left corner\n    vec3* uvw3,  // the 3D texture coordinates of the bottom right corner\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_slice_texture","title":"<code>dvz_slice_texture()</code>","text":"<p>Assign a texture to a slice visual.</p> <pre><code>void dvz_slice_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_sphere","title":"<code>dvz_sphere()</code>","text":"<p>Create a sphere visual.</p> <pre><code>DvzVisual* dvz_sphere(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_sphere_alloc","title":"<code>dvz_sphere_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_sphere_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of spheres to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_sphere_color","title":"<code>dvz_sphere_color()</code>","text":"<p>Set the sphere colors.</p> <pre><code>void dvz_sphere_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzColor* color,  // the sphere colors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_sphere_light_params","title":"<code>dvz_sphere_light_params()</code>","text":"<p>Set the sphere light parameters.</p> <pre><code>void dvz_sphere_light_params(\n    DvzVisual* visual,  // the visual\n    vec4 params,  // the light parameters (vec4 ambient, diffuse, specular, exponent)\n)\n</code></pre>"},{"location":"api/#dvz_sphere_light_pos","title":"<code>dvz_sphere_light_pos()</code>","text":"<p>Set the sphere light position.</p> <pre><code>void dvz_sphere_light_pos(\n    DvzVisual* visual,  // the visual\n    vec3 pos,  // the light position\n)\n</code></pre>"},{"location":"api/#dvz_sphere_position","title":"<code>dvz_sphere_position()</code>","text":"<p>Set the sphere positions.</p> <pre><code>void dvz_sphere_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* pos,  // the 3D positions of the sphere centers\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_sphere_size","title":"<code>dvz_sphere_size()</code>","text":"<p>Set the sphere sizes.</p> <pre><code>void dvz_sphere_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* size,  // the radius of the spheres\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_tex_image","title":"<code>dvz_tex_image()</code>","text":"<p>Create a 2D texture to be used in an image visual.</p> <pre><code>DvzId dvz_tex_image(  // returns: the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    void* data,  // the texture data to upload\n)\n</code></pre>"},{"location":"api/#dvz_tex_slice","title":"<code>dvz_tex_slice()</code>","text":"<p>Create a 3D texture to be used in a slice visual.</p> <pre><code>DvzId dvz_tex_slice(  // returns: the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    uint32_t depth,  // the texture depth\n    void* data,  // the texture data to upload\n)\n</code></pre>"},{"location":"api/#dvz_tex_volume","title":"<code>dvz_tex_volume()</code>","text":"<p>Create a 3D texture to be used in a volume visual.</p> <pre><code>DvzId dvz_tex_volume(  // returns: the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    uint32_t depth,  // the texture depth\n    void* data,  // the texture data to upload\n)\n</code></pre>"},{"location":"api/#dvz_version","title":"<code>dvz_version()</code>","text":"<p>Return the current version string.</p> <pre><code>char* dvz_version(  // returns: the version string\n\n)\n</code></pre>"},{"location":"api/#dvz_visual_alloc","title":"<code>dvz_visual_alloc()</code>","text":"<p>Allocate a visual.</p> <pre><code>void dvz_visual_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the number of items\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices\n)\n</code></pre>"},{"location":"api/#dvz_visual_attr","title":"<code>dvz_visual_attr()</code>","text":"<p>Declare a visual attribute.</p> <pre><code>void dvz_visual_attr(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    DvzSize offset,  // the attribute offset within the vertex buffer, in bytes\n    DvzSize item_size,  // the attribute size, in bytes\n    DvzFormat format,  // the attribute data format\n    int flags,  // the attribute flags\n)\n</code></pre>"},{"location":"api/#dvz_visual_blend","title":"<code>dvz_visual_blend()</code>","text":"<p>Set the blending type of a visual.</p> <pre><code>void dvz_visual_blend(\n    DvzVisual* visual,  // the visual\n    DvzBlendType blend_type,  // the blending type\n)\n</code></pre>"},{"location":"api/#dvz_visual_clip","title":"<code>dvz_visual_clip()</code>","text":"<p>Set the visual clipping.</p> <pre><code>void dvz_visual_clip(\n    DvzVisual* visual,  // the visual\n    DvzViewportClip clip,  // the viewport clipping\n)\n</code></pre>"},{"location":"api/#dvz_visual_cull","title":"<code>dvz_visual_cull()</code>","text":"<p>Set the cull mode of a visual.</p> <pre><code>void dvz_visual_cull(\n    DvzVisual* visual,  // the visual\n    DvzCullMode cull_mode,  // the cull mode\n)\n</code></pre>"},{"location":"api/#dvz_visual_dat","title":"<code>dvz_visual_dat()</code>","text":"<p>Bind a dat to a visual slot.</p> <pre><code>void dvz_visual_dat(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    DvzId dat,  // the dat ID\n)\n</code></pre>"},{"location":"api/#dvz_visual_data","title":"<code>dvz_visual_data()</code>","text":"<p>Set visual data.</p> <pre><code>void dvz_visual_data(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    uint32_t first,  // the index of the first item to set\n    uint32_t count,  // the number of items to set\n    void* data,  // a pointer to the data buffer\n)\n</code></pre>"},{"location":"api/#dvz_visual_depth","title":"<code>dvz_visual_depth()</code>","text":"<p>Set the visual depth.</p> <pre><code>void dvz_visual_depth(\n    DvzVisual* visual,  // the visual\n    DvzDepthTest depth_test,  // whether to activate the depth test\n)\n</code></pre>"},{"location":"api/#dvz_visual_fixed","title":"<code>dvz_visual_fixed()</code>","text":"<p>Fix some axes in a visual.</p> <pre><code>void dvz_visual_fixed(\n    DvzVisual* visual,  // the visual\n    bool fixed_x,  // whether the x axis should be fixed\n    bool fixed_y,  // whether the y axis should be fixed\n    bool fixed_z,  // whether the z axis should be fixed\n)\n</code></pre>"},{"location":"api/#dvz_visual_front","title":"<code>dvz_visual_front()</code>","text":"<p>Set the front face mode of a visual.</p> <pre><code>void dvz_visual_front(\n    DvzVisual* visual,  // the visual\n    DvzFrontFace front_face,  // the front face mode\n)\n</code></pre>"},{"location":"api/#dvz_visual_groups","title":"<code>dvz_visual_groups()</code>","text":"<p>Set groups in a visual.</p> <pre><code>void dvz_visual_groups(\n    DvzVisual* visual,  // the visual\n    uint32_t group_count,  // the number of groups\n    uint32_t* group_sizes,  // the size of each group\n)\n</code></pre>"},{"location":"api/#dvz_visual_index","title":"<code>dvz_visual_index()</code>","text":"<p>Set the visual index data.</p> <pre><code>void dvz_visual_index(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first index to set\n    uint32_t count,  // the number of indices\n    DvzIndex* data,  // a pointer to a buffer of DvzIndex (uint32_t) values with the indices\n)\n</code></pre>"},{"location":"api/#dvz_visual_param","title":"<code>dvz_visual_param()</code>","text":"<p>Set a visual parameter value.</p> <pre><code>void dvz_visual_param(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    uint32_t attr_idx,  // the index of the parameter attribute within the params structure\n    void* item,  // a pointer to the value to use for that parameter\n)\n</code></pre>"},{"location":"api/#dvz_visual_params","title":"<code>dvz_visual_params()</code>","text":"<p>Declare a set of visual parameters.</p> <pre><code>DvzParams* dvz_visual_params(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index of the uniform buffer storing the parameter values\n    DvzSize size,  // the size, in bytes, of that uniform buffer\n)\n</code></pre>"},{"location":"api/#dvz_visual_polygon","title":"<code>dvz_visual_polygon()</code>","text":"<p>Set the polygon mode of a visual.</p> <pre><code>void dvz_visual_polygon(\n    DvzVisual* visual,  // the visual\n    DvzPolygonMode polygon_mode,  // the polygon mode\n)\n</code></pre>"},{"location":"api/#dvz_visual_primitive","title":"<code>dvz_visual_primitive()</code>","text":"<p>Set the primitive topology of a visual.</p> <pre><code>void dvz_visual_primitive(\n    DvzVisual* visual,  // the visual\n    DvzPrimitiveTopology primitive,  // the primitive topology\n)\n</code></pre>"},{"location":"api/#dvz_visual_quads","title":"<code>dvz_visual_quads()</code>","text":"<p>Set visual data as quads.</p> <pre><code>void dvz_visual_quads(\n    DvzVisual* visual,  // the visual\n    uint32_t attr_idx,  // the attribute index\n    uint32_t first,  // the index of the first item to set\n    uint32_t count,  // the number of items to set\n    vec4* tl_br,  // a pointer to a buffer of vec4 with the 2D coordinates of the top-left and\n)\n</code></pre>"},{"location":"api/#dvz_visual_resize","title":"<code>dvz_visual_resize()</code>","text":"<p>Resize a visual allocation.</p> <pre><code>void dvz_visual_resize(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the number of items\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices (0 if there is no index buffer)\n)\n</code></pre>"},{"location":"api/#dvz_visual_shader","title":"<code>dvz_visual_shader()</code>","text":"<p>Set the shader SPIR-V name of a visual.</p> <pre><code>void dvz_visual_shader(\n    DvzVisual* visual,  // the visual\n    char* name,  // the built-in resource name of the shader (_vert and _frag are appended)\n)\n</code></pre>"},{"location":"api/#dvz_visual_show","title":"<code>dvz_visual_show()</code>","text":"<p>Set the visibility of a visual.</p> <pre><code>void dvz_visual_show(\n    DvzVisual* visual,  // the visual\n    bool is_visible,  // the visual visibility\n)\n</code></pre>"},{"location":"api/#dvz_visual_slot","title":"<code>dvz_visual_slot()</code>","text":"<p>Declare a visual slot.</p> <pre><code>void dvz_visual_slot(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    DvzSlotType type,  // the slot type\n)\n</code></pre>"},{"location":"api/#dvz_visual_specialization","title":"<code>dvz_visual_specialization()</code>","text":"<p>Set a specialization constant of a visual.</p> <pre><code>void dvz_visual_specialization(\n    DvzVisual* visual,  // the visual\n    DvzShaderType shader,  // the shader type\n    uint32_t idx,  // the specialization constant index\n    DvzSize size,  // the size, in bytes, of the value passed to this function\n    void* value,  // a pointer to the value to use for that specialization constant\n)\n</code></pre>"},{"location":"api/#dvz_visual_spirv","title":"<code>dvz_visual_spirv()</code>","text":"<p>Set the shader SPIR-V code of a visual.</p> <pre><code>void dvz_visual_spirv(\n    DvzVisual* visual,  // the visual\n    DvzShaderType type,  // the shader type\n    DvzSize size,  // the size, in bytes, of the SPIR-V buffer\n    char* buffer,  // a pointer to the SPIR-V buffer\n)\n</code></pre>"},{"location":"api/#dvz_visual_stride","title":"<code>dvz_visual_stride()</code>","text":"<p>Declare a visual binding.</p> <pre><code>void dvz_visual_stride(\n    DvzVisual* visual,  // the visual\n    uint32_t binding_idx,  // the binding index\n    DvzSize stride,  // the binding stride, in bytes\n)\n</code></pre>"},{"location":"api/#dvz_visual_tex","title":"<code>dvz_visual_tex()</code>","text":"<p>Bind a tex to a visual slot.</p> <pre><code>void dvz_visual_tex(\n    DvzVisual* visual,  // the visual\n    uint32_t slot_idx,  // the slot index\n    DvzId tex,  // the tex ID\n    DvzId sampler,  // the sampler ID\n    uvec3 offset,  // the texture offset\n)\n</code></pre>"},{"location":"api/#dvz_visual_transform","title":"<code>dvz_visual_transform()</code>","text":"<p>Set a visual transform.</p> <pre><code>void dvz_visual_transform(\n    DvzVisual* visual,  // the visual\n    DvzTransform* tr,  // the transform\n    uint32_t vertex_attr,  // the vertex attribute on which the transform applies to\n)\n</code></pre>"},{"location":"api/#dvz_visual_update","title":"<code>dvz_visual_update()</code>","text":"<p>Update a visual after its data has changed.</p> <pre><code>void dvz_visual_update(\n    DvzVisual* visual,  // the visual\n)\n</code></pre>"},{"location":"api/#dvz_volume","title":"<code>dvz_volume()</code>","text":"<p>Create a volume visual.</p> <pre><code>DvzVisual* dvz_volume(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_volume_alloc","title":"<code>dvz_volume_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_volume_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of volumes to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_volume_size","title":"<code>dvz_volume_size()</code>","text":"<p>Set the volume size.</p> <pre><code>void dvz_volume_size(\n    DvzVisual* visual,  // the visual\n    float w,  // the texture width\n    float h,  // the texture height\n    float d,  // the texture depth\n)\n</code></pre>"},{"location":"api/#dvz_volume_texcoords","title":"<code>dvz_volume_texcoords()</code>","text":"<p>Set the texture coordinates of two corner points.</p> <pre><code>void dvz_volume_texcoords(\n    DvzVisual* visual,  // the visual\n    vec3 uvw0,  // coordinates of one of the corner points\n    vec3 uvw1,  // coordinates of one of the corner points\n)\n</code></pre>"},{"location":"api/#dvz_volume_texture","title":"<code>dvz_volume_texture()</code>","text":"<p>Assign a 3D texture to a volume visual.</p> <pre><code>void dvz_volume_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_volume_transfer","title":"<code>dvz_volume_transfer()</code>","text":"<p>Set the volume size.</p> <pre><code>void dvz_volume_transfer(\n    DvzVisual* visual,  // the visual\n    vec4 transfer,  // transfer function, for now `vec4(x, 0, 0, 0)` where x is a scaling factor\n)\n</code></pre>"},{"location":"api/#dvz_app","title":"<code>dvz_app()</code>","text":"<p>Create an app.</p> <pre><code>DvzApp* dvz_app(  // returns: the app\n    int flags,  // the app creation flags\n)\n</code></pre>"},{"location":"api/#dvz_app_batch","title":"<code>dvz_app_batch()</code>","text":"<p>Return the app batch.</p> <pre><code>DvzBatch* dvz_app_batch(  // returns: the batch\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_destroy","title":"<code>dvz_app_destroy()</code>","text":"<p>Destroy the app.</p> <pre><code>void dvz_app_destroy(\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_frame","title":"<code>dvz_app_frame()</code>","text":"<p>Run one frame.</p> <pre><code>void dvz_app_frame(\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_gui","title":"<code>dvz_app_gui()</code>","text":"<p>Register a GUI callback.</p> <pre><code>void dvz_app_gui(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas ID\n    DvzAppGuiCallback callback,  // the GUI callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onframe","title":"<code>dvz_app_onframe()</code>","text":"<p>Register a frame callback.</p> <pre><code>void dvz_app_onframe(\n    DvzApp* app,  // the app\n    DvzAppFrameCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onkeyboard","title":"<code>dvz_app_onkeyboard()</code>","text":"<p>Register a keyboard callback.</p> <pre><code>void dvz_app_onkeyboard(\n    DvzApp* app,  // the app\n    DvzAppKeyboardCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onmouse","title":"<code>dvz_app_onmouse()</code>","text":"<p>Register a mouse callback.</p> <pre><code>void dvz_app_onmouse(\n    DvzApp* app,  // the app\n    DvzAppMouseCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onresize","title":"<code>dvz_app_onresize()</code>","text":"<p>Register a resize callback.</p> <pre><code>void dvz_app_onresize(\n    DvzApp* app,  // the app\n    DvzAppResizeCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_ontimer","title":"<code>dvz_app_ontimer()</code>","text":"<p>Register a timer callback.</p> <pre><code>void dvz_app_ontimer(\n    DvzApp* app,  // the app\n    DvzAppTimerCallback callback,  // the timer callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_run","title":"<code>dvz_app_run()</code>","text":"<p>Start the application event loop.</p> <pre><code>void dvz_app_run(\n    DvzApp* app,  // the app\n    uint64_t n_frames,  // the maximum number of frames, 0 for infinite loop\n)\n</code></pre>"},{"location":"api/#dvz_app_screenshot","title":"<code>dvz_app_screenshot()</code>","text":"<p>Make a screenshot of a canvas.</p> <pre><code>void dvz_app_screenshot(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the ID of the canvas\n    char* filename,  // the path to the PNG file with the screenshot\n)\n</code></pre>"},{"location":"api/#dvz_app_submit","title":"<code>dvz_app_submit()</code>","text":"<p>Submit the current batch to the application.</p> <pre><code>void dvz_app_submit(\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_timer","title":"<code>dvz_app_timer()</code>","text":"<p>Create a timer.</p> <pre><code>DvzTimerItem* dvz_app_timer(  // returns: the timer\n    DvzApp* app,  // the app\n    double delay,  // the delay, in seconds, until the first event\n    double period,  // the period, in seconds, between two events\n    uint64_t max_count,  // the maximum number of events\n)\n</code></pre>"},{"location":"api/#dvz_free","title":"<code>dvz_free()</code>","text":"<p>Free a pointer.</p> <pre><code>void dvz_free(\n    void* pointer,  // a pointer\n)\n</code></pre>"},{"location":"api/#dvz_earcut","title":"<code>dvz_earcut()</code>","text":"<p>Compute a polygon triangulation with only indexing on the polygon contour vertices.</p> <pre><code>DvzIndex* dvz_earcut(  // returns: the computed indices (must be FREED by the caller)\n    uint32_t point_count,  // the number of points\n    dvec2* polygon,  // the polygon 2D positions\n)\n</code></pre>"},{"location":"api/#dvz_mean","title":"<code>dvz_mean()</code>","text":"<p>Compute the mean of an array of double values.</p> <pre><code>double dvz_mean(  // returns: the mean\n    uint32_t n,  // the number of values\n    double* values,  // an array of double numbers\n)\n</code></pre>"},{"location":"api/#dvz_min_max","title":"<code>dvz_min_max()</code>","text":"<p>Compute the min and max of an array of float values.</p> <pre><code>void dvz_min_max(  // returns: the mean\n    uint32_t n,  // the number of values\n    float* values,  // an array of float numbers\n    vec2 out_min_max,  // the min and max\n)\n</code></pre>"},{"location":"api/#dvz_mock_band","title":"<code>dvz_mock_band()</code>","text":"<p>Generate points on a band.</p> <pre><code>vec3* dvz_mock_band(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    vec2 size,  // the size of the band\n)\n</code></pre>"},{"location":"api/#dvz_mock_circle","title":"<code>dvz_mock_circle()</code>","text":"<p>Generate points on a circle.</p> <pre><code>vec3* dvz_mock_circle(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    float radius,  // the radius of the circle\n)\n</code></pre>"},{"location":"api/#dvz_mock_cmap","title":"<code>dvz_mock_cmap()</code>","text":"<p>Generate a set of HSV colors.</p> <pre><code>DvzColor* dvz_mock_cmap(  // returns: colors\n    uint32_t count,  // the number of colors to generate\n    DvzAlpha alpha,  // the alpha value\n)\n</code></pre>"},{"location":"api/#dvz_mock_color","title":"<code>dvz_mock_color()</code>","text":"<p>Generate a set of random colors.</p> <pre><code>DvzColor* dvz_mock_color(  // returns: random colors\n    uint32_t count,  // the number of colors to generate\n    DvzAlpha alpha,  // the alpha value\n)\n</code></pre>"},{"location":"api/#dvz_mock_fixed","title":"<code>dvz_mock_fixed()</code>","text":"<p>Generate identical 3D positions.</p> <pre><code>vec3* dvz_mock_fixed(  // returns: the repeated positions\n    uint32_t count,  // the number of positions to generate\n    vec3 fixed,  // the position\n)\n</code></pre>"},{"location":"api/#dvz_mock_full","title":"<code>dvz_mock_full()</code>","text":"<p>Generate an array with the same value.</p> <pre><code>float* dvz_mock_full(  // returns: the values\n    uint32_t count,  // the number of scalars to generate\n    float value,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_mock_line","title":"<code>dvz_mock_line()</code>","text":"<p>Generate 3D positions on a line.</p> <pre><code>vec3* dvz_mock_line(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    vec3 p0,  // initial position\n    vec3 p1,  // terminal position\n)\n</code></pre>"},{"location":"api/#dvz_mock_linspace","title":"<code>dvz_mock_linspace()</code>","text":"<p>Generate an array ranging from an initial value to a final value.</p> <pre><code>float* dvz_mock_linspace(  // returns: the values\n    uint32_t count,  // the number of scalars to generate\n    float initial,  // the initial value\n    float final,  // the final value\n)\n</code></pre>"},{"location":"api/#dvz_mock_monochrome","title":"<code>dvz_mock_monochrome()</code>","text":"<p>Repeat a color in an array.</p> <pre><code>DvzColor* dvz_mock_monochrome(  // returns: colors\n    uint32_t count,  // the number of colors to generate\n    DvzColor mono,  // the color to repeat\n)\n</code></pre>"},{"location":"api/#dvz_mock_pos2d","title":"<code>dvz_mock_pos2D()</code>","text":"<p>Generate a set of random 2D positions.</p> <pre><code>vec3* dvz_mock_pos2D(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    float std,  // the standard deviation\n)\n</code></pre>"},{"location":"api/#dvz_mock_pos3d","title":"<code>dvz_mock_pos3D()</code>","text":"<p>Generate a set of random 3D positions.</p> <pre><code>vec3* dvz_mock_pos3D(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    float std,  // the standard deviation\n)\n</code></pre>"},{"location":"api/#dvz_mock_range","title":"<code>dvz_mock_range()</code>","text":"<p>Generate an array of consecutive positive numbers.</p> <pre><code>uint32_t* dvz_mock_range(  // returns: the values\n    uint32_t count,  // the number of consecutive integers to generate\n    uint32_t initial,  // the initial value\n)\n</code></pre>"},{"location":"api/#dvz_mock_uniform","title":"<code>dvz_mock_uniform()</code>","text":"<p>Generate a set of uniformly random scalar values.</p> <pre><code>float* dvz_mock_uniform(  // returns: the values\n    uint32_t count,  // the number of values to generate\n    float vmin,  // the minimum value of the interval\n    float vmax,  // the maximum value of the interval\n)\n</code></pre>"},{"location":"api/#dvz_next_pow2","title":"<code>dvz_next_pow2()</code>","text":"<p>Return the smallest power of 2 larger or equal than a positive integer.</p> <pre><code>uint64_t dvz_next_pow2(  // returns: the power of 2\n    uint64_t x,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_normalize_bytes","title":"<code>dvz_normalize_bytes()</code>","text":"<p>Normalize the array.</p> <pre><code>uint8_t* dvz_normalize_bytes(  // returns: the normalized array\n    uint32_t count,  // the number of values\n    float* values,  // an array of float numbers\n)\n</code></pre>"},{"location":"api/#dvz_num_procs","title":"<code>dvz_num_procs()</code>","text":"<p>Return the number of processors on the current system.</p> <pre><code>int dvz_num_procs(  // returns: the number of processors\n\n)\n</code></pre>"},{"location":"api/#dvz_num_threads","title":"<code>dvz_num_threads()</code>","text":"<p>Set the number of threads to use in OpenMP-aware functions.</p> <pre><code>void dvz_num_threads(\n    int num_threads,  // the requested number of threads\n)\n</code></pre>"},{"location":"api/#dvz_rand_byte","title":"<code>dvz_rand_byte()</code>","text":"<p>Return a random integer number between 0 and 255.</p> <pre><code>uint8_t dvz_rand_byte(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_double","title":"<code>dvz_rand_double()</code>","text":"<p>Return a random floating-point number between 0 and 1.</p> <pre><code>double dvz_rand_double(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_float","title":"<code>dvz_rand_float()</code>","text":"<p>Return a random floating-point number between 0 and 1.</p> <pre><code>float dvz_rand_float(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_int","title":"<code>dvz_rand_int()</code>","text":"<p>Return a random integer number.</p> <pre><code>int dvz_rand_int(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_normal","title":"<code>dvz_rand_normal()</code>","text":"<p>Return a random normal floating-point number.</p> <pre><code>double dvz_rand_normal(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_range","title":"<code>dvz_range()</code>","text":"<p>Compute the range of an array of double values.</p> <pre><code>void dvz_range(\n    uint32_t n,  // the number of values\n    double* values,  // an array of double numbers\n)\n</code></pre>"},{"location":"api/#datoviz-rendering-protocol-functions","title":"Datoviz Rendering Protocol functions","text":""},{"location":"api/#dvz_batch","title":"<code>dvz_batch()</code>","text":"<p>Create a batch holding a number of requests.</p> <pre><code>DvzBatch* dvz_batch(\n\n)\n</code></pre>"},{"location":"api/#dvz_batch_add","title":"<code>dvz_batch_add()</code>","text":"<p>Add a request to a batch.</p> <pre><code>void dvz_batch_add(\n    DvzBatch* batch,  // the batch\n    DvzRequest req,  // the request\n)\n</code></pre>"},{"location":"api/#dvz_batch_clear","title":"<code>dvz_batch_clear()</code>","text":"<p>Remove all requests in a batch.</p> <pre><code>void dvz_batch_clear(\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_batch_copy","title":"<code>dvz_batch_copy()</code>","text":"<p>Create a copy of a batch.</p> <pre><code>DvzBatch* dvz_batch_copy(\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_batch_desc","title":"<code>dvz_batch_desc()</code>","text":"<p>Set the description of the last added request.</p> <pre><code>void dvz_batch_desc(\n    DvzBatch* batch,  // the batch\n    char* desc,  // the description\n)\n</code></pre>"},{"location":"api/#dvz_batch_destroy","title":"<code>dvz_batch_destroy()</code>","text":"<p>Destroy a batch.</p> <pre><code>void dvz_batch_destroy(\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_batch_dump","title":"<code>dvz_batch_dump()</code>","text":"<p>Dump all batch requests in raw binary file.</p> <pre><code>int dvz_batch_dump(\n    DvzBatch* batch,  // the batch\n    char* filename,  // the dump filename\n)\n</code></pre>"},{"location":"api/#dvz_batch_load","title":"<code>dvz_batch_load()</code>","text":"<p>Load a dump of batch requests into an existing batch object.</p> <pre><code>void dvz_batch_load(\n    DvzBatch* batch,  // the batch\n    char* filename,  // the dump filename\n)\n</code></pre>"},{"location":"api/#dvz_batch_print","title":"<code>dvz_batch_print()</code>","text":"<p>Display information about all requests in the batch.</p> <pre><code>void dvz_batch_print(\n    DvzBatch* batch,  // the batch\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_batch_requests","title":"<code>dvz_batch_requests()</code>","text":"<p>Return a pointer to the array of all requests in the batch.</p> <pre><code>DvzRequest* dvz_batch_requests(\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_batch_size","title":"<code>dvz_batch_size()</code>","text":"<p>Return the number of requests in the batch.</p> <pre><code>uint32_t dvz_batch_size(\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_batch_yaml","title":"<code>dvz_batch_yaml()</code>","text":"<p>Export requests in a YAML file.</p> <pre><code>void dvz_batch_yaml(\n    DvzBatch* batch,  // the batch\n    char* filename,  // the YAML filename\n)\n</code></pre>"},{"location":"api/#dvz_bind_dat","title":"<code>dvz_bind_dat()</code>","text":"<p>Create a request for associating a dat to a pipe's slot.</p> <pre><code>DvzRequest dvz_bind_dat(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId pipe,  // the id of the pipe\n    uint32_t slot_idx,  // the index of the descriptor slot\n    DvzId dat,  // the id of the dat to bind to the pipe\n    DvzSize offset,  // the offset\n)\n</code></pre>"},{"location":"api/#dvz_bind_index","title":"<code>dvz_bind_index()</code>","text":"<p>Create a request for associating an index dat to a graphics pipe.</p> <pre><code>DvzRequest dvz_bind_index(  // returns: the request\n    DvzBatch* batch,  // the batch\n     graphics,  // the id of the graphics pipe\n    DvzId dat,  // the id of the dat with the index data\n    DvzSize offset,  // the offset within the dat\n)\n</code></pre>"},{"location":"api/#dvz_bind_tex","title":"<code>dvz_bind_tex()</code>","text":"<p>Create a request for associating a tex to a pipe's slot.</p> <pre><code>DvzRequest dvz_bind_tex(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId pipe,  // the id of the pipe\n    uint32_t slot_idx,  // the index of the descriptor slot\n    DvzId tex,  // the id of the tex to bind to the pipe\n    DvzId tex,  // the id of the sampler\n    uvec3 offset,  // the offset\n)\n</code></pre>"},{"location":"api/#dvz_bind_vertex","title":"<code>dvz_bind_vertex()</code>","text":"<p>Create a request for associating a vertex dat to a graphics pipe.</p> <pre><code>DvzRequest dvz_bind_vertex(  // returns: the request\n    DvzBatch* batch,  // the batch\n     graphics,  // the id of the graphics pipe\n    DvzId dat,  // the id of the dat with the vertex data\n    DvzSize offset,  // the offset within the dat\n)\n</code></pre>"},{"location":"api/#dvz_create_board","title":"<code>dvz_create_board()</code>","text":"<p>Create a request for board creation.</p> <pre><code>DvzRequest dvz_create_board(  // returns: the request, containing a newly-generated id for the board to be created\n    DvzBatch* batch,  // the batch\n    uint32_t width,  // the board width\n    uint32_t height,  // the board height\n    cvec4 background,  // the background color\n    int flags,  // the board creation flags\n)\n</code></pre>"},{"location":"api/#dvz_create_canvas","title":"<code>dvz_create_canvas()</code>","text":"<p>Create a request for canvas creation.</p> <pre><code>DvzRequest dvz_create_canvas(  // returns: the request, containing a newly-generated id for the canvas to be created\n    DvzBatch* batch,  // the batch\n    uint32_t width,  // the canvas width (in screen pixels)\n    uint32_t height,  // the canvas height (in screen pixels)\n    cvec4 background,  // the background color\n    int flags,  // the canvas creation flags\n)\n</code></pre>"},{"location":"api/#dvz_create_dat","title":"<code>dvz_create_dat()</code>","text":"<p>Create a request for a dat creation.</p> <pre><code>DvzRequest dvz_create_dat(  // returns: the request, containing a newly-generated id for the dat to be created\n    DvzBatch* batch,  // the batch\n    DvzBufferType type,  // the buffer type\n    DvzSize size,  // the dat size, in bytes\n    int flags,  // the dat creation flags\n)\n</code></pre>"},{"location":"api/#dvz_create_glsl","title":"<code>dvz_create_glsl()</code>","text":"<p>Create a request for GLSL shader creation.</p> <pre><code>DvzRequest dvz_create_glsl(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzShaderType shader_type,  // the shader type\n    char* code,  // an ASCII string with the GLSL code\n)\n</code></pre>"},{"location":"api/#dvz_create_graphics","title":"<code>dvz_create_graphics()</code>","text":"<p>Create a request for a builtin graphics pipe creation.</p> <pre><code>DvzRequest dvz_create_graphics(  // returns: the request, containing a newly-generated id for the graphics pipe to be created\n    DvzBatch* batch,  // the batch\n     parent,  // either the parent board or canvas id\n    DvzGraphicsType type,  // the graphics type\n    int flags,  // the graphics creation flags\n)\n</code></pre>"},{"location":"api/#dvz_create_sampler","title":"<code>dvz_create_sampler()</code>","text":"<p>Create a request for a sampler creation.</p> <pre><code>DvzRequest dvz_create_sampler(  // returns: the request, containing a newly-generated id for the sampler to be created\n    DvzBatch* batch,  // the batch\n    DvzFilter filter,  // the sampler filter\n    DvzSamplerAddressMode mode,  // the sampler address mode\n)\n</code></pre>"},{"location":"api/#dvz_create_spirv","title":"<code>dvz_create_spirv()</code>","text":"<p>Create a request for SPIR-V shader creation.</p> <pre><code>DvzRequest dvz_create_spirv(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzShaderType shader_type,  // the shader type\n    DvzSize size,  // the size in bytes of the SPIR-V buffer\n    char* buffer,  // pointer to a buffer with the SPIR-V bytecode\n)\n</code></pre>"},{"location":"api/#dvz_create_tex","title":"<code>dvz_create_tex()</code>","text":"<p>Create a request for a tex creation.</p> <pre><code>DvzRequest dvz_create_tex(  // returns: the request, containing a newly-generated id for the tex to be created\n    DvzBatch* batch,  // the batch\n    DvzTexDims dims,  // the number of dimensions, 1, 2, or 3\n    DvzFormat format,  // the image format\n    uvec3 shape,  // the texture shape\n    int flags,  // the dat creation flags\n)\n</code></pre>"},{"location":"api/#dvz_delete_board","title":"<code>dvz_delete_board()</code>","text":"<p>Create a request for a board deletion.</p> <pre><code>DvzRequest dvz_delete_board(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the board id\n)\n</code></pre>"},{"location":"api/#dvz_delete_canvas","title":"<code>dvz_delete_canvas()</code>","text":"<p>Create a request for a canvas deletion.</p> <pre><code>DvzRequest dvz_delete_canvas(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the canvas id\n)\n</code></pre>"},{"location":"api/#dvz_delete_dat","title":"<code>dvz_delete_dat()</code>","text":"<p>Create a request for dat deletion.</p> <pre><code>DvzRequest dvz_delete_dat(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the dat id\n)\n</code></pre>"},{"location":"api/#dvz_delete_graphics","title":"<code>dvz_delete_graphics()</code>","text":"<p>Create a request for graphics deletion.</p> <pre><code>DvzRequest dvz_delete_graphics(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the graphics id\n)\n</code></pre>"},{"location":"api/#dvz_delete_sampler","title":"<code>dvz_delete_sampler()</code>","text":"<p>Create a request for sampler deletion.</p> <pre><code>DvzRequest dvz_delete_sampler(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the sampler id\n)\n</code></pre>"},{"location":"api/#dvz_delete_tex","title":"<code>dvz_delete_tex()</code>","text":"<p>Create a request for tex deletion.</p> <pre><code>DvzRequest dvz_delete_tex(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the tex id\n)\n</code></pre>"},{"location":"api/#dvz_record_begin","title":"<code>dvz_record_begin()</code>","text":"<p>Create a request for starting recording of command buffer.</p> <pre><code>DvzRequest dvz_record_begin(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n)\n</code></pre>"},{"location":"api/#dvz_record_draw","title":"<code>dvz_record_draw()</code>","text":"<p>Create a request for a direct draw of a graphics during command buffer recording.</p> <pre><code>DvzRequest dvz_record_draw(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n    DvzId graphics,  // the id of the graphics pipe to draw\n    uint32_t first_vertex,  // the index of the first vertex to draw\n    uint32_t vertex_count,  // the number of vertices to draw\n    uint32_t first_instance,  // the index of the first instance to draw\n    uint32_t instance_count,  // the number of instances to draw\n)\n</code></pre>"},{"location":"api/#dvz_record_draw_indexed","title":"<code>dvz_record_draw_indexed()</code>","text":"<p>Create a request for an indexed draw of a graphics during command buffer recording.</p> <pre><code>DvzRequest dvz_record_draw_indexed(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n    DvzId graphics,  // the id of the graphics pipe to draw\n    uint32_t first_index,  // the index of the first index to draw\n    uint32_t vertex_offset,  // the vertex offset within the vertices indexed by the indexes\n    uint32_t index_count,  // the number of indexes to draw\n    uint32_t first_instance,  // the index of the first instance to draw\n    uint32_t instance_count,  // the number of instances to draw\n)\n</code></pre>"},{"location":"api/#dvz_record_draw_indexed_indirect","title":"<code>dvz_record_draw_indexed_indirect()</code>","text":"<p>Create a request for an indexed indirect draw of a graphics during command buffer recording.</p> <pre><code>DvzRequest dvz_record_draw_indexed_indirect(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n    DvzId graphics,  // the id of the graphics pipe to draw\n    DvzId indirect,  // the id of the dat containing the indirect draw data\n    uint32_t draw_count,  // the number of draws to make\n)\n</code></pre>"},{"location":"api/#dvz_record_draw_indirect","title":"<code>dvz_record_draw_indirect()</code>","text":"<p>Create a request for an indirect draw of a graphics during command buffer recording.</p> <pre><code>DvzRequest dvz_record_draw_indirect(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n    DvzId graphics,  // the id of the graphics pipe to draw\n    DvzId indirect,  // the id of the dat containing the indirect draw data\n    uint32_t draw_count,  // the number of draws to make\n)\n</code></pre>"},{"location":"api/#dvz_record_end","title":"<code>dvz_record_end()</code>","text":"<p>Create a request for ending recording of command buffer.</p> <pre><code>DvzRequest dvz_record_end(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n)\n</code></pre>"},{"location":"api/#dvz_record_viewport","title":"<code>dvz_record_viewport()</code>","text":"<p>Create a request for setting the viewport during command buffer recording.</p> <pre><code>DvzRequest dvz_record_viewport(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId canvas_or_board_id,  // the id of the canvas or board\n    vec2 offset,  // the viewport offset, in framebuffer pixels\n    vec2 shape,  // the viewport size, in framebuffer pixels\n)\n</code></pre>"},{"location":"api/#dvz_request_print","title":"<code>dvz_request_print()</code>","text":"<p>Display information about a request.</p> <pre><code>void dvz_request_print(\n    DvzRequest* req,  // the request\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_requester","title":"<code>dvz_requester()</code>","text":"<p>Create a requester, used to create requests.</p> <pre><code>DvzRequester* dvz_requester(  // returns: the requester struct\n\n)\n</code></pre>"},{"location":"api/#dvz_requester_commit","title":"<code>dvz_requester_commit()</code>","text":"<p>Add a batch's requests to a requester.</p> <pre><code>void dvz_requester_commit(\n    DvzRequester* rqr,  // the requester\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_requester_destroy","title":"<code>dvz_requester_destroy()</code>","text":"<p>Destroy a requester.</p> <pre><code>void dvz_requester_destroy(\n    DvzRequester* rqr,  // the requester\n)\n</code></pre>"},{"location":"api/#dvz_requester_flush","title":"<code>dvz_requester_flush()</code>","text":"<p>Return the requests in the requester and clear it.</p> <pre><code>DvzBatch* dvz_requester_flush(  // returns: an array with all requests in the requester\n    DvzRequester* rqr,  // the requester\n)\n</code></pre>"},{"location":"api/#dvz_resize_board","title":"<code>dvz_resize_board()</code>","text":"<p>Create a request to resize a board.</p> <pre><code>DvzRequest dvz_resize_board(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId board,  // the board id\n    uint32_t width,  // the new board width\n    uint32_t height,  // the new board height\n)\n</code></pre>"},{"location":"api/#dvz_resize_dat","title":"<code>dvz_resize_dat()</code>","text":"<p>Create a request to resize a dat.</p> <pre><code>DvzRequest dvz_resize_dat(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId dat,  // the dat id\n    DvzSize size,  // the new dat size, in bytes\n)\n</code></pre>"},{"location":"api/#dvz_resize_tex","title":"<code>dvz_resize_tex()</code>","text":"<p>Create a request to resize a tex.</p> <pre><code>DvzRequest dvz_resize_tex(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId tex,  // the tex id\n    uvec3 shape,  // the new tex shape\n)\n</code></pre>"},{"location":"api/#dvz_set_attr","title":"<code>dvz_set_attr()</code>","text":"<p>Create a request for setting a vertex attribute of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_attr(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    uint32_t binding_idx,  // the index of the vertex binding\n    uint32_t location,  // the GLSL attribute location\n    DvzFormat format,  // the attribute format\n    DvzSize offset,  // the byte offset of the attribute within the vertex binding\n)\n</code></pre>"},{"location":"api/#dvz_set_background","title":"<code>dvz_set_background()</code>","text":"<p>Change the background color of the board.</p> <pre><code>DvzRequest dvz_set_background(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the board id\n    cvec4 background,  // the background color\n)\n</code></pre>"},{"location":"api/#dvz_set_blend","title":"<code>dvz_set_blend()</code>","text":"<p>Create a request for setting the blend type of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_blend(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzBlendType blend_type,  // the graphics blend type\n)\n</code></pre>"},{"location":"api/#dvz_set_cull","title":"<code>dvz_set_cull()</code>","text":"<p>Create a request for setting the cull mode of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_cull(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzCullMode cull_mode,  // the cull mode\n)\n</code></pre>"},{"location":"api/#dvz_set_depth","title":"<code>dvz_set_depth()</code>","text":"<p>Create a request for setting the depth test of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_depth(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzDepthTest depth_test,  // the graphics depth test\n)\n</code></pre>"},{"location":"api/#dvz_set_front","title":"<code>dvz_set_front()</code>","text":"<p>Create a request for setting the front face of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_front(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzFrontFace front_face,  // the front face\n)\n</code></pre>"},{"location":"api/#dvz_set_polygon","title":"<code>dvz_set_polygon()</code>","text":"<p>Create a request for setting the polygon mode of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_polygon(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzPolygonMode polygon_mode,  // the polygon mode\n)\n</code></pre>"},{"location":"api/#dvz_set_primitive","title":"<code>dvz_set_primitive()</code>","text":"<p>Create a request for setting the primitive topology of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_primitive(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzPrimitiveTopology primitive,  // the graphics primitive topology\n)\n</code></pre>"},{"location":"api/#dvz_set_shader","title":"<code>dvz_set_shader()</code>","text":"<p>Create a request for setting a shader a graphics pipe.</p> <pre><code>DvzRequest dvz_set_shader(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzId shader,  // the id of the shader object\n)\n</code></pre>"},{"location":"api/#dvz_set_slot","title":"<code>dvz_set_slot()</code>","text":"<p>Create a request for setting a binding slot (descriptor) of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_slot(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    uint32_t slot_idx,  // the index of the GLSL binding slot\n    DvzDescriptorType type,  // the descriptor type\n)\n</code></pre>"},{"location":"api/#dvz_set_specialization","title":"<code>dvz_set_specialization()</code>","text":"<p>Create a request for setting a specialization constant of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_specialization(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    DvzShaderType shader,  // the shader with the specialization constant\n    uint32_t idx,  // the specialization constant index as specified in the GLSL code\n    DvzSize size,  // the byte size of the value\n    void* value,  // a pointer to the specialization constant value\n)\n</code></pre>"},{"location":"api/#dvz_set_vertex","title":"<code>dvz_set_vertex()</code>","text":"<p>Create a request for setting a vertex binding of a graphics pipe.</p> <pre><code>DvzRequest dvz_set_vertex(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId graphics,  // the graphics pipe id\n    uint32_t binding_idx,  // the index of the vertex binding\n    DvzSize stride,  // the binding stride\n)\n</code></pre>"},{"location":"api/#dvz_update_board","title":"<code>dvz_update_board()</code>","text":"<p>Create a request for a board redraw (command buffer submission).</p> <pre><code>DvzRequest dvz_update_board(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId id,  // the board id\n)\n</code></pre>"},{"location":"api/#dvz_upload_dat","title":"<code>dvz_upload_dat()</code>","text":"<p>Create a request for dat upload.</p> <pre><code>DvzRequest dvz_upload_dat(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId dat,  // the id of the dat to upload to\n    DvzSize offset,  // the byte offset of the upload transfer\n    DvzSize size,  // the number of bytes in data to transfer\n    void* data,  // a pointer to the data to upload\n)\n</code></pre>"},{"location":"api/#dvz_upload_tex","title":"<code>dvz_upload_tex()</code>","text":"<p>Create a request for tex upload.</p> <pre><code>DvzRequest dvz_upload_tex(  // returns: the request\n    DvzBatch* batch,  // the batch\n    DvzId tex,  // the id of the tex to upload to\n    uvec3 offset,  // the offset\n    uvec3 shape,  // the shape\n    DvzSize size,  // the number of bytes in data to transfer\n    void* data,  // a pointer to the data to upload\n)\n</code></pre>"},{"location":"api/#enumerations","title":"Enumerations","text":""},{"location":"api/#dvzappflags","title":"<code>DvzAppFlags</code>","text":"<pre><code>DVZ_APP_FLAGS_NONE\nDVZ_APP_FLAGS_OFFSCREEN\nDVZ_APP_FLAGS_WHITE_BACKGROUND\n</code></pre>"},{"location":"api/#dvzarcballflags","title":"<code>DvzArcballFlags</code>","text":"<pre><code>DVZ_ARCBALL_FLAGS_NONE\nDVZ_ARCBALL_FLAGS_CONSTRAIN\n</code></pre>"},{"location":"api/#dvzblendtype","title":"<code>DvzBlendType</code>","text":"<pre><code>DVZ_BLEND_DISABLE\nDVZ_BLEND_STANDARD\nDVZ_BLEND_OIT\n</code></pre>"},{"location":"api/#dvzboxextentstrategy","title":"<code>DvzBoxExtentStrategy</code>","text":"<pre><code>DVZ_BOX_EXTENT_DEFAULT\nDVZ_BOX_EXTENT_FIXED_ASPECT_EXPAND\nDVZ_BOX_EXTENT_FIXED_ASPECT_CONTRACT\n</code></pre>"},{"location":"api/#dvzboxmergestrategy","title":"<code>DvzBoxMergeStrategy</code>","text":"<pre><code>DVZ_BOX_MERGE_DEFAULT\nDVZ_BOX_MERGE_CENTER\nDVZ_BOX_MERGE_CORNER\n</code></pre>"},{"location":"api/#dvzbuffertype","title":"<code>DvzBufferType</code>","text":"<pre><code>DVZ_BUFFER_TYPE_UNDEFINED\nDVZ_BUFFER_TYPE_STAGING\nDVZ_BUFFER_TYPE_VERTEX\nDVZ_BUFFER_TYPE_INDEX\nDVZ_BUFFER_TYPE_STORAGE\nDVZ_BUFFER_TYPE_UNIFORM\nDVZ_BUFFER_TYPE_INDIRECT\n</code></pre>"},{"location":"api/#dvzcameraflags","title":"<code>DvzCameraFlags</code>","text":"<pre><code>DVZ_CAMERA_FLAGS_PERSPECTIVE\nDVZ_CAMERA_FLAGS_ORTHO\n</code></pre>"},{"location":"api/#dvzcanvasflags","title":"<code>DvzCanvasFlags</code>","text":"<pre><code>DVZ_CANVAS_FLAGS_NONE\nDVZ_CANVAS_FLAGS_IMGUI\nDVZ_CANVAS_FLAGS_FPS\nDVZ_CANVAS_FLAGS_MONITOR\nDVZ_CANVAS_FLAGS_VSYNC\nDVZ_CANVAS_FLAGS_PICK\n</code></pre>"},{"location":"api/#dvzcaptype","title":"<code>DvzCapType</code>","text":"<pre><code>DVZ_CAP_NONE\nDVZ_CAP_ROUND\nDVZ_CAP_TRIANGLE_IN\nDVZ_CAP_TRIANGLE_OUT\nDVZ_CAP_SQUARE\nDVZ_CAP_BUTT\nDVZ_CAP_COUNT\n</code></pre>"},{"location":"api/#dvzcolormap","title":"<code>DvzColormap</code>","text":"<pre><code>DVZ_CMAP_BINARY\nDVZ_CMAP_HSV\nDVZ_CMAP_CIVIDIS\nDVZ_CMAP_INFERNO\nDVZ_CMAP_MAGMA\nDVZ_CMAP_PLASMA\nDVZ_CMAP_VIRIDIS\nDVZ_CMAP_BLUES\nDVZ_CMAP_BUGN\nDVZ_CMAP_BUPU\nDVZ_CMAP_GNBU\nDVZ_CMAP_GREENS\nDVZ_CMAP_GREYS\nDVZ_CMAP_ORANGES\nDVZ_CMAP_ORRD\nDVZ_CMAP_PUBU\nDVZ_CMAP_PUBUGN\nDVZ_CMAP_PURPLES\nDVZ_CMAP_RDPU\nDVZ_CMAP_REDS\nDVZ_CMAP_YLGN\nDVZ_CMAP_YLGNBU\nDVZ_CMAP_YLORBR\nDVZ_CMAP_YLORRD\nDVZ_CMAP_AFMHOT\nDVZ_CMAP_AUTUMN\nDVZ_CMAP_BONE\nDVZ_CMAP_COOL\nDVZ_CMAP_COPPER\nDVZ_CMAP_GIST_HEAT\nDVZ_CMAP_GRAY\nDVZ_CMAP_HOT\nDVZ_CMAP_PINK\nDVZ_CMAP_SPRING\nDVZ_CMAP_SUMMER\nDVZ_CMAP_WINTER\nDVZ_CMAP_WISTIA\nDVZ_CMAP_BRBG\nDVZ_CMAP_BWR\nDVZ_CMAP_COOLWARM\nDVZ_CMAP_PIYG\nDVZ_CMAP_PRGN\nDVZ_CMAP_PUOR\nDVZ_CMAP_RDBU\nDVZ_CMAP_RDGY\nDVZ_CMAP_RDYLBU\nDVZ_CMAP_RDYLGN\nDVZ_CMAP_SEISMIC\nDVZ_CMAP_SPECTRAL\nDVZ_CMAP_TWILIGHT_SHIFTED\nDVZ_CMAP_TWILIGHT\nDVZ_CMAP_BRG\nDVZ_CMAP_CMRMAP\nDVZ_CMAP_CUBEHELIX\nDVZ_CMAP_FLAG\nDVZ_CMAP_GIST_EARTH\nDVZ_CMAP_GIST_NCAR\nDVZ_CMAP_GIST_RAINBOW\nDVZ_CMAP_GIST_STERN\nDVZ_CMAP_GNUPLOT2\nDVZ_CMAP_GNUPLOT\nDVZ_CMAP_JET\nDVZ_CMAP_NIPY_SPECTRAL\nDVZ_CMAP_OCEAN\nDVZ_CMAP_PRISM\nDVZ_CMAP_RAINBOW\nDVZ_CMAP_TERRAIN\nDVZ_CMAP_BKR\nDVZ_CMAP_BKY\nDVZ_CMAP_CET_D10\nDVZ_CMAP_CET_D11\nDVZ_CMAP_CET_D8\nDVZ_CMAP_CET_D13\nDVZ_CMAP_CET_D3\nDVZ_CMAP_CET_D1A\nDVZ_CMAP_BJY\nDVZ_CMAP_GWV\nDVZ_CMAP_BWY\nDVZ_CMAP_CET_D12\nDVZ_CMAP_CET_R3\nDVZ_CMAP_CET_D9\nDVZ_CMAP_CWR\nDVZ_CMAP_CET_CBC1\nDVZ_CMAP_CET_CBC2\nDVZ_CMAP_CET_CBL1\nDVZ_CMAP_CET_CBL2\nDVZ_CMAP_CET_CBTC1\nDVZ_CMAP_CET_CBTC2\nDVZ_CMAP_CET_CBTL1\nDVZ_CMAP_BGY\nDVZ_CMAP_BGYW\nDVZ_CMAP_BMW\nDVZ_CMAP_CET_C1\nDVZ_CMAP_CET_C1S\nDVZ_CMAP_CET_C2\nDVZ_CMAP_CET_C4\nDVZ_CMAP_CET_C4S\nDVZ_CMAP_CET_C5\nDVZ_CMAP_CET_I1\nDVZ_CMAP_CET_I3\nDVZ_CMAP_CET_L10\nDVZ_CMAP_CET_L11\nDVZ_CMAP_CET_L12\nDVZ_CMAP_CET_L16\nDVZ_CMAP_CET_L17\nDVZ_CMAP_CET_L18\nDVZ_CMAP_CET_L19\nDVZ_CMAP_CET_L4\nDVZ_CMAP_CET_L7\nDVZ_CMAP_CET_L8\nDVZ_CMAP_CET_L9\nDVZ_CMAP_CET_R1\nDVZ_CMAP_CET_R2\nDVZ_CMAP_COLORWHEEL\nDVZ_CMAP_FIRE\nDVZ_CMAP_ISOLUM\nDVZ_CMAP_KB\nDVZ_CMAP_KBC\nDVZ_CMAP_KG\nDVZ_CMAP_KGY\nDVZ_CMAP_KR\nDVZ_CMAP_BLACK_BODY\nDVZ_CMAP_KINDLMANN\nDVZ_CMAP_EXTENDED_KINDLMANN\nDVZ_CPAL256_GLASBEY\nDVZ_CPAL256_GLASBEY_COOL\nDVZ_CPAL256_GLASBEY_DARK\nDVZ_CPAL256_GLASBEY_HV\nDVZ_CPAL256_GLASBEY_LIGHT\nDVZ_CPAL256_GLASBEY_WARM\nDVZ_CPAL032_ACCENT\nDVZ_CPAL032_DARK2\nDVZ_CPAL032_PAIRED\nDVZ_CPAL032_PASTEL1\nDVZ_CPAL032_PASTEL2\nDVZ_CPAL032_SET1\nDVZ_CPAL032_SET2\nDVZ_CPAL032_SET3\nDVZ_CPAL032_TAB10\nDVZ_CPAL032_TAB20\nDVZ_CPAL032_TAB20B\nDVZ_CPAL032_TAB20C\nDVZ_CPAL032_CATEGORY10_10\nDVZ_CPAL032_CATEGORY20_20\nDVZ_CPAL032_CATEGORY20B_20\nDVZ_CPAL032_CATEGORY20C_20\nDVZ_CPAL032_COLORBLIND8\n</code></pre>"},{"location":"api/#dvzcontourflags","title":"<code>DvzContourFlags</code>","text":"<pre><code>DVZ_CONTOUR_NONE\nDVZ_CONTOUR_EDGES\nDVZ_CONTOUR_JOINTS\nDVZ_CONTOUR_FULL\n</code></pre>"},{"location":"api/#dvzcorner","title":"<code>DvzCorner</code>","text":"<pre><code>DVZ_DIALOG_CORNER_TOP_LEFT\nDVZ_DIALOG_CORNER_TOP_RIGHT\nDVZ_DIALOG_CORNER_BOTTOM_LEFT\nDVZ_DIALOG_CORNER_BOTTOM_RIGHT\n</code></pre>"},{"location":"api/#dvzcullmode","title":"<code>DvzCullMode</code>","text":"<pre><code>DVZ_CULL_MODE_NONE\nDVZ_CULL_MODE_FRONT\nDVZ_CULL_MODE_BACK\n</code></pre>"},{"location":"api/#dvzdatflags","title":"<code>DvzDatFlags</code>","text":"<pre><code>DVZ_DAT_FLAGS_NONE\nDVZ_DAT_FLAGS_STANDALONE\nDVZ_DAT_FLAGS_MAPPABLE\nDVZ_DAT_FLAGS_DUP\nDVZ_DAT_FLAGS_KEEP_ON_RESIZE\nDVZ_DAT_FLAGS_PERSISTENT_STAGING\n</code></pre>"},{"location":"api/#dvzdepthtest","title":"<code>DvzDepthTest</code>","text":"<pre><code>DVZ_DEPTH_TEST_DISABLE\nDVZ_DEPTH_TEST_ENABLE\n</code></pre>"},{"location":"api/#dvzdescriptortype","title":"<code>DvzDescriptorType</code>","text":"<pre><code>DVZ_DESCRIPTOR_TYPE_SAMPLER\nDVZ_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\nDVZ_DESCRIPTOR_TYPE_SAMPLED_IMAGE\nDVZ_DESCRIPTOR_TYPE_STORAGE_IMAGE\nDVZ_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER\nDVZ_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER\nDVZ_DESCRIPTOR_TYPE_UNIFORM_BUFFER\nDVZ_DESCRIPTOR_TYPE_STORAGE_BUFFER\nDVZ_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC\nDVZ_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\n</code></pre>"},{"location":"api/#dvzdialogflags","title":"<code>DvzDialogFlags</code>","text":"<pre><code>DVZ_DIALOG_FLAGS_NONE\nDVZ_DIALOG_FLAGS_OVERLAY\n</code></pre>"},{"location":"api/#dvzeasing","title":"<code>DvzEasing</code>","text":"<pre><code>DVZ_EASING_NONE\nDVZ_EASING_IN_SINE\nDVZ_EASING_OUT_SINE\nDVZ_EASING_IN_OUT_SINE\nDVZ_EASING_IN_QUAD\nDVZ_EASING_OUT_QUAD\nDVZ_EASING_IN_OUT_QUAD\nDVZ_EASING_IN_CUBIC\nDVZ_EASING_OUT_CUBIC\nDVZ_EASING_IN_OUT_CUBIC\nDVZ_EASING_IN_QUART\nDVZ_EASING_OUT_QUART\nDVZ_EASING_IN_OUT_QUART\nDVZ_EASING_IN_QUINT\nDVZ_EASING_OUT_QUINT\nDVZ_EASING_IN_OUT_QUINT\nDVZ_EASING_IN_EXPO\nDVZ_EASING_OUT_EXPO\nDVZ_EASING_IN_OUT_EXPO\nDVZ_EASING_IN_CIRC\nDVZ_EASING_OUT_CIRC\nDVZ_EASING_IN_OUT_CIRC\nDVZ_EASING_IN_BACK\nDVZ_EASING_OUT_BACK\nDVZ_EASING_IN_OUT_BACK\nDVZ_EASING_IN_ELASTIC\nDVZ_EASING_OUT_ELASTIC\nDVZ_EASING_IN_OUT_ELASTIC\nDVZ_EASING_IN_BOUNCE\nDVZ_EASING_OUT_BOUNCE\nDVZ_EASING_IN_OUT_BOUNCE\nDVZ_EASING_COUNT\n</code></pre>"},{"location":"api/#dvzfilter","title":"<code>DvzFilter</code>","text":"<pre><code>DVZ_FILTER_NEAREST\nDVZ_FILTER_LINEAR\nDVZ_FILTER_CUBIC_IMG\n</code></pre>"},{"location":"api/#dvzfontflags","title":"<code>DvzFontFlags</code>","text":"<pre><code>DVZ_FONT_FLAGS_RGB\nDVZ_FONT_FLAGS_RGBA\n</code></pre>"},{"location":"api/#dvzformat","title":"<code>DvzFormat</code>","text":"<pre><code>DVZ_FORMAT_NONE\nDVZ_FORMAT_R8_UNORM\nDVZ_FORMAT_R8_SNORM\nDVZ_FORMAT_R8_UINT\nDVZ_FORMAT_R8_SINT\nDVZ_FORMAT_R8G8_UNORM\nDVZ_FORMAT_R8G8_SNORM\nDVZ_FORMAT_R8G8_UINT\nDVZ_FORMAT_R8G8_SINT\nDVZ_FORMAT_R8G8B8_UNORM\nDVZ_FORMAT_R8G8B8_SNORM\nDVZ_FORMAT_R8G8B8_UINT\nDVZ_FORMAT_R8G8B8_SINT\nDVZ_FORMAT_R8G8B8A8_UNORM\nDVZ_FORMAT_R8G8B8A8_SNORM\nDVZ_FORMAT_R8G8B8A8_UINT\nDVZ_FORMAT_R8G8B8A8_SINT\nDVZ_FORMAT_B8G8R8A8_UNORM\nDVZ_FORMAT_R16_UNORM\nDVZ_FORMAT_R16_SNORM\nDVZ_FORMAT_R32_UINT\nDVZ_FORMAT_R32_SINT\nDVZ_FORMAT_R32_SFLOAT\nDVZ_FORMAT_R32G32_UINT\nDVZ_FORMAT_R32G32_SINT\nDVZ_FORMAT_R32G32_SFLOAT\nDVZ_FORMAT_R32G32B32_UINT\nDVZ_FORMAT_R32G32B32_SINT\nDVZ_FORMAT_R32G32B32_SFLOAT\nDVZ_FORMAT_R32G32B32A32_UINT\nDVZ_FORMAT_R32G32B32A32_SINT\nDVZ_FORMAT_R32G32B32A32_SFLOAT\n</code></pre>"},{"location":"api/#dvzfrontface","title":"<code>DvzFrontFace</code>","text":"<pre><code>DVZ_FRONT_FACE_COUNTER_CLOCKWISE\nDVZ_FRONT_FACE_CLOCKWISE\n</code></pre>"},{"location":"api/#dvzgraphicstype","title":"<code>DvzGraphicsType</code>","text":"<pre><code>DVZ_GRAPHICS_NONE\nDVZ_GRAPHICS_POINT\nDVZ_GRAPHICS_TRIANGLE\nDVZ_GRAPHICS_CUSTOM\n</code></pre>"},{"location":"api/#dvzimageflags","title":"<code>DvzImageFlags</code>","text":"<pre><code>DVZ_IMAGE_FLAGS_SIZE_PIXELS\nDVZ_IMAGE_FLAGS_SIZE_NDC\nDVZ_IMAGE_FLAGS_RESCALE_KEEP_RATIO\nDVZ_IMAGE_FLAGS_RESCALE\nDVZ_IMAGE_FLAGS_FILL\n</code></pre>"},{"location":"api/#dvzjointype","title":"<code>DvzJoinType</code>","text":"<pre><code>DVZ_JOIN_SQUARE\nDVZ_JOIN_ROUND\n</code></pre>"},{"location":"api/#dvzkeyboardeventtype","title":"<code>DvzKeyboardEventType</code>","text":"<pre><code>DVZ_KEYBOARD_EVENT_NONE\nDVZ_KEYBOARD_EVENT_PRESS\nDVZ_KEYBOARD_EVENT_REPEAT\nDVZ_KEYBOARD_EVENT_RELEASE\n</code></pre>"},{"location":"api/#dvzkeyboardmodifiers","title":"<code>DvzKeyboardModifiers</code>","text":"<pre><code>DVZ_KEY_MODIFIER_NONE\nDVZ_KEY_MODIFIER_SHIFT\nDVZ_KEY_MODIFIER_CONTROL\nDVZ_KEY_MODIFIER_ALT\nDVZ_KEY_MODIFIER_SUPER\n</code></pre>"},{"location":"api/#dvzmarkeraspect","title":"<code>DvzMarkerAspect</code>","text":"<pre><code>DVZ_MARKER_ASPECT_FILLED\nDVZ_MARKER_ASPECT_STROKE\nDVZ_MARKER_ASPECT_OUTLINE\n</code></pre>"},{"location":"api/#dvzmarkermode","title":"<code>DvzMarkerMode</code>","text":"<pre><code>DVZ_MARKER_MODE_NONE\nDVZ_MARKER_MODE_CODE\nDVZ_MARKER_MODE_BITMAP\nDVZ_MARKER_MODE_SDF\nDVZ_MARKER_MODE_MSDF\nDVZ_MARKER_MODE_MTSDF\n</code></pre>"},{"location":"api/#dvzmarkershape","title":"<code>DvzMarkerShape</code>","text":"<pre><code>DVZ_MARKER_SHAPE_DISC\nDVZ_MARKER_SHAPE_ASTERISK\nDVZ_MARKER_SHAPE_CHEVRON\nDVZ_MARKER_SHAPE_CLOVER\nDVZ_MARKER_SHAPE_CLUB\nDVZ_MARKER_SHAPE_CROSS\nDVZ_MARKER_SHAPE_DIAMOND\nDVZ_MARKER_SHAPE_ARROW\nDVZ_MARKER_SHAPE_ELLIPSE\nDVZ_MARKER_SHAPE_HBAR\nDVZ_MARKER_SHAPE_HEART\nDVZ_MARKER_SHAPE_INFINITY\nDVZ_MARKER_SHAPE_PIN\nDVZ_MARKER_SHAPE_RING\nDVZ_MARKER_SHAPE_SPADE\nDVZ_MARKER_SHAPE_SQUARE\nDVZ_MARKER_SHAPE_TAG\nDVZ_MARKER_SHAPE_TRIANGLE\nDVZ_MARKER_SHAPE_VBAR\nDVZ_MARKER_SHAPE_ROUNDED_RECT\nDVZ_MARKER_SHAPE_COUNT\n</code></pre>"},{"location":"api/#dvzmeshflags","title":"<code>DvzMeshFlags</code>","text":"<pre><code>DVZ_MESH_FLAGS_NONE\nDVZ_MESH_FLAGS_TEXTURED\nDVZ_MESH_FLAGS_LIGHTING\nDVZ_MESH_FLAGS_CONTOUR\nDVZ_MESH_FLAGS_ISOLINE\n</code></pre>"},{"location":"api/#dvzmockflags","title":"<code>DvzMockFlags</code>","text":"<pre><code>DVZ_MOCK_FLAGS_NONE\nDVZ_MOCK_FLAGS_CLOSED\n</code></pre>"},{"location":"api/#dvzmousebutton","title":"<code>DvzMouseButton</code>","text":"<pre><code>DVZ_MOUSE_BUTTON_NONE\nDVZ_MOUSE_BUTTON_LEFT\nDVZ_MOUSE_BUTTON_MIDDLE\nDVZ_MOUSE_BUTTON_RIGHT\n</code></pre>"},{"location":"api/#dvzmouseeventtype","title":"<code>DvzMouseEventType</code>","text":"<pre><code>DVZ_MOUSE_EVENT_RELEASE\nDVZ_MOUSE_EVENT_PRESS\nDVZ_MOUSE_EVENT_MOVE\nDVZ_MOUSE_EVENT_CLICK\nDVZ_MOUSE_EVENT_DOUBLE_CLICK\nDVZ_MOUSE_EVENT_DRAG_START\nDVZ_MOUSE_EVENT_DRAG\nDVZ_MOUSE_EVENT_DRAG_STOP\nDVZ_MOUSE_EVENT_WHEEL\nDVZ_MOUSE_EVENT_ALL\n</code></pre>"},{"location":"api/#dvzmousestate","title":"<code>DvzMouseState</code>","text":"<pre><code>DVZ_MOUSE_STATE_RELEASE\nDVZ_MOUSE_STATE_PRESS\nDVZ_MOUSE_STATE_CLICK\nDVZ_MOUSE_STATE_CLICK_PRESS\nDVZ_MOUSE_STATE_DOUBLE_CLICK\nDVZ_MOUSE_STATE_DRAGGING\n</code></pre>"},{"location":"api/#dvzpanzoomflags","title":"<code>DvzPanzoomFlags</code>","text":"<pre><code>DVZ_PANZOOM_FLAGS_NONE\nDVZ_PANZOOM_FLAGS_KEEP_ASPECT\nDVZ_PANZOOM_FLAGS_FIXED_X\nDVZ_PANZOOM_FLAGS_FIXED_Y\n</code></pre>"},{"location":"api/#dvzpathflags","title":"<code>DvzPathFlags</code>","text":"<pre><code>DVZ_PATH_FLAGS_OPEN\nDVZ_PATH_FLAGS_CLOSED\n</code></pre>"},{"location":"api/#dvzpolygonmode","title":"<code>DvzPolygonMode</code>","text":"<pre><code>DVZ_POLYGON_MODE_FILL\nDVZ_POLYGON_MODE_LINE\nDVZ_POLYGON_MODE_POINT\n</code></pre>"},{"location":"api/#dvzprimitivetopology","title":"<code>DvzPrimitiveTopology</code>","text":"<pre><code>DVZ_PRIMITIVE_TOPOLOGY_POINT_LIST\nDVZ_PRIMITIVE_TOPOLOGY_LINE_LIST\nDVZ_PRIMITIVE_TOPOLOGY_LINE_STRIP\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN\n</code></pre>"},{"location":"api/#dvzrecordercommandtype","title":"<code>DvzRecorderCommandType</code>","text":"<pre><code>DVZ_RECORDER_NONE\nDVZ_RECORDER_BEGIN\nDVZ_RECORDER_DRAW\nDVZ_RECORDER_DRAW_INDEXED\nDVZ_RECORDER_DRAW_INDIRECT\nDVZ_RECORDER_DRAW_INDEXED_INDIRECT\nDVZ_RECORDER_VIEWPORT\nDVZ_RECORDER_END\n</code></pre>"},{"location":"api/#dvzrequestaction","title":"<code>DvzRequestAction</code>","text":"<pre><code>DVZ_REQUEST_ACTION_NONE\nDVZ_REQUEST_ACTION_CREATE\nDVZ_REQUEST_ACTION_DELETE\nDVZ_REQUEST_ACTION_RESIZE\nDVZ_REQUEST_ACTION_UPDATE\nDVZ_REQUEST_ACTION_BIND\nDVZ_REQUEST_ACTION_RECORD\nDVZ_REQUEST_ACTION_UPLOAD\nDVZ_REQUEST_ACTION_UPFILL\nDVZ_REQUEST_ACTION_DOWNLOAD\nDVZ_REQUEST_ACTION_SET\nDVZ_REQUEST_ACTION_GET\n</code></pre>"},{"location":"api/#dvzrequestobject","title":"<code>DvzRequestObject</code>","text":"<pre><code>DVZ_REQUEST_OBJECT_NONE\nDVZ_REQUEST_OBJECT_BOARD\nDVZ_REQUEST_OBJECT_CANVAS\nDVZ_REQUEST_OBJECT_DAT\nDVZ_REQUEST_OBJECT_TEX\nDVZ_REQUEST_OBJECT_SAMPLER\nDVZ_REQUEST_OBJECT_COMPUTE\nDVZ_REQUEST_OBJECT_PRIMITIVE\nDVZ_REQUEST_OBJECT_DEPTH\nDVZ_REQUEST_OBJECT_BLEND\nDVZ_REQUEST_OBJECT_POLYGON\nDVZ_REQUEST_OBJECT_CULL\nDVZ_REQUEST_OBJECT_FRONT\nDVZ_REQUEST_OBJECT_SHADER\nDVZ_REQUEST_OBJECT_VERTEX\nDVZ_REQUEST_OBJECT_VERTEX_ATTR\nDVZ_REQUEST_OBJECT_SLOT\nDVZ_REQUEST_OBJECT_SPECIALIZATION\nDVZ_REQUEST_OBJECT_GRAPHICS\nDVZ_REQUEST_OBJECT_INDEX\nDVZ_REQUEST_OBJECT_BACKGROUND\nDVZ_REQUEST_OBJECT_RECORD\n</code></pre>"},{"location":"api/#dvzsampleraddressmode","title":"<code>DvzSamplerAddressMode</code>","text":"<pre><code>DVZ_SAMPLER_ADDRESS_MODE_REPEAT\nDVZ_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT\nDVZ_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE\nDVZ_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER\nDVZ_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE\n</code></pre>"},{"location":"api/#dvzsampleraxis","title":"<code>DvzSamplerAxis</code>","text":"<pre><code>DVZ_SAMPLER_AXIS_U\nDVZ_SAMPLER_AXIS_V\nDVZ_SAMPLER_AXIS_W\n</code></pre>"},{"location":"api/#dvzshaderformat","title":"<code>DvzShaderFormat</code>","text":"<pre><code>DVZ_SHADER_NONE\nDVZ_SHADER_SPIRV\nDVZ_SHADER_GLSL\n</code></pre>"},{"location":"api/#dvzshadertype","title":"<code>DvzShaderType</code>","text":"<pre><code>DVZ_SHADER_VERTEX\nDVZ_SHADER_TESSELLATION_CONTROL\nDVZ_SHADER_TESSELLATION_EVALUATION\nDVZ_SHADER_GEOMETRY\nDVZ_SHADER_FRAGMENT\nDVZ_SHADER_COMPUTE\n</code></pre>"},{"location":"api/#dvzshapetype","title":"<code>DvzShapeType</code>","text":"<pre><code>DVZ_SHAPE_NONE\nDVZ_SHAPE_SQUARE\nDVZ_SHAPE_DISC\nDVZ_SHAPE_POLYGON\nDVZ_SHAPE_CUBE\nDVZ_SHAPE_SPHERE\nDVZ_SHAPE_CYLINDER\nDVZ_SHAPE_CONE\nDVZ_SHAPE_SURFACE\nDVZ_SHAPE_OBJ\nDVZ_SHAPE_OTHER\n</code></pre>"},{"location":"api/#dvzslottype","title":"<code>DvzSlotType</code>","text":"<pre><code>DVZ_SLOT_DAT\nDVZ_SLOT_TEX\n</code></pre>"},{"location":"api/#dvztexdims","title":"<code>DvzTexDims</code>","text":"<pre><code>DVZ_TEX_NONE\nDVZ_TEX_1D\nDVZ_TEX_2D\nDVZ_TEX_3D\n</code></pre>"},{"location":"api/#dvztexflags","title":"<code>DvzTexFlags</code>","text":"<pre><code>DVZ_TEX_FLAGS_NONE\nDVZ_TEX_FLAGS_PERSISTENT_STAGING\n</code></pre>"},{"location":"api/#dvzuploadflags","title":"<code>DvzUploadFlags</code>","text":"<pre><code>DVZ_UPLOAD_FLAGS_NOCOPY\n</code></pre>"},{"location":"api/#dvzvertexinputrate","title":"<code>DvzVertexInputRate</code>","text":"<pre><code>DVZ_VERTEX_INPUT_RATE_VERTEX\nDVZ_VERTEX_INPUT_RATE_INSTANCE\n</code></pre>"},{"location":"api/#dvzviewflags","title":"<code>DvzViewFlags</code>","text":"<pre><code>DVZ_VIEW_FLAGS_NONE\nDVZ_VIEW_FLAGS_STATIC\n</code></pre>"},{"location":"api/#dvzviewportclip","title":"<code>DvzViewportClip</code>","text":"<pre><code>DVZ_VIEWPORT_CLIP_INNER\nDVZ_VIEWPORT_CLIP_OUTER\nDVZ_VIEWPORT_CLIP_BOTTOM\nDVZ_VIEWPORT_CLIP_LEFT\n</code></pre>"},{"location":"api/#dvzvisualflags","title":"<code>DvzVisualFlags</code>","text":"<pre><code>DVZ_VISUAL_FLAGS_DEFAULT\nDVZ_VISUAL_FLAGS_INDEXED\nDVZ_VISUAL_FLAGS_INDIRECT\nDVZ_VISUAL_FLAGS_VERTEX_MAPPABLE\nDVZ_VISUAL_FLAGS_INDEX_MAPPABLE\n</code></pre>"},{"location":"api/#dvzvolumeflags","title":"<code>DvzVolumeFlags</code>","text":"<pre><code>DVZ_VOLUME_FLAGS_NONE\nDVZ_VOLUME_FLAGS_RGBA\nDVZ_VOLUME_FLAGS_COLORMAP\nDVZ_VOLUME_FLAGS_BACK_FRONT\n</code></pre>"},{"location":"api/#dvzkeycode","title":"<code>DvzKeyCode</code>","text":"<pre><code>DVZ_KEY_UNKNOWN\nDVZ_KEY_NONE\nDVZ_KEY_SPACE\nDVZ_KEY_APOSTROPHE\nDVZ_KEY_COMMA\nDVZ_KEY_MINUS\nDVZ_KEY_PERIOD\nDVZ_KEY_SLASH\nDVZ_KEY_0\nDVZ_KEY_1\nDVZ_KEY_2\nDVZ_KEY_3\nDVZ_KEY_4\nDVZ_KEY_5\nDVZ_KEY_6\nDVZ_KEY_7\nDVZ_KEY_8\nDVZ_KEY_9\nDVZ_KEY_SEMICOLON\nDVZ_KEY_EQUAL\nDVZ_KEY_A\nDVZ_KEY_B\nDVZ_KEY_C\nDVZ_KEY_D\nDVZ_KEY_E\nDVZ_KEY_F\nDVZ_KEY_G\nDVZ_KEY_H\nDVZ_KEY_I\nDVZ_KEY_J\nDVZ_KEY_K\nDVZ_KEY_L\nDVZ_KEY_M\nDVZ_KEY_N\nDVZ_KEY_O\nDVZ_KEY_P\nDVZ_KEY_Q\nDVZ_KEY_R\nDVZ_KEY_S\nDVZ_KEY_T\nDVZ_KEY_U\nDVZ_KEY_V\nDVZ_KEY_W\nDVZ_KEY_X\nDVZ_KEY_Y\nDVZ_KEY_Z\nDVZ_KEY_LEFT_BRACKET\nDVZ_KEY_BACKSLASH\nDVZ_KEY_RIGHT_BRACKET\nDVZ_KEY_GRAVE_ACCENT\nDVZ_KEY_WORLD_1\nDVZ_KEY_WORLD_2\nDVZ_KEY_ESCAPE\nDVZ_KEY_ENTER\nDVZ_KEY_TAB\nDVZ_KEY_BACKSPACE\nDVZ_KEY_INSERT\nDVZ_KEY_DELETE\nDVZ_KEY_RIGHT\nDVZ_KEY_LEFT\nDVZ_KEY_DOWN\nDVZ_KEY_UP\nDVZ_KEY_PAGE_UP\nDVZ_KEY_PAGE_DOWN\nDVZ_KEY_HOME\nDVZ_KEY_END\nDVZ_KEY_CAPS_LOCK\nDVZ_KEY_SCROLL_LOCK\nDVZ_KEY_NUM_LOCK\nDVZ_KEY_PRINT_SCREEN\nDVZ_KEY_PAUSE\nDVZ_KEY_F1\nDVZ_KEY_F2\nDVZ_KEY_F3\nDVZ_KEY_F4\nDVZ_KEY_F5\nDVZ_KEY_F6\nDVZ_KEY_F7\nDVZ_KEY_F8\nDVZ_KEY_F9\nDVZ_KEY_F10\nDVZ_KEY_F11\nDVZ_KEY_F12\nDVZ_KEY_F13\nDVZ_KEY_F14\nDVZ_KEY_F15\nDVZ_KEY_F16\nDVZ_KEY_F17\nDVZ_KEY_F18\nDVZ_KEY_F19\nDVZ_KEY_F20\nDVZ_KEY_F21\nDVZ_KEY_F22\nDVZ_KEY_F23\nDVZ_KEY_F24\nDVZ_KEY_F25\nDVZ_KEY_KP_0\nDVZ_KEY_KP_1\nDVZ_KEY_KP_2\nDVZ_KEY_KP_3\nDVZ_KEY_KP_4\nDVZ_KEY_KP_5\nDVZ_KEY_KP_6\nDVZ_KEY_KP_7\nDVZ_KEY_KP_8\nDVZ_KEY_KP_9\nDVZ_KEY_KP_DECIMAL\nDVZ_KEY_KP_DIVIDE\nDVZ_KEY_KP_MULTIPLY\nDVZ_KEY_KP_SUBTRACT\nDVZ_KEY_KP_ADD\nDVZ_KEY_KP_ENTER\nDVZ_KEY_KP_EQUAL\nDVZ_KEY_LEFT_SHIFT\nDVZ_KEY_LEFT_CONTROL\nDVZ_KEY_LEFT_ALT\nDVZ_KEY_LEFT_SUPER\nDVZ_KEY_RIGHT_SHIFT\nDVZ_KEY_RIGHT_CONTROL\nDVZ_KEY_RIGHT_ALT\nDVZ_KEY_RIGHT_SUPER\nDVZ_KEY_MENU\nDVZ_KEY_LAST\n</code></pre>"},{"location":"api/#dvzgraphicsrequestflags","title":"<code>DvzGraphicsRequestFlags</code>","text":"<pre><code>DVZ_GRAPHICS_REQUEST_FLAGS_NONE\nDVZ_GRAPHICS_REQUEST_FLAGS_OFFSCREEN\n</code></pre>"},{"location":"api/#dvzprintflagsflags","title":"<code>DvzPrintFlagsFlags</code>","text":"<pre><code>DVZ_PRINT_FLAGS_NONE\nDVZ_PRINT_FLAGS_DATA\n</code></pre>"},{"location":"api/#structures","title":"Structures","text":""},{"location":"api/#dvzatlasfont","title":"<code>DvzAtlasFont</code>","text":"<pre><code>struct DvzAtlasFont\n    unsigned long ttf_size\n    unsigned char* ttf_bytes\n    DvzAtlas* atlas\n    DvzFont* font\n</code></pre>"},{"location":"api/#dvzbatch","title":"<code>DvzBatch</code>","text":"<pre><code>struct DvzBatch\n    uint32_t capacity\n    uint32_t count\n    DvzRequest* requests\n    DvzList* pointers_to_free\n    DvzId board_id\n    int flags\n</code></pre>"},{"location":"api/#dvzframeevent","title":"<code>DvzFrameEvent</code>","text":"<pre><code>struct DvzFrameEvent\n    uint64_t frame_idx\n    double time\n    double interval\n    void* user_data\n</code></pre>"},{"location":"api/#dvzguievent","title":"<code>DvzGuiEvent</code>","text":"<pre><code>struct DvzGuiEvent\n    void* user_data\n</code></pre>"},{"location":"api/#dvzkeyboardevent","title":"<code>DvzKeyboardEvent</code>","text":"<pre><code>struct DvzKeyboardEvent\n    DvzKeyboardEventType type\n    DvzKeyCode key\n    int mods\n    void* user_data\n</code></pre>"},{"location":"api/#dvzmvp","title":"<code>DvzMVP</code>","text":"<pre><code>struct DvzMVP\n    mat4 model\n    mat4 view\n    mat4 proj\n</code></pre>"},{"location":"api/#dvzmousebuttonevent","title":"<code>DvzMouseButtonEvent</code>","text":"<pre><code>struct DvzMouseButtonEvent\n    DvzMouseButton button\n</code></pre>"},{"location":"api/#dvzmouseclickevent","title":"<code>DvzMouseClickEvent</code>","text":"<pre><code>struct DvzMouseClickEvent\n    DvzMouseButton button\n</code></pre>"},{"location":"api/#dvzmousedragevent","title":"<code>DvzMouseDragEvent</code>","text":"<pre><code>struct DvzMouseDragEvent\n    DvzMouseButton button\n    vec2 press_pos\n    vec2 shift\n</code></pre>"},{"location":"api/#dvzmouseevent","title":"<code>DvzMouseEvent</code>","text":"<pre><code>struct DvzMouseEvent\n    DvzMouseEventType type\n    DvzMouseEventUnion content\n    vec2 pos\n    int mods\n    float content_scale\n    void* user_data\n</code></pre>"},{"location":"api/#dvzmouseeventunion","title":"<code>DvzMouseEventUnion</code>","text":"<pre><code>union DvzMouseEventUnion\n    DvzMouseButtonEvent b\n    DvzMouseWheelEvent w\n    DvzMouseDragEvent d\n    DvzMouseClickEvent c\n</code></pre>"},{"location":"api/#dvzmousewheelevent","title":"<code>DvzMouseWheelEvent</code>","text":"<pre><code>struct DvzMouseWheelEvent\n    vec2 dir\n</code></pre>"},{"location":"api/#dvzrecordercommand","title":"<code>DvzRecorderCommand</code>","text":"<pre><code>struct DvzRecorderCommand\n    DvzRecorderCommandType type\n    DvzId canvas_or_board_id\n    DvzRequestObject object_type\n    DvzRecorderUnion contents\n</code></pre>"},{"location":"api/#dvzrecorderdraw","title":"<code>DvzRecorderDraw</code>","text":"<pre><code>struct DvzRecorderDraw\n    DvzId pipe_id\n    uint32_t first_vertex\n    uint32_t vertex_count\n    uint32_t first_instance\n    uint32_t instance_count\n</code></pre>"},{"location":"api/#dvzrecorderdrawindexed","title":"<code>DvzRecorderDrawIndexed</code>","text":"<pre><code>struct DvzRecorderDrawIndexed\n    DvzId pipe_id\n    uint32_t first_index\n    uint32_t vertex_offset\n    uint32_t index_count\n    uint32_t first_instance\n    uint32_t instance_count\n</code></pre>"},{"location":"api/#dvzrecorderdrawindexedindirect","title":"<code>DvzRecorderDrawIndexedIndirect</code>","text":"<pre><code>struct DvzRecorderDrawIndexedIndirect\n    DvzId pipe_id\n    DvzId dat_indirect_id\n    uint32_t draw_count\n</code></pre>"},{"location":"api/#dvzrecorderdrawindirect","title":"<code>DvzRecorderDrawIndirect</code>","text":"<pre><code>struct DvzRecorderDrawIndirect\n    DvzId pipe_id\n    DvzId dat_indirect_id\n    uint32_t draw_count\n</code></pre>"},{"location":"api/#dvzrecorderunion","title":"<code>DvzRecorderUnion</code>","text":"<pre><code>union DvzRecorderUnion\n    DvzRecorderViewport v\n    DvzRecorderDraw draw\n    DvzRecorderDrawIndexed draw_indexed\n    DvzRecorderDrawIndirect draw_indirect\n    DvzRecorderDrawIndexedIndirect draw_indexed_indirect\n</code></pre>"},{"location":"api/#dvzrecorderviewport","title":"<code>DvzRecorderViewport</code>","text":"<pre><code>struct DvzRecorderViewport\n    vec2 offset\n    vec2 shape\n</code></pre>"},{"location":"api/#dvzrequest","title":"<code>DvzRequest</code>","text":"<pre><code>struct DvzRequest\n    uint32_t version\n    DvzRequestAction action\n    DvzRequestObject type\n    DvzId id\n    DvzRequestContent content\n    int tag\n    int flags\n    char* desc\n</code></pre>"},{"location":"api/#dvzrequestattr","title":"<code>DvzRequestAttr</code>","text":"<pre><code>struct DvzRequestAttr\n    uint32_t binding_idx\n    uint32_t location\n    DvzFormat format\n    DvzSize offset\n</code></pre>"},{"location":"api/#dvzrequestbinddat","title":"<code>DvzRequestBindDat</code>","text":"<pre><code>struct DvzRequestBindDat\n    uint32_t slot_idx\n    DvzId dat\n    DvzSize offset\n</code></pre>"},{"location":"api/#dvzrequestbindindex","title":"<code>DvzRequestBindIndex</code>","text":"<pre><code>struct DvzRequestBindIndex\n    DvzId dat\n    DvzSize offset\n</code></pre>"},{"location":"api/#dvzrequestbindtex","title":"<code>DvzRequestBindTex</code>","text":"<pre><code>struct DvzRequestBindTex\n    uint32_t slot_idx\n    DvzId tex\n    DvzId sampler\n    uvec3 offset\n</code></pre>"},{"location":"api/#dvzrequestbindvertex","title":"<code>DvzRequestBindVertex</code>","text":"<pre><code>struct DvzRequestBindVertex\n    uint32_t binding_idx\n    DvzId dat\n    DvzSize offset\n</code></pre>"},{"location":"api/#dvzrequestblend","title":"<code>DvzRequestBlend</code>","text":"<pre><code>struct DvzRequestBlend\n    DvzBlendType blend\n</code></pre>"},{"location":"api/#dvzrequestboard","title":"<code>DvzRequestBoard</code>","text":"<pre><code>struct DvzRequestBoard\n    uint32_t width\n    uint32_t height\n    cvec4 background\n</code></pre>"},{"location":"api/#dvzrequestcanvas","title":"<code>DvzRequestCanvas</code>","text":"<pre><code>struct DvzRequestCanvas\n    uint32_t framebuffer_width\n    uint32_t framebuffer_height\n    uint32_t screen_width\n    uint32_t screen_height\n    cvec4 background\n</code></pre>"},{"location":"api/#dvzrequestcontent","title":"<code>DvzRequestContent</code>","text":"<pre><code>union DvzRequestContent\n    DvzRequestBoard board\n    DvzRequestCanvas canvas\n    DvzRequestDat dat\n    DvzRequestTex tex\n    DvzRequestSampler sampler\n    DvzRequestShader shader\n    DvzRequestDatUpload dat_upload\n    DvzRequestTexUpload tex_upload\n    DvzRequestGraphics graphics\n    DvzRequestPrimitive set_primitive\n    DvzRequestBlend set_blend\n    DvzRequestDepth set_depth\n    DvzRequestPolygon set_polygon\n    DvzRequestCull set_cull\n    DvzRequestFront set_front\n    DvzRequestShaderSet set_shader\n    DvzRequestVertex set_vertex\n    DvzRequestAttr set_attr\n    DvzRequestSlot set_slot\n    DvzRequestSpecialization set_specialization\n    DvzRequestBindVertex bind_vertex\n    DvzRequestBindIndex bind_index\n    DvzRequestBindDat bind_dat\n    DvzRequestBindTex bind_tex\n    DvzRequestRecord record\n</code></pre>"},{"location":"api/#dvzrequestcull","title":"<code>DvzRequestCull</code>","text":"<pre><code>struct DvzRequestCull\n    DvzCullMode cull\n</code></pre>"},{"location":"api/#dvzrequestdat","title":"<code>DvzRequestDat</code>","text":"<pre><code>struct DvzRequestDat\n    DvzBufferType type\n    DvzSize size\n</code></pre>"},{"location":"api/#dvzrequestdatupload","title":"<code>DvzRequestDatUpload</code>","text":"<pre><code>struct DvzRequestDatUpload\n    int upload_type\n    DvzSize offset\n    DvzSize size\n    void* data\n</code></pre>"},{"location":"api/#dvzrequestdepth","title":"<code>DvzRequestDepth</code>","text":"<pre><code>struct DvzRequestDepth\n    DvzDepthTest depth\n</code></pre>"},{"location":"api/#dvzrequestfront","title":"<code>DvzRequestFront</code>","text":"<pre><code>struct DvzRequestFront\n    DvzFrontFace front\n</code></pre>"},{"location":"api/#dvzrequestgraphics","title":"<code>DvzRequestGraphics</code>","text":"<pre><code>struct DvzRequestGraphics\n    DvzGraphicsType type\n</code></pre>"},{"location":"api/#dvzrequestpolygon","title":"<code>DvzRequestPolygon</code>","text":"<pre><code>struct DvzRequestPolygon\n    DvzPolygonMode polygon\n</code></pre>"},{"location":"api/#dvzrequestprimitive","title":"<code>DvzRequestPrimitive</code>","text":"<pre><code>struct DvzRequestPrimitive\n    DvzPrimitiveTopology primitive\n</code></pre>"},{"location":"api/#dvzrequestrecord","title":"<code>DvzRequestRecord</code>","text":"<pre><code>struct DvzRequestRecord\n    DvzRecorderCommand command\n</code></pre>"},{"location":"api/#dvzrequestsampler","title":"<code>DvzRequestSampler</code>","text":"<pre><code>struct DvzRequestSampler\n    DvzFilter filter\n    DvzSamplerAddressMode mode\n</code></pre>"},{"location":"api/#dvzrequestshader","title":"<code>DvzRequestShader</code>","text":"<pre><code>struct DvzRequestShader\n    DvzShaderFormat format\n    DvzShaderType type\n    DvzSize size\n    char* code\n    uint32_t* buffer\n</code></pre>"},{"location":"api/#dvzrequestshaderset","title":"<code>DvzRequestShaderSet</code>","text":"<pre><code>struct DvzRequestShaderSet\n    DvzId shader\n</code></pre>"},{"location":"api/#dvzrequestslot","title":"<code>DvzRequestSlot</code>","text":"<pre><code>struct DvzRequestSlot\n    uint32_t slot_idx\n    DvzDescriptorType type\n</code></pre>"},{"location":"api/#dvzrequestspecialization","title":"<code>DvzRequestSpecialization</code>","text":"<pre><code>struct DvzRequestSpecialization\n    DvzShaderType shader\n    uint32_t idx\n    DvzSize size\n    void* value\n</code></pre>"},{"location":"api/#dvzrequesttex","title":"<code>DvzRequestTex</code>","text":"<pre><code>struct DvzRequestTex\n    DvzTexDims dims\n    uvec3 shape\n    DvzFormat format\n</code></pre>"},{"location":"api/#dvzrequesttexupload","title":"<code>DvzRequestTexUpload</code>","text":"<pre><code>struct DvzRequestTexUpload\n    int upload_type\n    uvec3 offset\n    uvec3 shape\n    DvzSize size\n    void* data\n</code></pre>"},{"location":"api/#dvzrequestvertex","title":"<code>DvzRequestVertex</code>","text":"<pre><code>struct DvzRequestVertex\n    uint32_t binding_idx\n    DvzSize stride\n    DvzVertexInputRate input_rate\n</code></pre>"},{"location":"api/#dvzrequester","title":"<code>DvzRequester</code>","text":"<pre><code>struct DvzRequester\n    DvzFifo* fifo\n</code></pre>"},{"location":"api/#dvzrequestsevent","title":"<code>DvzRequestsEvent</code>","text":"<pre><code>struct DvzRequestsEvent\n    DvzBatch* batch\n    void* user_data\n</code></pre>"},{"location":"api/#dvzshape","title":"<code>DvzShape</code>","text":"<pre><code>struct DvzShape\n    mat4 transform\n    uint32_t first\n    uint32_t count\n    DvzShapeType type\n    uint32_t vertex_count\n    uint32_t index_count\n    vec3* pos\n    vec3* normal\n    DvzColor* color\n    vec4* texcoords\n    float* isoline\n    vec3* d_left\n    vec3* d_right\n    cvec4* contour\n    DvzIndex* index\n</code></pre>"},{"location":"api/#dvztimerevent","title":"<code>DvzTimerEvent</code>","text":"<pre><code>struct DvzTimerEvent\n    uint32_t timer_idx\n    DvzTimerItem* timer_item\n    uint64_t step_idx\n    double time\n    void* user_data\n</code></pre>"},{"location":"api/#dvzwindowevent","title":"<code>DvzWindowEvent</code>","text":"<pre><code>struct DvzWindowEvent\n    uint32_t framebuffer_width\n    uint32_t framebuffer_height\n    uint32_t screen_width\n    uint32_t screen_height\n    int flags\n    void* user_data\n</code></pre>"},{"location":"colormaps/","title":"Colormaps","text":"<p>Datoviz natively includes a collection of common colormaps (continuous) and color palettes (discrete). They come from:</p> <ul> <li>matplotlib</li> <li>bokeh</li> <li>colorcet</li> <li>Kenneth Moreland's page</li> </ul> Name Row, Col Colormap <code>binary</code> 0, 0 <code>hsv</code> 1, 0 <code>cividis</code> 2, 0 <code>inferno</code> 3, 0 <code>magma</code> 4, 0 <code>plasma</code> 5, 0 <code>viridis</code> 6, 0 <code>blues</code> 7, 0 <code>bugn</code> 8, 0 <code>bupu</code> 9, 0 <code>gnbu</code> 10, 0 <code>greens</code> 11, 0 <code>greys</code> 12, 0 <code>oranges</code> 13, 0 <code>orrd</code> 14, 0 <code>pubu</code> 15, 0 <code>pubugn</code> 16, 0 <code>purples</code> 17, 0 <code>rdpu</code> 18, 0 <code>reds</code> 19, 0 <code>ylgn</code> 20, 0 <code>ylgnbu</code> 21, 0 <code>ylorbr</code> 22, 0 <code>ylorrd</code> 23, 0 <code>afmhot</code> 24, 0 <code>autumn</code> 25, 0 <code>bone</code> 26, 0 <code>cool</code> 27, 0 <code>copper</code> 28, 0 <code>gist_heat</code> 29, 0 <code>gray</code> 30, 0 <code>hot</code> 31, 0 <code>pink</code> 32, 0 <code>spring</code> 33, 0 <code>summer</code> 34, 0 <code>winter</code> 35, 0 <code>wistia</code> 36, 0 <code>brbg</code> 37, 0 <code>bwr</code> 38, 0 <code>coolwarm</code> 39, 0 <code>piyg</code> 40, 0 <code>prgn</code> 41, 0 <code>puor</code> 42, 0 <code>rdbu</code> 43, 0 <code>rdgy</code> 44, 0 <code>rdylbu</code> 45, 0 <code>rdylgn</code> 46, 0 <code>seismic</code> 47, 0 <code>spectral</code> 48, 0 <code>twilight_shifted</code> 49, 0 <code>twilight</code> 50, 0 <code>brg</code> 51, 0 <code>cmrmap</code> 52, 0 <code>cubehelix</code> 53, 0 <code>flag</code> 54, 0 <code>gist_earth</code> 55, 0 <code>gist_ncar</code> 56, 0 <code>gist_rainbow</code> 57, 0 <code>gist_stern</code> 58, 0 <code>gnuplot2</code> 59, 0 <code>gnuplot</code> 60, 0 <code>jet</code> 61, 0 <code>nipy_spectral</code> 62, 0 <code>ocean</code> 63, 0 <code>prism</code> 64, 0 <code>rainbow</code> 65, 0 <code>terrain</code> 66, 0 <code>bkr</code> 67, 0 <code>bky</code> 68, 0 <code>cet_d10</code> 69, 0 <code>cet_d11</code> 70, 0 <code>cet_d8</code> 71, 0 <code>cet_d13</code> 72, 0 <code>cet_d3</code> 73, 0 <code>cet_d1a</code> 74, 0 <code>bjy</code> 75, 0 <code>gwv</code> 76, 0 <code>bwy</code> 77, 0 <code>cet_d12</code> 78, 0 <code>cet_r3</code> 79, 0 <code>cet_d9</code> 80, 0 <code>cwr</code> 81, 0 <code>cet_cbc1</code> 82, 0 <code>cet_cbc2</code> 83, 0 <code>cet_cbl1</code> 84, 0 <code>cet_cbl2</code> 85, 0 <code>cet_cbtc1</code> 86, 0 <code>cet_cbtc2</code> 87, 0 <code>cet_cbtl1</code> 88, 0 <code>bgy</code> 89, 0 <code>bgyw</code> 90, 0 <code>bmw</code> 91, 0 <code>cet_c1</code> 92, 0 <code>cet_c1s</code> 93, 0 <code>cet_c2</code> 94, 0 <code>cet_c4</code> 95, 0 <code>cet_c4s</code> 96, 0 <code>cet_c5</code> 97, 0 <code>cet_i1</code> 98, 0 <code>cet_i3</code> 99, 0 <code>cet_l10</code> 100, 0 <code>cet_l11</code> 101, 0 <code>cet_l12</code> 102, 0 <code>cet_l16</code> 103, 0 <code>cet_l17</code> 104, 0 <code>cet_l18</code> 105, 0 <code>cet_l19</code> 106, 0 <code>cet_l4</code> 107, 0 <code>cet_l7</code> 108, 0 <code>cet_l8</code> 109, 0 <code>cet_l9</code> 110, 0 <code>cet_r1</code> 111, 0 <code>cet_r2</code> 112, 0 <code>colorwheel</code> 113, 0 <code>fire</code> 114, 0 <code>isolum</code> 115, 0 <code>kb</code> 116, 0 <code>kbc</code> 117, 0 <code>kg</code> 118, 0 <code>kgy</code> 119, 0 <code>kr</code> 120, 0 <code>black_body</code> 121, 0 <code>kindlmann</code> 122, 0 <code>extended_kindlmann</code> 123, 0 <code>glasbey</code> 176, 0 <code>glasbey_cool</code> 177, 0 <code>glasbey_dark</code> 178, 0 <code>glasbey_hv</code> 179, 0 <code>glasbey_light</code> 180, 0 <code>glasbey_warm</code> 181, 0 <code>accent</code> 240, 0 <code>dark2</code> 240, 32 <code>paired</code> 240, 64 <code>pastel1</code> 240, 96 <code>pastel2</code> 240, 128 <code>set1</code> 240, 160 <code>set2</code> 240, 192 <code>set3</code> 240, 224 <code>tab10</code> 241, 0 <code>tab20</code> 241, 32 <code>tab20b</code> 241, 64 <code>tab20c</code> 241, 96 <code>category10_10</code> 241, 128 <code>category20_20</code> 241, 160 <code>category20b_20</code> 241, 192 <code>category20c_20</code> 241, 224 <code>colorblind8</code> 242, 0"},{"location":"drp/","title":"Datoviz Rendering Protocol","text":"<p>The main Datoviz API is the scene API. It offers tools to create built-in visuals, manage interactivity controllers, and organize them within a figure.</p> <p>The scene API is built on top of a lower-level API, the Datoviz Rendering Protocol (DRP). This API, similar to WebGPU, provides an asynchronous interface for creating GPU objects such as shaders, graphics pipelines, data buffers, and textures, as well as for generating command buffers. Although currently implemented for desktop use, it can also be adapted for distributed environments.</p> <p>The DRP is defined in the <code>datoviz_protocol.h</code> header file and documented in the API reference. A \"hello world\" example can be found in <code>examples/drp.c</code> and <code>examples/drp.py</code>.</p> <p>Using DRP, you typically generate requests, group them into a batch, and a separate renderer processes these pending requests during the event loop. The architecture is designed with multithreading in mind, though this is not yet officially supported. Requests can be issued at initialization or in response to user events, such as mouse and keyboard inputs or timers.</p>"},{"location":"drp/#usage-example","title":"Usage example","text":"<pre><code>#include &lt;datoviz_protocol.h&gt;\n\n// ...\n\n// Create an application (managing the event loop, renderer, and GPU access).\nDvzApp* app = dvz_app(0);\n\n// Retrieve the batch which all pending requests until they are processed by the app's renderer.\nDvzBatch* batch = dvz_app_batch(app);\n\n// Create requests here.\n\n// Start the event loop. The second argument is the number of frames in the event loop.\n// The application stops afterwards, except if this number is 0, corresponding to an infinite loop.\ndvz_app_run(app, 0);\ndvz_app_destroy(app);\n</code></pre>"},{"location":"drp/#types-of-requests","title":"Types of requests","text":"<p>The API documentation lists all functions that can be used to create requests. They all take the batch as a first argument.</p>"},{"location":"drp/#object-creationdeletion","title":"Object creation/deletion","text":"<p>These functions, that start with <code>dvz_create_</code>, are used to create/delete:</p> <ul> <li>a board (an offscreen canvas)</li> <li>a canvas (a canvas on screen)</li> <li>a dat (GPU data buffer)</li> <li>a tex (GPU 1D, 2D, or 3D texture)</li> <li>a sampler (shader access to images)</li> <li>a shader, either in GLSL (will be compiled by Datoviz via libshaderc) or directly in SPIU-V</li> <li>a graphics pipeline</li> </ul> <p>(Support for compute shaders coming soon).</p>"},{"location":"drp/#resizing","title":"Resizing","text":"<p>These functions, that start with <code>dvz_resize_</code>, are used to resize:</p> <ul> <li>a board</li> <li>a dat</li> <li>a tex</li> </ul>"},{"location":"drp/#uploading","title":"Uploading","text":"<p>These functions, that start with <code>dvz_upload_</code>, are used to upload to the GPU:</p> <ul> <li>a dat</li> <li>a tex</li> </ul>"},{"location":"drp/#graphics-pipelines","title":"Graphics pipelines","text":"<p>These functions, that start with <code>dvz_set_</code>, are used to specify the fixed state function of graphics pipelines and other attributes:</p> <ul> <li>the primitive topology</li> <li>the blend mode</li> <li>the depth test</li> <li>the polygon mode</li> <li>the cull mode</li> <li>the front face</li> <li>the shaders</li> <li>the vertex bindings</li> <li>the vertex attributes</li> <li>the binding slots (descriptors)</li> <li>the specialization constants.</li> </ul>"},{"location":"drp/#bindings","title":"Bindings","text":"<p>These functions, that start with <code>dvz_bind_</code>, are used to bind to graphics pipelines:</p> <ul> <li>a vertex buffer</li> <li>an index buffer</li> <li>a dat as uniform or storage buffer</li> <li>a tex and sampler as a texture</li> </ul>"},{"location":"drp/#command-buffer-recording","title":"Command buffer recording","text":"<p>These functions, that start with <code>dvz_record_</code>, are used to record in the a canvas' command buffer the following commands:</p> <ul> <li>begin a command buffer</li> <li>set a viewport for the next drawing calls</li> <li>draw a graphics pipeline (indexed or not, direct or indirect)</li> <li>end a command buffer</li> </ul> <p>Support for more complex command buffers will be implemented later (in particular, compute pipelines, synchronization mechanisms, multipass rendering).</p>"},{"location":"examples/","title":"Examples","text":"<ul> <li>Basic visual example</li> <li>GUI example</li> <li>Image example</li> <li>Mesh example</li> <li>Path offscreen example</li> <li>Panels example</li> <li>Scatter plot example</li> <li>Spheres example</li> <li>Surface example</li> <li>Volume example</li> <li>Datoviz Rendering Protocol (DRP) example</li> </ul>"},{"location":"examples/#basic-visual-example","title":"Basic visual example","text":"<p>Show a colored triangle using a basic visual.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Basic visual</li> <li>Vertex color interpolation</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/basic.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Basic visual.\nvisual = dvz.basic(batch, dvz.PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, 0)\n\n# Visual data allocation.\ndvz.basic_alloc(visual, 3)\n\n# Positions.\npos = np.array([\n    [-1, -1, 0],\n    [0, 1, 0],\n    [+1, -1, 0],\n]).astype(np.float32)\ndvz.basic_position(visual, 0, 3, pos, 0)\n\n# Colors.\ncolor = np.array(\n    [[255, 0, 0, 255],\n     [0, 255, 0, 255],\n     [0, 0, 255, 255],\n     ]).astype(np.uint8)\ndvz.basic_color(visual, 0, 3, color, 0)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#gui-example","title":"GUI example","text":"<p>Display a simple GUI to control the size of a mesh.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Shape</li> <li>Mesh visual and shape mesh</li> <li>GUI callback</li> <li>GUI dialog</li> <li>GUI buttons</li> <li>Shape transforms</li> <li>Dynamic shape and mesh update</li> </ul> <p>Note: the screenshot does not show the GUI at the moment, this will be fixed soon.</p> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/gui.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import (\n    S_,  # Python string to ctypes char*\n    vec2,\n    vec3,\n    vec4,\n)\n\n\n# GUI callback function.\n@dvz.gui\ndef ongui(app, fid, ev):\n    # Set the size of the next GUI dialog.\n    dvz.gui_size(vec2(170, 110))\n\n    # Start a GUI dialog with a dialog title.\n    dvz.gui_begin(S_(\"My GUI\"), 0)\n\n    # Add two buttons. The functions return whether the button was pressed.\n    incr = dvz.gui_button(S_(\"Increase\"), 150, 30)\n    decr = dvz.gui_button(S_(\"Decrease\"), 150, 30)\n\n    # Scaling factor.\n    scale = 1.0\n    if incr:\n        scale = 1.1\n    elif decr:\n        scale = 0.9\n    if incr or decr:\n\n        # Start recording shape transforms for all vertices in the shape (first=0, count=0=all).\n        dvz.shape_begin(shape, 0, 0)\n\n        # Scaling transform.\n        dvz.shape_scale(shape, vec3(scale, scale, scale))\n\n        # Stop recording the shape transforms.\n        dvz.shape_end(shape)\n\n        # Update the mesh visual data with the new shape's data.\n        dvz.mesh_reshape(visual, shape)\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure.\n# NOTE: to use a GUI, use this flag. Don't use it if there is no GUI.\nfigure = dvz.figure(scene, 800, 800, dvz.CANVAS_FLAGS_IMGUI)\npanel = dvz.panel_default(figure)\narcball = dvz.panel_arcball(panel)\n\n# Cube colors.\ncolors = np.array([\n    [255, 0, 0, 255],\n    [0, 255, 0, 255],\n    [0, 0, 255, 255],\n    [255, 255, 0, 255],\n    [255, 0, 255, 255],\n    [0, 255, 255, 255],\n], dtype=np.uint8)\nshape = dvz.shape_cube(colors)\n\n# Create a mesh visual directly instantiated with the shape data.\nvisual = dvz.mesh_shape(batch, shape, dvz.MESH_FLAGS_LIGHTING)\n\n# Add the visual to the panel.\ndvz.panel_visual(panel, visual, 0)\n\n# Associate a GUI callback function with a figure.\ndvz.app_gui(app, dvz.figure_id(figure), ongui, None)\n\n# Initial arcball angles.\ndvz.arcball_initial(arcball, vec3(+0.6, -1.2, +3.0))\ndvz.panel_update(panel)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.shape_destroy(shape)\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#image-example","title":"Image example","text":"<p>Show an image.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Loading a PNG image with pillow</li> <li>Image visual</li> <li>Creating a texture</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/image.py</code> <pre><code>from pathlib import Path\nimport numpy as np\nfrom PIL import Image\n\nimport datoviz as dvz\nfrom datoviz import A_\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n\n# Load a PNG image.\nCURDIR = Path(__file__).parent\nfilepath = CURDIR / \"../data/textures/image.png\"\nwith Image.open(filepath) as f:\n    image = np.array(f.convert('RGBA'), dtype=np.uint8)\n    height, width = image.shape[:2]\n\n    # Texture parameters.\n    format = dvz.FORMAT_R8G8B8A8_UNORM\n    address_mode = dvz.SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER\n    filter = dvz.FILTER_LINEAR\n\n    # Create a texture out of a RGB image.\n    tex = dvz.tex_image(batch, format, width, height, A_(image))\n\n\n# Create a figure 1000x1000.\nfigure = dvz.figure(scene, 1000, 1000, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Panzoom interactivity.\npz = dvz.panel_panzoom(panel)\n\n# Image visual.\nvisual = dvz.image(batch, dvz.IMAGE_FLAGS_RESCALE)\n\n# One image in this visual, there could be multiple images sharing the same underlying texture.\ndvz.image_alloc(visual, 1)\n\n# xyz coordinates of the top left corner.\npos = np.array([[0, 0, 0]], dtype=np.float32)\ndvz.image_position(visual, 0, 1, pos, 0)\n\n# Image size, in pixels.\nsize = np.array([[width, height]], dtype=np.float32)\ndvz.image_size(visual, 0, 1, size, 0)\n\n# Image anchor.\nanchor = np.array([[.5, .5]], dtype=np.float32)\ndvz.image_anchor(visual, 0, 1, anchor, 0)\n\n# uv coordinates of the top left corner, and bottom right corner.\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\ndvz.image_texcoords(visual, 0, 1, texcoords, 0)\n\n\n# Assign the texture to the visual.\ndvz.image_texture(visual, tex, filter, address_mode)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#mesh-example","title":"Mesh example","text":"<p>Show a 3D mesh.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Arcball interactivity</li> <li>Loading a .OBJ mesh file</li> <li>3D shape</li> <li>Mesh visual and shape mesh</li> <li>Colormaps</li> <li>Manual mesh colors</li> <li>Timer events</li> <li>Dynamic visual updates</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/mesh.py</code> <pre><code>from pathlib import Path\nimport numpy as np\nimport datoviz as dvz\nfrom datoviz import vec3, vec4, S_\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Arcball interactivity.\narcball = dvz.panel_arcball(panel)\n\n# Load a .OBJ mesh file.\nCURDIR = Path(__file__).parent\nfilepath = (CURDIR / \"../data/mesh/brain.obj\").resolve()\nshape = dvz.shape_obj(S_(filepath))\n\n# Fill artificial colors.\nnv = shape.vertex_count\nni = shape.index_count\nprint(f\"Loaded {filepath} with {nv} vertices and {ni // 3} faces.\")\n\n# Create the mesh visual from the surface shape.\nflags = dvz.MESH_FLAGS_LIGHTING\nvisual = dvz.mesh_shape(batch, shape, flags)\n\n# Set artificial vertex colors.\nt = np.linspace(0, 1, nv).astype(np.float32)\ncolors = np.empty((nv, 4), dtype=np.uint8)\ndvz.colormap_array(dvz.CMAP_COOLWARM, nv, t, 0, 1, colors)\ndvz.mesh_color(visual, 0, nv, colors, 0)\n\n# Add the visual to the panel.\ndvz.panel_visual(panel, visual, 0)\n\n# Initial arcball angles.\ndvz.arcball_initial(arcball, vec3(+0.6, -1.2, +3.0))\ndvz.panel_update(panel)\n\n\n# Timer callback: update the arcball angles in real time.\n@dvz.timer\ndef _on_timer(app, window_id, ev):\n    a = 20 * (ev.time % 1)\n    u = 1 / (1 + np.exp(-a * (t - 0.5)))\n\n    dvz.colormap_array(dvz.CMAP_COOLWARM, nv, u.astype(np.float32), 0, 1, colors)\n    dvz.mesh_color(visual, 0, nv, colors, 0)\n\n\n# Create a timer (60 events per second).\ndvz.app_timer(app, 0, 1. / 60., 0)\n\n# Register a timer callback.\ndvz.app_ontimer(app, _on_timer, None)\n\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#path-offscreen-example","title":"Path offscreen example","text":"<p>This path example illustrates how to generate an offscreen image and save it as a PNG.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Path visual</li> <li>Offscreen rendering (save to a PNG image)</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/offscreen.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import (\n    S_,  # Python string to ctypes char*\n)\n\noffscreen = True\n\n# Boilerplate.\napp = dvz.app(dvz.APP_FLAGS_OFFSCREEN if offscreen else 0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure.\nfigure = dvz.figure(scene, 400, 800, 0)\npanel = dvz.panel_default(figure)\n\n# Panzoom interactivity.\npz = dvz.panel_panzoom(panel)\n\n# Path visual.\nvisual = dvz.path(batch, 0)\n\n# Multiple paths.\nn_paths = 100\npath_size = 1000\nn = n_paths * path_size\npath_lengths = np.full(n_paths, path_size, dtype=np.uint32)\ndvz.path_alloc(visual, n)\n\n# Positions.\nx = np.linspace(-1, +1, path_size)\nx = np.tile(x, (n_paths, 1))\nw = np.random.uniform(size=(n_paths, 1), low=20, high=100)\nd = 0.5 / (n_paths - 1)\ny = d * np.sin(w * x)\ny += np.linspace(-1, 1, n_paths).reshape((-1, 1))\nz = np.zeros((n_paths, path_size))\npos = np.c_[x.flat, y.flat, z.flat].astype(np.float32)\ndvz.path_position(visual, n, pos, n_paths, path_lengths, 0)\n\n# Colors.\nt = np.linspace(0, 1, n_paths).astype(np.float32)\ncolor = np.full((n_paths, 4), 255, dtype=np.uint8)\ndvz.colormap_array(dvz.CMAP_HSV, n_paths, t, 0, 1, color)\ncolor = np.repeat(color, path_size, axis=0)\ndvz.path_color(visual, 0, n, color, 0)\n\n# Line width.\ndvz.path_linewidth(visual, 3.0)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Screenshot to ./offscreen.png.\nif offscreen:\n    dvz.app_screenshot(app, dvz.figure_id(figure), S_(\"offscreen_python.png\"))\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#panels-example","title":"Panels example","text":"<p>Show visuals in two different panels.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Point visual</li> <li>Marker visual</li> <li>Multiple panels</li> <li>Mixing 2D and 3D in the same window</li> <li>GUI checkbox</li> <li>Show/hide a visual</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/panels.py</code> <pre><code>import ctypes\nimport numpy as np\nimport datoviz as dvz\nfrom datoviz import vec2, vec3, S_, V_\n\n\n# -------------------------------------------------------------------------------------------------\n# 1. Creating the scene\n# -------------------------------------------------------------------------------------------------\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nw, h = 800, 600\nfigure = dvz.figure(scene, w, h, dvz.CANVAS_FLAGS_IMGUI)\n\n\n# -------------------------------------------------------------------------------------------------\n# 2. First visual\n# -------------------------------------------------------------------------------------------------\n\n# Point visual.\nvisual0 = dvz.point(batch, 0)\n\n# Visual data allocation.\nn = 10_000\ndvz.point_alloc(visual0, n)\n\n# Point positions.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.point_position(visual0, 0, n, pos, 0)\n\n# Point colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ncolor[:, 3] = 240\ndvz.point_color(visual0, 0, n, color, 0)\n\n# Point sizes.\nsize = np.random.uniform(size=(n,), low=10, high=30).astype(np.float32)\ndvz.point_size(visual0, 0, n, size, 0)\n\ndvz.visual_depth(visual0, dvz.DEPTH_TEST_ENABLE)\n\n\n# -------------------------------------------------------------------------------------------------\n# 3. Second visual\n# -------------------------------------------------------------------------------------------------\n\n# Point visual.\nvisual1 = dvz.marker(batch, 0)\n\n# Visual data allocation.\nn = 1_000\ndvz.marker_alloc(visual1, n)\n\n# Marker positions.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.marker_position(visual1, 0, n, pos, 0)\n\n# Marker colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ncolor[:, 3] = 240\ndvz.marker_color(visual1, 0, n, color, 0)\n\n# Marker sizes.\nsize = np.random.uniform(size=(n,), low=30, high=60).astype(np.float32)\ndvz.marker_size(visual1, 0, n, size, 0)\n\n# Marker parameters.\ndvz.marker_aspect(visual1, dvz.MARKER_ASPECT_OUTLINE)\ndvz.marker_shape(visual1, dvz.MARKER_SHAPE_CROSS)\n# dvz.marker_edge_color(visual1, cvec4(255, 255, 255, 255))\n# dvz.marker_edge_width(visual1, 3.0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 4. Panels\n# -------------------------------------------------------------------------------------------------\n\n# Panels.\npanel0 = dvz.panel(figure, 0, 0, w / 2, h)\npanel1 = dvz.panel(figure, w / 2, 0, w / 2, h)\n\ndvz.panel_arcball(panel0)\ndvz.panel_panzoom(panel1)\n\ndvz.panel_visual(panel0, visual0, 0)\ndvz.panel_visual(panel1, visual1, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 5. GUI with checkbox\n# -------------------------------------------------------------------------------------------------\n\n# There are four steps to add a GUI with a checkbox.\n# i.    Initialize the figure with the flag `dvz.CANVAS_FLAGS_IMGUI``\n# ii.   Define a global-scoped object representing the variable to be updated by the GUI.\n# iii.  Define the GUI callback.\n# iv.   Call `dvz.app_gui(...)`\n\n# A wrapped boolean value with initial value False.\nchecked = V_(True, ctypes.c_bool)\n\n\n@dvz.gui\ndef ongui(app, fid, ev):\n    \"\"\"GUI callback function.\"\"\"\n\n    # Set the size of the next GUI dialog.\n    dvz.gui_size(vec2(170, 110))\n\n    # Start a GUI dialog with a dialog title.\n    dvz.gui_begin(S_(\"My GUI\"), 0)\n\n    # Add a checkbox\n    with checked:  # Wrap the boolean value.\n        # Return True if the checkbox's state has changed.\n        if dvz.gui_checkbox(S_(\"Show visual\"), checked.P_):\n            #                                  ^^^^^^^^^^ pass a C pointer to our wrapped bool\n            is_checked = checked.value  # Python variable with the checkbox's state\n\n            # Show/hide the visual.\n            dvz.visual_show(visual0, is_checked)\n\n            # Update the figure after its composition has changed.\n            dvz.figure_update(figure)\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n\n# Associate a GUI callback function with a figure.\ndvz.app_gui(app, dvz.figure_id(figure), ongui, None)\n\n\n# -------------------------------------------------------------------------------------------------\n# 6. Run and cleanup\n# -------------------------------------------------------------------------------------------------\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#scatter-plot-example","title":"Scatter plot example","text":"<p>Show points in 2D with various colors and sizes.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Point visual</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/scatter.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Panzoom interactivity.\npz = dvz.panel_panzoom(panel)\n\n# Point visual.\nvisual = dvz.point(batch, 0)\n\n# Visual data allocation.\nn = 100_000\ndvz.point_alloc(visual, n)\n\n# Point positions.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.point_position(visual, 0, n, pos, 0)\n\n# Point colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ndvz.point_color(visual, 0, n, color, 0)\n\n# Point sizes.\nsize = np.random.uniform(size=(n,), low=10, high=30).astype(np.float32)\ndvz.point_size(visual, 0, n, size, 0)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#spheres-example","title":"Spheres example","text":"<p>Show fake 3D spheres and static text with manual camera control.</p> <p>Illustrates:</p> <ul> <li>Adding multiple visuals to a panel</li> <li>Sphere visual</li> <li>Glyph (text) visual</li> <li>Dynamic and static visual (visual opting out of the global panel transform)</li> <li>Keyboard event callbacks</li> <li>Manual camera control</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/spheres.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import vec2, vec3, vec4, S_\n\n\n# -------------------------------------------------------------------------------------------------\n# 1. Creating the scene\n# -------------------------------------------------------------------------------------------------\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure.\nfigure = dvz.figure(scene, 1000, 1000, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# 3D camera.\ncamera = dvz.panel_camera(panel, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 2. Text\n# -------------------------------------------------------------------------------------------------\n\n# Show a static glyph.\nglyph = dvz.glyph(batch, 0)\n\n# First, we load the default font (Roboto) with a given font size, and we load the pre-generated\n# glyph atlas.\n# NOTE: generating custom atlases dynamically with arbitrary TTF fonts (using the msdfgen library)\n# is possible but undocumented yet.\nfont_size = 32\naf = dvz.atlas_font(font_size)\ndvz.glyph_atlas(glyph, af.atlas)\n\n# Glyph text.\ntext = \"Press the arrow keys!\"\n\n# We specify the number of glyphs.\nn = len(text)\ndvz.glyph_alloc(glyph, n)\n\n# When displaying a single string, all glyph share the exact same position in 3D space, BUT\n# each glyph has a fixed pixel offset due to its relative position within the string (see below).\n# Here, the string will be displayed at (1, 1, 0) (we will not use the panel camera transform).\npos = np.c_[np.ones(n), np.ones(n), np.zeros(n)].astype(np.float32)\ndvz.glyph_position(glyph, 0, n, pos, 0)\n\n# We can assign a different color per glyph.\ncolor = np.full((n, 4), 255, dtype=np.uint8)\ndvz.glyph_color(glyph, 0, n, color, 0)\n\n# We specify the ASCII string (we could also specify unicode uint32 codepoints with glyph_unicode)\n# NOTE: we need to use S_() to pass a Python string to this ctypes-wrapped C function expecting\n# a const char*.\ndvz.glyph_ascii(glyph, S_(text))\n\n# Now we compute the glyph shifts (called \"xywh\") using our font.\nxywh = dvz.font_ascii(af.font, S_(text))\n# We also define a global relative anchor point, in pixels (xy), for the string.\n# By default, the anchor is (0, 0) which represents the lower left corner of the string. The\n# anchor position is the string position defined above (1, 1, 0).\nanchor = vec2(-.5 * font_size * len(text), -2 * font_size)\ndvz.glyph_xywh(glyph, 0, n, xywh, anchor, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 3. Spheres\n# -------------------------------------------------------------------------------------------------\n\n# Now we define a fake sphere visual, similar to markers, but with a fake 3D effect to simulate\n# spheres whereas they are really 2D bitmap sprites in a 3D world.\n# See https://paroj.github.io/gltut/Illumination/Tutorial%2013.html\nvisual = dvz.sphere(batch, 0)\n\n# Sphere data allocation (100 000 spheres).\nn = 100_000\ndvz.sphere_alloc(visual, n)\n\n# Sphere random positions.\npos = np.random.uniform(size=(n, 3), low=-1, high=+1).astype(np.float32)\npos *= np.array([100, 1, 100])\ndvz.sphere_position(visual, 0, n, pos, 0)\n\n# Sphere random colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=200).astype(np.uint8)\ncolor[:, 3] = 255\ndvz.sphere_color(visual, 0, n, color, 0)\n\n# Sphere sizes in pixels.\nsize = np.random.uniform(size=(n,), low=50, high=100).astype(np.float32)\ndvz.sphere_size(visual, 0, n, size, 0)\n\n# Light position.\ndvz.sphere_light_pos(visual, vec3(-5, +5, +100))\n\n# Light parameters.\ndvz.sphere_light_params(visual, vec4(.4, .8, 2, 32))\n\n\n# -------------------------------------------------------------------------------------------------\n# 4. Panel composition\n# -------------------------------------------------------------------------------------------------\n\n# We add the sphere visual.\ndvz.panel_visual(panel, visual, 0)\n\n# We add the glyph visual and we opt out of the panel transform (3D movable camera).\ndvz.panel_visual(panel, glyph, dvz.VIEW_FLAGS_STATIC)\n\n\n# -------------------------------------------------------------------------------------------------\n# 5. Manual camera control\n# -------------------------------------------------------------------------------------------------\n\n# Custom camera manipulation with the keyboard.\n# NOTE: a similar interaction pattern will be soon provided as a builtin option in Datoviz\n# (similar to the existing panzoom and arcball).\n\n# Initial camera position.\neye = vec3(0, 0, 4)\n\n# Camera movement offset.\nd = .2\n\n\n# Keyboard event callback function.\n@dvz.keyboard\ndef on_keyboard(app, window_id, ev):\n    global eye\n    # Keyboard events are PRESS, RELEASE, and REPEAT.\n    if ev.type != dvz.KEYBOARD_EVENT_RELEASE:\n        # Move the camera position depending on the pressed keys.\n        if ev.key == dvz.KEY_UP:\n            eye[2] -= d\n        elif ev.key == dvz.KEY_DOWN:\n            eye[2] += d\n        elif ev.key == dvz.KEY_LEFT:\n            eye[0] -= d\n        elif ev.key == dvz.KEY_RIGHT:\n            eye[0] += d\n\n        # Update the camera position.\n        dvz.camera_position(camera, eye)\n\n        # Update the lookat position (just forward looking).\n        lookat = vec3(*eye)\n        lookat[2] -= 1\n        dvz.camera_lookat(camera, lookat)\n\n        # Important: we must update the panel after the panel transformation parameters\n        # have changed.\n        dvz.panel_update(panel)\n\n\n# We register the keyboard callback function.\ndvz.app_onkeyboard(app, on_keyboard, None)\n\n\n# -------------------------------------------------------------------------------------------------\n# 6. Run and cleanup\n# -------------------------------------------------------------------------------------------------\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.atlas_destroy(af.atlas)\ndvz.font_destroy(af.font)\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#surface-example","title":"Surface example","text":"<p>Show a rotating surface in 3D.</p> <p>Illustrates:</p> <ul> <li>White background</li> <li>Surface shape</li> <li>Mesh visual and surface mesh</li> <li>Arcball interactivity</li> <li>Initial arcball angles</li> <li>Manual arcball parameter update</li> <li>Timers and timer callbacks</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/surface.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import vec3, vec4\n\n# Boilerplate.\napp = dvz.app(dvz.APP_FLAGS_WHITE_BACKGROUND)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Arcball interactivity.\narcball = dvz.panel_arcball(panel)\n\n# Grid parameters.\nrow_count = 250\ncol_count = row_count\nn = row_count * col_count\no = vec3(-1, 0, -1)\nu = vec3(0, 0, 2.0 / (col_count - 1))\nv = vec3(2.0 / (row_count - 1), 0, 0)\n\n# Allocate heights and colors arrays.\ngrid = np.meshgrid(row_count, col_count)\nshape = (row_count, col_count)\nheights = np.zeros(shape, dtype=np.float32)\n\n# Create grid of coordinates\nx = np.arange(col_count)\ny = np.arange(row_count)\nxv, yv = np.meshgrid(x, y)\n\n# Distances.\ncenter_x = col_count / 2\ncenter_y = row_count / 2\nd = np.sqrt((xv - center_x) ** 2 + (yv - center_y) ** 2)\n\n# Heights.\na = 4.0 * 2 * np.pi / row_count\nb = 3.0 * 2 * np.pi / col_count\nc = .5\nhmin = -.5\nhmax = +.5\nheights = np.exp(-.0001 * d ** 2) * np.sin(a*xv) * np.cos(b*yv)\nheights = heights.ravel().astype(np.float32)\n\n# Colors.\ncolors = np.empty((n, 4), dtype=np.uint8)\ndvz.colormap_array(\n    dvz.CMAP_PLASMA, n, heights, hmin, hmax, colors)\n\n# Create the surface shape.\nshape = dvz.shape_surface(row_count, col_count, heights, colors, o, u, v, 0)\n\n# Create the mesh visual from the surface shape.\nflags = dvz.MESH_FLAGS_LIGHTING\nvisual = dvz.mesh_shape(batch, shape, flags)\n\n# Add the visual to the panel.\ndvz.panel_visual(panel, visual, 0)\n\n# Initial arcball angles.\nangle = -0.39686\ndvz.arcball_initial(arcball, vec3(0.42339, angle, -0.00554))\ndvz.panel_update(panel)\n\n\n# Timer callback: update the arcball angles in real time.\n@dvz.timer\ndef _on_timer(app, window_id, ev):\n    global angle\n    angle += .01\n    dvz.arcball_set(arcball, vec3(0.42339, angle, -0.00554))\n    dvz.panel_update(panel)\n\n\n# Create a timer (60 events per second).\ndvz.app_timer(app, 0, 1. / 60., 0)\n\n# Register a timer callback.\ndvz.app_ontimer(app, _on_timer, None)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#volume-example","title":"Volume example","text":"<p>Show a 3D volume.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Arcball interactivity</li> <li>Loading a volume from file</li> <li>Creating a 3D texture</li> <li>Volume visual</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/volume.py</code> <pre><code>import gzip\nfrom pathlib import Path\nimport numpy as np\nimport datoviz as dvz\nfrom datoviz import A_, vec3, vec4\n\n\n# -------------------------------------------------------------------------------------------------\n# 1. Creating the scene\n# -------------------------------------------------------------------------------------------------\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Arcball interactivity.\narcball = dvz.panel_arcball(panel)\n\n\n# -------------------------------------------------------------------------------------------------\n# 2. Loading the volume and creating the 3D GPU texture\n# -------------------------------------------------------------------------------------------------\n\n# Load a volume file.\nCURDIR = Path(__file__).parent\nfilepath = (CURDIR / \"../data/volumes/allen_mouse_brain_rgba.npy.gz\").resolve()\nwith gzip.open(filepath, 'rb') as f:\n    volume_data = np.load(f)\nshape = volume_data.shape\n\n# Volume parameters.\nMOUSE_D, MOUSE_H, MOUSE_W = shape[:3]\nscaling = 1.0 / MOUSE_D\n\n# Create the 3D texture.\nformat = dvz.FORMAT_R8G8B8A8_UNORM\ntex = dvz.tex_volume(batch, format, MOUSE_W, MOUSE_H, MOUSE_D, A_(volume_data))\n\n\n# -------------------------------------------------------------------------------------------------\n# 3. Volume visual\n# -------------------------------------------------------------------------------------------------\n\n# Create the volume visual.\nvisual = dvz.volume(batch, dvz.VOLUME_FLAGS_RGBA)\n\n# Visual data allocation (1 volumetric object).\ndvz.volume_alloc(visual, 1)\n\n# Bind the volume texture to the visual.\nvolume_tex = dvz.volume_texture(\n    visual, tex, dvz.FILTER_LINEAR, dvz.SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE)\n\n# Volume parameters.\ndvz.volume_size(visual, MOUSE_W * scaling, MOUSE_H * scaling, 1)\ndvz.volume_transfer(visual, vec4(1, 0, 0, 0))\n\n\n# Add the visual to the panel AFTER setting the visual's data.\ndvz.panel_visual(panel, visual, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 4. Initial panel parameters\n# -------------------------------------------------------------------------------------------------\n\n# Initial arcball angles.\ndvz.arcball_initial(arcball, vec3(-2.25, 0.65, 1.5))\n\n# Initial camera position.\ncamera = dvz.panel_camera(panel, 0)\ndvz.camera_initial(camera, vec3(0, 0, 1.5), vec3(), vec3(0, 1, 0))\n\n# Update the panel after updating the arcball and camera.\ndvz.panel_update(panel)\n\n\n# -------------------------------------------------------------------------------------------------\n# 5. Run and cleanup\n# -------------------------------------------------------------------------------------------------\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#datoviz-rendering-protocol-drp-example","title":"Datoviz Rendering Protocol (DRP) example","text":"<p>Show a simple triangle using raw DRP requests.</p> <p>Illustrates:</p> <ul> <li>Using the DRP API</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/drp.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\n\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\n\n# Constants.\nwidth = 1024\nheight = 768\n\n# Define the Vertex dtype\nvertex_dtype = np.dtype([\n    ('pos', np.float32, (3,)),  # 3D position (vec3)\n    ('color', np.uint8, (4,))   # RGBA color (cvec4)\n])\nvertex_size = vertex_dtype.itemsize\npos_offset = vertex_dtype.fields['pos'][1]\ncolor_offset = vertex_dtype.fields['color'][1]\n\n\n# Create a canvas.\nreq = dvz.create_canvas(batch, width, height, dvz.DEFAULT_CLEAR_COLOR, 0)\ncanvas_id = req.id\n\n\n# Create a custom graphics.\nreq = dvz.create_graphics(batch, dvz.GRAPHICS_CUSTOM, 0)\ngraphics_id = req.id\n\n\n# Vertex shader.\nvertex_glsl = \"\"\"\n#version 450\n\nlayout(location = 0) in vec3 pos;\nlayout(location = 1) in vec4 color;\nlayout(location = 0) out vec4 out_color;\n\nvoid main()\n{\n    gl_Position = vec4(pos, 1.0);\n    out_color = color;\n}\n\"\"\"\n\nreq = dvz.create_glsl(\n    batch, dvz.SHADER_VERTEX, dvz.S_(vertex_glsl))\n\n# Assign the shader to the graphics pipe.\nvertex_id = req.id\ndvz.set_shader(batch, graphics_id, vertex_id)\n\n\n# Fragment shader.\nfragment_glsl = \"\"\"\n#version 450\n\nlayout(location = 0) in vec4 in_color;\nlayout(location = 0) out vec4 out_color;\n\nvoid main()\n{\n    out_color = in_color;\n}\n\"\"\"\n\nreq = dvz.create_glsl(\n    batch, dvz.SHADER_FRAGMENT, dvz.S_(fragment_glsl))\n\n# Assign the shader to the graphics pipe.\nfragment_id = req.id\ndvz.set_shader(batch, graphics_id, fragment_id)\n\n\n# Primitive topology.\ndvz.set_primitive(batch, graphics_id, dvz.PRIMITIVE_TOPOLOGY_TRIANGLE_LIST)\n\n# Polygon mode.\ndvz.set_polygon(batch, graphics_id, dvz.POLYGON_MODE_FILL)\n\n\n# Vertex binding.\ndvz.set_vertex(\n    batch, graphics_id, 0, vertex_size, dvz.VERTEX_INPUT_RATE_VERTEX)\n\n# Vertex attrs.\ndvz.set_attr(batch, graphics_id, 0, 0, dvz.FORMAT_R32G32B32_SFLOAT, pos_offset)\ndvz.set_attr(batch, graphics_id, 0, 1, dvz.FORMAT_R8G8B8A8_UNORM, color_offset)\n\n\n# Create the vertex buffer dat.\nreq = dvz.create_dat(batch, dvz.BUFFER_TYPE_VERTEX, 3 * vertex_size, 0)\ndat_id = req.id\n\n# Bind the vertex buffer dat to the graphics pipe.\nreq = dvz.bind_vertex(batch, graphics_id, 0, dat_id, 0)\n\n# Upload the triangle data.\ndata = np.array([\n    ((-1, +1, 0), (255, 0, 0, 255)),\n    ((+1, +1, 0), (0, 255, 0, 255)),\n    ((+0, -1, 0), (0, 0, 255, 255)),\n], dtype=vertex_dtype)\nreq = dvz.upload_dat(batch, dat_id, 0, 3 * vertex_size, dvz.A_(data), 0)\n\n\n# Commands.\ndvz.record_begin(batch, canvas_id)\ndvz.record_viewport(\n    batch, canvas_id, dvz.DEFAULT_VIEWPORT, dvz.DEFAULT_VIEWPORT)\ndvz.record_draw(batch, canvas_id, graphics_id, 0, 3, 0, 1)\ndvz.record_end(batch, canvas_id)\n\n\n# Run the application.\n\n# NOTE: disabling this example for now as the current stable version of Datoviz is NOT built with\n# shaderc support, due to compatibility issues on Linux. We'll fix it later.\n# dvz.app_run(app, 0)\n\n# Cleanup.\ndvz.app_destroy(app)\n</code></pre>"},{"location":"userguide/","title":"User guide","text":"<p>Datoviz is a C-first library. It provides auto-generated Python ctypes bindings that closely follow the Datoviz C API.</p> <p>While this user guide focuses on Python for convenience, it can be readily translated into C.</p> <p>To use a Datoviz C function in Python, you typically need to replace the <code>dvz_</code> (functions), <code>DVZ_</code> (enumerations), or <code>Dvz</code> (structures) prefix with <code>dvz.</code> after importing Datoviz with <code>import datoviz as dvz</code>.</p> <p>Please note that this user guide is a work in progress. We strongly recommend looking at the examples (located in the <code>examples/</code> subfolder of the repository) and the auto-generated C API reference (found in <code>docs/api.md</code>).</p>"},{"location":"userguide/#overview","title":"Overview","text":"<p>Creating a GPU-based interactive visualization script with Datoviz in Python typically involves the following steps:</p> <ol> <li>Creating an <code>app</code> and a <code>scene</code>.</li> <li>Creating one or several <code>figures</code> (window).</li> <li>Creating one or several <code>panels</code> (subplots) in each figure, defined by their offset and size in pixels.</li> <li>Creating <code>visuals</code> of predefined types.</li> <li>Setting the visual data (position, size, color, groups...).</li> <li>Optionally, setting up event callbacks (mouse, keyboard, timers...).</li> <li>Optionally, creating GUIs.</li> <li>Running the application.</li> <li>Closing and destroying the <code>scene</code> and <code>app</code>.</li> </ol> <p>GPU knowledge is not required when using this interface. The lower-level GPU-based layers are not yet exposed in the <code>datoviz.h</code> public header file. Contact us if you would be interested in using them in your application.</p>"},{"location":"userguide/#app-and-scene","title":"App and scene","text":"<p>The <code>app</code> handles the window, user events, event loop.</p> <p>The <code>scene</code> handles the panels, visuals, and data.</p> <p>A visualization script is typically organized as follows:</p> <pre><code># This imports the binary libdatoviz shared library.\nimport datoviz as dvz\n\n# Create an application. The argument is reserved to optional flags, like dvz.APP_FLAGS_OFFSCREEN\n# for running an offscreen application (without a window, saving a figure to a PNG file).\n# See the offscreen.py example.\napp = dvz.app(0)\n\n# Retrieve the app's batch, which contains a stream of Datoviz Intermediate Protocol requests that\n# will be processed at the next frame by the app's event loop. It's used to create visuals.\nbatch = dvz.app_batch(app)\n\n# Create a scene, which handles the plotting objects (figures, panels, visuals, data, callbacks).\nscene = dvz.scene(batch)\n\n# ... your code here ...\n\n# Run the application. The last argument is the number of frames (0 = infinite loop).\ndvz.scene_run(scene, app, 0)\n\n# App and scene clean up, memory freeing, etc.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre> <p>Internally, the <code>scene</code> API generates a stream of Datoviz Intermediate Protocol (DIP) requests and sends them to the Datoviz Vulkan renderer (managed by the <code>app</code>). The DIP closely resembles the WebGPU specification. This decoupled architecture ensures that, in the future, the <code>scene</code> API can be implemented on top of other non-Vulkan DIP renderers (including a future JavaScript-based one).</p> <p>Although the architecture is designed with multithreading in mind (allowing for data computation and transfers without blocking the event loop), our primary focus has been on single-threaded applications so far. Multithreading functionality will be provided and documented at a later time.</p>"},{"location":"userguide/#figures","title":"Figures","text":"<p>A <code>Figure</code> is a window on which to draw visuals. It is created as follows:</p> <pre><code># Create a figure with size 800 x 600 and no optional flags.\nfigure = dvz.figure(scene, 800, 600, 0)\n</code></pre>"},{"location":"userguide/#panels","title":"Panels","text":"<p>A <code>Panel</code> is a rectangular portion of a <code>Figure</code> on which to render visuals.</p> <p>You can create a default panel spanning the entire figure as follows:</p> <pre><code>panel = dvz.panel_default(figure)\n</code></pre> <p>Create an arbitrary panel as follows:</p> <pre><code># x, y is the offset of the top left panel corner.\n# w, h is the size in pixels of the panel.\npanel = dvz.panel(figure, x, y, w, h)\n</code></pre>"},{"location":"userguide/#visuals","title":"Visuals","text":"<p>The <code>Visual</code> is the most important object type in Datoviz. It represents a visual collection of similar elements, such as points, markers, segments, glyphs (text), paths, images, meshes, and more.</p> <p>The concept of a collection is crucial for high-performance rendering with GPUs. Visual elements of the same type should be grouped within the same <code>Visual</code> to optimize performance.</p> <p>The primary limitation of grouping elements together is that they currently share the same transform, meaning they share the same coordinate system.</p> <p>Datoviz offers a predefined set of common visuals:</p> <ul> <li>Basic visuals (faster but lower quality than other visuals): <code>basic</code> with an adequate <code>dvz.PRIMITIVE_TOPOLOGY_*</code> enumeration, supporting pixels (<code>POINT_LIST</code>), aliased thin lines (<code>LINE_LIST</code>, <code>LINE_STRIP</code>), triangles (<code>TRIANGLE_LIST</code>, <code>TRIANGLE_STRIP</code>);</li> <li>0D visuals: <code>pixel</code>, <code>point</code> (disc), <code>marker</code>, <code>glyph</code> (string characters rendered on the GPU with multichannel signed distance fields);</li> <li>1D visuals: <code>segment</code>, <code>path</code>;</li> <li>2D visuals: <code>image</code>;</li> <li>3D visuals: <code>mesh</code>, <code>sphere</code> (2D sprites with \"fake\" 3D rendering, also known as impostors), <code>volume</code> (currently using a basic GPU raymarching algorithm), <code>slice</code> (volume image slices).</li> </ul> <p></p> <p>The visuals are implemented on the GPU using advanced antialiasing techniques within the shaders.</p> <p>Additional visuals and the ability to create custom visuals via user-provided shaders will be added in the future.</p> <p>To create a visual, use this:</p> <pre><code># Create a `point` visual with no optional flags.\nvisual = dvz.point(batch, 0)\n</code></pre>"},{"location":"userguide/#visual-data","title":"Visual data","text":"<p>Once a visual is created, you can specify its data using the provided visual-specific functions.</p> <p>The most common types of visual properties are point positions and colors, but each visual has its own specific data properties (e.g., size, shape, groups). For more details, refer to the C API reference.</p>"},{"location":"userguide/#text","title":"Text","text":"<p>Rendering high-quality text on the GPU efficiently is challenging. Several methods have been developed within the graphics community. Datoviz currently offers or plans to offer the following visuals:</p> <ul> <li><code>glyph</code>: Reasonably good quality, supports scaling, but currently not ideal for small font sizes. Utilizes multi-channel signed distance fields. Refer to Chlumsky's code.</li> <li><code>monoglyph</code>: Fast but very low quality and still experimental (may not work on Linux for now). See glumpy's example.</li> <li><code>font</code>: High quality but slow and does not support scaling. Renders on the CPU with freetype.</li> <li><code>vectorglyph</code>: Potentially the most promising option, though not yet implemented! Refer to GreenLightning's code.</li> </ul> <p>Datoviz currently includes the Roboto font and supports loading TTF/OTF fonts directly via freetype, which is a library dependency. Additional fonts may be integrated into Datoviz in the near future.</p> <p>Additionally, we are exploring basic standalone LaTeX rendering in Datoviz, potentially using a micro LaTeX renderer such as MicroTeX. This approach would not require a LaTeX distribution on the client side and would be particularly useful for rendering mathematical equations. This could work via bundling of the New Computer Modern font (<code>NewCMMath-Regular.otf</code>).</p>"},{"location":"userguide/#terminology","title":"Terminology","text":"<p>We use the following terminology:</p> <ul> <li>item: A single visual element, such as a particular point, marker, or a single image within an <code>image</code> visual. Each visual represents a collection of elements, so an <code>image</code> visual may represent one or multiple images.</li> <li>group: A consecutive sequence of items that share common properties. This concept is mostly used in the <code>path</code> visual, where a group refers to an entire path, while an item refers to a point within that path. Thus, a <code>path</code> visual contains a set of points (items) organized into one or multiple disjoint paths (groups).</li> <li>vertex: A 3D point sent to the GPU, which is managed transparently by Datoviz. For example, a single image is represented by two triangles and six vertices. Datoviz automatically handles the triangulation, so you typically don't need to concern yourself with vertices.</li> <li>index: In the mesh visual, an index refers to the set of vertices. A mesh is primarily defined by (1) a set of 3D points (vertices), and (2) a set of index triplets (three indices) that define a triangular face.</li> </ul> <p>A visual represents a collection of <code>n</code> items, indexed from <code>0</code> to <code>n-1</code>.</p>"},{"location":"userguide/#python-ctypes-bindings","title":"Python ctypes bindings","text":"<p>C visual data functions expect pointers to arrays of a specific type, such as an array of <code>vec3</code> (three <code>float32</code> values) for positions, or an array of <code>cvec4</code> (four <code>char</code>, representing RGBA <code>uint8</code> unsigned bytes) for colors.</p> <p>Python ctypes bindings are auto-generated and expect a NumPy array when a C visual data function expects a pointer to an array of values. Currently, the ctypes bindings check the <code>dtype</code>, shape, and C-contiguity of the provided arrays.</p>"},{"location":"userguide/#position","title":"Position","text":"<p>The <code>position</code> property specifies the 3D coordinates of visual points. Some visuals require the point positions in a specific format. For instance, segment positions are defined by the 3D coordinates of the start and end points of each segment. Image positions are currently defined by the 2D coordinates of the top left and bottom right corners, though this may change based on user feedback.</p> <p>To set the positions of a visual, for example the <code>point</code> visual, use this:</p> <p><pre><code># Define a (N, 3) NumPy array of float32 values (one row = one point).\n# Note that the C function dvz_point_position() expects a vec3 array.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\n\n# Set the positions of `n` items starting with item #0.\n# The last argument represents the optional data transfer flags (typically 0).\ndvz.point_position(visual, 0, n, pos, 0)\n</code></pre> The coordinate system is defined as follows:</p> <ul> <li>x: left to right <code>[-1, +1]</code></li> <li>y: bottom to top <code>[-1, +1]</code></li> <li>z: front to back <code>[-1, +1]</code></li> </ul> <p>Positions must be provided in a normalized coordinate system, known as normalized device coordinates (NDC) in computer graphics terminology. Since your data is typically not in this range, you'll need to manually normalize it to the <code>[-1, +1]</code> interval before passing it to Datoviz.</p> <p>Datoviz v0.2 does not yet include built-in axes or data normalization features, but these will be introduced in v0.3.</p>"},{"location":"userguide/#color","title":"Color","text":"<p>Colors are passed as RGBA values, each represented by four <code>uint8</code> values. Use opacity values less than 255 in the last component (the alpha channel, <code>a</code>) to create transparent elements.</p>"},{"location":"userguide/#textures","title":"Textures","text":"<p>Textures are used in the <code>image</code> (2D textures), <code>mesh</code> (2D textures), and <code>volume</code> (3D textures) visuals. Refer to the examples for more details.</p> <p>For example, here\u2019s how to create a 2D texture and apply it to an <code>image</code> visual:</p> <pre><code># Assuming rgba is a 3D NumPy array (height, width, 4).\n# NOTE: the dtype of the NumPy array should match the Vulkan format below.\n# NOTE: Datoviz expects row-major order for arrays (C order)\n# TODO: write a NumPy-Vulkan/Datoviz format correspondance table in the documentation.\n# TODO: write a utility function automatically mapping NumPy dtypes to Vulkan/Datoviz formats.\nheight, width = rgba.shape[:2]\n\n# Texture parameters.\nformat = dvz.FORMAT_R8G8B8A8_UNORM  # This Vulkan format corresponds to 4*uint8 values.\naddress_mode = dvz.SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER  # Texture address mode.\nfilter = dvz.FILTER_LINEAR  # Linear filtering, use dvz.FILTER_NEAREST to disable.\n\n# Create a texture out of a RGB image.\n# NOTE: since dvz_tex_image() accepts any type of pointer, we need to manually convert the NumPy\n# array to a void* pointer. This is done with the `A_()` function (`from datoviz import A_`).\ntex = dvz.tex_image(batch, format, width, height, A_(rgb))\n\n# Finally, we assign this texture to the image visual.\ndvz.image_texture(visual, tex, filter, address_mode)\n</code></pre>"},{"location":"userguide/#data-sharing","title":"Data sharing","text":"<p>Since textures are decoupled from visuals, they can be easily shared across different visuals.</p> <p>However, it is not yet straightforward to share other types of data between visuals. While the underlying architecture is designed to support this, the user-facing API does not currently offer this capability.</p>"},{"location":"userguide/#dynamic-data-updates","title":"Dynamic data updates","text":"<p>You can modify the data of a visual dynamically while the event loop is running, such as in an event callback. After updating a visual, the function <code>dvz.visual_update(visual)</code> is automatically called internally to trigger the data updates on the GPU, so you should not need to call it manually in most cases.</p>"},{"location":"userguide/#shapes","title":"Shapes","text":"<p>The <code>mesh</code> visual can be directly used with properties such as vertices, indices, colors, normals, and texture coordinates. Alternatively, you can use the <code>Shape</code> structure, which encapsulates these arrays. Shapes can be created using functions for predefined forms, along with affine transforms, merging, and other operations.</p>"},{"location":"userguide/#interactivity","title":"Interactivity","text":"<p>Two types of interactivity patterns are currently supported:</p> <ul> <li>Panzoom (2D): Pan with left mouse drag, zoom with right mouse drag.</li> <li>Arcball (3D): Rotate with left mouse drag.</li> </ul> <p>Additional interactivity patterns will be implemented in the future.</p> <p>To define the interactivity pattern in a panel:</p> <pre><code>pz = dvz.panel_panzoom(panel)\n# or\narcball = dvz.panel_arcball(panel)\n</code></pre> <p>Refer to the C API reference for functions you can use to manually control the panzoom or arcball. After updating these interactivity objects, you need to update the panel to apply your changes:</p> <pre><code>dvz.panel_update(panel)\n</code></pre>"},{"location":"userguide/#event-callbacks","title":"Event callbacks","text":"<p>You can define custom event callbacks to respond to mouse and keyboard interactions, as well as set up timers.</p>"},{"location":"userguide/#mouse","title":"Mouse","text":"<p>Define a mouse callback as follows:</p> <pre><code>@dvz.mouse\ndef on_mouse(app, window_id, ev):\n    # Access the mouse event structure.\n    # Mouse position.\n    x, y = ev.pos\n    print(f\"Position {x:.0f},{y:.0f}\")\n    # Detect mouse event type.\n    if ev.type == dvz.MOUSE_EVENT_CLICK:\n        # Identify mouse click button.\n        button = ev.content.b.button\n        print(f\"Clicked with button {button}\")\n</code></pre> <p>The mouse event types are:</p> <pre><code>MOUSE_EVENT_RELEASE             b       DvzMouseButtonEvent\nMOUSE_EVENT_PRESS               b       DvzMouseButtonEvent\nMOUSE_EVENT_MOVE\nMOUSE_EVENT_CLICK               c       DvzMouseClickEvent\nMOUSE_EVENT_DOUBLE_CLICK        c       DvzMouseClickEvent\nMOUSE_EVENT_DRAG_START          d       DvzMouseDragEvent\nMOUSE_EVENT_DRAG                d       DvzMouseDragEvent\nMOUSE_EVENT_DRAG_STOP           d       DvzMouseDragEvent\nMOUSE_EVENT_WHEEL               w       DvzMouseWheelEvent\n</code></pre> <p>Use the corresponding letter after <code>ev.content.</code>, such as <code>ev.content.b</code> for a <code>DvzMouseButtonEvent</code> structure. Refer to the C API reference for more details about the fields in these structures.</p> <p>The mouse buttons are:</p> <pre><code>MOUSE_BUTTON_LEFT = 1\nMOUSE_BUTTON_MIDDLE = 2\nMOUSE_BUTTON_RIGHT = 3\n</code></pre> <p>Datoviz currently does not provide built-in picking functionality. The only information available in mouse event callbacks is the pixel coordinates of the mouse cursor.</p>"},{"location":"userguide/#keyboard","title":"Keyboard","text":"<p>Define a keyboard callback as follows:</p> <pre><code># Keyboard event callback function.\n@dvz.keyboard\ndef on_keyboard(app, window_id, ev):\n\n    # Get the key code (refer to the C API reference).\n    key = ev.key\n\n    # Determine modifier flags.\n    mods = {\n        'shift': ev.mods &amp; dvz.KEY_MODIFIER_SHIFT != 0,\n        'control': ev.mods &amp; dvz.KEY_MODIFIER_CONTROL != 0,\n        'alt': ev.mods &amp; dvz.KEY_MODIFIER_ALT != 0,\n        'sup': ev.mods &amp; dvz.KEY_MODIFIER_SUPER != 0,\n    }\n    mods = '+'.join(key for key, val in mods.items() if val)\n\n    # Identify the keyboard event type (PRESS, RELEASE, REPEAT).\n    type = {\n        dvz.KEYBOARD_EVENT_PRESS: 'press',\n        dvz.KEYBOARD_EVENT_REPEAT: 'repeat',\n        dvz.KEYBOARD_EVENT_RELEASE: 'release',\n    }\n    type = type.get(ev.type, '')\n\n    print(f\"{type} {mods} {key}\")\n\n# Register the keyboard callback function.\ndvz.app_onkeyboard(app, on_keyboard, None)\n</code></pre>"},{"location":"userguide/#timer","title":"Timer","text":"<p>Define a timer as follows:</p> <pre><code># Timer callback.\n@dvz.timer\ndef on_timer(app, window_id, ev):\n    # Use the timer index for identifying multiple timers.\n    idx = ev.timer_idx\n    step = ev.step_idx\n    time = ev.time\n    print(f\"{time:.3f}: timer #{idx}, step {step}\")\n\n# Set the timer frequency.\nfrequency = 4\n\n# Define a timer with this frequency, starting after 0.5 seconds, stopping after 50 ticks.\n# Use 0 as the last argument for an infinite timer.\ndvz.app_timer(app, 0.5, 1. / frequency, 50)\n\n# Register the timer callback.\ndvz.app_ontimer(app, on_timer, None)\n</code></pre>"},{"location":"userguide/#manual-3d-camera-control","title":"Manual 3D camera control","text":"<p>By default, a panel is 2D. To define a 3D panel, you can either use an arcball (see above) or a generic 3D perspective camera. Here's how to define a 3D perspective camera:</p> <pre><code>from datoviz import vec3\n\n# Define a 3D perspective camera.\ncamera = dvz.panel_camera(panel)\n\n# Set the camera position.\ndvz.camera_position(camera, vec3(x, y, z))\n\n# Set the position of the point the camera is looking at.\ndvz.camera_lookat(camera, vec3(lx, ly, lz))\n</code></pre> <p>You can implement custom 3D camera control by calling these functions within mouse and keyboard callbacks. After these camera functions are called, it is crucial to apply the changes to the panel:</p> <pre><code>dvz.panel_update(panel)\n</code></pre>"},{"location":"userguide/#graphical-user-interfaces","title":"Graphical User Interfaces","text":"<p>Datoviz includes basic GUI capabilities via the Dear ImGui C++ library. A future version of Datoviz may allow more direct use of Dear ImGui functionalities beyond the current wrappers.</p> <p>To display a GUI dialog, follow these steps:</p> <ol> <li>Use the <code>dvz.CANVAS_FLAGS_IMGUI</code> flag when creating a figure (last argument of <code>dvz.figure()</code>).</li> <li>Define a GUI callback function.</li> <li>Register the GUI callback function.</li> </ol> <p>Example:</p> <pre><code>from datoviz import vec2, S_\n\n@dvz.gui\ndef on_gui(app, fid, ev):\n    \"\"\"GUI callback function.\"\"\"\n\n    # Set the size of the next GUI dialog.\n    dvz.gui_size(vec2(200, 100))\n\n    # Start a GUI dialog with a title.\n    # Use `S_()` to pass a Python string to a C function expecting a const char*.\n    dvz.gui_begin(S_(\"My GUI dialog\"), 0)\n\n    # Display a button.\n    clicked = dvz.gui_button(S_(\"Click me\"), 150, 30)\n    if clicked:\n        print(\"Clicked!\")\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n# Associate a GUI callback function with a figure.\ndvz.app_gui(app, dvz.figure_id(figure), on_gui, None)\n</code></pre> <p>The GUI callback function is called on every frame. To avoid blocking the main event loop, ensure there is no long-lasting computation within it. Dear ImGui recreates the entire GUI at each frame (immediate mode rendering). GUI widget functions like <code>dvz.gui_button()</code> typically return a boolean indicating whether the widget's state has changed.</p>"},{"location":"userguide/#using-datoviz-in-a-cc-application","title":"Using Datoviz in a C/C++ application","text":"<p>This section provides general instructions for C/C++ developers who want to use Datoviz in their library or application.</p>"},{"location":"userguide/#ubuntu","title":"Ubuntu","text":"<p>Note: to be completed.</p> <p>Install the <code>.deb</code> package and look at the <code>.c</code> examples in <code>examples/</code>.</p>"},{"location":"userguide/#macos-arm64","title":"macOS (arm64)","text":"<p>Looking at the <code>justfile</code> (<code>pkg</code> and <code>testpkg</code> commands) may be helpful. To build an application using Datoviz:</p> <ol> <li>You need to link your application to <code>libdatoviz.dylib</code>, that you can build yourself or find in the provided <code>.pkg</code> installation file.</li> <li>You also need to link to the non-system dependencies of Datoviz, for now they are <code>libvulkan</code>, <code>libshaderc_shared</code>, <code>libMoltenVK</code> (\"emulating\" Vulkan on top of Apple Metal), <code>libpng</code> and <code>freetype</code>. You can see the dependencies with <code>just deps</code> (which uses <code>otool</code> on <code>libdatoviz.dylib</code>). You'll find these dependencies in <code>libs/vulkan/macos</code> in the GitHub repository.</li> <li>You should bundle these <code>dylib</code> dependencies alongside your application, and that will depend on how your application is built and distributed.</li> <li>Note that the <code>just pkg</code> script modifies the rpath of <code>libdatoviz.dylib</code> with <code>install_name_tool</code> before building the <code>.pkg</code> package to declare that its dependencies are to be found in the same directory.</li> <li>Another thing to keep in mind is that, for now, the <code>VK_DRIVER_FILES</code> environment variable needs to be set to the absolute path to <code>libs/vulkan/macos/MoltenVK_icd.json</code> (available in this GitHub repository). The <code>.pkg</code> package installs it to <code>/usr/local/lib/datoviz/MoltenVK_icd.json</code>. Right now, <code>datoviz.h</code> automatically sets this environment variable if it's included in the source file implementing your <code>main()</code> entry-point. These complications are necessary to avoid requiring the end-users to install the Vulkan SDK manually.</li> </ol>"},{"location":"userguide/#windows","title":"Windows","text":"<p>To be completed.</p>"},{"location":"userguide/#technical-notes-for-cc-developers","title":"Technical notes for C/C++ developers","text":"<ul> <li>\ud83e\udde0 Memory management. Datoviz uses opaque pointers and manages its own memory. Porting the relatively light high-level code of Datoviz (scene API) to a more modern and safer language may be considered in the future.</li> <li>\ud83d\udcbb C/C++ usage. Datoviz employs a restricted and straightforward usage of C, with very limited C++ functionality (mostly common dynamic data structures, in ~10% of the code).</li> <li>\ud83d\udcc2 Data copies. When passing data to visuals, data is copied by default to Datoviz for memory safety reasons. This might impact performance and memory usage when handling large datasets (tens of millions of points). We will soon document how to avoid these extra copies and prevent crashes related to Datoviz accessing deallocated memory.</li> <li>\ud83c\udfd7\ufe0f Modular architecture. Datoviz v0.2+ features a modular architecture where the low-level Vulkan-specific rendering engine is decoupled from the higher-level visual and interactive logic. A private asynchronous message-based protocol is used internally, enabling a future Javascript/WebAssembly/WebGPU port of Datoviz, which we plan to work on in the coming years.</li> <li>\ud83d\udc65 Contributing. This modular architecture allows C/C++ contributors without GPU knowledge to propose improvements and new functionality in the higher-level parts.</li> <li>\ud83d\udd17 Bindings. While we provide raw ctypes bindings in Python to the Datoviz C API, our goal is to implement as much functionality in C/C++ to offer the same functionality to other languages that may provide Datoviz bindings in the future (Julia, Rust, R, MATLAB...).</li> </ul>"}]}