{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Datoviz: GPU interactive scientific data visualization with Vulkan \u00b6 Datoviz is an open-source high-performance interactive scientific data visualization library leveraging the graphics processing unit ( GPU ) for speed, visual quality, and scalability. It supports both 2D and 3D rendering, as well as minimal graphical user interfaces (using the Dear ImGUI library ). Written in C/C++ , Datoviz has been designed from the ground up for performance . It provides native Python bindings (based on Cython). Bindings to other languages could be developed thanks to community efforts (Julia, R, MATLAB, Rust, C#, and so on). Datoviz uses the Vulkan graphics API created by the Khronos consortium, successor of OpenGL. Supporting other modern graphics API, such as WebGPU, would constitute interesting developments. Datoviz is currently being developed mostly by Cyrille Rossant at the International Brain Laboratory , a consortium of neuroscience research labs around the world. Note Datoviz is at an early stage of development and the API is not yet stabilized. Use at your own risks, but feel free to share your feedback, suggestions, use-cases, feature requests on GitHub. Screenshots \u00b6 Credits: mouse brain volume: Allen SDK . France: Natural Earth . Molecule: Crystal structure of S. pyogenes Cas9 from PDB (thanks to Eric for conversion to OBJ mesh). Earth: Pixabay . Raster plot: IBL. 3D human brain: Anneke Alkemade et al. 2020 , thanks to Pierre-Louis Bazin and Julia Huntenburg. Code example \u00b6 import numpy as np from datoviz import canvas , run , colormap panel = canvas ( show_fps = True ) . scene () . panel () visual = panel . visual ( 'marker' ) N = 10_000 pos = np . random . randn ( N , 3 ) ms = np . random . uniform ( low = 2 , high = 35 , size = N ) color = colormap ( np . random . rand ( N ), cmap = 'viridis' ) visual . data ( 'pos' , pos ) visual . data ( 'ms' , ms ) visual . data ( 'color' , color ) run () Documentation \u00b6 The documentation is divided into: Installation : install guide, Quick start tutorial with Python, Examples : gallery of Python examples, How to guides : advanced topics explaining how to use the C API, how to create custom visuals... Reference : comprehensive list of included colormaps, visuals, and graphics pipelines, Discussions : high-level discussions, Vulkan crash course... C API reference , Preliminary performance results \u00b6 scatter plot with 10M points: 250 FPS ( point visual) high-resolution 3D mesh with 10M triangles and 5M vertices: 400 FPS 1000 signals with 30K points each (30M vertices): 200 FPS GPU: 2019 NVIDIA GeForce RTX 2070 SUPER. Window size: 1024x768. Features \u00b6 Current features \u00b6 High-quality antialiased 2D visuals : markers, paths, lines (contributions by Nicolas P. Rougier, code from Glumpy ) 3D visuals : meshes Mixing 2D and 3D plots seamlessly in the same window ~150 colormaps included (from matplotlib, colorcet, MATLAB) High-level interactivity : pan & zoom, mouse arcball, first-person cameras Axes : ticks, grids, labels Subplots organized in a grid layout GUIs integrated via the Dear ImGUI C++ library (Qt or other backends not required) Custom visuals , with custom shaders and/or custom data transformations Experimental/work-in-progress features \u00b6 Multiple canvases Builtin creencasts and video recording with ffmpeg (optional dependency) Offscreen rendering and CPU emulation via swiftshader Mouse picking IPython event-loop integration DPI-aware canvases Continuous integration and continuous building Panel linking, shared axes Longer-term features \u00b6 More visuals: arrows, triangulations, planar straight-line graphs (PSLG), histograms, areas, graphs, fake 3D spheres... Further data transformations: logarithmic, polar, basic Earth coordinate systems for geographical data Fixed aspect ratio Colorbars 3D axes Deep zooming CUDA- Vulkan interoperability example Better support of multiple GPUs Qt integration Bindings in other languages (Julia, R, MATLAB, Rust...) Automated benchmarkes Distributed architecture (integration in the web browser, Jupyter...) History and roadmap \u00b6 late 2019: first experiments with using Vulkan for scientific visualization 2020: multiple cycles of prototyping and refactoring 17 Feb 2021 : first public experimental release (manual compilation required) 31 May 2021 : first experimental release v0.1.0-alpha.0 with precompiled pip wheels for Linux, Windows, macOS 20 Oct 2021 : new experimental release v0.1.0-alpha.1 with bug fixes and minor improvements early 2022? : final v0.1.0 release late 2022? : redesigned internal architecture for multithreading and distributed environments (still a work-in-progress) Credits and related projects \u00b6 Datoviz borrows heavily ideas and code from other projects. VisPy \u00b6 VisPy is a Python scientific visualization library created in 2013 by Luke Campagnola (developer of pyqtgraph ), Almar Klein (developer of visvis ), Nicolas Rougier (developer of glumpy ), and myself (Cyrille Rossant, developer of galry ). We joined forces to create a single library unifying all of our approaches. There is today a community of users and projects based on VisPy ( napari ). David Hoese and some of the original VisPy developers are currently maintaining the library. The current version of VisPy suffers from the limitations of OpenGL, a 30-year-old technology. In 2020, VisPy received a 1-year funding from the Chan Zuckerberg Initiative (CZI) to improve the documentation and knowledge base. In 2021, VisPy received another CZI grant for building VisPy 2.0, a completely redesigned library leveraging newer GPU technology such as Vulkan and WebGPU. The current strategy is to rebuild VisPy on top of Datoviz, pygfx (a WebGPU-based library developed by Almar Klein), and other backends. Glumpy \u00b6 Glumpy, developed by Nicolas Rougier, provides efficient implementations of high-quality 2D visuals on the GPU , using algorithms from the antigrain geometry library. The GPU code of most 2D visuals in Datoviz comes directly from Glumpy. Dependencies and algorithms \u00b6 LunarG Vulkan SDK (mandatory) GLFW (mandatory) (support for alternative window backends will be considered) ffmpeg (optional), for making live screencasts libpng (optional), for making PNG screenshots glslang (optional), for compiling GLSL shaders to SPIR-V on the fly earcut (included), developed by Mapbox, for polygon triangulations triangle (included), developed by Jonathan Richard Shewchuk, for Delaunay triangulations extended Wilkinson algorithm (included) for tick placement Dear ImGUI (included) antigrain geometry ( GLSL implementation included) msdfgen : multi-channel signed distance field (to do: bundle as submodule?) freetype (optional) Related projects \u00b6 mayavi VTK napari vedo ipygany ipyvolume Makie.jl Funding \u00b6 Datoviz is being developed by Cyrille Rossant at the International Brain Laboratory , with funding from the Simons Foundation, the Flatiron Institute, the Wellcome Trust, INCF. The logo was graciously created by Chiara Zini . Glossary:","title":"Home"},{"location":"#datoviz-gpu-interactive-scientific-data-visualization-with-vulkan","text":"Datoviz is an open-source high-performance interactive scientific data visualization library leveraging the graphics processing unit ( GPU ) for speed, visual quality, and scalability. It supports both 2D and 3D rendering, as well as minimal graphical user interfaces (using the Dear ImGUI library ). Written in C/C++ , Datoviz has been designed from the ground up for performance . It provides native Python bindings (based on Cython). Bindings to other languages could be developed thanks to community efforts (Julia, R, MATLAB, Rust, C#, and so on). Datoviz uses the Vulkan graphics API created by the Khronos consortium, successor of OpenGL. Supporting other modern graphics API, such as WebGPU, would constitute interesting developments. Datoviz is currently being developed mostly by Cyrille Rossant at the International Brain Laboratory , a consortium of neuroscience research labs around the world. Note Datoviz is at an early stage of development and the API is not yet stabilized. Use at your own risks, but feel free to share your feedback, suggestions, use-cases, feature requests on GitHub.","title":"Datoviz: GPU interactive scientific data visualization with Vulkan"},{"location":"#screenshots","text":"Credits: mouse brain volume: Allen SDK . France: Natural Earth . Molecule: Crystal structure of S. pyogenes Cas9 from PDB (thanks to Eric for conversion to OBJ mesh). Earth: Pixabay . Raster plot: IBL. 3D human brain: Anneke Alkemade et al. 2020 , thanks to Pierre-Louis Bazin and Julia Huntenburg.","title":"Screenshots"},{"location":"#code-example","text":"import numpy as np from datoviz import canvas , run , colormap panel = canvas ( show_fps = True ) . scene () . panel () visual = panel . visual ( 'marker' ) N = 10_000 pos = np . random . randn ( N , 3 ) ms = np . random . uniform ( low = 2 , high = 35 , size = N ) color = colormap ( np . random . rand ( N ), cmap = 'viridis' ) visual . data ( 'pos' , pos ) visual . data ( 'ms' , ms ) visual . data ( 'color' , color ) run ()","title":"Code example"},{"location":"#documentation","text":"The documentation is divided into: Installation : install guide, Quick start tutorial with Python, Examples : gallery of Python examples, How to guides : advanced topics explaining how to use the C API, how to create custom visuals... Reference : comprehensive list of included colormaps, visuals, and graphics pipelines, Discussions : high-level discussions, Vulkan crash course... C API reference ,","title":"Documentation"},{"location":"#preliminary-performance-results","text":"scatter plot with 10M points: 250 FPS ( point visual) high-resolution 3D mesh with 10M triangles and 5M vertices: 400 FPS 1000 signals with 30K points each (30M vertices): 200 FPS GPU: 2019 NVIDIA GeForce RTX 2070 SUPER. Window size: 1024x768.","title":"Preliminary performance results"},{"location":"#features","text":"","title":"Features"},{"location":"#current-features","text":"High-quality antialiased 2D visuals : markers, paths, lines (contributions by Nicolas P. Rougier, code from Glumpy ) 3D visuals : meshes Mixing 2D and 3D plots seamlessly in the same window ~150 colormaps included (from matplotlib, colorcet, MATLAB) High-level interactivity : pan & zoom, mouse arcball, first-person cameras Axes : ticks, grids, labels Subplots organized in a grid layout GUIs integrated via the Dear ImGUI C++ library (Qt or other backends not required) Custom visuals , with custom shaders and/or custom data transformations","title":"Current features"},{"location":"#experimentalwork-in-progress-features","text":"Multiple canvases Builtin creencasts and video recording with ffmpeg (optional dependency) Offscreen rendering and CPU emulation via swiftshader Mouse picking IPython event-loop integration DPI-aware canvases Continuous integration and continuous building Panel linking, shared axes","title":"Experimental/work-in-progress features"},{"location":"#longer-term-features","text":"More visuals: arrows, triangulations, planar straight-line graphs (PSLG), histograms, areas, graphs, fake 3D spheres... Further data transformations: logarithmic, polar, basic Earth coordinate systems for geographical data Fixed aspect ratio Colorbars 3D axes Deep zooming CUDA- Vulkan interoperability example Better support of multiple GPUs Qt integration Bindings in other languages (Julia, R, MATLAB, Rust...) Automated benchmarkes Distributed architecture (integration in the web browser, Jupyter...)","title":"Longer-term features"},{"location":"#history-and-roadmap","text":"late 2019: first experiments with using Vulkan for scientific visualization 2020: multiple cycles of prototyping and refactoring 17 Feb 2021 : first public experimental release (manual compilation required) 31 May 2021 : first experimental release v0.1.0-alpha.0 with precompiled pip wheels for Linux, Windows, macOS 20 Oct 2021 : new experimental release v0.1.0-alpha.1 with bug fixes and minor improvements early 2022? : final v0.1.0 release late 2022? : redesigned internal architecture for multithreading and distributed environments (still a work-in-progress)","title":"History and\u00a0roadmap"},{"location":"#credits-and-related-projects","text":"Datoviz borrows heavily ideas and code from other projects.","title":"Credits and related projects"},{"location":"#vispy","text":"VisPy is a Python scientific visualization library created in 2013 by Luke Campagnola (developer of pyqtgraph ), Almar Klein (developer of visvis ), Nicolas Rougier (developer of glumpy ), and myself (Cyrille Rossant, developer of galry ). We joined forces to create a single library unifying all of our approaches. There is today a community of users and projects based on VisPy ( napari ). David Hoese and some of the original VisPy developers are currently maintaining the library. The current version of VisPy suffers from the limitations of OpenGL, a 30-year-old technology. In 2020, VisPy received a 1-year funding from the Chan Zuckerberg Initiative (CZI) to improve the documentation and knowledge base. In 2021, VisPy received another CZI grant for building VisPy 2.0, a completely redesigned library leveraging newer GPU technology such as Vulkan and WebGPU. The current strategy is to rebuild VisPy on top of Datoviz, pygfx (a WebGPU-based library developed by Almar Klein), and other backends.","title":"VisPy"},{"location":"#glumpy","text":"Glumpy, developed by Nicolas Rougier, provides efficient implementations of high-quality 2D visuals on the GPU , using algorithms from the antigrain geometry library. The GPU code of most 2D visuals in Datoviz comes directly from Glumpy.","title":"Glumpy"},{"location":"#dependencies-and-algorithms","text":"LunarG Vulkan SDK (mandatory) GLFW (mandatory) (support for alternative window backends will be considered) ffmpeg (optional), for making live screencasts libpng (optional), for making PNG screenshots glslang (optional), for compiling GLSL shaders to SPIR-V on the fly earcut (included), developed by Mapbox, for polygon triangulations triangle (included), developed by Jonathan Richard Shewchuk, for Delaunay triangulations extended Wilkinson algorithm (included) for tick placement Dear ImGUI (included) antigrain geometry ( GLSL implementation included) msdfgen : multi-channel signed distance field (to do: bundle as submodule?) freetype (optional)","title":"Dependencies and algorithms"},{"location":"#related-projects","text":"mayavi VTK napari vedo ipygany ipyvolume Makie.jl","title":"Related projects"},{"location":"#funding","text":"Datoviz is being developed by Cyrille Rossant at the International Brain Laboratory , with funding from the Simons Foundation, the Flatiron Institute, the Wellcome Trust, INCF. The logo was graciously created by Chiara Zini . Glossary:","title":"Funding"},{"location":"api/","text":"C API documentation \u00b6 Scene API Visual API Controller API GUI API Canvas API GPU API vklite API Misc API Enumerations","title":"Index"},{"location":"api/#c-api-documentation","text":"Scene API Visual API Controller API GUI API Canvas API GPU API vklite API Misc API Enumerations","title":"C API documentation"},{"location":"api/canvas/","text":"Canvas API \u00b6 Canvas \u00b6 dvz_canvas_commands() \u00b6 Create a set of Vulkan command buffers on a given GPU queue. DvzCommands * dvz_canvas_commands ( DvzCanvas * canvas , uint32_t queue_idx , uint32_t count ); Parameter Type Description canvas DvzCanvas* the canvas queue_idx uint32_t the index of the GPU queue within the GPU context count uint32_t number of command buffers to create returns DvzCommands* set of created command buffers dvz_canvas_clear_color() \u00b6 Change the background color of a canvas. void dvz_canvas_clear_color ( DvzCanvas * canvas , float red , float green , float blue ); Parameter Type Description canvas DvzCanvas* the canvas red float the red component, between 0 and 1 green float the green component, between 0 and 1 blue float the blue component, between 0 and 1 Note A command buffer refill will be triggered so as to record them again with the updated clear color value. dvz_canvas_size() \u00b6 Get the canvas size. void dvz_canvas_size ( DvzCanvas * canvas , DvzCanvasSizeType type , uvec2 size ); Parameter Type Description canvas DvzCanvas* the canvas type DvzCanvasSizeType the unit of the requested screen size size uvec2 the size vector filled by this function dvz_canvas_aspect() \u00b6 Get the canvas aspect ratio. double dvz_canvas_aspect ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas ratio None the canvas aspect ratio (width / height) dvz_canvas_close_on_esc() \u00b6 Whether the canvas should close when Escape is pressed. void dvz_canvas_close_on_esc ( DvzCanvas * canvas , bool value ); Parameter Type Description canvas DvzCanvas* the canvas value bool the boolean value dvz_canvas_recreate() \u00b6 Recreate the canvas GPU resources and swapchain. void dvz_canvas_recreate ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas to recreate dvz_canvas_resize() \u00b6 Resize a canvas. void dvz_canvas_resize ( DvzCanvas * canvas , uint32_t width , uint32_t height ); Parameter Type Description canvas DvzCanvas* the canvas to resize width uint32_t the new width height uint32_t the new height dvz_canvas_buffers() \u00b6 Upload fast-changing data to a special mappable buffer at every canvas frame. void dvz_canvas_buffers ( DvzCanvas * canvas , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , const void * data ); Parameter Type Description canvas DvzCanvas* the canvas br DvzBufferRegions the buffer regions offset VkDeviceSize the offset size VkDeviceSize the data size data void* the data to upload This function is used to upload MVP matrices at every frame in the scene interface. There are several constraints: the buffer must have the uniform mappable type there must be as many buffer regions as there are swapchain images in the canvas this function must be called at every frame. dvz_canvas_to_refill() \u00b6 Trigger a canvas refill at the next frame. void dvz_canvas_to_refill ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_canvas_to_close() \u00b6 Close the canvas at the next frame. void dvz_canvas_to_close ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_canvases_destroy() \u00b6 Destroy all canvases. void dvz_canvases_destroy ( DvzContainer * canvases ); Parameter Type Description canvases DvzContainer* the container with the canvases. Misc \u00b6 dvz_viewport_full() \u00b6 Get the viewport corresponding to the full canvas. DvzViewport dvz_viewport_full ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzViewport viewport dvz_viewport_default() \u00b6 Create a default viewport. DvzViewport dvz_viewport_default ( uint32_t width , uint32_t height ); Parameter Type Description width uint32_t the framebuffer width height uint32_t the framebuffer height returns DvzViewport viewport Event emitting \u00b6 dvz_event_mouse_press() \u00b6 Emit a mouse press event. void dvz_event_mouse_press ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_release() \u00b6 Emit a mouse release event. void dvz_event_mouse_release ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_move() \u00b6 Emit a mouse move event. void dvz_event_mouse_move ( DvzCanvas * canvas , vec2 pos , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the current mouse position, in pixels modifiers int flags with the active keyboard modifiers dvz_event_mouse_wheel() \u00b6 Emit a mouse wheel event. void dvz_event_mouse_wheel ( DvzCanvas * canvas , vec2 pos , vec2 dir , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the current mouse position, in pixels dir vec2 the mouse wheel direction modifiers int flags with the active keyboard modifiers dvz_event_mouse_click() \u00b6 Emit a mouse click event. void dvz_event_mouse_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_double_click() \u00b6 Emit a mouse double-click event. void dvz_event_mouse_double_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the double-click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_drag() \u00b6 Emit a mouse drag event. void dvz_event_mouse_drag ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag start position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_drag_end() \u00b6 Emit a mouse drag end event. void dvz_event_mouse_drag_end ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag end position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_key_press() \u00b6 Emit a key press event. void dvz_event_key_press ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers dvz_event_key_release() \u00b6 Emit a key release event. void dvz_event_key_release ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers dvz_event_frame() \u00b6 Emit a frame event. void dvz_event_frame ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the frame index time double the current time interval double the interval since the last frame event Typically raised at every canvas frame. dvz_event_timer() \u00b6 Emit a timer event. void dvz_event_timer ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the timer event index time double the current time interval double the interval since the last timer event Screencast \u00b6 dvz_screencast() \u00b6 Prepare the canvas for a screencast. void dvz_screencast ( DvzCanvas * canvas , double interval , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas interval double screencast events interval has_alpha bool whether the screencast array is RGB or RGBA A screencast is a live record of one or several frames of the canvas during the interactive execution of the app. Creating a screencast is required for: - screenshots, - video records (requires ffmpeg) This command creates a host-coherent GPU image with the same size as the current framebuffer size. If the interval is non-zero, the canvas will raise periodic SCREENCAST events every interval seconds. The event payload will contain a pointer to the grabbed framebuffer image. dvz_screencast_destroy() \u00b6 Destroy the screencast. void dvz_screencast_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_screenshot() \u00b6 Make a screenshot. uint8_t * dvz_screenshot ( DvzCanvas * canvas , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas returns uint8_t* pointer to the 24-bit RGB framebuffer. This function creates a screencast if there isn't one already. It is implemented with hard synchronization commands so this command should not be used for creating many successive screenshots. For that, one should register a SCREENCAST event callback. Important The caller MUST free the output pointer. dvz_screenshot_file() \u00b6 Make a screenshot and save it to a PNG file. void dvz_screenshot_file ( DvzCanvas * canvas , const char * png_path ); Parameter Type Description canvas DvzCanvas* the canvas png_path char* the path to the PNG file to create Note This function uses full GPU synchronization methods so it is relatively inefficient. More efficient methods are not yet implemented. dvz_canvas_video() \u00b6 Record a live screencast video of the canvas. void dvz_canvas_video ( DvzCanvas * canvas , int framerate , int bitrate , const char * path , bool record ); Parameter Type Description canvas DvzCanvas* the canvas framerate int the framerate in images per second (30 recommended) bitrate int the bitrate, in bytes (10000000 for high quality) path char* path to the file (.mp4 extension recommended) record bool whether to start recording immediately or not This function should be run before calling dvz_app_run() . dvz_canvas_pause() \u00b6 Pause the live video screencast. void dvz_canvas_pause ( DvzCanvas * canvas , bool record ); Parameter Type Description canvas DvzCanvas* the canvas record bool whether to pause or continue the recording dvz_canvas_stop() \u00b6 Stop the live video screencast and save the file. void dvz_canvas_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas Internal event loop \u00b6 dvz_canvas_frame() \u00b6 Process a single frame in the event loop and present it to the window. int dvz_canvas_frame ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns int if the frame was successfully presented, 1 othersiwe This function probably never needs to be called directly, unless writing a custom backend. dvz_canvas_frame_submit() \u00b6 Submit the rendered frame to the swapchain system. void dvz_canvas_frame_submit ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas Internal event system \u00b6 dvz_event_callback() \u00b6 Register a callback for canvas events. void dvz_event_callback ( DvzCanvas * canvas , DvzEventType type , double param , DvzEventMode mode , DvzEventCallback callback , void * user_data ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type param double time interval for TIMER events, in seconds mode DvzEventMode whether the callback is sync or async callback DvzEventCallback the callback function user_data void* a pointer to arbitrary user data These user callbacks run either in the main thread ( sync callbacks) or in the background thread * ( async callbacks). Callbacks can access the DvzMouse and DvzKeyboard structures with the current state of the mouse and keyboard. Callback function signature: void(DvzCanvas*, DvzEvent) The event object has a field with the user-specified pointer user_data . dvz_event_pending() \u00b6 Return the number of pending events. int dvz_event_pending ( DvzCanvas * canvas , DvzEventType type ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type returns int number of pending events This is the number of events of the given type that are still being processed or pending in the queue. dvz_event_stop() \u00b6 Stop the background event loop. void dvz_event_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas This function sends a special \"closing\" event to the event loop, causing it to stop. dvz_mouse() \u00b6 Create the mouse object holding the current mouse state. DvzMouse dvz_mouse ( void ); | returns | DvzMouse | object | dvz_mouse_toggle() \u00b6 Active or deactivate interactive mouse events. void dvz_mouse_toggle ( DvzMouse * mouse , bool enable ); Parameter Type Description mouse DvzMouse* the mouse object enable bool whether to activate or deactivate mouse events dvz_mouse_reset() \u00b6 Reset the mouse state. void dvz_mouse_reset ( DvzMouse * mouse ); Parameter Type Description mouse DvzMouse* the mouse object dvz_mouse_event() \u00b6 Emit a mouse event. void dvz_mouse_event ( DvzMouse * mouse , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description mouse DvzMouse* the mouse object canvas DvzCanvas* the canvas ev DvzEvent the mouse event dvz_mouse_local() \u00b6 Convert mouse coordinates from global to local. void dvz_mouse_local ( DvzMouse * mouse , DvzMouseLocal * mouse_local , DvzCanvas * canvas , DvzViewport viewport ); Parameter Type Description mouse DvzMouse* the mouse object mouse_local DvzMouseLocal* the mouse local object canvas DvzCanvas* the canvas viewport DvzViewport the viewport defining the local coordinates Global coordinates: in pixels, origin at the top-left corner of the window. Local coordinates: in normalize coordinates [-1, 1], origin at the center of a given viewport, taking viewport margins into account dvz_keyboard() \u00b6 Create the keyboard object holding the current keyboard state. DvzKeyboard dvz_keyboard ( void ); | returns | DvzKeyboard | object | dvz_keyboard_toggle() \u00b6 Active or deactivate interactive keyboard events. void dvz_keyboard_toggle ( DvzKeyboard * keyboard , bool enable ); Parameter Type Description keyboard DvzKeyboard* the keyboard object enable bool whether to activate or deactivate keyboard events dvz_keyboard_reset() \u00b6 Reset the keyboard state void dvz_keyboard_reset ( DvzKeyboard * keyboard ); | returns | void | object | dvz_keyboard_event() \u00b6 Emit a keyboard event. void dvz_keyboard_event ( DvzKeyboard * keyboard , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description keyboard DvzKeyboard* the keyboard object canvas DvzCanvas* the canvas ev DvzEvent the keyboard event","title":"Canvas API"},{"location":"api/canvas/#canvas-api","text":"","title":"Canvas API"},{"location":"api/canvas/#canvas","text":"","title":"Canvas"},{"location":"api/canvas/#dvz_canvas_commands","text":"Create a set of Vulkan command buffers on a given GPU queue. DvzCommands * dvz_canvas_commands ( DvzCanvas * canvas , uint32_t queue_idx , uint32_t count ); Parameter Type Description canvas DvzCanvas* the canvas queue_idx uint32_t the index of the GPU queue within the GPU context count uint32_t number of command buffers to create returns DvzCommands* set of created command buffers","title":"dvz_canvas_commands()"},{"location":"api/canvas/#dvz_canvas_clear_color","text":"Change the background color of a canvas. void dvz_canvas_clear_color ( DvzCanvas * canvas , float red , float green , float blue ); Parameter Type Description canvas DvzCanvas* the canvas red float the red component, between 0 and 1 green float the green component, between 0 and 1 blue float the blue component, between 0 and 1 Note A command buffer refill will be triggered so as to record them again with the updated clear color value.","title":"dvz_canvas_clear_color()"},{"location":"api/canvas/#dvz_canvas_size","text":"Get the canvas size. void dvz_canvas_size ( DvzCanvas * canvas , DvzCanvasSizeType type , uvec2 size ); Parameter Type Description canvas DvzCanvas* the canvas type DvzCanvasSizeType the unit of the requested screen size size uvec2 the size vector filled by this function","title":"dvz_canvas_size()"},{"location":"api/canvas/#dvz_canvas_aspect","text":"Get the canvas aspect ratio. double dvz_canvas_aspect ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas ratio None the canvas aspect ratio (width / height)","title":"dvz_canvas_aspect()"},{"location":"api/canvas/#dvz_canvas_close_on_esc","text":"Whether the canvas should close when Escape is pressed. void dvz_canvas_close_on_esc ( DvzCanvas * canvas , bool value ); Parameter Type Description canvas DvzCanvas* the canvas value bool the boolean value","title":"dvz_canvas_close_on_esc()"},{"location":"api/canvas/#dvz_canvas_recreate","text":"Recreate the canvas GPU resources and swapchain. void dvz_canvas_recreate ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas to recreate","title":"dvz_canvas_recreate()"},{"location":"api/canvas/#dvz_canvas_resize","text":"Resize a canvas. void dvz_canvas_resize ( DvzCanvas * canvas , uint32_t width , uint32_t height ); Parameter Type Description canvas DvzCanvas* the canvas to resize width uint32_t the new width height uint32_t the new height","title":"dvz_canvas_resize()"},{"location":"api/canvas/#dvz_canvas_buffers","text":"Upload fast-changing data to a special mappable buffer at every canvas frame. void dvz_canvas_buffers ( DvzCanvas * canvas , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , const void * data ); Parameter Type Description canvas DvzCanvas* the canvas br DvzBufferRegions the buffer regions offset VkDeviceSize the offset size VkDeviceSize the data size data void* the data to upload This function is used to upload MVP matrices at every frame in the scene interface. There are several constraints: the buffer must have the uniform mappable type there must be as many buffer regions as there are swapchain images in the canvas this function must be called at every frame.","title":"dvz_canvas_buffers()"},{"location":"api/canvas/#dvz_canvas_to_refill","text":"Trigger a canvas refill at the next frame. void dvz_canvas_to_refill ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_to_refill()"},{"location":"api/canvas/#dvz_canvas_to_close","text":"Close the canvas at the next frame. void dvz_canvas_to_close ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_to_close()"},{"location":"api/canvas/#dvz_canvases_destroy","text":"Destroy all canvases. void dvz_canvases_destroy ( DvzContainer * canvases ); Parameter Type Description canvases DvzContainer* the container with the canvases.","title":"dvz_canvases_destroy()"},{"location":"api/canvas/#misc","text":"","title":"Misc"},{"location":"api/canvas/#dvz_viewport_full","text":"Get the viewport corresponding to the full canvas. DvzViewport dvz_viewport_full ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzViewport viewport","title":"dvz_viewport_full()"},{"location":"api/canvas/#dvz_viewport_default","text":"Create a default viewport. DvzViewport dvz_viewport_default ( uint32_t width , uint32_t height ); Parameter Type Description width uint32_t the framebuffer width height uint32_t the framebuffer height returns DvzViewport viewport","title":"dvz_viewport_default()"},{"location":"api/canvas/#event-emitting","text":"","title":"Event emitting"},{"location":"api/canvas/#dvz_event_mouse_press","text":"Emit a mouse press event. void dvz_event_mouse_press ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_press()"},{"location":"api/canvas/#dvz_event_mouse_release","text":"Emit a mouse release event. void dvz_event_mouse_release ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_release()"},{"location":"api/canvas/#dvz_event_mouse_move","text":"Emit a mouse move event. void dvz_event_mouse_move ( DvzCanvas * canvas , vec2 pos , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the current mouse position, in pixels modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_move()"},{"location":"api/canvas/#dvz_event_mouse_wheel","text":"Emit a mouse wheel event. void dvz_event_mouse_wheel ( DvzCanvas * canvas , vec2 pos , vec2 dir , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the current mouse position, in pixels dir vec2 the mouse wheel direction modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_wheel()"},{"location":"api/canvas/#dvz_event_mouse_click","text":"Emit a mouse click event. void dvz_event_mouse_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_click()"},{"location":"api/canvas/#dvz_event_mouse_double_click","text":"Emit a mouse double-click event. void dvz_event_mouse_double_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the double-click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_double_click()"},{"location":"api/canvas/#dvz_event_mouse_drag","text":"Emit a mouse drag event. void dvz_event_mouse_drag ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag start position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_drag()"},{"location":"api/canvas/#dvz_event_mouse_drag_end","text":"Emit a mouse drag end event. void dvz_event_mouse_drag_end ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag end position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_drag_end()"},{"location":"api/canvas/#dvz_event_key_press","text":"Emit a key press event. void dvz_event_key_press ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers","title":"dvz_event_key_press()"},{"location":"api/canvas/#dvz_event_key_release","text":"Emit a key release event. void dvz_event_key_release ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers","title":"dvz_event_key_release()"},{"location":"api/canvas/#dvz_event_frame","text":"Emit a frame event. void dvz_event_frame ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the frame index time double the current time interval double the interval since the last frame event Typically raised at every canvas frame.","title":"dvz_event_frame()"},{"location":"api/canvas/#dvz_event_timer","text":"Emit a timer event. void dvz_event_timer ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the timer event index time double the current time interval double the interval since the last timer event","title":"dvz_event_timer()"},{"location":"api/canvas/#screencast","text":"","title":"Screencast"},{"location":"api/canvas/#dvz_screencast","text":"Prepare the canvas for a screencast. void dvz_screencast ( DvzCanvas * canvas , double interval , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas interval double screencast events interval has_alpha bool whether the screencast array is RGB or RGBA A screencast is a live record of one or several frames of the canvas during the interactive execution of the app. Creating a screencast is required for: - screenshots, - video records (requires ffmpeg) This command creates a host-coherent GPU image with the same size as the current framebuffer size. If the interval is non-zero, the canvas will raise periodic SCREENCAST events every interval seconds. The event payload will contain a pointer to the grabbed framebuffer image.","title":"dvz_screencast()"},{"location":"api/canvas/#dvz_screencast_destroy","text":"Destroy the screencast. void dvz_screencast_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_screencast_destroy()"},{"location":"api/canvas/#dvz_screenshot","text":"Make a screenshot. uint8_t * dvz_screenshot ( DvzCanvas * canvas , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas returns uint8_t* pointer to the 24-bit RGB framebuffer. This function creates a screencast if there isn't one already. It is implemented with hard synchronization commands so this command should not be used for creating many successive screenshots. For that, one should register a SCREENCAST event callback. Important The caller MUST free the output pointer.","title":"dvz_screenshot()"},{"location":"api/canvas/#dvz_screenshot_file","text":"Make a screenshot and save it to a PNG file. void dvz_screenshot_file ( DvzCanvas * canvas , const char * png_path ); Parameter Type Description canvas DvzCanvas* the canvas png_path char* the path to the PNG file to create Note This function uses full GPU synchronization methods so it is relatively inefficient. More efficient methods are not yet implemented.","title":"dvz_screenshot_file()"},{"location":"api/canvas/#dvz_canvas_video","text":"Record a live screencast video of the canvas. void dvz_canvas_video ( DvzCanvas * canvas , int framerate , int bitrate , const char * path , bool record ); Parameter Type Description canvas DvzCanvas* the canvas framerate int the framerate in images per second (30 recommended) bitrate int the bitrate, in bytes (10000000 for high quality) path char* path to the file (.mp4 extension recommended) record bool whether to start recording immediately or not This function should be run before calling dvz_app_run() .","title":"dvz_canvas_video()"},{"location":"api/canvas/#dvz_canvas_pause","text":"Pause the live video screencast. void dvz_canvas_pause ( DvzCanvas * canvas , bool record ); Parameter Type Description canvas DvzCanvas* the canvas record bool whether to pause or continue the recording","title":"dvz_canvas_pause()"},{"location":"api/canvas/#dvz_canvas_stop","text":"Stop the live video screencast and save the file. void dvz_canvas_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_stop()"},{"location":"api/canvas/#internal-event-loop","text":"","title":"Internal event loop"},{"location":"api/canvas/#dvz_canvas_frame","text":"Process a single frame in the event loop and present it to the window. int dvz_canvas_frame ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns int if the frame was successfully presented, 1 othersiwe This function probably never needs to be called directly, unless writing a custom backend.","title":"dvz_canvas_frame()"},{"location":"api/canvas/#dvz_canvas_frame_submit","text":"Submit the rendered frame to the swapchain system. void dvz_canvas_frame_submit ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_frame_submit()"},{"location":"api/canvas/#internal-event-system","text":"","title":"Internal event system"},{"location":"api/canvas/#dvz_event_callback","text":"Register a callback for canvas events. void dvz_event_callback ( DvzCanvas * canvas , DvzEventType type , double param , DvzEventMode mode , DvzEventCallback callback , void * user_data ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type param double time interval for TIMER events, in seconds mode DvzEventMode whether the callback is sync or async callback DvzEventCallback the callback function user_data void* a pointer to arbitrary user data These user callbacks run either in the main thread ( sync callbacks) or in the background thread * ( async callbacks). Callbacks can access the DvzMouse and DvzKeyboard structures with the current state of the mouse and keyboard. Callback function signature: void(DvzCanvas*, DvzEvent) The event object has a field with the user-specified pointer user_data .","title":"dvz_event_callback()"},{"location":"api/canvas/#dvz_event_pending","text":"Return the number of pending events. int dvz_event_pending ( DvzCanvas * canvas , DvzEventType type ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type returns int number of pending events This is the number of events of the given type that are still being processed or pending in the queue.","title":"dvz_event_pending()"},{"location":"api/canvas/#dvz_event_stop","text":"Stop the background event loop. void dvz_event_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas This function sends a special \"closing\" event to the event loop, causing it to stop.","title":"dvz_event_stop()"},{"location":"api/canvas/#dvz_mouse","text":"Create the mouse object holding the current mouse state. DvzMouse dvz_mouse ( void ); | returns | DvzMouse | object |","title":"dvz_mouse()"},{"location":"api/canvas/#dvz_mouse_toggle","text":"Active or deactivate interactive mouse events. void dvz_mouse_toggle ( DvzMouse * mouse , bool enable ); Parameter Type Description mouse DvzMouse* the mouse object enable bool whether to activate or deactivate mouse events","title":"dvz_mouse_toggle()"},{"location":"api/canvas/#dvz_mouse_reset","text":"Reset the mouse state. void dvz_mouse_reset ( DvzMouse * mouse ); Parameter Type Description mouse DvzMouse* the mouse object","title":"dvz_mouse_reset()"},{"location":"api/canvas/#dvz_mouse_event","text":"Emit a mouse event. void dvz_mouse_event ( DvzMouse * mouse , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description mouse DvzMouse* the mouse object canvas DvzCanvas* the canvas ev DvzEvent the mouse event","title":"dvz_mouse_event()"},{"location":"api/canvas/#dvz_mouse_local","text":"Convert mouse coordinates from global to local. void dvz_mouse_local ( DvzMouse * mouse , DvzMouseLocal * mouse_local , DvzCanvas * canvas , DvzViewport viewport ); Parameter Type Description mouse DvzMouse* the mouse object mouse_local DvzMouseLocal* the mouse local object canvas DvzCanvas* the canvas viewport DvzViewport the viewport defining the local coordinates Global coordinates: in pixels, origin at the top-left corner of the window. Local coordinates: in normalize coordinates [-1, 1], origin at the center of a given viewport, taking viewport margins into account","title":"dvz_mouse_local()"},{"location":"api/canvas/#dvz_keyboard","text":"Create the keyboard object holding the current keyboard state. DvzKeyboard dvz_keyboard ( void ); | returns | DvzKeyboard | object |","title":"dvz_keyboard()"},{"location":"api/canvas/#dvz_keyboard_toggle","text":"Active or deactivate interactive keyboard events. void dvz_keyboard_toggle ( DvzKeyboard * keyboard , bool enable ); Parameter Type Description keyboard DvzKeyboard* the keyboard object enable bool whether to activate or deactivate keyboard events","title":"dvz_keyboard_toggle()"},{"location":"api/canvas/#dvz_keyboard_reset","text":"Reset the keyboard state void dvz_keyboard_reset ( DvzKeyboard * keyboard ); | returns | void | object |","title":"dvz_keyboard_reset()"},{"location":"api/canvas/#dvz_keyboard_event","text":"Emit a keyboard event. void dvz_keyboard_event ( DvzKeyboard * keyboard , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description keyboard DvzKeyboard* the keyboard object canvas DvzCanvas* the canvas ev DvzEvent the keyboard event","title":"dvz_keyboard_event()"},{"location":"api/controller/","text":"Controller API \u00b6 Controller utilities \u00b6 dvz_camera_pos() \u00b6 Set the camera position. void dvz_camera_pos ( DvzPanel * panel , vec3 pos ); Parameter Type Description panel DvzPanel* the panel pos vec3 the position in scene coordinates dvz_camera_look() \u00b6 Set the camera center position (the position the camera points to). void dvz_camera_look ( DvzPanel * panel , vec3 center ); Parameter Type Description panel DvzPanel* the panel center vec3 the center position dvz_arcball_rotate() \u00b6 Set the arcball rotation. void dvz_arcball_rotate ( DvzPanel * panel , float angle , vec3 axis ); Parameter Type Description panel DvzPanel* the panel angle float the rotation angle axis vec3 the rotation angle dvz_mvp_camera() \u00b6 Set up a 3D camera on a Model-View-Projection (MVP) object. void dvz_mvp_camera ( DvzViewport viewport , vec3 eye , vec3 center , vec2 near_far , DvzMVP * mvp ); Parameter Type Description viewport DvzViewport the viewport eye vec3 the camera position in scene coordinates center vec3 the position the camera points to near_far vec2 the near and far values for the perspective matrix mvp DvzMVP* a pointer to an MVP object Internal controller \u00b6 dvz_controller() \u00b6 Create a custom controller. DvzController dvz_controller ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzController controller structure dvz_controller_visual() \u00b6 Add a visual to a controller. void dvz_controller_visual ( DvzController * controller , DvzVisual * visual ); Parameter Type Description controller DvzController* the controller visual DvzVisual* the visual dvz_controller_interact() \u00b6 Add an interact to a controller. void dvz_controller_interact ( DvzController * controller , DvzInteractType type ); Parameter Type Description controller DvzController* the controller interact None the interact dvz_controller_callback() \u00b6 Specify a controller frame callback. void dvz_controller_callback ( DvzController * controller , DvzControllerCallback callback ); Parameter Type Description controller DvzController* the controller callback DvzControllerCallback the callback Callback signature: void(DvzController* controller, DvzEvent ev); dvz_controller_update() \u00b6 Update a controller. void dvz_controller_update ( DvzController * controller ); Parameter Type Description controller DvzController* the controller Not yet implemented dvz_controller_destroy() \u00b6 Destroy a controller. void dvz_controller_destroy ( DvzController * controller ); Parameter Type Description controller DvzController* the controller dvz_controller_builtin() \u00b6 Create a builtin controller. DvzController dvz_controller_builtin ( DvzPanel * panel , DvzControllerType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzControllerType the controller type flags int flags for the builtin controller returns DvzController controller Transform \u00b6 dvz_transform_pos() \u00b6 Apply a CPU builtin transformation on position data. void dvz_transform_pos ( DvzDataCoords coords , DvzArray * pos_in , DvzArray * pos_out , bool inverse ); Parameter Type Description coords DvzDataCoords the data coordinate system and bounds pos_in DvzArray* input array of dvec3 values pos_out DvzArray* output array of dvec3 values inverse bool whether to use the inverse or forward transformation dvz_transform() \u00b6 Convert a 3D position from a coordinate system to another. void dvz_transform ( DvzPanel * panel , DvzCDS source , dvec3 pos_in , DvzCDS target , dvec3 pos_out ); Parameter Type Description panel DvzPanel* the panel source DvzCDS the source coordinate system in None the input position target DvzCDS the target coordinate system out None the output (transformed) position","title":"Controller API"},{"location":"api/controller/#controller-api","text":"","title":"Controller API"},{"location":"api/controller/#controller-utilities","text":"","title":"Controller utilities"},{"location":"api/controller/#dvz_camera_pos","text":"Set the camera position. void dvz_camera_pos ( DvzPanel * panel , vec3 pos ); Parameter Type Description panel DvzPanel* the panel pos vec3 the position in scene coordinates","title":"dvz_camera_pos()"},{"location":"api/controller/#dvz_camera_look","text":"Set the camera center position (the position the camera points to). void dvz_camera_look ( DvzPanel * panel , vec3 center ); Parameter Type Description panel DvzPanel* the panel center vec3 the center position","title":"dvz_camera_look()"},{"location":"api/controller/#dvz_arcball_rotate","text":"Set the arcball rotation. void dvz_arcball_rotate ( DvzPanel * panel , float angle , vec3 axis ); Parameter Type Description panel DvzPanel* the panel angle float the rotation angle axis vec3 the rotation angle","title":"dvz_arcball_rotate()"},{"location":"api/controller/#dvz_mvp_camera","text":"Set up a 3D camera on a Model-View-Projection (MVP) object. void dvz_mvp_camera ( DvzViewport viewport , vec3 eye , vec3 center , vec2 near_far , DvzMVP * mvp ); Parameter Type Description viewport DvzViewport the viewport eye vec3 the camera position in scene coordinates center vec3 the position the camera points to near_far vec2 the near and far values for the perspective matrix mvp DvzMVP* a pointer to an MVP object","title":"dvz_mvp_camera()"},{"location":"api/controller/#internal-controller","text":"","title":"Internal controller"},{"location":"api/controller/#dvz_controller","text":"Create a custom controller. DvzController dvz_controller ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzController controller structure","title":"dvz_controller()"},{"location":"api/controller/#dvz_controller_visual","text":"Add a visual to a controller. void dvz_controller_visual ( DvzController * controller , DvzVisual * visual ); Parameter Type Description controller DvzController* the controller visual DvzVisual* the visual","title":"dvz_controller_visual()"},{"location":"api/controller/#dvz_controller_interact","text":"Add an interact to a controller. void dvz_controller_interact ( DvzController * controller , DvzInteractType type ); Parameter Type Description controller DvzController* the controller interact None the interact","title":"dvz_controller_interact()"},{"location":"api/controller/#dvz_controller_callback","text":"Specify a controller frame callback. void dvz_controller_callback ( DvzController * controller , DvzControllerCallback callback ); Parameter Type Description controller DvzController* the controller callback DvzControllerCallback the callback Callback signature: void(DvzController* controller, DvzEvent ev);","title":"dvz_controller_callback()"},{"location":"api/controller/#dvz_controller_update","text":"Update a controller. void dvz_controller_update ( DvzController * controller ); Parameter Type Description controller DvzController* the controller Not yet implemented","title":"dvz_controller_update()"},{"location":"api/controller/#dvz_controller_destroy","text":"Destroy a controller. void dvz_controller_destroy ( DvzController * controller ); Parameter Type Description controller DvzController* the controller","title":"dvz_controller_destroy()"},{"location":"api/controller/#dvz_controller_builtin","text":"Create a builtin controller. DvzController dvz_controller_builtin ( DvzPanel * panel , DvzControllerType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzControllerType the controller type flags int flags for the builtin controller returns DvzController controller","title":"dvz_controller_builtin()"},{"location":"api/controller/#transform","text":"","title":"Transform"},{"location":"api/controller/#dvz_transform_pos","text":"Apply a CPU builtin transformation on position data. void dvz_transform_pos ( DvzDataCoords coords , DvzArray * pos_in , DvzArray * pos_out , bool inverse ); Parameter Type Description coords DvzDataCoords the data coordinate system and bounds pos_in DvzArray* input array of dvec3 values pos_out DvzArray* output array of dvec3 values inverse bool whether to use the inverse or forward transformation","title":"dvz_transform_pos()"},{"location":"api/controller/#dvz_transform","text":"Convert a 3D position from a coordinate system to another. void dvz_transform ( DvzPanel * panel , DvzCDS source , dvec3 pos_in , DvzCDS target , dvec3 pos_out ); Parameter Type Description panel DvzPanel* the panel source DvzCDS the source coordinate system in None the input position target DvzCDS the target coordinate system out None the output (transformed) position","title":"dvz_transform()"},{"location":"api/enums/","text":"Enumerations \u00b6 Scene \u00b6 DvzControllerType \u00b6 Name Value DVZ_CONTROLLER_NONE 0 DVZ_CONTROLLER_PANZOOM 1 DVZ_CONTROLLER_AXES_2D 2 DVZ_CONTROLLER_ARCBALL 3 DVZ_CONTROLLER_CAMERA 4 DVZ_CONTROLLER_AXES_3D 5 Visuals \u00b6 DvzMarkerType \u00b6 Name Value DVZ_MARKER_DISC 0 DVZ_MARKER_ASTERISK 1 DVZ_MARKER_CHEVRON 2 DVZ_MARKER_CLOVER 3 DVZ_MARKER_CLUB 4 DVZ_MARKER_CROSS 5 DVZ_MARKER_DIAMOND 6 DVZ_MARKER_ARROW 7 DVZ_MARKER_ELLIPSE 8 DVZ_MARKER_HBAR 9 DVZ_MARKER_HEART 10 DVZ_MARKER_INFINITY 11 DVZ_MARKER_PIN 12 DVZ_MARKER_RING 13 DVZ_MARKER_SPADE 14 DVZ_MARKER_SQUARE 15 DVZ_MARKER_TAG 16 DVZ_MARKER_TRIANGLE 17 DVZ_MARKER_VBAR 18 DVZ_MARKER_COUNT 19 DvzJoinType \u00b6 Name Value DVZ_JOIN_SQUARE False DVZ_JOIN_ROUND True DvzCapType \u00b6 Name Value DVZ_CAP_TYPE_NONE 0 DVZ_CAP_ROUND 1 DVZ_CAP_TRIANGLE_IN 2 DVZ_CAP_TRIANGLE_OUT 3 DVZ_CAP_SQUARE 4 DVZ_CAP_BUTT 5 DVZ_CAP_COUNT 6 DvzPathTopology \u00b6 Name Value DVZ_PATH_OPEN 0 DVZ_PATH_CLOSED 1 Colormaps \u00b6 The following colormaps, in addition to being stored in the colormap texture, are also implemented directly in GLSL. They may thereby be used directly from shaders without using the colormap texture. Avoiding texture lookup is sometimes faster. This is implemented in the function vec4 colormap(int cmap, float x) in colormaps.glsl . Colormap DVZ_CMAP_HSV DVZ_CMAP_CIVIDIS DVZ_CMAP_INFERNO DVZ_CMAP_MAGMA DVZ_CMAP_PLASMA DVZ_CMAP_VIRIDIS DVZ_CMAP_AUTUMN DVZ_CMAP_BONE DVZ_CMAP_COOL DVZ_CMAP_COPPER DVZ_CMAP_HOT DVZ_CMAP_SPRING DVZ_CMAP_SUMMER DVZ_CMAP_WINTER DVZ_CMAP_JET Miscellaneous \u00b6 DvzDataType \u00b6 Name Value DVZ_DTYPE_NONE 0 DVZ_DTYPE_CUSTOM 1 DVZ_DTYPE_STR 2 DVZ_DTYPE_CHAR 3 DVZ_DTYPE_CVEC2 4 DVZ_DTYPE_CVEC3 5 DVZ_DTYPE_CVEC4 6 DVZ_DTYPE_USHORT 7 DVZ_DTYPE_USVEC2 8 DVZ_DTYPE_USVEC3 9 DVZ_DTYPE_USVEC4 10 DVZ_DTYPE_SHORT 11 DVZ_DTYPE_SVEC2 12 DVZ_DTYPE_SVEC3 13 DVZ_DTYPE_SVEC4 14 DVZ_DTYPE_UINT 15 DVZ_DTYPE_UVEC2 16 DVZ_DTYPE_UVEC3 17 DVZ_DTYPE_UVEC4 18 DVZ_DTYPE_INT 19 DVZ_DTYPE_IVEC2 20 DVZ_DTYPE_IVEC3 21 DVZ_DTYPE_IVEC4 22 DVZ_DTYPE_FLOAT 23 DVZ_DTYPE_VEC2 24 DVZ_DTYPE_VEC3 25 DVZ_DTYPE_VEC4 26 DVZ_DTYPE_DOUBLE 27 DVZ_DTYPE_DVEC2 28 DVZ_DTYPE_DVEC3 29 DVZ_DTYPE_DVEC4 30 DVZ_DTYPE_MAT2 31 DVZ_DTYPE_MAT3 32 DVZ_DTYPE_MAT4 33 Flags \u00b6 Note Flags specification for the canvas, scene, visuals, controllers are still being improved and may change at any time. Canvas flags \u00b6 0x0001: ImGUI 0x0002: FPS 0x0003: FPS+FPS GUI 0x0004: enable picking 0xD000: DPI scaling (D=1..4 for 50%, 100%, 150%, 200%) Panel flags \u00b6 0x00XX: transform 0xXX00: controller-specific flags Visual flags \u00b6 0x000X: visual-specific flags 0x00X0: POS prop transformation flags 0x0X00: graphics flags (0x0100: enable depth test) 0xX000: interact axes Axes \u00b6 Axes visual flags: 0x000X`, X=0 (x axis) or X=1 (y axis). When using an axes controller, the controller-specific flags in 0x0X00 (to hide minor/grid level) are passed to the axes visual flags as 0x000X (bit shift). Note that the first bit must be reserved to the axis coordinate (0/1), so we use higher bits for the axes flags (4 and 8).","title":"Enumerations"},{"location":"api/enums/#enumerations","text":"","title":"Enumerations"},{"location":"api/enums/#scene","text":"","title":"Scene"},{"location":"api/enums/#dvzcontrollertype","text":"Name Value DVZ_CONTROLLER_NONE 0 DVZ_CONTROLLER_PANZOOM 1 DVZ_CONTROLLER_AXES_2D 2 DVZ_CONTROLLER_ARCBALL 3 DVZ_CONTROLLER_CAMERA 4 DVZ_CONTROLLER_AXES_3D 5","title":"DvzControllerType"},{"location":"api/enums/#visuals","text":"","title":"Visuals"},{"location":"api/enums/#dvzmarkertype","text":"Name Value DVZ_MARKER_DISC 0 DVZ_MARKER_ASTERISK 1 DVZ_MARKER_CHEVRON 2 DVZ_MARKER_CLOVER 3 DVZ_MARKER_CLUB 4 DVZ_MARKER_CROSS 5 DVZ_MARKER_DIAMOND 6 DVZ_MARKER_ARROW 7 DVZ_MARKER_ELLIPSE 8 DVZ_MARKER_HBAR 9 DVZ_MARKER_HEART 10 DVZ_MARKER_INFINITY 11 DVZ_MARKER_PIN 12 DVZ_MARKER_RING 13 DVZ_MARKER_SPADE 14 DVZ_MARKER_SQUARE 15 DVZ_MARKER_TAG 16 DVZ_MARKER_TRIANGLE 17 DVZ_MARKER_VBAR 18 DVZ_MARKER_COUNT 19","title":"DvzMarkerType"},{"location":"api/enums/#dvzjointype","text":"Name Value DVZ_JOIN_SQUARE False DVZ_JOIN_ROUND True","title":"DvzJoinType"},{"location":"api/enums/#dvzcaptype","text":"Name Value DVZ_CAP_TYPE_NONE 0 DVZ_CAP_ROUND 1 DVZ_CAP_TRIANGLE_IN 2 DVZ_CAP_TRIANGLE_OUT 3 DVZ_CAP_SQUARE 4 DVZ_CAP_BUTT 5 DVZ_CAP_COUNT 6","title":"DvzCapType"},{"location":"api/enums/#dvzpathtopology","text":"Name Value DVZ_PATH_OPEN 0 DVZ_PATH_CLOSED 1","title":"DvzPathTopology"},{"location":"api/enums/#colormaps","text":"The following colormaps, in addition to being stored in the colormap texture, are also implemented directly in GLSL. They may thereby be used directly from shaders without using the colormap texture. Avoiding texture lookup is sometimes faster. This is implemented in the function vec4 colormap(int cmap, float x) in colormaps.glsl . Colormap DVZ_CMAP_HSV DVZ_CMAP_CIVIDIS DVZ_CMAP_INFERNO DVZ_CMAP_MAGMA DVZ_CMAP_PLASMA DVZ_CMAP_VIRIDIS DVZ_CMAP_AUTUMN DVZ_CMAP_BONE DVZ_CMAP_COOL DVZ_CMAP_COPPER DVZ_CMAP_HOT DVZ_CMAP_SPRING DVZ_CMAP_SUMMER DVZ_CMAP_WINTER DVZ_CMAP_JET","title":"Colormaps"},{"location":"api/enums/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"api/enums/#dvzdatatype","text":"Name Value DVZ_DTYPE_NONE 0 DVZ_DTYPE_CUSTOM 1 DVZ_DTYPE_STR 2 DVZ_DTYPE_CHAR 3 DVZ_DTYPE_CVEC2 4 DVZ_DTYPE_CVEC3 5 DVZ_DTYPE_CVEC4 6 DVZ_DTYPE_USHORT 7 DVZ_DTYPE_USVEC2 8 DVZ_DTYPE_USVEC3 9 DVZ_DTYPE_USVEC4 10 DVZ_DTYPE_SHORT 11 DVZ_DTYPE_SVEC2 12 DVZ_DTYPE_SVEC3 13 DVZ_DTYPE_SVEC4 14 DVZ_DTYPE_UINT 15 DVZ_DTYPE_UVEC2 16 DVZ_DTYPE_UVEC3 17 DVZ_DTYPE_UVEC4 18 DVZ_DTYPE_INT 19 DVZ_DTYPE_IVEC2 20 DVZ_DTYPE_IVEC3 21 DVZ_DTYPE_IVEC4 22 DVZ_DTYPE_FLOAT 23 DVZ_DTYPE_VEC2 24 DVZ_DTYPE_VEC3 25 DVZ_DTYPE_VEC4 26 DVZ_DTYPE_DOUBLE 27 DVZ_DTYPE_DVEC2 28 DVZ_DTYPE_DVEC3 29 DVZ_DTYPE_DVEC4 30 DVZ_DTYPE_MAT2 31 DVZ_DTYPE_MAT3 32 DVZ_DTYPE_MAT4 33","title":"DvzDataType"},{"location":"api/enums/#flags","text":"Note Flags specification for the canvas, scene, visuals, controllers are still being improved and may change at any time.","title":"Flags"},{"location":"api/enums/#canvas-flags","text":"0x0001: ImGUI 0x0002: FPS 0x0003: FPS+FPS GUI 0x0004: enable picking 0xD000: DPI scaling (D=1..4 for 50%, 100%, 150%, 200%)","title":"Canvas flags"},{"location":"api/enums/#panel-flags","text":"0x00XX: transform 0xXX00: controller-specific flags","title":"Panel flags"},{"location":"api/enums/#visual-flags","text":"0x000X: visual-specific flags 0x00X0: POS prop transformation flags 0x0X00: graphics flags (0x0100: enable depth test) 0xX000: interact axes","title":"Visual flags"},{"location":"api/enums/#axes","text":"Axes visual flags: 0x000X`, X=0 (x axis) or X=1 (y axis). When using an axes controller, the controller-specific flags in 0x0X00 (to hide minor/grid level) are passed to the axes visual flags as 0x000X (bit shift). Note that the first bit must be reserved to the axis coordinate (0/1), so we use higher bits for the axes flags (4 and 8).","title":"Axes"},{"location":"api/gpu/","text":"GPU context and objects \u00b6 Context \u00b6 dvz_context() \u00b6 Create a context associated to a GPU. DvzContext * dvz_context ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU Note The GPU must have been created beforehand. dvz_context_reset() \u00b6 Destroy all GPU resources in a GPU context. void dvz_context_reset ( DvzContext * context ); Parameter Type Description context DvzContext* the context dvz_app_reset() \u00b6 Reset all GPUs. void dvz_app_reset ( DvzApp * app ); Parameter Type Description app DvzApp* the application instance dvz_context_destroy() \u00b6 Destroy a context. void dvz_context_destroy ( DvzContext * context ); Parameter Type Description context DvzContext* the context Buffers \u00b6 dvz_ctx_buffers() \u00b6 Allocate one of several buffer regions on the GPU. DvzBufferRegions dvz_ctx_buffers ( DvzContext * context , DvzBufferType buffer_type , uint32_t buffer_count , VkDeviceSize size ); Parameter Type Description context DvzContext* the context buffer_type DvzBufferType the type of buffer to allocate the regions on buffer_count uint32_t the number of buffer regions to allocate size VkDeviceSize the size of each region to allocate, in bytes dvz_ctx_buffers_resize() \u00b6 Resize a set of buffer regions. void dvz_ctx_buffers_resize ( DvzContext * context , DvzBufferRegions * br , VkDeviceSize new_size ); Parameter Type Description context DvzContext* the context br DvzBufferRegions* the buffer regions to resize new_size VkDeviceSize the new size of each buffer region, in bytes Textures \u00b6 dvz_ctx_texture() \u00b6 Create a new GPU texture. DvzTexture * dvz_ctx_texture ( DvzContext * context , uint32_t dims , uvec3 size , VkFormat format ); Parameter Type Description context DvzContext* the context dims uint32_t the number of dimensions of the texture (1, 2, or 3) size uvec3 the width, height, and depth format VkFormat the format of each pixel dvz_texture_resize() \u00b6 Resize a texture. void dvz_texture_resize ( DvzTexture * texture , uvec3 size ); Parameter Type Description texture DvzTexture* the texture size uvec3 the new size (width, height, depth) Warning This function will delete the texture data. dvz_texture_filter() \u00b6 Set the texture filter. void dvz_texture_filter ( DvzTexture * texture , DvzFilterType type , VkFilter filter ); Parameter Type Description texture DvzTexture* the texture type DvzFilterType the filter type filter VkFilter the filter dvz_texture_address_mode() \u00b6 Set the texture address mode. void dvz_texture_address_mode ( DvzTexture * texture , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description texture DvzTexture* the texture axis DvzTextureAxis the axis address_mode VkSamplerAddressMode the address mode dvz_texture_upload() \u00b6 Upload data to a GPU texture. void dvz_texture_upload ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , const void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to update size VkDeviceSize size of the data to upload, in bytes data void* pointer to the data to upload Note This function should not be used to update a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead. dvz_texture_download() \u00b6 Download a texture from the GPU to the CPU. void dvz_texture_download ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to download size VkDeviceSize size of the data to download, in bytes data void* pointer to the buffer to download to (should be already allocated) Note This function should not be used to download from a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead. dvz_texture_copy() \u00b6 Copy part of a texture to another texture. void dvz_texture_copy ( DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape ); Parameter Type Description src DvzTexture* the source texture src_offset uvec3 offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 offset within the target texture shape uvec3 shape of the part of the texture to copy This function does not involve CPU-GPU data transfers. dvz_texture_transition() \u00b6 Transition a texture to its layout. void dvz_texture_transition ( DvzTexture * tex ); Parameter Type Description texture None the texture to transition dvz_texture_destroy() \u00b6 Destroy a texture. void dvz_texture_destroy ( DvzTexture * texture ); Parameter Type Description texture DvzTexture* the texture Compute pipeline \u00b6 dvz_ctx_compute() \u00b6 Create a new compute pipeline. DvzCompute * dvz_ctx_compute ( DvzContext * context , const char * shader_path ); Parameter Type Description context DvzContext* the context shader_path char* path to the .spirv file containing the compute shader Data transfers \u00b6 dvz_upload_buffer() \u00b6 Upload data to 1 or N buffer regions on the GPU while the app event loop is running. void dvz_upload_buffer ( DvzContext * context , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to the data to upload to the GPU dvz_download_buffer() \u00b6 Download data from a buffer region to the CPU while the app event loop is running. void dvz_download_buffer ( DvzContext * context , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to a buffer already allocated to contain size bytes dvz_copy_buffer() \u00b6 Copy data between two GPU buffer regions. void dvz_copy_buffer ( DvzContext * context , DvzBufferRegions src , VkDeviceSize src_offset , DvzBufferRegions dst , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description canvas None the canvas src DvzBufferRegions the buffer region to copy from src_offset VkDeviceSize the offset within the source buffer region dst DvzBufferRegions the buffer region to copy to dst_offset VkDeviceSize the offset within the target buffer region size VkDeviceSize the size of the data to copy This function does not involve GPU-CPU data transfers. dvz_upload_texture() \u00b6 Upload data to a texture. void dvz_upload_texture ( DvzContext * context , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas texture DvzTexture* the texture to update offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the uploaded data, in bytes data void* pointer to the data to upload to the GPU dvz_download_texture() \u00b6 Download data from a texture. void dvz_download_texture ( DvzContext * context , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas texture DvzTexture* the texture to download from offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the downloaded data, in bytes data void* pointer to the buffer that will hold the downloaded data dvz_copy_texture() \u00b6 Copy part of a texture to another. void dvz_copy_texture ( DvzContext * context , DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape , VkDeviceSize size ); Parameter Type Description canvas None the canvas src DvzTexture* the source texture src_offset uvec3 the offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 the offset within the target texture shape uvec3 the shape of the part of the texture to copy size VkDeviceSize the corresponding size of that part, in bytes This function does not involve GPU-CPU data transfers. dvz_process_transfers() \u00b6 Process the pending transfers. void dvz_process_transfers ( DvzContext * context ); Parameter Type Description canvas None the canvas br None the buffer regions to update offset None the offset within the buffer regions, in bytes size None the size of the data to upload, in bytes data None pointer to the data to upload to the GPU When the event loop is running, all transfers are enqueued in a queue rather than executed directly. The reason is that proper synchronization is required in order to avoid modifying GPU objects while they are being used for rendering. The transfer processing function is called at a deterministic time within the main event loop.","title":"GPU API"},{"location":"api/gpu/#gpu-context-and-objects","text":"","title":"GPU context and objects"},{"location":"api/gpu/#context","text":"","title":"Context"},{"location":"api/gpu/#dvz_context","text":"Create a context associated to a GPU. DvzContext * dvz_context ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU Note The GPU must have been created beforehand.","title":"dvz_context()"},{"location":"api/gpu/#dvz_context_reset","text":"Destroy all GPU resources in a GPU context. void dvz_context_reset ( DvzContext * context ); Parameter Type Description context DvzContext* the context","title":"dvz_context_reset()"},{"location":"api/gpu/#dvz_app_reset","text":"Reset all GPUs. void dvz_app_reset ( DvzApp * app ); Parameter Type Description app DvzApp* the application instance","title":"dvz_app_reset()"},{"location":"api/gpu/#dvz_context_destroy","text":"Destroy a context. void dvz_context_destroy ( DvzContext * context ); Parameter Type Description context DvzContext* the context","title":"dvz_context_destroy()"},{"location":"api/gpu/#buffers","text":"","title":"Buffers"},{"location":"api/gpu/#dvz_ctx_buffers","text":"Allocate one of several buffer regions on the GPU. DvzBufferRegions dvz_ctx_buffers ( DvzContext * context , DvzBufferType buffer_type , uint32_t buffer_count , VkDeviceSize size ); Parameter Type Description context DvzContext* the context buffer_type DvzBufferType the type of buffer to allocate the regions on buffer_count uint32_t the number of buffer regions to allocate size VkDeviceSize the size of each region to allocate, in bytes","title":"dvz_ctx_buffers()"},{"location":"api/gpu/#dvz_ctx_buffers_resize","text":"Resize a set of buffer regions. void dvz_ctx_buffers_resize ( DvzContext * context , DvzBufferRegions * br , VkDeviceSize new_size ); Parameter Type Description context DvzContext* the context br DvzBufferRegions* the buffer regions to resize new_size VkDeviceSize the new size of each buffer region, in bytes","title":"dvz_ctx_buffers_resize()"},{"location":"api/gpu/#textures","text":"","title":"Textures"},{"location":"api/gpu/#dvz_ctx_texture","text":"Create a new GPU texture. DvzTexture * dvz_ctx_texture ( DvzContext * context , uint32_t dims , uvec3 size , VkFormat format ); Parameter Type Description context DvzContext* the context dims uint32_t the number of dimensions of the texture (1, 2, or 3) size uvec3 the width, height, and depth format VkFormat the format of each pixel","title":"dvz_ctx_texture()"},{"location":"api/gpu/#dvz_texture_resize","text":"Resize a texture. void dvz_texture_resize ( DvzTexture * texture , uvec3 size ); Parameter Type Description texture DvzTexture* the texture size uvec3 the new size (width, height, depth) Warning This function will delete the texture data.","title":"dvz_texture_resize()"},{"location":"api/gpu/#dvz_texture_filter","text":"Set the texture filter. void dvz_texture_filter ( DvzTexture * texture , DvzFilterType type , VkFilter filter ); Parameter Type Description texture DvzTexture* the texture type DvzFilterType the filter type filter VkFilter the filter","title":"dvz_texture_filter()"},{"location":"api/gpu/#dvz_texture_address_mode","text":"Set the texture address mode. void dvz_texture_address_mode ( DvzTexture * texture , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description texture DvzTexture* the texture axis DvzTextureAxis the axis address_mode VkSamplerAddressMode the address mode","title":"dvz_texture_address_mode()"},{"location":"api/gpu/#dvz_texture_upload","text":"Upload data to a GPU texture. void dvz_texture_upload ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , const void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to update size VkDeviceSize size of the data to upload, in bytes data void* pointer to the data to upload Note This function should not be used to update a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead.","title":"dvz_texture_upload()"},{"location":"api/gpu/#dvz_texture_download","text":"Download a texture from the GPU to the CPU. void dvz_texture_download ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to download size VkDeviceSize size of the data to download, in bytes data void* pointer to the buffer to download to (should be already allocated) Note This function should not be used to download from a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead.","title":"dvz_texture_download()"},{"location":"api/gpu/#dvz_texture_copy","text":"Copy part of a texture to another texture. void dvz_texture_copy ( DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape ); Parameter Type Description src DvzTexture* the source texture src_offset uvec3 offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 offset within the target texture shape uvec3 shape of the part of the texture to copy This function does not involve CPU-GPU data transfers.","title":"dvz_texture_copy()"},{"location":"api/gpu/#dvz_texture_transition","text":"Transition a texture to its layout. void dvz_texture_transition ( DvzTexture * tex ); Parameter Type Description texture None the texture to transition","title":"dvz_texture_transition()"},{"location":"api/gpu/#dvz_texture_destroy","text":"Destroy a texture. void dvz_texture_destroy ( DvzTexture * texture ); Parameter Type Description texture DvzTexture* the texture","title":"dvz_texture_destroy()"},{"location":"api/gpu/#compute-pipeline","text":"","title":"Compute pipeline"},{"location":"api/gpu/#dvz_ctx_compute","text":"Create a new compute pipeline. DvzCompute * dvz_ctx_compute ( DvzContext * context , const char * shader_path ); Parameter Type Description context DvzContext* the context shader_path char* path to the .spirv file containing the compute shader","title":"dvz_ctx_compute()"},{"location":"api/gpu/#data-transfers","text":"","title":"Data transfers"},{"location":"api/gpu/#dvz_upload_buffer","text":"Upload data to 1 or N buffer regions on the GPU while the app event loop is running. void dvz_upload_buffer ( DvzContext * context , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to the data to upload to the GPU","title":"dvz_upload_buffer()"},{"location":"api/gpu/#dvz_download_buffer","text":"Download data from a buffer region to the CPU while the app event loop is running. void dvz_download_buffer ( DvzContext * context , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to a buffer already allocated to contain size bytes","title":"dvz_download_buffer()"},{"location":"api/gpu/#dvz_copy_buffer","text":"Copy data between two GPU buffer regions. void dvz_copy_buffer ( DvzContext * context , DvzBufferRegions src , VkDeviceSize src_offset , DvzBufferRegions dst , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description canvas None the canvas src DvzBufferRegions the buffer region to copy from src_offset VkDeviceSize the offset within the source buffer region dst DvzBufferRegions the buffer region to copy to dst_offset VkDeviceSize the offset within the target buffer region size VkDeviceSize the size of the data to copy This function does not involve GPU-CPU data transfers.","title":"dvz_copy_buffer()"},{"location":"api/gpu/#dvz_upload_texture","text":"Upload data to a texture. void dvz_upload_texture ( DvzContext * context , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas texture DvzTexture* the texture to update offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the uploaded data, in bytes data void* pointer to the data to upload to the GPU","title":"dvz_upload_texture()"},{"location":"api/gpu/#dvz_download_texture","text":"Download data from a texture. void dvz_download_texture ( DvzContext * context , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas None the canvas texture DvzTexture* the texture to download from offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the downloaded data, in bytes data void* pointer to the buffer that will hold the downloaded data","title":"dvz_download_texture()"},{"location":"api/gpu/#dvz_copy_texture","text":"Copy part of a texture to another. void dvz_copy_texture ( DvzContext * context , DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape , VkDeviceSize size ); Parameter Type Description canvas None the canvas src DvzTexture* the source texture src_offset uvec3 the offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 the offset within the target texture shape uvec3 the shape of the part of the texture to copy size VkDeviceSize the corresponding size of that part, in bytes This function does not involve GPU-CPU data transfers.","title":"dvz_copy_texture()"},{"location":"api/gpu/#dvz_process_transfers","text":"Process the pending transfers. void dvz_process_transfers ( DvzContext * context ); Parameter Type Description canvas None the canvas br None the buffer regions to update offset None the offset within the buffer regions, in bytes size None the size of the data to upload, in bytes data None pointer to the data to upload to the GPU When the event loop is running, all transfers are enqueued in a queue rather than executed directly. The reason is that proper synchronization is required in order to avoid modifying GPU objects while they are being used for rendering. The transfer processing function is called at a deterministic time within the main event loop.","title":"dvz_process_transfers()"},{"location":"api/gui/","text":"GUI \u00b6 GUI controls \u00b6 dvz_gui() \u00b6 Create a new GUI dialog. DvzGui * dvz_gui ( DvzCanvas * canvas , const char * title , int flags ); Parameter Type Description canvas DvzCanvas* the canvas title char* the GUI title flags int optional flags returns DvzGui* GUI dvz_gui_checkbox() \u00b6 Add a checkbox control. DvzGuiControl * dvz_gui_checkbox ( DvzGui * gui , const char * name , bool value ); Parameter Type Description gui DvzGui* the GUI name char* the control label value bool whether the checkbox is initially checked returns DvzGuiControl* control dvz_gui_slider_float() \u00b6 Add a slider for float number input. DvzGuiControl * dvz_gui_slider_float ( DvzGui * gui , const char * name , float vmin , float vmax , float value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin float the minimum value vmax float the maximum value value float the initial value returns DvzGuiControl* control dvz_gui_slider_int() \u00b6 Add a slider for integer input. DvzGuiControl * dvz_gui_slider_int ( DvzGui * gui , const char * name , int vmin , int vmax , int value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin int the minimum value vmax int the maximum value value int the initial value returns DvzGuiControl* control dvz_gui_label() \u00b6 Add a static, non-modifiable label. DvzGuiControl * dvz_gui_label ( DvzGui * gui , const char * name , char * text ); Parameter Type Description gui DvzGui* the GUI name char* the control label text char* the control text returns DvzGuiControl* control dvz_gui_textbox() \u00b6 Add a textbox control for text input. DvzGuiControl * dvz_gui_textbox ( DvzGui * gui , const char * name , char * text ); Parameter Type Description gui DvzGui* the GUI name char* the control label value None the initial text returns DvzGuiControl* control dvz_gui_button() \u00b6 Add a button. DvzGuiControl * dvz_gui_button ( DvzGui * gui , const char * name , int flags ); Parameter Type Description gui DvzGui* the GUI name char* the control label flags int optional flags returns DvzGuiControl* control dvz_gui_colormap() \u00b6 Add a colormap image. DvzGuiControl * dvz_gui_colormap ( DvzGui * gui , DvzColormap cmap ); Parameter Type Description gui DvzGui* the GUI cmap DvzColormap the colormap returns DvzGuiControl* control dvz_gui_destroy() \u00b6 Destroy a GUI. void dvz_gui_destroy ( DvzGui * gui ); Parameter Type Description gui DvzGui* the GUI","title":"GUI API"},{"location":"api/gui/#gui","text":"","title":"GUI"},{"location":"api/gui/#gui-controls","text":"","title":"GUI controls"},{"location":"api/gui/#dvz_gui","text":"Create a new GUI dialog. DvzGui * dvz_gui ( DvzCanvas * canvas , const char * title , int flags ); Parameter Type Description canvas DvzCanvas* the canvas title char* the GUI title flags int optional flags returns DvzGui* GUI","title":"dvz_gui()"},{"location":"api/gui/#dvz_gui_checkbox","text":"Add a checkbox control. DvzGuiControl * dvz_gui_checkbox ( DvzGui * gui , const char * name , bool value ); Parameter Type Description gui DvzGui* the GUI name char* the control label value bool whether the checkbox is initially checked returns DvzGuiControl* control","title":"dvz_gui_checkbox()"},{"location":"api/gui/#dvz_gui_slider_float","text":"Add a slider for float number input. DvzGuiControl * dvz_gui_slider_float ( DvzGui * gui , const char * name , float vmin , float vmax , float value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin float the minimum value vmax float the maximum value value float the initial value returns DvzGuiControl* control","title":"dvz_gui_slider_float()"},{"location":"api/gui/#dvz_gui_slider_int","text":"Add a slider for integer input. DvzGuiControl * dvz_gui_slider_int ( DvzGui * gui , const char * name , int vmin , int vmax , int value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin int the minimum value vmax int the maximum value value int the initial value returns DvzGuiControl* control","title":"dvz_gui_slider_int()"},{"location":"api/gui/#dvz_gui_label","text":"Add a static, non-modifiable label. DvzGuiControl * dvz_gui_label ( DvzGui * gui , const char * name , char * text ); Parameter Type Description gui DvzGui* the GUI name char* the control label text char* the control text returns DvzGuiControl* control","title":"dvz_gui_label()"},{"location":"api/gui/#dvz_gui_textbox","text":"Add a textbox control for text input. DvzGuiControl * dvz_gui_textbox ( DvzGui * gui , const char * name , char * text ); Parameter Type Description gui DvzGui* the GUI name char* the control label value None the initial text returns DvzGuiControl* control","title":"dvz_gui_textbox()"},{"location":"api/gui/#dvz_gui_button","text":"Add a button. DvzGuiControl * dvz_gui_button ( DvzGui * gui , const char * name , int flags ); Parameter Type Description gui DvzGui* the GUI name char* the control label flags int optional flags returns DvzGuiControl* control","title":"dvz_gui_button()"},{"location":"api/gui/#dvz_gui_colormap","text":"Add a colormap image. DvzGuiControl * dvz_gui_colormap ( DvzGui * gui , DvzColormap cmap ); Parameter Type Description gui DvzGui* the GUI cmap DvzColormap the colormap returns DvzGuiControl* control","title":"dvz_gui_colormap()"},{"location":"api/gui/#dvz_gui_destroy","text":"Destroy a GUI. void dvz_gui_destroy ( DvzGui * gui ); Parameter Type Description gui DvzGui* the GUI","title":"dvz_gui_destroy()"},{"location":"api/misc/","text":"Misc API \u00b6 Array \u00b6 dvz_array() \u00b6 Create a new 1D array. DvzArray dvz_array ( uint32_t item_count , DvzDataType dtype ); Parameter Type Description item_count uint32_t initial number of elements dtype DvzDataType the data type of the array returns DvzArray new array dvz_array_point() \u00b6 Create an array with a single dvec3 position. DvzArray dvz_array_point ( dvec3 pos ); Parameter Type Description pos dvec3 initial number of elements returns DvzArray new array dvz_array_wrap() \u00b6 Create a 1D array from an existing compatible memory buffer. DvzArray dvz_array_wrap ( uint32_t item_count , DvzDataType dtype , void * data ); Parameter Type Description item_count uint32_t number of elements in the passed buffer dtype DvzDataType the data type of the array returns DvzArray array wrapping the buffer The created array does not allocate memory, it uses the passed buffer instead. Warning Destroying the array will free the passed pointer! dvz_array_struct() \u00b6 Create a 1D record array with heterogeneous data type. DvzArray dvz_array_struct ( uint32_t item_count , VkDeviceSize item_size ); Parameter Type Description item_count uint32_t number of elements item_size VkDeviceSize size, in bytes, of each item returns DvzArray array dvz_array_3D() \u00b6 Create a 3D array holding a texture. DvzArray dvz_array_3D ( uint32_t ndims , uint32_t width , uint32_t height , uint32_t depth , VkDeviceSize item_size ); Parameter Type Description ndims uint32_t number of dimensions (1, 2, 3) width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension item_size VkDeviceSize size of each item in bytes returns DvzArray array dvz_array_resize() \u00b6 Resize an existing array. void dvz_array_resize ( DvzArray * array , uint32_t item_count ); Parameter Type Description array DvzArray* the array to resize item_count uint32_t the new number of items If the new size is equal to the old size, do nothing. If the new size is smaller than the old size, change the size attribute but do not reallocate If the new size is larger than the old size, reallocate memory and copy over the old values dvz_array_clear() \u00b6 Reset to 0 the contents of an existing array. void dvz_array_clear ( DvzArray * array ); Parameter Type Description array DvzArray* the array to clear dvz_array_reshape() \u00b6 Reshape a 3D array and delete all the data in it . void dvz_array_reshape ( DvzArray * array , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description array DvzArray* the array to reshape and clear width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension Warning The contents of the array will be cleared. Copying the existing data would require more work and is not necessary at the moment. dvz_array_data() \u00b6 Copy data into an array. void dvz_array_data ( DvzArray * array , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data ); Parameter Type Description array DvzArray* the array first_item uint32_t first element in the array to be overwritten item_count uint32_t number of items to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy There will be item_count values copied between first_item and first_item + item_count in the array. There are data_item_count values in the passed buffer. If item_count > data_item_count , the last value of data will be repeated until the last value. Example: C DvzArray arr = dvz_array ( 10 , DVZ_DTYPE_DOUBLE ); double item = 1.23 ; dvz_array_data ( & arr , 0 , 10 , 1 , & item ); dvz_array_item() \u00b6 Retrieve a single element from an array. void * dvz_array_item ( DvzArray * array , uint32_t idx ); Parameter Type Description array DvzArray* the array idx uint32_t the index of the element to retrieve returns void* pointer to the requested element dvz_array_column() \u00b6 Copy data into the column of a record array. void dvz_array_column ( DvzArray * array , VkDeviceSize offset , VkDeviceSize col_size , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data , DvzDataType source_dtype , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description array DvzArray* the array offset VkDeviceSize the offset within the array, in bytes col_size VkDeviceSize stride in the source array, in bytes first_item uint32_t first element in the array to be overwritten item_count uint32_t number of elements to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy source_dtype DvzDataType the source dtype (only used when casting) target_dtype DvzDataType the target dtype (only used when casting) copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied element This function is used by the default visual baking function, which copies to the vertex buffer (corresponding to a record array with as many fields as GLSL attributes in the vertex shader) the user-specified visual props (data for the individual elements). dvz_array_insert() \u00b6 Insert data in an array. void dvz_array_insert ( DvzArray * array , uint32_t offset , uint32_t size , void * insert ); Parameter Type Description array DvzArray* the array offset uint32_t the index of the first element of the inserted data in the new array size uint32_t the number of elements to insert insert void* the data to insert dvz_array_copy_region() \u00b6 Copy a region of an array into another. void dvz_array_copy_region ( DvzArray * src_arr , DvzArray * dst_arr , uint32_t src_offset , uint32_t dst_offset , uint32_t item_count ); Parameter Type Description src_arr DvzArray* the source array dst_arr DvzArray* the destination array src_offset uint32_t the index, in the source array, of the first item to copy dst_offset uint32_t the destination index item_count uint32_t the number of items to copy dvz_array_destroy() \u00b6 Destroy an array. void dvz_array_destroy ( DvzArray * array ); Parameter Type Description array DvzArray* the array to destroy This function frees the allocated underlying data buffer. Object \u00b6 dvz_obj_init() \u00b6 Initialize an object. void dvz_obj_init ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object Memory for the object has been allocated and its fields properly initialized. dvz_obj_created() \u00b6 Mark an object as successfully created on the GPU. void dvz_obj_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object dvz_obj_destroyed() \u00b6 Mark an object as destroyed. void dvz_obj_destroyed ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object dvz_obj_is_created() \u00b6 Whether an object has been successfully created. bool dvz_obj_is_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object returns bool boolean indicated whether the object has been successfully created Container \u00b6 dvz_container() \u00b6 Create a container that will contain an arbitrary number of objects of the same type. DvzContainer dvz_container ( uint32_t count , size_t item_size , DvzObjectType type ); Parameter Type Description count uint32_t initial number of objects in the container item_size size_t size of each object, in bytes type DvzObjectType object type dvz_container_delete_if_destroyed() \u00b6 Free a given object in the constainer if it was previously destroyed. void dvz_container_delete_if_destroyed ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container dvz_container_alloc() \u00b6 Get a pointer to a new object in the container. void * dvz_container_alloc ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns void* pointer to an allocated object If the container is full, it will be automatically resized. dvz_container_get() \u00b6 Return the object at a given index. void * dvz_container_get ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container returns None a pointer to the object at the specified index dvz_container_iterator() \u00b6 Start a loop iteration over all valid objects within the container. DvzContainerIterator dvz_container_iterator ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns DvzContainerIterator pointer to the first object dvz_container_iter() \u00b6 Continue an already-started loop iteration on a container. void dvz_container_iter ( DvzContainerIterator * iterator ); Parameter Type Description container None the container returns void pointer to the next object in the container, or NULL at the end dvz_container_destroy() \u00b6 Destroy a container. void dvz_container_destroy ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container idx None the index of the object within the container Free all remaining objects, as well as the container itself. Warning All objects in the container must have been destroyed beforehand, since the generic container does not know how to properly destroy objects that were created with Vulkan. I/O \u00b6 dvz_write_png() \u00b6 Save an image to a PNG file int dvz_write_png ( const char * filename , uint32_t width , uint32_t height , const uint8_t * image ); Parameter Type Description filename char* path to the PNG file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values dvz_write_ppm() \u00b6 Save an image to a PPM file (short ASCII header and flat binary RGBA values). int dvz_write_ppm ( const char * filename , uint32_t width , uint32_t height , const uint8_t * image ); Parameter Type Description filename char* path to the PPM file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values dvz_read_file() \u00b6 Read a binary file. uint32_t * dvz_read_file ( const char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns uint32_t* to a byte buffer with the file contents dvz_read_npy() \u00b6 Read a NumPy NPY file. char * dvz_read_npy ( const char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns char* to a buffer containing the array elements dvz_read_ppm() \u00b6 Read a PPM image file. uint8_t * dvz_read_ppm ( const char * filename , int * width , int * height ); Parameter Type Description filename char* path of the file to open width int* width of the image height int* of the image returns uint8_t* to a buffer with the loaded RGBA pixel colors Thread \u00b6 dvz_thread() \u00b6 Create a thread. DvzThread dvz_thread ( DvzThreadCallback callback , void * user_data ); Parameter Type Description callback DvzThreadCallback the function that will run in a background thread user_data void* a pointer to arbitrary user data returns DvzThread object Callback function signature: void*(void*) dvz_thread_lock() \u00b6 Acquire a mutex lock associated to the thread. void dvz_thread_lock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread dvz_thread_unlock() \u00b6 Release a mutex lock associated to the thread. void dvz_thread_unlock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread dvz_thread_join() \u00b6 Destroy a thread after the thread function has finished running. void dvz_thread_join ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread FIFO queue \u00b6 dvz_fifo() \u00b6 Create a FIFO queue. DvzFifo dvz_fifo ( int32_t capacity ); Parameter Type Description capacity int32_t the maximum size returns DvzFifo FIFO queue dvz_fifo_enqueue() \u00b6 Enqueue an object in a queue. void dvz_fifo_enqueue ( DvzFifo * fifo , void * item ); Parameter Type Description fifo DvzFifo* the FIFO queue item void* the pointer to the object to enqueue dvz_fifo_dequeue() \u00b6 Dequeue an object from a queue. void * dvz_fifo_dequeue ( DvzFifo * fifo , bool wait ); Parameter Type Description fifo DvzFifo* the FIFO queue wait bool whether to return immediately, or wait until the queue is non-empty returns void* pointer to the dequeued object, or NULL if the queue is empty dvz_fifo_size() \u00b6 Get the number of items in a queue. int dvz_fifo_size ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue returns int number of elements in the queue dvz_fifo_discard() \u00b6 Discard old items in a queue. void dvz_fifo_discard ( DvzFifo * fifo , int max_size ); Parameter Type Description fifo DvzFifo* the FIFO queue max_size int the number of items to keep in the queue. This function will suppress all items in the queue except the max_size most recent ones. dvz_fifo_reset() \u00b6 Delete all items in a queue. void dvz_fifo_reset ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue dvz_fifo_destroy() \u00b6 Destroy a queue. void dvz_fifo_destroy ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue Mesh \u00b6 dvz_mesh() \u00b6 Create a new mesh. DvzMesh dvz_mesh ( void ); | returns | DvzMesh | mesh object | A mesh is represented by an array of vertices of type DvzGraphicsMeshVertex and indices, where every triplet of vertex indices represents a triangular face of the mesh. dvz_mesh_obj() \u00b6 Load an OBJ mesh. DvzMesh dvz_mesh_obj ( const char * file_path ); Parameter Type Description file_path char* the path to the .obj file returns DvzMesh mesh dvz_mesh_grid() \u00b6 Create a grid mesh. DvzMesh dvz_mesh_grid ( uint32_t row_count , uint32_t col_count , const vec3 * positions , const vec2 * texcoords ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns positions vec3* the 3D position of each vertex in the grid texcoords vec2* the texture coordinates of each vertex returns DvzMesh mesh object The positions buffer should contain row_count * col_count vec3 positions (C order). dvz_mesh_surface() \u00b6 Create a surface mesh. DvzMesh dvz_mesh_surface ( uint32_t row_count , uint32_t col_count , const float * heights ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns heights float* the height of each vertex in the grid returns DvzMesh mesh object The heights buffer should contain row_count * col_count float positions (C order). dvz_mesh_cube() \u00b6 Create a unit cube mesh (ranging [-0.5, +0.5]). DvzMesh dvz_mesh_cube ( void ); | returns | DvzMesh | mesh object | dvz_mesh_sphere() \u00b6 Create a sphere mesh. DvzMesh dvz_mesh_sphere ( uint32_t row_count , uint32_t col_count ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns returns DvzMesh mesh object dvz_mesh_cylinder() \u00b6 Create a cylinder mesh. DvzMesh dvz_mesh_cylinder ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object dvz_mesh_cone() \u00b6 Create a cone mesh. DvzMesh dvz_mesh_cone ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object dvz_mesh_square() \u00b6 Create a square mesh. DvzMesh dvz_mesh_square ( void ); | returns | DvzMesh | mesh object | dvz_mesh_disc() \u00b6 Create a disc mesh. DvzMesh dvz_mesh_disc ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object dvz_mesh_normalize() \u00b6 Normalize a mesh. void dvz_mesh_normalize ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh dvz_mesh_destroy() \u00b6 Destroy a mesh. void dvz_mesh_destroy ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh Mesh transform \u00b6 dvz_mesh_transform_reset() \u00b6 Reset the mesh transformation. void dvz_mesh_transform_reset ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh dvz_mesh_transform_add() \u00b6 Append a mesh transformation. void dvz_mesh_transform_add ( DvzMesh * mesh , mat4 transform ); Parameter Type Description mesh DvzMesh* the mesh transform mat4 the transform matrix dvz_mesh_translate() \u00b6 Append a translation transformation. void dvz_mesh_translate ( DvzMesh * mesh , vec3 translate ); Parameter Type Description mesh DvzMesh* the mesh translate vec3 the translation vector dvz_mesh_scale() \u00b6 Append a scaling transformation. void dvz_mesh_scale ( DvzMesh * mesh , vec3 scale ); Parameter Type Description mesh DvzMesh* the mesh scale vec3 the scaling coefficients dvz_mesh_rotate() \u00b6 Append a rotation transformation. void dvz_mesh_rotate ( DvzMesh * mesh , float angle , vec3 axis ); Parameter Type Description mesh DvzMesh* the mesh angle float the rotation angle axis vec3 the rotation axis dvz_mesh_transform() \u00b6 Apply the transformation matrix to a mesh. void dvz_mesh_transform ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh Random \u00b6 dvz_rand_byte() \u00b6 Return a random integer number between 0 and 255. uint8_t dvz_rand_byte ( void ); | returns | uint8_t | number | dvz_rand_float() \u00b6 Return a random floating-point number between 0 and 1. float dvz_rand_float ( void ); | returns | float | number | dvz_rand_normal() \u00b6 Return a random normal floating-point number. float dvz_rand_normal ( void ); | returns | float | number | Misc \u00b6 dvz_sleep() \u00b6 Wait a given number of milliseconds. void dvz_sleep ( int milliseconds ); Parameter Type Description milliseconds int sleep duration dvz_next_pow2() \u00b6 uint64_t dvz_next_pow2 ( uint64_t x );","title":"Misc API"},{"location":"api/misc/#misc-api","text":"","title":"Misc API"},{"location":"api/misc/#array","text":"","title":"Array"},{"location":"api/misc/#dvz_array","text":"Create a new 1D array. DvzArray dvz_array ( uint32_t item_count , DvzDataType dtype ); Parameter Type Description item_count uint32_t initial number of elements dtype DvzDataType the data type of the array returns DvzArray new array","title":"dvz_array()"},{"location":"api/misc/#dvz_array_point","text":"Create an array with a single dvec3 position. DvzArray dvz_array_point ( dvec3 pos ); Parameter Type Description pos dvec3 initial number of elements returns DvzArray new array","title":"dvz_array_point()"},{"location":"api/misc/#dvz_array_wrap","text":"Create a 1D array from an existing compatible memory buffer. DvzArray dvz_array_wrap ( uint32_t item_count , DvzDataType dtype , void * data ); Parameter Type Description item_count uint32_t number of elements in the passed buffer dtype DvzDataType the data type of the array returns DvzArray array wrapping the buffer The created array does not allocate memory, it uses the passed buffer instead. Warning Destroying the array will free the passed pointer!","title":"dvz_array_wrap()"},{"location":"api/misc/#dvz_array_struct","text":"Create a 1D record array with heterogeneous data type. DvzArray dvz_array_struct ( uint32_t item_count , VkDeviceSize item_size ); Parameter Type Description item_count uint32_t number of elements item_size VkDeviceSize size, in bytes, of each item returns DvzArray array","title":"dvz_array_struct()"},{"location":"api/misc/#dvz_array_3d","text":"Create a 3D array holding a texture. DvzArray dvz_array_3D ( uint32_t ndims , uint32_t width , uint32_t height , uint32_t depth , VkDeviceSize item_size ); Parameter Type Description ndims uint32_t number of dimensions (1, 2, 3) width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension item_size VkDeviceSize size of each item in bytes returns DvzArray array","title":"dvz_array_3D()"},{"location":"api/misc/#dvz_array_resize","text":"Resize an existing array. void dvz_array_resize ( DvzArray * array , uint32_t item_count ); Parameter Type Description array DvzArray* the array to resize item_count uint32_t the new number of items If the new size is equal to the old size, do nothing. If the new size is smaller than the old size, change the size attribute but do not reallocate If the new size is larger than the old size, reallocate memory and copy over the old values","title":"dvz_array_resize()"},{"location":"api/misc/#dvz_array_clear","text":"Reset to 0 the contents of an existing array. void dvz_array_clear ( DvzArray * array ); Parameter Type Description array DvzArray* the array to clear","title":"dvz_array_clear()"},{"location":"api/misc/#dvz_array_reshape","text":"Reshape a 3D array and delete all the data in it . void dvz_array_reshape ( DvzArray * array , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description array DvzArray* the array to reshape and clear width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension Warning The contents of the array will be cleared. Copying the existing data would require more work and is not necessary at the moment.","title":"dvz_array_reshape()"},{"location":"api/misc/#dvz_array_data","text":"Copy data into an array. void dvz_array_data ( DvzArray * array , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data ); Parameter Type Description array DvzArray* the array first_item uint32_t first element in the array to be overwritten item_count uint32_t number of items to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy There will be item_count values copied between first_item and first_item + item_count in the array. There are data_item_count values in the passed buffer. If item_count > data_item_count , the last value of data will be repeated until the last value. Example: C DvzArray arr = dvz_array ( 10 , DVZ_DTYPE_DOUBLE ); double item = 1.23 ; dvz_array_data ( & arr , 0 , 10 , 1 , & item );","title":"dvz_array_data()"},{"location":"api/misc/#dvz_array_item","text":"Retrieve a single element from an array. void * dvz_array_item ( DvzArray * array , uint32_t idx ); Parameter Type Description array DvzArray* the array idx uint32_t the index of the element to retrieve returns void* pointer to the requested element","title":"dvz_array_item()"},{"location":"api/misc/#dvz_array_column","text":"Copy data into the column of a record array. void dvz_array_column ( DvzArray * array , VkDeviceSize offset , VkDeviceSize col_size , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data , DvzDataType source_dtype , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description array DvzArray* the array offset VkDeviceSize the offset within the array, in bytes col_size VkDeviceSize stride in the source array, in bytes first_item uint32_t first element in the array to be overwritten item_count uint32_t number of elements to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy source_dtype DvzDataType the source dtype (only used when casting) target_dtype DvzDataType the target dtype (only used when casting) copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied element This function is used by the default visual baking function, which copies to the vertex buffer (corresponding to a record array with as many fields as GLSL attributes in the vertex shader) the user-specified visual props (data for the individual elements).","title":"dvz_array_column()"},{"location":"api/misc/#dvz_array_insert","text":"Insert data in an array. void dvz_array_insert ( DvzArray * array , uint32_t offset , uint32_t size , void * insert ); Parameter Type Description array DvzArray* the array offset uint32_t the index of the first element of the inserted data in the new array size uint32_t the number of elements to insert insert void* the data to insert","title":"dvz_array_insert()"},{"location":"api/misc/#dvz_array_copy_region","text":"Copy a region of an array into another. void dvz_array_copy_region ( DvzArray * src_arr , DvzArray * dst_arr , uint32_t src_offset , uint32_t dst_offset , uint32_t item_count ); Parameter Type Description src_arr DvzArray* the source array dst_arr DvzArray* the destination array src_offset uint32_t the index, in the source array, of the first item to copy dst_offset uint32_t the destination index item_count uint32_t the number of items to copy","title":"dvz_array_copy_region()"},{"location":"api/misc/#dvz_array_destroy","text":"Destroy an array. void dvz_array_destroy ( DvzArray * array ); Parameter Type Description array DvzArray* the array to destroy This function frees the allocated underlying data buffer.","title":"dvz_array_destroy()"},{"location":"api/misc/#object","text":"","title":"Object"},{"location":"api/misc/#dvz_obj_init","text":"Initialize an object. void dvz_obj_init ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object Memory for the object has been allocated and its fields properly initialized.","title":"dvz_obj_init()"},{"location":"api/misc/#dvz_obj_created","text":"Mark an object as successfully created on the GPU. void dvz_obj_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object","title":"dvz_obj_created()"},{"location":"api/misc/#dvz_obj_destroyed","text":"Mark an object as destroyed. void dvz_obj_destroyed ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object","title":"dvz_obj_destroyed()"},{"location":"api/misc/#dvz_obj_is_created","text":"Whether an object has been successfully created. bool dvz_obj_is_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object returns bool boolean indicated whether the object has been successfully created","title":"dvz_obj_is_created()"},{"location":"api/misc/#container","text":"","title":"Container"},{"location":"api/misc/#dvz_container","text":"Create a container that will contain an arbitrary number of objects of the same type. DvzContainer dvz_container ( uint32_t count , size_t item_size , DvzObjectType type ); Parameter Type Description count uint32_t initial number of objects in the container item_size size_t size of each object, in bytes type DvzObjectType object type","title":"dvz_container()"},{"location":"api/misc/#dvz_container_delete_if_destroyed","text":"Free a given object in the constainer if it was previously destroyed. void dvz_container_delete_if_destroyed ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container","title":"dvz_container_delete_if_destroyed()"},{"location":"api/misc/#dvz_container_alloc","text":"Get a pointer to a new object in the container. void * dvz_container_alloc ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns void* pointer to an allocated object If the container is full, it will be automatically resized.","title":"dvz_container_alloc()"},{"location":"api/misc/#dvz_container_get","text":"Return the object at a given index. void * dvz_container_get ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container returns None a pointer to the object at the specified index","title":"dvz_container_get()"},{"location":"api/misc/#dvz_container_iterator","text":"Start a loop iteration over all valid objects within the container. DvzContainerIterator dvz_container_iterator ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns DvzContainerIterator pointer to the first object","title":"dvz_container_iterator()"},{"location":"api/misc/#dvz_container_iter","text":"Continue an already-started loop iteration on a container. void dvz_container_iter ( DvzContainerIterator * iterator ); Parameter Type Description container None the container returns void pointer to the next object in the container, or NULL at the end","title":"dvz_container_iter()"},{"location":"api/misc/#dvz_container_destroy","text":"Destroy a container. void dvz_container_destroy ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container idx None the index of the object within the container Free all remaining objects, as well as the container itself. Warning All objects in the container must have been destroyed beforehand, since the generic container does not know how to properly destroy objects that were created with Vulkan.","title":"dvz_container_destroy()"},{"location":"api/misc/#io","text":"","title":"I/O"},{"location":"api/misc/#dvz_write_png","text":"Save an image to a PNG file int dvz_write_png ( const char * filename , uint32_t width , uint32_t height , const uint8_t * image ); Parameter Type Description filename char* path to the PNG file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values","title":"dvz_write_png()"},{"location":"api/misc/#dvz_write_ppm","text":"Save an image to a PPM file (short ASCII header and flat binary RGBA values). int dvz_write_ppm ( const char * filename , uint32_t width , uint32_t height , const uint8_t * image ); Parameter Type Description filename char* path to the PPM file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values","title":"dvz_write_ppm()"},{"location":"api/misc/#dvz_read_file","text":"Read a binary file. uint32_t * dvz_read_file ( const char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns uint32_t* to a byte buffer with the file contents","title":"dvz_read_file()"},{"location":"api/misc/#dvz_read_npy","text":"Read a NumPy NPY file. char * dvz_read_npy ( const char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns char* to a buffer containing the array elements","title":"dvz_read_npy()"},{"location":"api/misc/#dvz_read_ppm","text":"Read a PPM image file. uint8_t * dvz_read_ppm ( const char * filename , int * width , int * height ); Parameter Type Description filename char* path of the file to open width int* width of the image height int* of the image returns uint8_t* to a buffer with the loaded RGBA pixel colors","title":"dvz_read_ppm()"},{"location":"api/misc/#thread","text":"","title":"Thread"},{"location":"api/misc/#dvz_thread","text":"Create a thread. DvzThread dvz_thread ( DvzThreadCallback callback , void * user_data ); Parameter Type Description callback DvzThreadCallback the function that will run in a background thread user_data void* a pointer to arbitrary user data returns DvzThread object Callback function signature: void*(void*)","title":"dvz_thread()"},{"location":"api/misc/#dvz_thread_lock","text":"Acquire a mutex lock associated to the thread. void dvz_thread_lock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread","title":"dvz_thread_lock()"},{"location":"api/misc/#dvz_thread_unlock","text":"Release a mutex lock associated to the thread. void dvz_thread_unlock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread","title":"dvz_thread_unlock()"},{"location":"api/misc/#dvz_thread_join","text":"Destroy a thread after the thread function has finished running. void dvz_thread_join ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread","title":"dvz_thread_join()"},{"location":"api/misc/#fifo-queue","text":"","title":"FIFO queue"},{"location":"api/misc/#dvz_fifo","text":"Create a FIFO queue. DvzFifo dvz_fifo ( int32_t capacity ); Parameter Type Description capacity int32_t the maximum size returns DvzFifo FIFO queue","title":"dvz_fifo()"},{"location":"api/misc/#dvz_fifo_enqueue","text":"Enqueue an object in a queue. void dvz_fifo_enqueue ( DvzFifo * fifo , void * item ); Parameter Type Description fifo DvzFifo* the FIFO queue item void* the pointer to the object to enqueue","title":"dvz_fifo_enqueue()"},{"location":"api/misc/#dvz_fifo_dequeue","text":"Dequeue an object from a queue. void * dvz_fifo_dequeue ( DvzFifo * fifo , bool wait ); Parameter Type Description fifo DvzFifo* the FIFO queue wait bool whether to return immediately, or wait until the queue is non-empty returns void* pointer to the dequeued object, or NULL if the queue is empty","title":"dvz_fifo_dequeue()"},{"location":"api/misc/#dvz_fifo_size","text":"Get the number of items in a queue. int dvz_fifo_size ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue returns int number of elements in the queue","title":"dvz_fifo_size()"},{"location":"api/misc/#dvz_fifo_discard","text":"Discard old items in a queue. void dvz_fifo_discard ( DvzFifo * fifo , int max_size ); Parameter Type Description fifo DvzFifo* the FIFO queue max_size int the number of items to keep in the queue. This function will suppress all items in the queue except the max_size most recent ones.","title":"dvz_fifo_discard()"},{"location":"api/misc/#dvz_fifo_reset","text":"Delete all items in a queue. void dvz_fifo_reset ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue","title":"dvz_fifo_reset()"},{"location":"api/misc/#dvz_fifo_destroy","text":"Destroy a queue. void dvz_fifo_destroy ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue","title":"dvz_fifo_destroy()"},{"location":"api/misc/#mesh","text":"","title":"Mesh"},{"location":"api/misc/#dvz_mesh","text":"Create a new mesh. DvzMesh dvz_mesh ( void ); | returns | DvzMesh | mesh object | A mesh is represented by an array of vertices of type DvzGraphicsMeshVertex and indices, where every triplet of vertex indices represents a triangular face of the mesh.","title":"dvz_mesh()"},{"location":"api/misc/#dvz_mesh_obj","text":"Load an OBJ mesh. DvzMesh dvz_mesh_obj ( const char * file_path ); Parameter Type Description file_path char* the path to the .obj file returns DvzMesh mesh","title":"dvz_mesh_obj()"},{"location":"api/misc/#dvz_mesh_grid","text":"Create a grid mesh. DvzMesh dvz_mesh_grid ( uint32_t row_count , uint32_t col_count , const vec3 * positions , const vec2 * texcoords ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns positions vec3* the 3D position of each vertex in the grid texcoords vec2* the texture coordinates of each vertex returns DvzMesh mesh object The positions buffer should contain row_count * col_count vec3 positions (C order).","title":"dvz_mesh_grid()"},{"location":"api/misc/#dvz_mesh_surface","text":"Create a surface mesh. DvzMesh dvz_mesh_surface ( uint32_t row_count , uint32_t col_count , const float * heights ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns heights float* the height of each vertex in the grid returns DvzMesh mesh object The heights buffer should contain row_count * col_count float positions (C order).","title":"dvz_mesh_surface()"},{"location":"api/misc/#dvz_mesh_cube","text":"Create a unit cube mesh (ranging [-0.5, +0.5]). DvzMesh dvz_mesh_cube ( void ); | returns | DvzMesh | mesh object |","title":"dvz_mesh_cube()"},{"location":"api/misc/#dvz_mesh_sphere","text":"Create a sphere mesh. DvzMesh dvz_mesh_sphere ( uint32_t row_count , uint32_t col_count ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns returns DvzMesh mesh object","title":"dvz_mesh_sphere()"},{"location":"api/misc/#dvz_mesh_cylinder","text":"Create a cylinder mesh. DvzMesh dvz_mesh_cylinder ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object","title":"dvz_mesh_cylinder()"},{"location":"api/misc/#dvz_mesh_cone","text":"Create a cone mesh. DvzMesh dvz_mesh_cone ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object","title":"dvz_mesh_cone()"},{"location":"api/misc/#dvz_mesh_square","text":"Create a square mesh. DvzMesh dvz_mesh_square ( void ); | returns | DvzMesh | mesh object |","title":"dvz_mesh_square()"},{"location":"api/misc/#dvz_mesh_disc","text":"Create a disc mesh. DvzMesh dvz_mesh_disc ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object","title":"dvz_mesh_disc()"},{"location":"api/misc/#dvz_mesh_normalize","text":"Normalize a mesh. void dvz_mesh_normalize ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_normalize()"},{"location":"api/misc/#dvz_mesh_destroy","text":"Destroy a mesh. void dvz_mesh_destroy ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_destroy()"},{"location":"api/misc/#mesh-transform","text":"","title":"Mesh transform"},{"location":"api/misc/#dvz_mesh_transform_reset","text":"Reset the mesh transformation. void dvz_mesh_transform_reset ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_transform_reset()"},{"location":"api/misc/#dvz_mesh_transform_add","text":"Append a mesh transformation. void dvz_mesh_transform_add ( DvzMesh * mesh , mat4 transform ); Parameter Type Description mesh DvzMesh* the mesh transform mat4 the transform matrix","title":"dvz_mesh_transform_add()"},{"location":"api/misc/#dvz_mesh_translate","text":"Append a translation transformation. void dvz_mesh_translate ( DvzMesh * mesh , vec3 translate ); Parameter Type Description mesh DvzMesh* the mesh translate vec3 the translation vector","title":"dvz_mesh_translate()"},{"location":"api/misc/#dvz_mesh_scale","text":"Append a scaling transformation. void dvz_mesh_scale ( DvzMesh * mesh , vec3 scale ); Parameter Type Description mesh DvzMesh* the mesh scale vec3 the scaling coefficients","title":"dvz_mesh_scale()"},{"location":"api/misc/#dvz_mesh_rotate","text":"Append a rotation transformation. void dvz_mesh_rotate ( DvzMesh * mesh , float angle , vec3 axis ); Parameter Type Description mesh DvzMesh* the mesh angle float the rotation angle axis vec3 the rotation axis","title":"dvz_mesh_rotate()"},{"location":"api/misc/#dvz_mesh_transform","text":"Apply the transformation matrix to a mesh. void dvz_mesh_transform ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_transform()"},{"location":"api/misc/#random","text":"","title":"Random"},{"location":"api/misc/#dvz_rand_byte","text":"Return a random integer number between 0 and 255. uint8_t dvz_rand_byte ( void ); | returns | uint8_t | number |","title":"dvz_rand_byte()"},{"location":"api/misc/#dvz_rand_float","text":"Return a random floating-point number between 0 and 1. float dvz_rand_float ( void ); | returns | float | number |","title":"dvz_rand_float()"},{"location":"api/misc/#dvz_rand_normal","text":"Return a random normal floating-point number. float dvz_rand_normal ( void ); | returns | float | number |","title":"dvz_rand_normal()"},{"location":"api/misc/#misc","text":"","title":"Misc"},{"location":"api/misc/#dvz_sleep","text":"Wait a given number of milliseconds. void dvz_sleep ( int milliseconds ); Parameter Type Description milliseconds int sleep duration","title":"dvz_sleep()"},{"location":"api/misc/#dvz_next_pow2","text":"uint64_t dvz_next_pow2 ( uint64_t x );","title":"dvz_next_pow2()"},{"location":"api/scene/","text":"Scene API \u00b6 App, canvas, main loop \u00b6 dvz_app() \u00b6 Create an application instance. DvzApp * dvz_app ( DvzBackend backend ); Parameter Type Description backend DvzBackend the backend returns DvzApp* pointer to the created app There is typically only one App object in a given application. This object holds a pointer to the Vulkan instance and is responsible for discovering the available GPUs. dvz_canvas() \u00b6 Create a canvas. DvzCanvas * dvz_canvas ( DvzGpu * gpu , uint32_t width , uint32_t height , int flags ); Parameter Type Description gpu DvzGpu* the GPU to use for swapchain presentation width uint32_t the initial window width, in pixels height uint32_t the initial window height, in pixels flags int the creation flags for the canvas dvz_canvas_dpi_scaling() \u00b6 Set the DPI scaling factor of a canvas. void dvz_canvas_dpi_scaling ( DvzCanvas * canvas , float scaling ); Parameter Type Description canvas DvzCanvas* the canvas scaling float the scaling factor dvz_scene() \u00b6 Create a scene with a grid layout. DvzScene * dvz_scene ( DvzCanvas * canvas , uint32_t n_rows , uint32_t n_cols ); Parameter Type Description canvas DvzCanvas* the canvas n_rows uint32_t number of rows in the grid n_cols uint32_t number of columns in the grid returns DvzScene* pointer to the created scene The scene defines a 2D grid where each cell contains a panel (subplot). Panels may support various kinds of interactivity. dvz_app_run() \u00b6 Start the main event loop. int dvz_app_run ( DvzApp * app , uint64_t frame_count ); Parameter Type Description app DvzApp* the app frame_count uint64_t number of frames to process (0 for infinite loop) returns int number of active canvases at the time the function returns Every loop iteration processes one frame of all open canvases. dvz_scene_destroy() \u00b6 Destroy a scene. void dvz_scene_destroy ( DvzScene * scene ); Parameter Type Description scene DvzScene* the scene Destroy all panels and visuals in the scene. dvz_canvas_destroy() \u00b6 Destroy a canvas. void dvz_canvas_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_app_destroy() \u00b6 Destroy the application. int dvz_app_destroy ( DvzApp * app ); Parameter Type Description app DvzApp* the application to destroy This function automatically destroys all objects created within the application. Set panels, add visuals \u00b6 dvz_scene_panel() \u00b6 Add a panel to the scene grid. DvzPanel * dvz_scene_panel ( DvzScene * scene , uint32_t row , uint32_t col , DvzControllerType type , int flags ); Parameter Type Description controller None the scene row uint32_t the row index (0-based) col uint32_t the column index (0-based) type DvzControllerType the controller type flags int flags for the builtin controller returns DvzPanel* panel dvz_scene_visual() \u00b6 Create a builtin visual and add it to a panel. DvzVisual * dvz_scene_visual ( DvzPanel * panel , DvzVisualType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzVisualType the type of visual flags int flags for the builtin visual returns DvzVisual* visual Custom visuals and graphics \u00b6 dvz_blank_graphics() \u00b6 Create a blank graphics (used when creating custom graphics and visuals). DvzGraphics * dvz_blank_graphics ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int graphics flags returns DvzGraphics* blank graphics dvz_custom_graphics() \u00b6 Make a custom graphics and add it to a visual. void dvz_custom_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* a visual graphics DvzGraphics* the custom graphics dvz_blank_visual() \u00b6 Create a blank visual (used when creating custom visuals). DvzVisual * dvz_blank_visual ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int visual flags returns DvzVisual* blank visual dvz_custom_visual() \u00b6 Make a custom visual and add it to a panel. void dvz_custom_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the custom visual Grid and panels \u00b6 dvz_grid() \u00b6 Create a grid of panels. DvzGrid dvz_grid ( DvzCanvas * canvas , uint32_t row_count , uint32_t col_count ); Parameter Type Description canvas DvzCanvas* the canvas row_count uint32_t the number of rows col_count uint32_t the number of columns returns DvzGrid grid object dvz_grid_destroy() \u00b6 Destroy a grid. void dvz_grid_destroy ( DvzGrid * grid ); Parameter Type Description grid DvzGrid* the grid dvz_panel() \u00b6 Create a panel at a given location in a grid. DvzPanel * dvz_panel ( DvzGrid * grid , uint32_t row , uint32_t col ); Parameter Type Description grid DvzGrid* the grid row uint32_t the row index in the grid col uint32_t the column index in the grid returns DvzPanel* panel dvz_panel_update() \u00b6 Update a panel viewport. void dvz_panel_update ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel dvz_panel_margins() \u00b6 Set panel margins. void dvz_panel_margins ( DvzPanel * panel , vec4 margins ); Parameter Type Description panel DvzPanel* the panel margins vec4 the margins, in pixels Margins are represented as a vec4 vector: top, right, bottom, left. dvz_panel_unit() \u00b6 Set the unit in which the panel size is specified. void dvz_panel_unit ( DvzPanel * panel , DvzPanelSizeUnit unit ); Parameter Type Description panel DvzPanel* the panel unit DvzPanelSizeUnit the unit dvz_panel_mode() \u00b6 Set the panel mode (grid or detached). void dvz_panel_mode ( DvzPanel * panel , DvzPanelMode mode ); Parameter Type Description panel DvzPanel* the panel mode DvzPanelMode the mode dvz_panel_visual() \u00b6 Add a visual to a panel. void dvz_panel_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the visual dvz_panel_pos() \u00b6 Set a panel position (in detached mode). void dvz_panel_pos ( DvzPanel * panel , float x , float y ); Parameter Type Description panel DvzPanel* the panel x float the position y float the position The unit in which the coordinates are specified is controller by dvz_panel_unit() . dvz_panel_size() \u00b6 Set a panel size (in detached mode). void dvz_panel_size ( DvzPanel * panel , DvzGridAxis axis , float size ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the axis on which to specify the size size float the size The unit in which the size is specified is controller by dvz_panel_unit() . dvz_panel_span() \u00b6 Set the number of cells a panel is spanning. void dvz_panel_span ( DvzPanel * panel , DvzGridAxis axis , uint32_t span ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the direction to set the span span uint32_t the number of cells the panel spans dvz_panel_cell() \u00b6 Set the position of a panel within a grid. void dvz_panel_cell ( DvzPanel * panel , uint32_t row , uint32_t col ); Parameter Type Description panel DvzPanel* the panel row uint32_t the row index col uint32_t the column index dvz_panel_transpose() \u00b6 Set the coordinate system transposition (order and direction of the 3 xyz axes). void dvz_panel_transpose ( DvzPanel * panel , DvzCDSTranspose transpose ); Parameter Type Description panel DvzPanel* the panel transpose DvzCDSTranspose the transposition mode dvz_panel_contains() \u00b6 Returns whether a point is contained in a panel. bool dvz_panel_contains ( DvzPanel * panel , vec2 screen_pos ); Parameter Type Description panel DvzPanel* the panel screen_pos vec2 the position in screen pixel coordinates returns bool boolean dvz_panel_at() \u00b6 Return the panel at a given position within the canvas. DvzPanel * dvz_panel_at ( DvzGrid * grid , vec2 screen_pos ); Parameter Type Description grid DvzGrid* the grid screen_pos vec2 the position in screen pixel coordinates returns DvzPanel* panel dvz_panel_destroy() \u00b6 Destroy a panel and all visuals inside it. void dvz_panel_destroy ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel dvz_panel_viewport() \u00b6 Return the viewport of a panel. DvzViewport dvz_panel_viewport ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzViewport viewport Colormaps \u00b6 dvz_colormap() \u00b6 Fetch a color from a colormap and a value. void dvz_colormap ( DvzColormap cmap , uint8_t value , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value color cvec4 the fetched color dvz_colormap_idx() \u00b6 Get the texture integer coordinates corresponding to a colormap and value. void dvz_colormap_idx ( DvzColormap cmap , uint8_t value , cvec2 out ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value out cvec2 the colormap coordinates within the texture dvz_colormap_uv() \u00b6 Get the texture normalized coordinates corresponding to a colormap and value. void dvz_colormap_uv ( DvzColormap cmap , uint8_t value , vec2 uv ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value uv vec2 the colormap coordinates within the texture dvz_colormap_scale() \u00b6 Fetch a color from a colormap and an interpolated value. void dvz_colormap_scale ( DvzColormap cmap , double value , double vmin , double vmax , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value double the value vmin double the minimum value vmax double the maximum value color cvec4 the fetched color dvz_colormap_array() \u00b6 Fetch colors from a colormap and an array of values. void dvz_colormap_array ( DvzColormap cmap , uint32_t count , double * values , double vmin , double vmax , cvec4 * out ); Parameter Type Description cmap DvzColormap the colormap count uint32_t the number of values values double* pointer to the array of double numbers vmin double the minimum value vmax double the maximum value out cvec4* the fetched colors dvz_colormap_packuv() \u00b6 Pack an arbitrary RGB color into a special uv texture coordinates void dvz_colormap_packuv ( cvec3 color , vec2 uv ); Parameter Type Description color cvec3 the RGB color uv vec2 the texture coordinates This is used by the mesh visual, that only accepts texture coordinates in its vertices. When setting the first texture coordinate to -1, the second coordinate, a float, is used to unpack 3 uint8_t RGB values. It only works because integers up to 2^24 can be represented exactly with float32. dvz_colormap_extent() \u00b6 Get the tex coords extent of a colormap. void dvz_colormap_extent ( DvzColormap cmap , vec4 uvuv ); Parameter Type Description cmap DvzColormap the colormap uvuv vec4 the texture coordinates of the upper-left and lower-right corners dvz_colormap_set() \u00b6 Modify a color in the colormap array (on the CPU only). void dvz_colormap_set ( uint8_t row , uint8_t col , cvec4 color ); Parameter Type Description row uint8_t the row index in the colormap array col uint8_t the column index in the colormap array color cvec4 the color dvz_colormap_custom() \u00b6 Add a custom colormap. void dvz_colormap_custom ( uint8_t cmap , uint32_t color_count , cvec4 * colors ); Parameter Type Description cmap uint8_t the custom colormap index color_count uint32_t the number of colors in the custom colormap colors cvec4* the colors The cmap index must be between 160 and 175 for continuous colormaps, or between 224 and 239 for categorical colormaps. The maximum number of colors in the colormap is 256.","title":"Scene API"},{"location":"api/scene/#scene-api","text":"","title":"Scene API"},{"location":"api/scene/#app-canvas-main-loop","text":"","title":"App, canvas, main loop"},{"location":"api/scene/#dvz_app","text":"Create an application instance. DvzApp * dvz_app ( DvzBackend backend ); Parameter Type Description backend DvzBackend the backend returns DvzApp* pointer to the created app There is typically only one App object in a given application. This object holds a pointer to the Vulkan instance and is responsible for discovering the available GPUs.","title":"dvz_app()"},{"location":"api/scene/#dvz_canvas","text":"Create a canvas. DvzCanvas * dvz_canvas ( DvzGpu * gpu , uint32_t width , uint32_t height , int flags ); Parameter Type Description gpu DvzGpu* the GPU to use for swapchain presentation width uint32_t the initial window width, in pixels height uint32_t the initial window height, in pixels flags int the creation flags for the canvas","title":"dvz_canvas()"},{"location":"api/scene/#dvz_canvas_dpi_scaling","text":"Set the DPI scaling factor of a canvas. void dvz_canvas_dpi_scaling ( DvzCanvas * canvas , float scaling ); Parameter Type Description canvas DvzCanvas* the canvas scaling float the scaling factor","title":"dvz_canvas_dpi_scaling()"},{"location":"api/scene/#dvz_scene","text":"Create a scene with a grid layout. DvzScene * dvz_scene ( DvzCanvas * canvas , uint32_t n_rows , uint32_t n_cols ); Parameter Type Description canvas DvzCanvas* the canvas n_rows uint32_t number of rows in the grid n_cols uint32_t number of columns in the grid returns DvzScene* pointer to the created scene The scene defines a 2D grid where each cell contains a panel (subplot). Panels may support various kinds of interactivity.","title":"dvz_scene()"},{"location":"api/scene/#dvz_app_run","text":"Start the main event loop. int dvz_app_run ( DvzApp * app , uint64_t frame_count ); Parameter Type Description app DvzApp* the app frame_count uint64_t number of frames to process (0 for infinite loop) returns int number of active canvases at the time the function returns Every loop iteration processes one frame of all open canvases.","title":"dvz_app_run()"},{"location":"api/scene/#dvz_scene_destroy","text":"Destroy a scene. void dvz_scene_destroy ( DvzScene * scene ); Parameter Type Description scene DvzScene* the scene Destroy all panels and visuals in the scene.","title":"dvz_scene_destroy()"},{"location":"api/scene/#dvz_canvas_destroy","text":"Destroy a canvas. void dvz_canvas_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_destroy()"},{"location":"api/scene/#dvz_app_destroy","text":"Destroy the application. int dvz_app_destroy ( DvzApp * app ); Parameter Type Description app DvzApp* the application to destroy This function automatically destroys all objects created within the application.","title":"dvz_app_destroy()"},{"location":"api/scene/#set-panels-add-visuals","text":"","title":"Set panels, add visuals"},{"location":"api/scene/#dvz_scene_panel","text":"Add a panel to the scene grid. DvzPanel * dvz_scene_panel ( DvzScene * scene , uint32_t row , uint32_t col , DvzControllerType type , int flags ); Parameter Type Description controller None the scene row uint32_t the row index (0-based) col uint32_t the column index (0-based) type DvzControllerType the controller type flags int flags for the builtin controller returns DvzPanel* panel","title":"dvz_scene_panel()"},{"location":"api/scene/#dvz_scene_visual","text":"Create a builtin visual and add it to a panel. DvzVisual * dvz_scene_visual ( DvzPanel * panel , DvzVisualType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzVisualType the type of visual flags int flags for the builtin visual returns DvzVisual* visual","title":"dvz_scene_visual()"},{"location":"api/scene/#custom-visuals-and-graphics","text":"","title":"Custom visuals and graphics"},{"location":"api/scene/#dvz_blank_graphics","text":"Create a blank graphics (used when creating custom graphics and visuals). DvzGraphics * dvz_blank_graphics ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int graphics flags returns DvzGraphics* blank graphics","title":"dvz_blank_graphics()"},{"location":"api/scene/#dvz_custom_graphics","text":"Make a custom graphics and add it to a visual. void dvz_custom_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* a visual graphics DvzGraphics* the custom graphics","title":"dvz_custom_graphics()"},{"location":"api/scene/#dvz_blank_visual","text":"Create a blank visual (used when creating custom visuals). DvzVisual * dvz_blank_visual ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int visual flags returns DvzVisual* blank visual","title":"dvz_blank_visual()"},{"location":"api/scene/#dvz_custom_visual","text":"Make a custom visual and add it to a panel. void dvz_custom_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the custom visual","title":"dvz_custom_visual()"},{"location":"api/scene/#grid-and-panels","text":"","title":"Grid and panels"},{"location":"api/scene/#dvz_grid","text":"Create a grid of panels. DvzGrid dvz_grid ( DvzCanvas * canvas , uint32_t row_count , uint32_t col_count ); Parameter Type Description canvas DvzCanvas* the canvas row_count uint32_t the number of rows col_count uint32_t the number of columns returns DvzGrid grid object","title":"dvz_grid()"},{"location":"api/scene/#dvz_grid_destroy","text":"Destroy a grid. void dvz_grid_destroy ( DvzGrid * grid ); Parameter Type Description grid DvzGrid* the grid","title":"dvz_grid_destroy()"},{"location":"api/scene/#dvz_panel","text":"Create a panel at a given location in a grid. DvzPanel * dvz_panel ( DvzGrid * grid , uint32_t row , uint32_t col ); Parameter Type Description grid DvzGrid* the grid row uint32_t the row index in the grid col uint32_t the column index in the grid returns DvzPanel* panel","title":"dvz_panel()"},{"location":"api/scene/#dvz_panel_update","text":"Update a panel viewport. void dvz_panel_update ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel","title":"dvz_panel_update()"},{"location":"api/scene/#dvz_panel_margins","text":"Set panel margins. void dvz_panel_margins ( DvzPanel * panel , vec4 margins ); Parameter Type Description panel DvzPanel* the panel margins vec4 the margins, in pixels Margins are represented as a vec4 vector: top, right, bottom, left.","title":"dvz_panel_margins()"},{"location":"api/scene/#dvz_panel_unit","text":"Set the unit in which the panel size is specified. void dvz_panel_unit ( DvzPanel * panel , DvzPanelSizeUnit unit ); Parameter Type Description panel DvzPanel* the panel unit DvzPanelSizeUnit the unit","title":"dvz_panel_unit()"},{"location":"api/scene/#dvz_panel_mode","text":"Set the panel mode (grid or detached). void dvz_panel_mode ( DvzPanel * panel , DvzPanelMode mode ); Parameter Type Description panel DvzPanel* the panel mode DvzPanelMode the mode","title":"dvz_panel_mode()"},{"location":"api/scene/#dvz_panel_visual","text":"Add a visual to a panel. void dvz_panel_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the visual","title":"dvz_panel_visual()"},{"location":"api/scene/#dvz_panel_pos","text":"Set a panel position (in detached mode). void dvz_panel_pos ( DvzPanel * panel , float x , float y ); Parameter Type Description panel DvzPanel* the panel x float the position y float the position The unit in which the coordinates are specified is controller by dvz_panel_unit() .","title":"dvz_panel_pos()"},{"location":"api/scene/#dvz_panel_size","text":"Set a panel size (in detached mode). void dvz_panel_size ( DvzPanel * panel , DvzGridAxis axis , float size ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the axis on which to specify the size size float the size The unit in which the size is specified is controller by dvz_panel_unit() .","title":"dvz_panel_size()"},{"location":"api/scene/#dvz_panel_span","text":"Set the number of cells a panel is spanning. void dvz_panel_span ( DvzPanel * panel , DvzGridAxis axis , uint32_t span ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the direction to set the span span uint32_t the number of cells the panel spans","title":"dvz_panel_span()"},{"location":"api/scene/#dvz_panel_cell","text":"Set the position of a panel within a grid. void dvz_panel_cell ( DvzPanel * panel , uint32_t row , uint32_t col ); Parameter Type Description panel DvzPanel* the panel row uint32_t the row index col uint32_t the column index","title":"dvz_panel_cell()"},{"location":"api/scene/#dvz_panel_transpose","text":"Set the coordinate system transposition (order and direction of the 3 xyz axes). void dvz_panel_transpose ( DvzPanel * panel , DvzCDSTranspose transpose ); Parameter Type Description panel DvzPanel* the panel transpose DvzCDSTranspose the transposition mode","title":"dvz_panel_transpose()"},{"location":"api/scene/#dvz_panel_contains","text":"Returns whether a point is contained in a panel. bool dvz_panel_contains ( DvzPanel * panel , vec2 screen_pos ); Parameter Type Description panel DvzPanel* the panel screen_pos vec2 the position in screen pixel coordinates returns bool boolean","title":"dvz_panel_contains()"},{"location":"api/scene/#dvz_panel_at","text":"Return the panel at a given position within the canvas. DvzPanel * dvz_panel_at ( DvzGrid * grid , vec2 screen_pos ); Parameter Type Description grid DvzGrid* the grid screen_pos vec2 the position in screen pixel coordinates returns DvzPanel* panel","title":"dvz_panel_at()"},{"location":"api/scene/#dvz_panel_destroy","text":"Destroy a panel and all visuals inside it. void dvz_panel_destroy ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel","title":"dvz_panel_destroy()"},{"location":"api/scene/#dvz_panel_viewport","text":"Return the viewport of a panel. DvzViewport dvz_panel_viewport ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzViewport viewport","title":"dvz_panel_viewport()"},{"location":"api/scene/#colormaps","text":"","title":"Colormaps"},{"location":"api/scene/#dvz_colormap","text":"Fetch a color from a colormap and a value. void dvz_colormap ( DvzColormap cmap , uint8_t value , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value color cvec4 the fetched color","title":"dvz_colormap()"},{"location":"api/scene/#dvz_colormap_idx","text":"Get the texture integer coordinates corresponding to a colormap and value. void dvz_colormap_idx ( DvzColormap cmap , uint8_t value , cvec2 out ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value out cvec2 the colormap coordinates within the texture","title":"dvz_colormap_idx()"},{"location":"api/scene/#dvz_colormap_uv","text":"Get the texture normalized coordinates corresponding to a colormap and value. void dvz_colormap_uv ( DvzColormap cmap , uint8_t value , vec2 uv ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value uv vec2 the colormap coordinates within the texture","title":"dvz_colormap_uv()"},{"location":"api/scene/#dvz_colormap_scale","text":"Fetch a color from a colormap and an interpolated value. void dvz_colormap_scale ( DvzColormap cmap , double value , double vmin , double vmax , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value double the value vmin double the minimum value vmax double the maximum value color cvec4 the fetched color","title":"dvz_colormap_scale()"},{"location":"api/scene/#dvz_colormap_array","text":"Fetch colors from a colormap and an array of values. void dvz_colormap_array ( DvzColormap cmap , uint32_t count , double * values , double vmin , double vmax , cvec4 * out ); Parameter Type Description cmap DvzColormap the colormap count uint32_t the number of values values double* pointer to the array of double numbers vmin double the minimum value vmax double the maximum value out cvec4* the fetched colors","title":"dvz_colormap_array()"},{"location":"api/scene/#dvz_colormap_packuv","text":"Pack an arbitrary RGB color into a special uv texture coordinates void dvz_colormap_packuv ( cvec3 color , vec2 uv ); Parameter Type Description color cvec3 the RGB color uv vec2 the texture coordinates This is used by the mesh visual, that only accepts texture coordinates in its vertices. When setting the first texture coordinate to -1, the second coordinate, a float, is used to unpack 3 uint8_t RGB values. It only works because integers up to 2^24 can be represented exactly with float32.","title":"dvz_colormap_packuv()"},{"location":"api/scene/#dvz_colormap_extent","text":"Get the tex coords extent of a colormap. void dvz_colormap_extent ( DvzColormap cmap , vec4 uvuv ); Parameter Type Description cmap DvzColormap the colormap uvuv vec4 the texture coordinates of the upper-left and lower-right corners","title":"dvz_colormap_extent()"},{"location":"api/scene/#dvz_colormap_set","text":"Modify a color in the colormap array (on the CPU only). void dvz_colormap_set ( uint8_t row , uint8_t col , cvec4 color ); Parameter Type Description row uint8_t the row index in the colormap array col uint8_t the column index in the colormap array color cvec4 the color","title":"dvz_colormap_set()"},{"location":"api/scene/#dvz_colormap_custom","text":"Add a custom colormap. void dvz_colormap_custom ( uint8_t cmap , uint32_t color_count , cvec4 * colors ); Parameter Type Description cmap uint8_t the custom colormap index color_count uint32_t the number of colors in the custom colormap colors cvec4* the colors The cmap index must be between 160 and 175 for continuous colormaps, or between 224 and 239 for categorical colormaps. The maximum number of colors in the colormap is 256.","title":"dvz_colormap_custom()"},{"location":"api/visual/","text":"Visual API \u00b6 Visual creation and destruction \u00b6 dvz_visual() \u00b6 Create a blank visual. DvzVisual dvz_visual ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzVisual visual object dvz_visual_graphics() \u00b6 Add a graphics pipeline to a visual. void dvz_visual_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* the visual graphics DvzGraphics* the graphics dvz_visual_compute() \u00b6 Add a compute pipeline to a visual. void dvz_visual_compute ( DvzVisual * visual , DvzCompute * compute ); Parameter Type Description visual DvzVisual* the visual compute DvzCompute* the compute pipeline dvz_visual_destroy() \u00b6 Destroy a visual. void dvz_visual_destroy ( DvzVisual * visual ); Parameter Type Description visual DvzVisual* the visual This function destroys all GPU objects associated to the visual. Visual data \u00b6 dvz_visual_group() \u00b6 Define a new data group within a visual. void dvz_visual_group ( DvzVisual * visual , uint32_t group_idx , uint32_t size ); Parameter Type Description visual DvzVisual* the visual group_idx uint32_t the group index size uint32_t the number of elements in the group dvz_visual_data() \u00b6 Set the data for a given visual prop. void dvz_visual_data ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , const void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to upload data void* the data, that should be in the dtype of the prop dvz_visual_data_partial() \u00b6 Set partial data for a given visual prop. void dvz_visual_data_partial ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the prop If the specified data has less elements than the number of elements to update, the last element will be repeated as many times as necessary. dvz_visual_data_append() \u00b6 Append elements to the prop. void dvz_visual_data_append ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , const void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to append to the prop data void* the data, that should be in the dtype of the prop dvz_visual_data_source() \u00b6 Set partial data for a given source. void dvz_visual_data_source ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the source dvz_visual_buffer() \u00b6 Set an existing GPU buffer for a visual source. void dvz_visual_buffer ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzBufferRegions br ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index br DvzBufferRegions the buffer regions dvz_visual_texture() \u00b6 Set an existing GPU texture for a visual source. void dvz_visual_texture ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzTexture * texture ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index texture DvzTexture* the texture Visual sources and props \u00b6 dvz_visual_source() \u00b6 Define a new source for a visual. void dvz_visual_source ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzPipelineType pipeline , uint32_t pipeline_idx , uint32_t slot_idx , VkDeviceSize item_size , int flags ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the index of the source pipeline DvzPipelineType the pipeline type pipeline_idx uint32_t the index of the pipeline slot_idx uint32_t the binding slot of the GPU object associated to the source item_size VkDeviceSize the size of every element in the source data, in bytes flags int the source creation flags Within a given visual, a source is uniquely determined by its type and index. The index is the index of the source among all sources of the same type within the visual. Within a given visual, a pipeline is uniquely determined by its type and index. The index is the index of the pipeline among all pipelines of the same type within the visual. dvz_visual_source_share() \u00b6 Set up a source share between two sources of the same type, in a given visual. void dvz_visual_source_share ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t other_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index other_idx uint32_t the index of the other source When two sources are shared, they use the same underlying data buffer. dvz_visual_prop() \u00b6 Define a new prop for a visual. DvzProp * dvz_visual_prop ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , DvzDataType dtype , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index dtype DvzDataType the data type of the prop source_type DvzSourceType the type of the source associated to the prop source_idx uint32_t the index of the source associated to the prop returns DvzProp* prop object Within a given visual, a prop is uniquely determined by its type and index. The index is the index of the prop among all props of the same type within the visual. dvz_visual_prop_default() \u00b6 Set up a default value for a prop. void dvz_visual_prop_default ( DvzProp * prop , void * default_value ); Parameter Type Description prop DvzProp* the prop default_value void* a pointer to the default value dvz_visual_prop_copy() \u00b6 Set up how a prop is copied to its associated source. void dvz_visual_prop_copy ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item dvz_visual_prop_cast() \u00b6 Set up how a prop should be cast when it is copied to its source. void dvz_visual_prop_cast ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item target_dtype DvzDataType the data type to cast to copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item Visual fill utils and callback \u00b6 dvz_visual_fill_callback() \u00b6 Set a fill callback for a visual void dvz_visual_fill_callback ( DvzVisual * visual , DvzVisualFillCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualFillCallback the fill callback Callback function signature: void(DvzVisual*, DvzVisualFillEvent) dvz_visual_fill_event() \u00b6 Call the visual fill callback. void dvz_visual_fill_event ( DvzVisual * visual , VkClearColorValue clear_color , DvzCommands * cmds , uint32_t cmd_idx , DvzViewport viewport , void * user_data ); Parameter Type Description visual DvzVisual* the visual clear_color VkClearColorValue the clear color cmds DvzCommands* the command buffers to update cmd_idx uint32_t the index of the command buffer to update viewport DvzViewport the viewport user_data void* arbitrary user data pointer dvz_visual_fill_begin() \u00b6 Begin recording a command buffer and begin the render pass. void dvz_visual_fill_begin ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index dvz_visual_fill_end() \u00b6 Stop recording a command buffer and stop the render pass. void dvz_visual_fill_end ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index dvz_visual_callback_bake() \u00b6 Set the visual bake callback function. void dvz_visual_callback_bake ( DvzVisual * visual , DvzVisualDataCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualDataCallback the bake callback function Callback function signature: void(DvzVisual*, DvzVisualDataEvent) Visual baking helpers \u00b6 dvz_source_get() \u00b6 Return a source object. DvzSource * dvz_source_get ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index returns DvzSource* source dvz_prop_get() \u00b6 Return a prop object. DvzProp * dvz_prop_get ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzProp* array dvz_prop_array() \u00b6 Return the array of a prop. DvzArray * dvz_prop_array ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzArray* array dvz_prop_size() \u00b6 Return the size of a prop array. uint32_t dvz_prop_size ( DvzProp * prop ); Parameter Type Description prop DvzProp* the prop returns uint32_t prop size dvz_prop_item() \u00b6 Return an item in a prop array. void * dvz_prop_item ( DvzProp * prop , uint32_t prop_idx ); Parameter Type Description prop DvzProp* the prop prop_idx uint32_t the prop idx returns void* pointer to the item Graphics pipeline \u00b6 dvz_graphics_callback() \u00b6 Set a graphics data callback. void dvz_graphics_callback ( DvzGraphics * graphics , DvzGraphicsCallback callback ); Parameter Type Description graphics DvzGraphics* the graphics pipeline callback DvzGraphicsCallback the callback function The callback function is called when one calls dvz_graphics_append() on that visual. It allows one to easily add graphical elements, letting the graphics handle low-level GPU implementation details (tesselation with vertices). Callback function signature: void(DvzGraphicsData*, uint32_t, const void*) dvz_graphics_data() \u00b6 Start a data collection for a graphics pipeline. DvzGraphicsData dvz_graphics_data ( DvzGraphics * graphics , DvzArray * vertices , DvzArray * indices , void * user_data ); Parameter Type Description graphics DvzGraphics* the graphics pipeline vertices DvzArray* pointer to an existing array containing vertices of the right type indices DvzArray* pointer to an existing array containing the indices user_data void* arbitrary user-provided pointer returns DvzGraphicsData graphics data object dvz_graphics_alloc() \u00b6 Allocate the graphics data object with the appropriate number of elements. void dvz_graphics_alloc ( DvzGraphicsData * data , uint32_t item_count ); Parameter Type Description data DvzGraphicsData* the graphics data object item_count uint32_t the number of graphical items dvz_graphics_append() \u00b6 Add one graphical element after the graphics data object has been properly allocated. void dvz_graphics_append ( DvzGraphicsData * data , const void * item ); Parameter Type Description data DvzGraphicsData* the graphics data object item void* a pointer to an object of the appropriate graphics item type dvz_graphics_builtin() \u00b6 Create a new graphics pipeline of a given builtin type. DvzGraphics * dvz_graphics_builtin ( DvzCanvas * canvas , DvzGraphicsType type , int flags ); Parameter Type Description canvas DvzCanvas* the canvas holding the grahpics pipeline type DvzGraphicsType the graphics type flags int the creation flags for the graphics Visual internal system \u00b6 dvz_visual_update() \u00b6 Update all GPU buffers and textures from the visual props and sources. void dvz_visual_update ( DvzVisual * visual , DvzViewport viewport , DvzDataCoords coords , const void * user_data ); Parameter Type Description visual DvzVisual* the visual viewport DvzViewport the viewport coords DvzDataCoords the data coordinates and transformation user_data void* arbitrary user data pointer","title":"Visual API"},{"location":"api/visual/#visual-api","text":"","title":"Visual API"},{"location":"api/visual/#visual-creation-and-destruction","text":"","title":"Visual creation and destruction"},{"location":"api/visual/#dvz_visual","text":"Create a blank visual. DvzVisual dvz_visual ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzVisual visual object","title":"dvz_visual()"},{"location":"api/visual/#dvz_visual_graphics","text":"Add a graphics pipeline to a visual. void dvz_visual_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* the visual graphics DvzGraphics* the graphics","title":"dvz_visual_graphics()"},{"location":"api/visual/#dvz_visual_compute","text":"Add a compute pipeline to a visual. void dvz_visual_compute ( DvzVisual * visual , DvzCompute * compute ); Parameter Type Description visual DvzVisual* the visual compute DvzCompute* the compute pipeline","title":"dvz_visual_compute()"},{"location":"api/visual/#dvz_visual_destroy","text":"Destroy a visual. void dvz_visual_destroy ( DvzVisual * visual ); Parameter Type Description visual DvzVisual* the visual This function destroys all GPU objects associated to the visual.","title":"dvz_visual_destroy()"},{"location":"api/visual/#visual-data","text":"","title":"Visual data"},{"location":"api/visual/#dvz_visual_group","text":"Define a new data group within a visual. void dvz_visual_group ( DvzVisual * visual , uint32_t group_idx , uint32_t size ); Parameter Type Description visual DvzVisual* the visual group_idx uint32_t the group index size uint32_t the number of elements in the group","title":"dvz_visual_group()"},{"location":"api/visual/#dvz_visual_data","text":"Set the data for a given visual prop. void dvz_visual_data ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , const void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to upload data void* the data, that should be in the dtype of the prop","title":"dvz_visual_data()"},{"location":"api/visual/#dvz_visual_data_partial","text":"Set partial data for a given visual prop. void dvz_visual_data_partial ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the prop If the specified data has less elements than the number of elements to update, the last element will be repeated as many times as necessary.","title":"dvz_visual_data_partial()"},{"location":"api/visual/#dvz_visual_data_append","text":"Append elements to the prop. void dvz_visual_data_append ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , const void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to append to the prop data void* the data, that should be in the dtype of the prop","title":"dvz_visual_data_append()"},{"location":"api/visual/#dvz_visual_data_source","text":"Set partial data for a given source. void dvz_visual_data_source ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , const void * data ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the source","title":"dvz_visual_data_source()"},{"location":"api/visual/#dvz_visual_buffer","text":"Set an existing GPU buffer for a visual source. void dvz_visual_buffer ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzBufferRegions br ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index br DvzBufferRegions the buffer regions","title":"dvz_visual_buffer()"},{"location":"api/visual/#dvz_visual_texture","text":"Set an existing GPU texture for a visual source. void dvz_visual_texture ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzTexture * texture ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index texture DvzTexture* the texture","title":"dvz_visual_texture()"},{"location":"api/visual/#visual-sources-and-props","text":"","title":"Visual sources and props"},{"location":"api/visual/#dvz_visual_source","text":"Define a new source for a visual. void dvz_visual_source ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzPipelineType pipeline , uint32_t pipeline_idx , uint32_t slot_idx , VkDeviceSize item_size , int flags ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the index of the source pipeline DvzPipelineType the pipeline type pipeline_idx uint32_t the index of the pipeline slot_idx uint32_t the binding slot of the GPU object associated to the source item_size VkDeviceSize the size of every element in the source data, in bytes flags int the source creation flags Within a given visual, a source is uniquely determined by its type and index. The index is the index of the source among all sources of the same type within the visual. Within a given visual, a pipeline is uniquely determined by its type and index. The index is the index of the pipeline among all pipelines of the same type within the visual.","title":"dvz_visual_source()"},{"location":"api/visual/#dvz_visual_source_share","text":"Set up a source share between two sources of the same type, in a given visual. void dvz_visual_source_share ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t other_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index other_idx uint32_t the index of the other source When two sources are shared, they use the same underlying data buffer.","title":"dvz_visual_source_share()"},{"location":"api/visual/#dvz_visual_prop","text":"Define a new prop for a visual. DvzProp * dvz_visual_prop ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , DvzDataType dtype , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index dtype DvzDataType the data type of the prop source_type DvzSourceType the type of the source associated to the prop source_idx uint32_t the index of the source associated to the prop returns DvzProp* prop object Within a given visual, a prop is uniquely determined by its type and index. The index is the index of the prop among all props of the same type within the visual.","title":"dvz_visual_prop()"},{"location":"api/visual/#dvz_visual_prop_default","text":"Set up a default value for a prop. void dvz_visual_prop_default ( DvzProp * prop , void * default_value ); Parameter Type Description prop DvzProp* the prop default_value void* a pointer to the default value","title":"dvz_visual_prop_default()"},{"location":"api/visual/#dvz_visual_prop_copy","text":"Set up how a prop is copied to its associated source. void dvz_visual_prop_copy ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item","title":"dvz_visual_prop_copy()"},{"location":"api/visual/#dvz_visual_prop_cast","text":"Set up how a prop should be cast when it is copied to its source. void dvz_visual_prop_cast ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item target_dtype DvzDataType the data type to cast to copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item","title":"dvz_visual_prop_cast()"},{"location":"api/visual/#visual-fill-utils-and-callback","text":"","title":"Visual fill utils and callback"},{"location":"api/visual/#dvz_visual_fill_callback","text":"Set a fill callback for a visual void dvz_visual_fill_callback ( DvzVisual * visual , DvzVisualFillCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualFillCallback the fill callback Callback function signature: void(DvzVisual*, DvzVisualFillEvent)","title":"dvz_visual_fill_callback()"},{"location":"api/visual/#dvz_visual_fill_event","text":"Call the visual fill callback. void dvz_visual_fill_event ( DvzVisual * visual , VkClearColorValue clear_color , DvzCommands * cmds , uint32_t cmd_idx , DvzViewport viewport , void * user_data ); Parameter Type Description visual DvzVisual* the visual clear_color VkClearColorValue the clear color cmds DvzCommands* the command buffers to update cmd_idx uint32_t the index of the command buffer to update viewport DvzViewport the viewport user_data void* arbitrary user data pointer","title":"dvz_visual_fill_event()"},{"location":"api/visual/#dvz_visual_fill_begin","text":"Begin recording a command buffer and begin the render pass. void dvz_visual_fill_begin ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index","title":"dvz_visual_fill_begin()"},{"location":"api/visual/#dvz_visual_fill_end","text":"Stop recording a command buffer and stop the render pass. void dvz_visual_fill_end ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index","title":"dvz_visual_fill_end()"},{"location":"api/visual/#dvz_visual_callback_bake","text":"Set the visual bake callback function. void dvz_visual_callback_bake ( DvzVisual * visual , DvzVisualDataCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualDataCallback the bake callback function Callback function signature: void(DvzVisual*, DvzVisualDataEvent)","title":"dvz_visual_callback_bake()"},{"location":"api/visual/#visual-baking-helpers","text":"","title":"Visual baking helpers"},{"location":"api/visual/#dvz_source_get","text":"Return a source object. DvzSource * dvz_source_get ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index returns DvzSource* source","title":"dvz_source_get()"},{"location":"api/visual/#dvz_prop_get","text":"Return a prop object. DvzProp * dvz_prop_get ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzProp* array","title":"dvz_prop_get()"},{"location":"api/visual/#dvz_prop_array","text":"Return the array of a prop. DvzArray * dvz_prop_array ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzArray* array","title":"dvz_prop_array()"},{"location":"api/visual/#dvz_prop_size","text":"Return the size of a prop array. uint32_t dvz_prop_size ( DvzProp * prop ); Parameter Type Description prop DvzProp* the prop returns uint32_t prop size","title":"dvz_prop_size()"},{"location":"api/visual/#dvz_prop_item","text":"Return an item in a prop array. void * dvz_prop_item ( DvzProp * prop , uint32_t prop_idx ); Parameter Type Description prop DvzProp* the prop prop_idx uint32_t the prop idx returns void* pointer to the item","title":"dvz_prop_item()"},{"location":"api/visual/#graphics-pipeline","text":"","title":"Graphics pipeline"},{"location":"api/visual/#dvz_graphics_callback","text":"Set a graphics data callback. void dvz_graphics_callback ( DvzGraphics * graphics , DvzGraphicsCallback callback ); Parameter Type Description graphics DvzGraphics* the graphics pipeline callback DvzGraphicsCallback the callback function The callback function is called when one calls dvz_graphics_append() on that visual. It allows one to easily add graphical elements, letting the graphics handle low-level GPU implementation details (tesselation with vertices). Callback function signature: void(DvzGraphicsData*, uint32_t, const void*)","title":"dvz_graphics_callback()"},{"location":"api/visual/#dvz_graphics_data","text":"Start a data collection for a graphics pipeline. DvzGraphicsData dvz_graphics_data ( DvzGraphics * graphics , DvzArray * vertices , DvzArray * indices , void * user_data ); Parameter Type Description graphics DvzGraphics* the graphics pipeline vertices DvzArray* pointer to an existing array containing vertices of the right type indices DvzArray* pointer to an existing array containing the indices user_data void* arbitrary user-provided pointer returns DvzGraphicsData graphics data object","title":"dvz_graphics_data()"},{"location":"api/visual/#dvz_graphics_alloc","text":"Allocate the graphics data object with the appropriate number of elements. void dvz_graphics_alloc ( DvzGraphicsData * data , uint32_t item_count ); Parameter Type Description data DvzGraphicsData* the graphics data object item_count uint32_t the number of graphical items","title":"dvz_graphics_alloc()"},{"location":"api/visual/#dvz_graphics_append","text":"Add one graphical element after the graphics data object has been properly allocated. void dvz_graphics_append ( DvzGraphicsData * data , const void * item ); Parameter Type Description data DvzGraphicsData* the graphics data object item void* a pointer to an object of the appropriate graphics item type","title":"dvz_graphics_append()"},{"location":"api/visual/#dvz_graphics_builtin","text":"Create a new graphics pipeline of a given builtin type. DvzGraphics * dvz_graphics_builtin ( DvzCanvas * canvas , DvzGraphicsType type , int flags ); Parameter Type Description canvas DvzCanvas* the canvas holding the grahpics pipeline type DvzGraphicsType the graphics type flags int the creation flags for the graphics","title":"dvz_graphics_builtin()"},{"location":"api/visual/#visual-internal-system","text":"","title":"Visual internal system"},{"location":"api/visual/#dvz_visual_update","text":"Update all GPU buffers and textures from the visual props and sources. void dvz_visual_update ( DvzVisual * visual , DvzViewport viewport , DvzDataCoords coords , const void * user_data ); Parameter Type Description visual DvzVisual* the visual viewport DvzViewport the viewport coords DvzDataCoords the data coordinates and transformation user_data void* arbitrary user data pointer","title":"dvz_visual_update()"},{"location":"api/vklite/","text":"vklite API \u00b6 GPU \u00b6 dvz_gpu() \u00b6 Initialize a GPU. DvzGpu * dvz_gpu ( DvzApp * app , uint32_t idx ); Parameter Type Description app DvzApp* the app idx uint32_t the GPU index among the system's GPUs returns DvzGpu* pointer to the created GPU object A GPU object is the interface to one of the GPUs on the current system. dvz_gpu_best() \u00b6 Find the \"best\" GPU on the system. DvzGpu * dvz_gpu_best ( DvzApp * app ); Parameter Type Description app DvzApp* the app returns DvzGpu* pointer to the best GPU object For now, this is just the discrete GPU with the most VRAM, or the GPU with the most VRAM if there are no discrete GPUs. dvz_gpu_request_features() \u00b6 Request some features before creating the GPU instance. void dvz_gpu_request_features ( DvzGpu * gpu , VkPhysicalDeviceFeatures requested_features ); Parameter Type Description gpu DvzGpu* the GPU requested_features VkPhysicalDeviceFeatures the list of requested features This function needs to be called before creating the GPU with dvz_gpu_create() . dvz_gpu_queue() \u00b6 Request a new Vulkan queue before creating the GPU. void dvz_gpu_queue ( DvzGpu * gpu , uint32_t idx , DvzQueueType type ); Parameter Type Description gpu DvzGpu* the GPU idx uint32_t the queue index (should be regularly increasing: 0, 1, 2...) type DvzQueueType the queue type dvz_gpu_create() \u00b6 Create a GPU once the features and queues have been set up. void dvz_gpu_create ( DvzGpu * gpu , VkSurfaceKHR surface ); Parameter Type Description gpu DvzGpu* the GPU surface VkSurfaceKHR the surface on which the GPU will need to render dvz_gpu_destroy() \u00b6 Destroy the resources associated to a GPU. void dvz_gpu_destroy ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU Coarse synchronization \u00b6 dvz_queue_wait() \u00b6 Wait for a queue to be idle. void dvz_queue_wait ( DvzGpu * gpu , uint32_t queue_idx ); Parameter Type Description gpu DvzGpu* the GPU queue_idx uint32_t the queue index This is one of the different GPU synchronization methods. It is not efficient as it waits until the queue is idle. dvz_app_wait() \u00b6 Full synchronization on all GPUs. void dvz_app_wait ( DvzApp * app ); Parameter Type Description app DvzApp* the application instance This function waits on all queues of all GPUs. The strongest, least efficient of the synchronization methods. dvz_gpu_wait() \u00b6 Full synchronization on a given GPU. void dvz_gpu_wait ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU This function waits on all queues of a given GPU. Window \u00b6 dvz_window() \u00b6 Create a blank window. DvzWindow * dvz_window ( DvzApp * app , uint32_t width , uint32_t height ); Parameter Type Description app DvzApp* the application instance width uint32_t the window width, in pixels height uint32_t the window height, in pixels returns DvzWindow* window This function is rarely used on its own. A bare window offers no functionality that allows one to render to it with Vulkan. One needs a swapchain, an event loop, and so on, which are provided instead at the level of the Canvas. dvz_window_get_size() \u00b6 Get the window size, in pixels. void dvz_window_get_size ( DvzWindow * window , uint32_t * framebuffer_width , uint32_t * framebuffer_height ); Parameter Type Description window DvzWindow* the window framebuffer_width uint32_t* the width, in pixels framebuffer_height uint32_t* the height, in pixels dvz_window_set_size() \u00b6 Set the window size, in pixels. void dvz_window_set_size ( DvzWindow * window , uint32_t width , uint32_t height ); Parameter Type Description window DvzWindow* the window width uint32_t the width, in pixels height uint32_t the height, in pixels dvz_window_poll_events() \u00b6 Process the pending windowing events by the backend (glfw by default). void dvz_window_poll_events ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window dvz_window_destroy() \u00b6 Destroy a window. void dvz_window_destroy ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window Warning This function must be imperatively called after dvz_swapchain_destroy() . Swapchain \u00b6 dvz_swapchain() \u00b6 Initialize a swapchain. DvzSwapchain dvz_swapchain ( DvzGpu * gpu , DvzWindow * window , uint32_t min_img_count ); Parameter Type Description gpu DvzGpu* the GPU window DvzWindow* the window min_img_count uint32_t the minimum acceptable number of images in the swapchain returns DvzSwapchain swapchain dvz_swapchain_format() \u00b6 Set the swapchain image format. void dvz_swapchain_format ( DvzSwapchain * swapchain , VkFormat format ); Parameter Type Description swapchain DvzSwapchain* the swapchain format VkFormat the format dvz_swapchain_present_mode() \u00b6 Set the swapchain present mode. void dvz_swapchain_present_mode ( DvzSwapchain * swapchain , VkPresentModeKHR present_mode ); Parameter Type Description swapchain DvzSwapchain* the swapchain present_mode VkPresentModeKHR the present mode dvz_swapchain_requested_size() \u00b6 Set the swapchain requested image size. void dvz_swapchain_requested_size ( DvzSwapchain * swapchain , uint32_t width , uint32_t height ); Parameter Type Description swapchain DvzSwapchain* the swapchain width uint32_t the requested width height uint32_t the requested height dvz_swapchain_create() \u00b6 Create the swapchain once it has been set up. void dvz_swapchain_create ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain dvz_swapchain_recreate() \u00b6 Recreate a swapchain (for example after a window resize). void dvz_swapchain_recreate ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain dvz_swapchain_acquire() \u00b6 Acquire a swapchain image. void dvz_swapchain_acquire ( DvzSwapchain * swapchain , DvzSemaphores * semaphores , uint32_t semaphore_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain semaphores DvzSemaphores* the set of signal semaphores semaphore_idx uint32_t the index of the semaphore to signal after image acquisition fences DvzFences* the set of signal fences fence_idx uint32_t the index of the fence to signal after image acquisition dvz_swapchain_present() \u00b6 Present a swapchain image to the screen after it has been rendered. void dvz_swapchain_present ( DvzSwapchain * swapchain , uint32_t queue_idx , DvzSemaphores * semaphores , uint32_t semaphore_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain queue_idx uint32_t the index of the present queue semaphores DvzSemaphores* the set of waiting semaphores semaphore_idx uint32_t the index of the semaphore to wait on before presentation dvz_swapchain_destroy() \u00b6 Destroy a swapchain void dvz_swapchain_destroy ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain Warning This function must imperatively be called before dvz_window_destroy() . Command buffers \u00b6 dvz_commands() \u00b6 Create a set of command buffers. DvzCommands dvz_commands ( DvzGpu * gpu , uint32_t queue , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU queue uint32_t the queue index within the GPU count uint32_t the number of command buffers to create returns DvzCommands set of command buffers Note We use the following convention in vklite and elsewhere in datoviz: the queue #0 must support transfer tasks. This convention makes the implementation a bit simpler. This convention is respected by the context module, where the first default queue is the transfer queue, dedicated to transfer tasks. dvz_cmd_begin() \u00b6 Start recording a command buffer. void dvz_cmd_begin ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to begin recording on dvz_cmd_end() \u00b6 Stop recording a command buffer. void dvz_cmd_end ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to stop the recording on dvz_cmd_reset() \u00b6 Reset a command buffer. void dvz_cmd_reset ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to reset dvz_cmd_free() \u00b6 Free a set of command buffers. void dvz_cmd_free ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers dvz_cmd_submit_sync() \u00b6 Submit a command buffer on its queue with inefficient full synchronization. void dvz_cmd_submit_sync ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to submit This function is relatively inefficient because it calls dvz_queue_wait() . dvz_commands_destroy() \u00b6 Destroy a set of command buffers. void dvz_commands_destroy ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers GPU buffer \u00b6 dvz_buffer() \u00b6 Initialize a GPU buffer. DvzBuffer dvz_buffer ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBuffer buffer dvz_buffer_size() \u00b6 Set the buffer size. void dvz_buffer_size ( DvzBuffer * buffer , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the buffer size, in bytes dvz_buffer_type() \u00b6 Set the buffer type. void dvz_buffer_type ( DvzBuffer * buffer , DvzBufferType type ); Parameter Type Description buffer DvzBuffer* the buffer type DvzBufferType the buffer type dvz_buffer_usage() \u00b6 Set the buffer usage. void dvz_buffer_usage ( DvzBuffer * buffer , VkBufferUsageFlags usage ); Parameter Type Description buffer DvzBuffer* the buffer usage VkBufferUsageFlags the buffer usage dvz_buffer_memory() \u00b6 Set the buffer memory properties. void dvz_buffer_memory ( DvzBuffer * buffer , VkMemoryPropertyFlags memory ); Parameter Type Description buffer DvzBuffer* the buffer memory VkMemoryPropertyFlags the memory properties dvz_buffer_queue_access() \u00b6 Set the buffer queue access. void dvz_buffer_queue_access ( DvzBuffer * buffer , uint32_t queue_idx ); Parameter Type Description buffer DvzBuffer* the buffer queue_idx uint32_t the queue index dvz_buffer_create() \u00b6 Create the buffer after it has been set. void dvz_buffer_create ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer dvz_buffer_resize() \u00b6 Resize a buffer. void dvz_buffer_resize ( DvzBuffer * buffer , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the new buffer size, in bytes dvz_buffer_map() \u00b6 Memory-map a buffer. void * dvz_buffer_map ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size to map, in bytes dvz_buffer_unmap() \u00b6 Unmap a buffer. void dvz_buffer_unmap ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer dvz_buffer_download() \u00b6 Download a buffer data to the CPU. void dvz_buffer_download ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size of the region to download, in bytes data void* the buffer to download on (must be allocated with the appropriate size) Important This function does not use any GPU synchronization primitive: this is the responsibility of the caller. A simple (but not optimal) method is just to call the following function after every call to this function: dvz_queue_wait(gpu, DVZ_DEFAULT_QUEUE_TRANSFER); dvz_buffer_upload() \u00b6 Upload data to a GPU buffer. void dvz_buffer_upload ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , const void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the buffer size, in bytes data void* the data to upload Important This function does not use any GPU synchronization primitive: this is the responsibility of the caller. A simple (but not optimal) method is just to call the following function after every call to this function: dvz_queue_wait(gpu, DVZ_DEFAULT_QUEUE_TRANSFER); dvz_buffer_destroy() \u00b6 Destroy a buffer void dvz_buffer_destroy ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer dvz_buffer_regions() \u00b6 Create buffer regions on an existing GPU buffer. DvzBufferRegions dvz_buffer_regions ( DvzBuffer * buffer , uint32_t count , VkDeviceSize offset , VkDeviceSize size , VkDeviceSize alignment ); Parameter Type Description buffer DvzBuffer* the buffer count uint32_t the number of successive regions offset VkDeviceSize the offset within the buffer size VkDeviceSize the size of each region, in bytes alignment VkDeviceSize the alignment requirement for the region offsets dvz_buffer_regions_map() \u00b6 Map a buffer region. void * dvz_buffer_regions_map ( DvzBufferRegions * br , uint32_t idx ); Parameter Type Description br DvzBufferRegions* the buffer regions idx uint32_t the index of the buffer region to map dvz_buffer_regions_unmap() \u00b6 Unmap a set of buffer regions. void dvz_buffer_regions_unmap ( DvzBufferRegions * br ); Parameter Type Description br DvzBufferRegions* the buffer regions dvz_buffer_regions_upload() \u00b6 Upload data to a buffer region. void dvz_buffer_regions_upload ( DvzBufferRegions * br , uint32_t idx , const void * data ); Parameter Type Description br DvzBufferRegions* the set of buffer regions idx uint32_t the index of the buffer region to upload data to data void* the data to upload Important This function does not use any GPU synchronization primitive: this is the responsibility of the caller. A simple (but not optimal) method is just to call the following function after every call to this function: dvz_queue_wait(gpu, DVZ_DEFAULT_QUEUE_TRANSFER); GPU images \u00b6 dvz_images() \u00b6 Initialize a set of GPU images. DvzImages dvz_images ( DvzGpu * gpu , VkImageType type , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU type VkImageType the image type count uint32_t the number of images returns DvzImages images dvz_images_format() \u00b6 Set the images format. void dvz_images_format ( DvzImages * images , VkFormat format ); Parameter Type Description images DvzImages* the images format VkFormat the image format dvz_images_layout() \u00b6 Set the images layout. void dvz_images_layout ( DvzImages * images , VkImageLayout layout ); Parameter Type Description images DvzImages* the images layout VkImageLayout the image layout dvz_images_size() \u00b6 Set the images size. void dvz_images_size ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the image width height uint32_t the image height depth uint32_t the image depth dvz_images_tiling() \u00b6 Set the images tiling. void dvz_images_tiling ( DvzImages * images , VkImageTiling tiling ); Parameter Type Description images DvzImages* the images tiling VkImageTiling the image tiling dvz_images_usage() \u00b6 Set the images usage. void dvz_images_usage ( DvzImages * images , VkImageUsageFlags usage ); Parameter Type Description images DvzImages* the images usage VkImageUsageFlags the image usage dvz_images_memory() \u00b6 Set the images memory properties. void dvz_images_memory ( DvzImages * images , VkMemoryPropertyFlags memory ); Parameter Type Description images DvzImages* the images memory VkMemoryPropertyFlags the memory properties dvz_images_aspect() \u00b6 Set the images aspect. void dvz_images_aspect ( DvzImages * images , VkImageAspectFlags aspect ); Parameter Type Description images DvzImages* the images aspect VkImageAspectFlags the image aspect dvz_images_queue_access() \u00b6 Set the images queue access. void dvz_images_queue_access ( DvzImages * images , uint32_t queue_idx ); Parameter Type Description images DvzImages* the images queue_idx uint32_t the queue index This parameter specifies which queues may access the image from command buffers submitted to them. dvz_images_create() \u00b6 Create the images after they have been set up. void dvz_images_create ( DvzImages * images ); Parameter Type Description images DvzImages* the images dvz_images_resize() \u00b6 Resize images. void dvz_images_resize ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the new width height uint32_t the new height depth uint32_t the new depth Warning This function deletes the images contents when resizing. dvz_images_transition() \u00b6 Transition the images to their layout after creation. void dvz_images_transition ( DvzImages * images ); Parameter Type Description images DvzImages* the images This function performs a hard synchronization on the queue and submits a command buffer with the image transition. dvz_images_download() \u00b6 Download the data from a staging GPU image. void dvz_images_download ( DvzImages * staging , uint32_t idx , VkDeviceSize bytes_per_component , bool swizzle , bool has_alpha , void * out ); Parameter Type Description staging DvzImages* the images to download the data from idx uint32_t the index of the image bytes_per_component VkDeviceSize number of bytes per component swizzle bool whether the RGB(A) values need to be transposed has_alpha bool whether there is an Alpha component in the output buffer out void* the buffer that will be filled with the image data (must be already allocated) dvz_images_destroy() \u00b6 Destroy images. void dvz_images_destroy ( DvzImages * images ); Parameter Type Description images DvzImages* the images Sampler \u00b6 dvz_sampler() \u00b6 Initialize a texture sampler. DvzSampler dvz_sampler ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSampler sampler object dvz_sampler_min_filter() \u00b6 Set the sampler min filter. void dvz_sampler_min_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter dvz_sampler_mag_filter() \u00b6 Set the sampler mag filter. void dvz_sampler_mag_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter dvz_sampler_address_mode() \u00b6 Set the sampler address mode void dvz_sampler_address_mode ( DvzSampler * sampler , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description sampler DvzSampler* the sampler axis DvzTextureAxis the sampler axis address_mode VkSamplerAddressMode the address mode dvz_sampler_create() \u00b6 Create the sampler after it has been set up. void dvz_sampler_create ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler dvz_sampler_destroy() \u00b6 Destroy a sampler void dvz_sampler_destroy ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler Pipeline slots \u00b6 Vulkan terminology: descriptor set layout. dvz_slots() \u00b6 Initialize pipeline slots (aka Vulkan descriptor set layout). DvzSlots dvz_slots ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSlots slots dvz_slots_binding() \u00b6 Set the slots binding. void dvz_slots_binding ( DvzSlots * slots , uint32_t idx , VkDescriptorType type ); Parameter Type Description slots DvzSlots* the slots idx uint32_t the slot index to set up type VkDescriptorType the descriptor type for that slot dvz_slots_push() \u00b6 Set up push constants. void dvz_slots_push ( DvzSlots * slots , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description slots DvzSlots* the slots offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant dvz_slots_create() \u00b6 Create the slots after they have been set up. void dvz_slots_create ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots dvz_slots_destroy() \u00b6 Destroy the slots void dvz_slots_destroy ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots Pipeline bindings \u00b6 Vulkan terminology: descriptor sets dvz_bindings() \u00b6 Initialize bindings corresponding to slots. DvzBindings dvz_bindings ( DvzSlots * slots , uint32_t dset_count ); Parameter Type Description slots DvzSlots* the slots dset_count uint32_t the number of descriptor sets (number of swapchain images) dvz_bindings_buffer() \u00b6 Bind a buffer to a slot. void dvz_bindings_buffer ( DvzBindings * bindings , uint32_t idx , DvzBufferRegions br ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br DvzBufferRegions the buffer regions to bind to that slot dvz_bindings_texture() \u00b6 Bind a texture to a slot. void dvz_bindings_texture ( DvzBindings * bindings , uint32_t idx , DvzTexture * texture ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br None the texture to bind to that slot dvz_bindings_update() \u00b6 Update the bindings after the buffers/textures have been set up. void dvz_bindings_update ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings dvz_bindings_destroy() \u00b6 Destroy bindings. void dvz_bindings_destroy ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings Graphics pipeline \u00b6 dvz_graphics() \u00b6 Initialize a graphics pipeline. DvzGraphics dvz_graphics ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzGraphics graphics pipeline dvz_graphics_renderpass() \u00b6 Set the renderpass of a graphics pipeline. void dvz_graphics_renderpass ( DvzGraphics * graphics , DvzRenderpass * renderpass , uint32_t subpass ); Parameter Type Description graphics DvzGraphics* the graphics pipeline renderpass DvzRenderpass* the render pass subpass uint32_t the subpass index dvz_graphics_topology() \u00b6 Set the graphics pipeline primitive topology void dvz_graphics_topology ( DvzGraphics * graphics , VkPrimitiveTopology topology ); Parameter Type Description graphics DvzGraphics* the graphics pipeline topology VkPrimitiveTopology the primitive topology dvz_graphics_shader_glsl() \u00b6 Set the GLSL code of a graphics pipeline. void dvz_graphics_shader_glsl ( DvzGraphics * graphics , VkShaderStageFlagBits stage , const char * code ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage code char* the GLSL code of the shader dvz_graphics_shader_spirv() \u00b6 Set the SPIRV code of a graphics pipeline. void dvz_graphics_shader_spirv ( DvzGraphics * graphics , VkShaderStageFlagBits stage , VkDeviceSize size , const uint32_t * buffer ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage size VkDeviceSize the size of the SPIRV buffer, in bytes buffer uint32_t* the binary buffer with the SPIRV code dvz_graphics_shader() \u00b6 Set the path to a shader for a graphics pipeline. void dvz_graphics_shader ( DvzGraphics * graphics , VkShaderStageFlagBits stage , const char * shader_path ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage shader_path char* the path to the .spirv shader file dvz_graphics_vertex_binding() \u00b6 Set the vertex binding. void dvz_graphics_vertex_binding ( DvzGraphics * graphics , uint32_t binding , VkDeviceSize stride ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index stride VkDeviceSize the stride in the vertex buffer, in bytes dvz_graphics_vertex_attr() \u00b6 Add a vertex attribute. void dvz_graphics_vertex_attr ( DvzGraphics * graphics , uint32_t binding , uint32_t location , VkFormat format , VkDeviceSize offset ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index (as specified in the vertex shader) location uint32_t the location index (as specified in the vertex shader) format VkFormat the format offset VkDeviceSize the offset, in bytes dvz_graphics_blend() \u00b6 Set the graphics blend type. void dvz_graphics_blend ( DvzGraphics * graphics , DvzBlendType blend_type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline blend_type DvzBlendType the blend type dvz_graphics_depth_test() \u00b6 Set the graphics depth test. void dvz_graphics_depth_test ( DvzGraphics * graphics , DvzDepthTest depth_test ); Parameter Type Description graphics DvzGraphics* the graphics pipeline depth_test DvzDepthTest the depth test dvz_graphics_pick() \u00b6 Set whether the graphics pipeline supports picking. void dvz_graphics_pick ( DvzGraphics * graphics , bool support_pick ); Parameter Type Description graphics DvzGraphics* the graphics pipeline support_pick bool whether the graphics pipeline supports picking Note Picking support is currently all or nothing: all graphics of a canvas must either support picking or not. In addition, the canvas must have been created with the DVZ_CANVAS_FLAGS_PICK flag. dvz_graphics_polygon_mode() \u00b6 Set the graphics polygon mode. void dvz_graphics_polygon_mode ( DvzGraphics * graphics , VkPolygonMode polygon_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline polygon_mode VkPolygonMode the polygon mode dvz_graphics_cull_mode() \u00b6 Set the graphics cull mode. void dvz_graphics_cull_mode ( DvzGraphics * graphics , VkCullModeFlags cull_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline cull_mode VkCullModeFlags the cull mode dvz_graphics_front_face() \u00b6 Set the graphics front face. void dvz_graphics_front_face ( DvzGraphics * graphics , VkFrontFace front_face ); Parameter Type Description graphics DvzGraphics* the graphics pipeline front_face VkFrontFace the front face dvz_graphics_create() \u00b6 Create a graphics pipeline after it has been set up. void dvz_graphics_create ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline dvz_graphics_slot() \u00b6 Set a binding slot for a graphics pipeline. void dvz_graphics_slot ( DvzGraphics * graphics , uint32_t idx , VkDescriptorType type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type dvz_graphics_push() \u00b6 Set a graphics pipeline push constant. void dvz_graphics_push ( DvzGraphics * graphics , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description graphics DvzGraphics* the graphics pipeline offset VkDeviceSize the push constant offset, in bytes offset VkDeviceSize the push size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant dvz_graphics_destroy() \u00b6 Destroy a graphics pipeline. void dvz_graphics_destroy ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline Compute pipeline \u00b6 dvz_compute() \u00b6 Initialize a compute pipeline. DvzCompute dvz_compute ( DvzGpu * gpu , const char * shader_path ); Parameter Type Description gpu DvzGpu* the GPU shader_path char* (optional) the path to the .spirv file with the compute shader returns DvzCompute compute pipeline dvz_compute_create() \u00b6 Create a compute pipeline after it has been set up. void dvz_compute_create ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline dvz_compute_code() \u00b6 Set the GLSL code directly (the library will compile it automatically to SPIRV). void dvz_compute_code ( DvzCompute * compute , const char * code ); Parameter Type Description compute DvzCompute* the compute pipeline code char* the GLSL code defining the compute shader dvz_compute_slot() \u00b6 Declare a slot for the compute pipeline. void dvz_compute_slot ( DvzCompute * compute , uint32_t idx , VkDescriptorType type ); Parameter Type Description compute DvzCompute* the compute pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type dvz_compute_push() \u00b6 Set up push constant. void dvz_compute_push ( DvzCompute * compute , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description compute DvzCompute* the compute pipeline offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shaders that will need to access the push constant dvz_compute_bindings() \u00b6 Associate a bindings object to a compute pipeline. void dvz_compute_bindings ( DvzCompute * compute , DvzBindings * bindings ); Parameter Type Description compute DvzCompute* the compute pipeline bindings DvzBindings* the bindings dvz_compute_destroy() \u00b6 Destroy a compute pipeline. void dvz_compute_destroy ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline Barrier \u00b6 dvz_barrier() \u00b6 Initialize a synchronization barrier (usedwithin a command buffer). DvzBarrier dvz_barrier ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBarrier barrier dvz_barrier_stages() \u00b6 Set the barrier stages. void dvz_barrier_stages ( DvzBarrier * barrier , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description barrier DvzBarrier* the barrier src_stage VkPipelineStageFlags the source stage dst_stage VkPipelineStageFlags the destination stage dvz_barrier_buffer() \u00b6 Set the barrier buffer. void dvz_barrier_buffer ( DvzBarrier * barrier , DvzBufferRegions br ); Parameter Type Description barrier DvzBarrier* the barrier br DvzBufferRegions the buffer regions dvz_barrier_buffer_queue() \u00b6 Set the barrier buffer queue. void dvz_barrier_buffer_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index dvz_barrier_buffer_access() \u00b6 Set the barrier buffer access. void dvz_barrier_buffer_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags dvz_barrier_images() \u00b6 Set the barrier images. void dvz_barrier_images ( DvzBarrier * barrier , DvzImages * images ); Parameter Type Description barrier DvzBarrier* the barrier images DvzImages* the images dvz_barrier_images_layout() \u00b6 Set the barrier images layout. void dvz_barrier_images_layout ( DvzBarrier * barrier , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description barrier DvzBarrier* the barrier src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout dvz_barrier_images_queue() \u00b6 Set the barrier images queue. void dvz_barrier_images_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index dvz_barrier_images_access() \u00b6 Set the barrier images access. void dvz_barrier_images_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags Semaphores \u00b6 dvz_semaphores() \u00b6 Initialize a set of semaphores (GPU-GPU synchronization). DvzSemaphores dvz_semaphores ( DvzGpu * gpu , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of semaphores returns DvzSemaphores semaphores dvz_semaphores_destroy() \u00b6 Destroy semaphores. void dvz_semaphores_destroy ( DvzSemaphores * semaphores ); Parameter Type Description semaphores DvzSemaphores* the semaphores Fences \u00b6 dvz_fences() \u00b6 Initialize a set of fences (CPU-GPU synchronization). DvzFences dvz_fences ( DvzGpu * gpu , uint32_t count , bool signaled ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of fences signaled bool whether the fences are created in the signaled state or not returns DvzFences fences dvz_fences_copy() \u00b6 Copy a fence from a set of fences to another. void dvz_fences_copy ( DvzFences * src_fences , uint32_t src_idx , DvzFences * dst_fences , uint32_t dst_idx ); Parameter Type Description src_fences DvzFences* the source fences src_idx uint32_t the fence index within the source fences dst_fences DvzFences* the destination fences dst_idx uint32_t the fence index within the destination fences dvz_fences_wait() \u00b6 Wait on the GPU until a fence is signaled. void dvz_fences_wait ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index dvz_fences_ready() \u00b6 Return whether a fence is ready. bool dvz_fences_ready ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index dvz_fences_reset() \u00b6 Rset the state of a fence. void dvz_fences_reset ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index dvz_fences_destroy() \u00b6 Destroy fences. void dvz_fences_destroy ( DvzFences * fences ); Parameter Type Description fences DvzFences* the fences Renderpass \u00b6 dvz_renderpass() \u00b6 Initialize a render pass. DvzRenderpass dvz_renderpass ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzRenderpass render pass dvz_renderpass_clear() \u00b6 Set the clear value of a render pass. void dvz_renderpass_clear ( DvzRenderpass * renderpass , VkClearValue value ); Parameter Type Description renderpass DvzRenderpass* the render pass value VkClearValue the clear value dvz_renderpass_attachment() \u00b6 Specify a render pass attachment. void dvz_renderpass_attachment ( DvzRenderpass * renderpass , uint32_t idx , DvzRenderpassAttachmentType type , VkFormat format , VkImageLayout ref_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index type DvzRenderpassAttachmentType the attachment type format VkFormat the attachment image format ref_layout VkImageLayout the image layout dvz_renderpass_attachment_layout() \u00b6 Set the attachment layout. void dvz_renderpass_attachment_layout ( DvzRenderpass * renderpass , uint32_t idx , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout dvz_renderpass_attachment_ops() \u00b6 Set the attachment load and store operations. void dvz_renderpass_attachment_ops ( DvzRenderpass * renderpass , uint32_t idx , VkAttachmentLoadOp load_op , VkAttachmentStoreOp store_op ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index load_op VkAttachmentLoadOp the load operation store_op VkAttachmentStoreOp the store operation dvz_renderpass_subpass_attachment() \u00b6 Set a subpass attachment. void dvz_renderpass_subpass_attachment ( DvzRenderpass * renderpass , uint32_t subpass_idx , uint32_t attachment_idx ); Parameter Type Description renderpass DvzRenderpass* the render pass subpass_idx uint32_t the subpass index attachment_idx uint32_t the attachment index dvz_renderpass_subpass_dependency() \u00b6 Set a subpass dependency. void dvz_renderpass_subpass_dependency ( DvzRenderpass * renderpass , uint32_t dependency_idx , uint32_t src_subpass , uint32_t dst_subpass ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_subpass uint32_t the source subpass index dst_subpass uint32_t the destination subpass index dvz_renderpass_subpass_dependency_access() \u00b6 Set a subpass dependency access. void dvz_renderpass_subpass_dependency_access ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destinationaccess flags dvz_renderpass_subpass_dependency_stage() \u00b6 Set a subpass dependency stage. void dvz_renderpass_subpass_dependency_stage ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_stage VkPipelineStageFlags the source pipeline stages dst_stage VkPipelineStageFlags the destination pipeline stages dvz_renderpass_create() \u00b6 Create a render pass after it has been set up. void dvz_renderpass_create ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass dvz_renderpass_destroy() \u00b6 Destroy a render pass. void dvz_renderpass_destroy ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass Framebuffers \u00b6 dvz_framebuffers() \u00b6 Initialize a set of framebuffers. DvzFramebuffers dvz_framebuffers ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzFramebuffers framebuffers dvz_framebuffers_attachment() \u00b6 Set framebuffers attachment. void dvz_framebuffers_attachment ( DvzFramebuffers * framebuffers , uint32_t attachment_idx , DvzImages * images ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers attachment_idx uint32_t the attachment index images DvzImages* the images dvz_framebuffers_create() \u00b6 Create a set of framebuffers after it has been set up. void dvz_framebuffers_create ( DvzFramebuffers * framebuffers , DvzRenderpass * renderpass ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers renderpass DvzRenderpass* the render pass dvz_framebuffers_destroy() \u00b6 Destroy a set of framebuffers. void dvz_framebuffers_destroy ( DvzFramebuffers * framebuffers ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers Submit \u00b6 dvz_submit() \u00b6 Create a submit object, used to submit command buffers to a GPU queue. DvzSubmit dvz_submit ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSubmit submit dvz_submit_commands() \u00b6 Set the command buffers to submit. void dvz_submit_commands ( DvzSubmit * submit , DvzCommands * commands ); Parameter Type Description submit DvzSubmit* the submit object cmds None the set of command buffers dvz_submit_wait_semaphores() \u00b6 Set the wait semaphores void dvz_submit_wait_semaphores ( DvzSubmit * submit , VkPipelineStageFlags stage , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object stage VkPipelineStageFlags the pipeline stage semaphores DvzSemaphores* the set of semaphores to wait on idx uint32_t the semaphore index to wait on dvz_submit_signal_semaphores() \u00b6 Set the signal semaphores void dvz_submit_signal_semaphores ( DvzSubmit * submit , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object semaphores DvzSemaphores* the set of semaphores to signal after the commands have completed idx uint32_t the semaphore index to signal dvz_submit_send() \u00b6 Submit the command buffers to their queue. void dvz_submit_send ( DvzSubmit * submit , uint32_t cmd_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description submit DvzSubmit* the submit object cmd_idx uint32_t the command buffer index to submit fences DvzFences* the fences to signal after completion fence_idx uint32_t the fence index to signal dvz_submit_reset() \u00b6 Reset a submit object. void dvz_submit_reset ( DvzSubmit * submit ); Parameter Type Description submit DvzSubmit* the submit object Command buffer recording \u00b6 dvz_cmd_begin_renderpass() \u00b6 Begin a render pass. void dvz_cmd_begin_renderpass ( DvzCommands * cmds , uint32_t idx , DvzRenderpass * renderpass , DvzFramebuffers * framebuffers ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record renderpass DvzRenderpass* the render pass framebuffers DvzFramebuffers* the framebuffers dvz_cmd_end_renderpass() \u00b6 End a render pass. void dvz_cmd_end_renderpass ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record dvz_cmd_compute() \u00b6 Launch a compute task. void dvz_cmd_compute ( DvzCommands * cmds , uint32_t idx , DvzCompute * compute , uvec3 size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record compute DvzCompute* the computer pipeline size uvec3 the task shape dvz_cmd_barrier() \u00b6 Register a barrier. void dvz_cmd_barrier ( DvzCommands * cmds , uint32_t idx , DvzBarrier * barrier ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record barrier DvzBarrier* the barrier dvz_cmd_copy_buffer_to_image() \u00b6 Copy a GPU buffer to a GPU image. void dvz_cmd_copy_buffer_to_image ( DvzCommands * cmds , uint32_t idx , DvzBuffer * buffer , DvzImages * images ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record buffer DvzBuffer* the buffer images DvzImages* the image dvz_cmd_copy_image_to_buffer() \u00b6 Copy a GPU image to a GPU buffer. void dvz_cmd_copy_image_to_buffer ( DvzCommands * cmds , uint32_t idx , DvzImages * images , DvzBuffer * buffer ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record images DvzImages* the image buffer DvzBuffer* the buffer dvz_cmd_copy_image() \u00b6 Copy a GPU image to another. void dvz_cmd_copy_image ( DvzCommands * cmds , uint32_t idx , DvzImages * src_img , DvzImages * dst_img ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_img DvzImages* the source image dst_img DvzImages* the destination image dvz_cmd_copy_image_region() \u00b6 Copy a GPU image to another. void dvz_cmd_copy_image_region ( DvzCommands * cmds , uint32_t idx , DvzImages * src_img , ivec3 src_offset , DvzImages * dst_img , ivec3 dst_offset , uvec3 shape ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_img DvzImages* the source image src_offset ivec3 the offset in the source image dst_img DvzImages* the destination image dst_offset ivec3 the offset in the target image shape uvec3 the shape of the region to copy dvz_cmd_viewport() \u00b6 Set the viewport. void dvz_cmd_viewport ( DvzCommands * cmds , uint32_t idx , VkViewport viewport ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record viewport VkViewport the viewport dvz_cmd_bind_graphics() \u00b6 Bind a graphics pipeline. void dvz_cmd_bind_graphics ( DvzCommands * cmds , uint32_t idx , DvzGraphics * graphics , DvzBindings * bindings , uint32_t dynamic_idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record graphics DvzGraphics* the graphics pipeline bindings DvzBindings* the bindings associated to the pipeline dynamic_idx uint32_t the dynamic uniform buffer index dvz_cmd_bind_vertex_buffer() \u00b6 Bind a vertex buffer. void dvz_cmd_bind_vertex_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes dvz_cmd_bind_index_buffer() \u00b6 Bind an index buffer. void dvz_cmd_bind_index_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes dvz_cmd_draw() \u00b6 Direct draw. void dvz_cmd_draw ( DvzCommands * cmds , uint32_t idx , uint32_t first_vertex , uint32_t vertex_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_vertex uint32_t index of the first vertex vertex_count uint32_t number of vertices to draw dvz_cmd_draw_indexed() \u00b6 Direct indexed draw. void dvz_cmd_draw_indexed ( DvzCommands * cmds , uint32_t idx , uint32_t first_index , uint32_t vertex_offset , uint32_t index_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_index uint32_t index of the first index vertex_offset uint32_t offset of the vertex index_count uint32_t number of indices to draw dvz_cmd_draw_indirect() \u00b6 Indirect draw. void dvz_cmd_draw_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info dvz_cmd_draw_indexed_indirect() \u00b6 Indirect indexed draw. void dvz_cmd_draw_indexed_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info dvz_cmd_copy_buffer() \u00b6 Copy a GPU buffer to another. void dvz_cmd_copy_buffer ( DvzCommands * cmds , uint32_t idx , DvzBuffer * src_buf , VkDeviceSize src_offset , DvzBuffer * dst_buf , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_buf DvzBuffer* the source buffer src_offset VkDeviceSize the offset in the source buffer dst_buf DvzBuffer* the destination buffer, in bytes dst_offset VkDeviceSize the offset in the destination buffer, in bytes size VkDeviceSize the size of the region to copy, in bytes dvz_cmd_push() \u00b6 Push constants. void dvz_cmd_push ( DvzCommands * cmds , uint32_t idx , DvzSlots * slots , VkShaderStageFlagBits shaders , VkDeviceSize offset , VkDeviceSize size , const void * data ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record slots DvzSlots* the slots shaders VkShaderStageFlagBits the shader stages that have access to the push constant offset VkDeviceSize the offset in the push constant, in bytes size VkDeviceSize the size in the push constant, in bytes data void* the data to send via the push constant","title":"vklite API"},{"location":"api/vklite/#vklite-api","text":"","title":"vklite API"},{"location":"api/vklite/#gpu","text":"","title":"GPU"},{"location":"api/vklite/#dvz_gpu","text":"Initialize a GPU. DvzGpu * dvz_gpu ( DvzApp * app , uint32_t idx ); Parameter Type Description app DvzApp* the app idx uint32_t the GPU index among the system's GPUs returns DvzGpu* pointer to the created GPU object A GPU object is the interface to one of the GPUs on the current system.","title":"dvz_gpu()"},{"location":"api/vklite/#dvz_gpu_best","text":"Find the \"best\" GPU on the system. DvzGpu * dvz_gpu_best ( DvzApp * app ); Parameter Type Description app DvzApp* the app returns DvzGpu* pointer to the best GPU object For now, this is just the discrete GPU with the most VRAM, or the GPU with the most VRAM if there are no discrete GPUs.","title":"dvz_gpu_best()"},{"location":"api/vklite/#dvz_gpu_request_features","text":"Request some features before creating the GPU instance. void dvz_gpu_request_features ( DvzGpu * gpu , VkPhysicalDeviceFeatures requested_features ); Parameter Type Description gpu DvzGpu* the GPU requested_features VkPhysicalDeviceFeatures the list of requested features This function needs to be called before creating the GPU with dvz_gpu_create() .","title":"dvz_gpu_request_features()"},{"location":"api/vklite/#dvz_gpu_queue","text":"Request a new Vulkan queue before creating the GPU. void dvz_gpu_queue ( DvzGpu * gpu , uint32_t idx , DvzQueueType type ); Parameter Type Description gpu DvzGpu* the GPU idx uint32_t the queue index (should be regularly increasing: 0, 1, 2...) type DvzQueueType the queue type","title":"dvz_gpu_queue()"},{"location":"api/vklite/#dvz_gpu_create","text":"Create a GPU once the features and queues have been set up. void dvz_gpu_create ( DvzGpu * gpu , VkSurfaceKHR surface ); Parameter Type Description gpu DvzGpu* the GPU surface VkSurfaceKHR the surface on which the GPU will need to render","title":"dvz_gpu_create()"},{"location":"api/vklite/#dvz_gpu_destroy","text":"Destroy the resources associated to a GPU. void dvz_gpu_destroy ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU","title":"dvz_gpu_destroy()"},{"location":"api/vklite/#coarse-synchronization","text":"","title":"Coarse synchronization"},{"location":"api/vklite/#dvz_queue_wait","text":"Wait for a queue to be idle. void dvz_queue_wait ( DvzGpu * gpu , uint32_t queue_idx ); Parameter Type Description gpu DvzGpu* the GPU queue_idx uint32_t the queue index This is one of the different GPU synchronization methods. It is not efficient as it waits until the queue is idle.","title":"dvz_queue_wait()"},{"location":"api/vklite/#dvz_app_wait","text":"Full synchronization on all GPUs. void dvz_app_wait ( DvzApp * app ); Parameter Type Description app DvzApp* the application instance This function waits on all queues of all GPUs. The strongest, least efficient of the synchronization methods.","title":"dvz_app_wait()"},{"location":"api/vklite/#dvz_gpu_wait","text":"Full synchronization on a given GPU. void dvz_gpu_wait ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU This function waits on all queues of a given GPU.","title":"dvz_gpu_wait()"},{"location":"api/vklite/#window","text":"","title":"Window"},{"location":"api/vklite/#dvz_window","text":"Create a blank window. DvzWindow * dvz_window ( DvzApp * app , uint32_t width , uint32_t height ); Parameter Type Description app DvzApp* the application instance width uint32_t the window width, in pixels height uint32_t the window height, in pixels returns DvzWindow* window This function is rarely used on its own. A bare window offers no functionality that allows one to render to it with Vulkan. One needs a swapchain, an event loop, and so on, which are provided instead at the level of the Canvas.","title":"dvz_window()"},{"location":"api/vklite/#dvz_window_get_size","text":"Get the window size, in pixels. void dvz_window_get_size ( DvzWindow * window , uint32_t * framebuffer_width , uint32_t * framebuffer_height ); Parameter Type Description window DvzWindow* the window framebuffer_width uint32_t* the width, in pixels framebuffer_height uint32_t* the height, in pixels","title":"dvz_window_get_size()"},{"location":"api/vklite/#dvz_window_set_size","text":"Set the window size, in pixels. void dvz_window_set_size ( DvzWindow * window , uint32_t width , uint32_t height ); Parameter Type Description window DvzWindow* the window width uint32_t the width, in pixels height uint32_t the height, in pixels","title":"dvz_window_set_size()"},{"location":"api/vklite/#dvz_window_poll_events","text":"Process the pending windowing events by the backend (glfw by default). void dvz_window_poll_events ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window","title":"dvz_window_poll_events()"},{"location":"api/vklite/#dvz_window_destroy","text":"Destroy a window. void dvz_window_destroy ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window Warning This function must be imperatively called after dvz_swapchain_destroy() .","title":"dvz_window_destroy()"},{"location":"api/vklite/#swapchain","text":"","title":"Swapchain"},{"location":"api/vklite/#dvz_swapchain","text":"Initialize a swapchain. DvzSwapchain dvz_swapchain ( DvzGpu * gpu , DvzWindow * window , uint32_t min_img_count ); Parameter Type Description gpu DvzGpu* the GPU window DvzWindow* the window min_img_count uint32_t the minimum acceptable number of images in the swapchain returns DvzSwapchain swapchain","title":"dvz_swapchain()"},{"location":"api/vklite/#dvz_swapchain_format","text":"Set the swapchain image format. void dvz_swapchain_format ( DvzSwapchain * swapchain , VkFormat format ); Parameter Type Description swapchain DvzSwapchain* the swapchain format VkFormat the format","title":"dvz_swapchain_format()"},{"location":"api/vklite/#dvz_swapchain_present_mode","text":"Set the swapchain present mode. void dvz_swapchain_present_mode ( DvzSwapchain * swapchain , VkPresentModeKHR present_mode ); Parameter Type Description swapchain DvzSwapchain* the swapchain present_mode VkPresentModeKHR the present mode","title":"dvz_swapchain_present_mode()"},{"location":"api/vklite/#dvz_swapchain_requested_size","text":"Set the swapchain requested image size. void dvz_swapchain_requested_size ( DvzSwapchain * swapchain , uint32_t width , uint32_t height ); Parameter Type Description swapchain DvzSwapchain* the swapchain width uint32_t the requested width height uint32_t the requested height","title":"dvz_swapchain_requested_size()"},{"location":"api/vklite/#dvz_swapchain_create","text":"Create the swapchain once it has been set up. void dvz_swapchain_create ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain","title":"dvz_swapchain_create()"},{"location":"api/vklite/#dvz_swapchain_recreate","text":"Recreate a swapchain (for example after a window resize). void dvz_swapchain_recreate ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain","title":"dvz_swapchain_recreate()"},{"location":"api/vklite/#dvz_swapchain_acquire","text":"Acquire a swapchain image. void dvz_swapchain_acquire ( DvzSwapchain * swapchain , DvzSemaphores * semaphores , uint32_t semaphore_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain semaphores DvzSemaphores* the set of signal semaphores semaphore_idx uint32_t the index of the semaphore to signal after image acquisition fences DvzFences* the set of signal fences fence_idx uint32_t the index of the fence to signal after image acquisition","title":"dvz_swapchain_acquire()"},{"location":"api/vklite/#dvz_swapchain_present","text":"Present a swapchain image to the screen after it has been rendered. void dvz_swapchain_present ( DvzSwapchain * swapchain , uint32_t queue_idx , DvzSemaphores * semaphores , uint32_t semaphore_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain queue_idx uint32_t the index of the present queue semaphores DvzSemaphores* the set of waiting semaphores semaphore_idx uint32_t the index of the semaphore to wait on before presentation","title":"dvz_swapchain_present()"},{"location":"api/vklite/#dvz_swapchain_destroy","text":"Destroy a swapchain void dvz_swapchain_destroy ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain Warning This function must imperatively be called before dvz_window_destroy() .","title":"dvz_swapchain_destroy()"},{"location":"api/vklite/#command-buffers","text":"","title":"Command buffers"},{"location":"api/vklite/#dvz_commands","text":"Create a set of command buffers. DvzCommands dvz_commands ( DvzGpu * gpu , uint32_t queue , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU queue uint32_t the queue index within the GPU count uint32_t the number of command buffers to create returns DvzCommands set of command buffers Note We use the following convention in vklite and elsewhere in datoviz: the queue #0 must support transfer tasks. This convention makes the implementation a bit simpler. This convention is respected by the context module, where the first default queue is the transfer queue, dedicated to transfer tasks.","title":"dvz_commands()"},{"location":"api/vklite/#dvz_cmd_begin","text":"Start recording a command buffer. void dvz_cmd_begin ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to begin recording on","title":"dvz_cmd_begin()"},{"location":"api/vklite/#dvz_cmd_end","text":"Stop recording a command buffer. void dvz_cmd_end ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to stop the recording on","title":"dvz_cmd_end()"},{"location":"api/vklite/#dvz_cmd_reset","text":"Reset a command buffer. void dvz_cmd_reset ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to reset","title":"dvz_cmd_reset()"},{"location":"api/vklite/#dvz_cmd_free","text":"Free a set of command buffers. void dvz_cmd_free ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers","title":"dvz_cmd_free()"},{"location":"api/vklite/#dvz_cmd_submit_sync","text":"Submit a command buffer on its queue with inefficient full synchronization. void dvz_cmd_submit_sync ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to submit This function is relatively inefficient because it calls dvz_queue_wait() .","title":"dvz_cmd_submit_sync()"},{"location":"api/vklite/#dvz_commands_destroy","text":"Destroy a set of command buffers. void dvz_commands_destroy ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers","title":"dvz_commands_destroy()"},{"location":"api/vklite/#gpu-buffer","text":"","title":"GPU buffer"},{"location":"api/vklite/#dvz_buffer","text":"Initialize a GPU buffer. DvzBuffer dvz_buffer ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBuffer buffer","title":"dvz_buffer()"},{"location":"api/vklite/#dvz_buffer_size","text":"Set the buffer size. void dvz_buffer_size ( DvzBuffer * buffer , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the buffer size, in bytes","title":"dvz_buffer_size()"},{"location":"api/vklite/#dvz_buffer_type","text":"Set the buffer type. void dvz_buffer_type ( DvzBuffer * buffer , DvzBufferType type ); Parameter Type Description buffer DvzBuffer* the buffer type DvzBufferType the buffer type","title":"dvz_buffer_type()"},{"location":"api/vklite/#dvz_buffer_usage","text":"Set the buffer usage. void dvz_buffer_usage ( DvzBuffer * buffer , VkBufferUsageFlags usage ); Parameter Type Description buffer DvzBuffer* the buffer usage VkBufferUsageFlags the buffer usage","title":"dvz_buffer_usage()"},{"location":"api/vklite/#dvz_buffer_memory","text":"Set the buffer memory properties. void dvz_buffer_memory ( DvzBuffer * buffer , VkMemoryPropertyFlags memory ); Parameter Type Description buffer DvzBuffer* the buffer memory VkMemoryPropertyFlags the memory properties","title":"dvz_buffer_memory()"},{"location":"api/vklite/#dvz_buffer_queue_access","text":"Set the buffer queue access. void dvz_buffer_queue_access ( DvzBuffer * buffer , uint32_t queue_idx ); Parameter Type Description buffer DvzBuffer* the buffer queue_idx uint32_t the queue index","title":"dvz_buffer_queue_access()"},{"location":"api/vklite/#dvz_buffer_create","text":"Create the buffer after it has been set. void dvz_buffer_create ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer","title":"dvz_buffer_create()"},{"location":"api/vklite/#dvz_buffer_resize","text":"Resize a buffer. void dvz_buffer_resize ( DvzBuffer * buffer , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the new buffer size, in bytes","title":"dvz_buffer_resize()"},{"location":"api/vklite/#dvz_buffer_map","text":"Memory-map a buffer. void * dvz_buffer_map ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size to map, in bytes","title":"dvz_buffer_map()"},{"location":"api/vklite/#dvz_buffer_unmap","text":"Unmap a buffer. void dvz_buffer_unmap ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer","title":"dvz_buffer_unmap()"},{"location":"api/vklite/#dvz_buffer_download","text":"Download a buffer data to the CPU. void dvz_buffer_download ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size of the region to download, in bytes data void* the buffer to download on (must be allocated with the appropriate size) Important This function does not use any GPU synchronization primitive: this is the responsibility of the caller. A simple (but not optimal) method is just to call the following function after every call to this function: dvz_queue_wait(gpu, DVZ_DEFAULT_QUEUE_TRANSFER);","title":"dvz_buffer_download()"},{"location":"api/vklite/#dvz_buffer_upload","text":"Upload data to a GPU buffer. void dvz_buffer_upload ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , const void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the buffer size, in bytes data void* the data to upload Important This function does not use any GPU synchronization primitive: this is the responsibility of the caller. A simple (but not optimal) method is just to call the following function after every call to this function: dvz_queue_wait(gpu, DVZ_DEFAULT_QUEUE_TRANSFER);","title":"dvz_buffer_upload()"},{"location":"api/vklite/#dvz_buffer_destroy","text":"Destroy a buffer void dvz_buffer_destroy ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer","title":"dvz_buffer_destroy()"},{"location":"api/vklite/#dvz_buffer_regions","text":"Create buffer regions on an existing GPU buffer. DvzBufferRegions dvz_buffer_regions ( DvzBuffer * buffer , uint32_t count , VkDeviceSize offset , VkDeviceSize size , VkDeviceSize alignment ); Parameter Type Description buffer DvzBuffer* the buffer count uint32_t the number of successive regions offset VkDeviceSize the offset within the buffer size VkDeviceSize the size of each region, in bytes alignment VkDeviceSize the alignment requirement for the region offsets","title":"dvz_buffer_regions()"},{"location":"api/vklite/#dvz_buffer_regions_map","text":"Map a buffer region. void * dvz_buffer_regions_map ( DvzBufferRegions * br , uint32_t idx ); Parameter Type Description br DvzBufferRegions* the buffer regions idx uint32_t the index of the buffer region to map","title":"dvz_buffer_regions_map()"},{"location":"api/vklite/#dvz_buffer_regions_unmap","text":"Unmap a set of buffer regions. void dvz_buffer_regions_unmap ( DvzBufferRegions * br ); Parameter Type Description br DvzBufferRegions* the buffer regions","title":"dvz_buffer_regions_unmap()"},{"location":"api/vklite/#dvz_buffer_regions_upload","text":"Upload data to a buffer region. void dvz_buffer_regions_upload ( DvzBufferRegions * br , uint32_t idx , const void * data ); Parameter Type Description br DvzBufferRegions* the set of buffer regions idx uint32_t the index of the buffer region to upload data to data void* the data to upload Important This function does not use any GPU synchronization primitive: this is the responsibility of the caller. A simple (but not optimal) method is just to call the following function after every call to this function: dvz_queue_wait(gpu, DVZ_DEFAULT_QUEUE_TRANSFER);","title":"dvz_buffer_regions_upload()"},{"location":"api/vklite/#gpu-images","text":"","title":"GPU images"},{"location":"api/vklite/#dvz_images","text":"Initialize a set of GPU images. DvzImages dvz_images ( DvzGpu * gpu , VkImageType type , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU type VkImageType the image type count uint32_t the number of images returns DvzImages images","title":"dvz_images()"},{"location":"api/vklite/#dvz_images_format","text":"Set the images format. void dvz_images_format ( DvzImages * images , VkFormat format ); Parameter Type Description images DvzImages* the images format VkFormat the image format","title":"dvz_images_format()"},{"location":"api/vklite/#dvz_images_layout","text":"Set the images layout. void dvz_images_layout ( DvzImages * images , VkImageLayout layout ); Parameter Type Description images DvzImages* the images layout VkImageLayout the image layout","title":"dvz_images_layout()"},{"location":"api/vklite/#dvz_images_size","text":"Set the images size. void dvz_images_size ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the image width height uint32_t the image height depth uint32_t the image depth","title":"dvz_images_size()"},{"location":"api/vklite/#dvz_images_tiling","text":"Set the images tiling. void dvz_images_tiling ( DvzImages * images , VkImageTiling tiling ); Parameter Type Description images DvzImages* the images tiling VkImageTiling the image tiling","title":"dvz_images_tiling()"},{"location":"api/vklite/#dvz_images_usage","text":"Set the images usage. void dvz_images_usage ( DvzImages * images , VkImageUsageFlags usage ); Parameter Type Description images DvzImages* the images usage VkImageUsageFlags the image usage","title":"dvz_images_usage()"},{"location":"api/vklite/#dvz_images_memory","text":"Set the images memory properties. void dvz_images_memory ( DvzImages * images , VkMemoryPropertyFlags memory ); Parameter Type Description images DvzImages* the images memory VkMemoryPropertyFlags the memory properties","title":"dvz_images_memory()"},{"location":"api/vklite/#dvz_images_aspect","text":"Set the images aspect. void dvz_images_aspect ( DvzImages * images , VkImageAspectFlags aspect ); Parameter Type Description images DvzImages* the images aspect VkImageAspectFlags the image aspect","title":"dvz_images_aspect()"},{"location":"api/vklite/#dvz_images_queue_access","text":"Set the images queue access. void dvz_images_queue_access ( DvzImages * images , uint32_t queue_idx ); Parameter Type Description images DvzImages* the images queue_idx uint32_t the queue index This parameter specifies which queues may access the image from command buffers submitted to them.","title":"dvz_images_queue_access()"},{"location":"api/vklite/#dvz_images_create","text":"Create the images after they have been set up. void dvz_images_create ( DvzImages * images ); Parameter Type Description images DvzImages* the images","title":"dvz_images_create()"},{"location":"api/vklite/#dvz_images_resize","text":"Resize images. void dvz_images_resize ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the new width height uint32_t the new height depth uint32_t the new depth Warning This function deletes the images contents when resizing.","title":"dvz_images_resize()"},{"location":"api/vklite/#dvz_images_transition","text":"Transition the images to their layout after creation. void dvz_images_transition ( DvzImages * images ); Parameter Type Description images DvzImages* the images This function performs a hard synchronization on the queue and submits a command buffer with the image transition.","title":"dvz_images_transition()"},{"location":"api/vklite/#dvz_images_download","text":"Download the data from a staging GPU image. void dvz_images_download ( DvzImages * staging , uint32_t idx , VkDeviceSize bytes_per_component , bool swizzle , bool has_alpha , void * out ); Parameter Type Description staging DvzImages* the images to download the data from idx uint32_t the index of the image bytes_per_component VkDeviceSize number of bytes per component swizzle bool whether the RGB(A) values need to be transposed has_alpha bool whether there is an Alpha component in the output buffer out void* the buffer that will be filled with the image data (must be already allocated)","title":"dvz_images_download()"},{"location":"api/vklite/#dvz_images_destroy","text":"Destroy images. void dvz_images_destroy ( DvzImages * images ); Parameter Type Description images DvzImages* the images","title":"dvz_images_destroy()"},{"location":"api/vklite/#sampler","text":"","title":"Sampler"},{"location":"api/vklite/#dvz_sampler","text":"Initialize a texture sampler. DvzSampler dvz_sampler ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSampler sampler object","title":"dvz_sampler()"},{"location":"api/vklite/#dvz_sampler_min_filter","text":"Set the sampler min filter. void dvz_sampler_min_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter","title":"dvz_sampler_min_filter()"},{"location":"api/vklite/#dvz_sampler_mag_filter","text":"Set the sampler mag filter. void dvz_sampler_mag_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter","title":"dvz_sampler_mag_filter()"},{"location":"api/vklite/#dvz_sampler_address_mode","text":"Set the sampler address mode void dvz_sampler_address_mode ( DvzSampler * sampler , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description sampler DvzSampler* the sampler axis DvzTextureAxis the sampler axis address_mode VkSamplerAddressMode the address mode","title":"dvz_sampler_address_mode()"},{"location":"api/vklite/#dvz_sampler_create","text":"Create the sampler after it has been set up. void dvz_sampler_create ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler","title":"dvz_sampler_create()"},{"location":"api/vklite/#dvz_sampler_destroy","text":"Destroy a sampler void dvz_sampler_destroy ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler","title":"dvz_sampler_destroy()"},{"location":"api/vklite/#pipeline-slots","text":"Vulkan terminology: descriptor set layout.","title":"Pipeline slots"},{"location":"api/vklite/#dvz_slots","text":"Initialize pipeline slots (aka Vulkan descriptor set layout). DvzSlots dvz_slots ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSlots slots","title":"dvz_slots()"},{"location":"api/vklite/#dvz_slots_binding","text":"Set the slots binding. void dvz_slots_binding ( DvzSlots * slots , uint32_t idx , VkDescriptorType type ); Parameter Type Description slots DvzSlots* the slots idx uint32_t the slot index to set up type VkDescriptorType the descriptor type for that slot","title":"dvz_slots_binding()"},{"location":"api/vklite/#dvz_slots_push","text":"Set up push constants. void dvz_slots_push ( DvzSlots * slots , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description slots DvzSlots* the slots offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant","title":"dvz_slots_push()"},{"location":"api/vklite/#dvz_slots_create","text":"Create the slots after they have been set up. void dvz_slots_create ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots","title":"dvz_slots_create()"},{"location":"api/vklite/#dvz_slots_destroy","text":"Destroy the slots void dvz_slots_destroy ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots","title":"dvz_slots_destroy()"},{"location":"api/vklite/#pipeline-bindings","text":"Vulkan terminology: descriptor sets","title":"Pipeline bindings"},{"location":"api/vklite/#dvz_bindings","text":"Initialize bindings corresponding to slots. DvzBindings dvz_bindings ( DvzSlots * slots , uint32_t dset_count ); Parameter Type Description slots DvzSlots* the slots dset_count uint32_t the number of descriptor sets (number of swapchain images)","title":"dvz_bindings()"},{"location":"api/vklite/#dvz_bindings_buffer","text":"Bind a buffer to a slot. void dvz_bindings_buffer ( DvzBindings * bindings , uint32_t idx , DvzBufferRegions br ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br DvzBufferRegions the buffer regions to bind to that slot","title":"dvz_bindings_buffer()"},{"location":"api/vklite/#dvz_bindings_texture","text":"Bind a texture to a slot. void dvz_bindings_texture ( DvzBindings * bindings , uint32_t idx , DvzTexture * texture ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br None the texture to bind to that slot","title":"dvz_bindings_texture()"},{"location":"api/vklite/#dvz_bindings_update","text":"Update the bindings after the buffers/textures have been set up. void dvz_bindings_update ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings","title":"dvz_bindings_update()"},{"location":"api/vklite/#dvz_bindings_destroy","text":"Destroy bindings. void dvz_bindings_destroy ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings","title":"dvz_bindings_destroy()"},{"location":"api/vklite/#graphics-pipeline","text":"","title":"Graphics pipeline"},{"location":"api/vklite/#dvz_graphics","text":"Initialize a graphics pipeline. DvzGraphics dvz_graphics ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzGraphics graphics pipeline","title":"dvz_graphics()"},{"location":"api/vklite/#dvz_graphics_renderpass","text":"Set the renderpass of a graphics pipeline. void dvz_graphics_renderpass ( DvzGraphics * graphics , DvzRenderpass * renderpass , uint32_t subpass ); Parameter Type Description graphics DvzGraphics* the graphics pipeline renderpass DvzRenderpass* the render pass subpass uint32_t the subpass index","title":"dvz_graphics_renderpass()"},{"location":"api/vklite/#dvz_graphics_topology","text":"Set the graphics pipeline primitive topology void dvz_graphics_topology ( DvzGraphics * graphics , VkPrimitiveTopology topology ); Parameter Type Description graphics DvzGraphics* the graphics pipeline topology VkPrimitiveTopology the primitive topology","title":"dvz_graphics_topology()"},{"location":"api/vklite/#dvz_graphics_shader_glsl","text":"Set the GLSL code of a graphics pipeline. void dvz_graphics_shader_glsl ( DvzGraphics * graphics , VkShaderStageFlagBits stage , const char * code ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage code char* the GLSL code of the shader","title":"dvz_graphics_shader_glsl()"},{"location":"api/vklite/#dvz_graphics_shader_spirv","text":"Set the SPIRV code of a graphics pipeline. void dvz_graphics_shader_spirv ( DvzGraphics * graphics , VkShaderStageFlagBits stage , VkDeviceSize size , const uint32_t * buffer ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage size VkDeviceSize the size of the SPIRV buffer, in bytes buffer uint32_t* the binary buffer with the SPIRV code","title":"dvz_graphics_shader_spirv()"},{"location":"api/vklite/#dvz_graphics_shader","text":"Set the path to a shader for a graphics pipeline. void dvz_graphics_shader ( DvzGraphics * graphics , VkShaderStageFlagBits stage , const char * shader_path ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage shader_path char* the path to the .spirv shader file","title":"dvz_graphics_shader()"},{"location":"api/vklite/#dvz_graphics_vertex_binding","text":"Set the vertex binding. void dvz_graphics_vertex_binding ( DvzGraphics * graphics , uint32_t binding , VkDeviceSize stride ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index stride VkDeviceSize the stride in the vertex buffer, in bytes","title":"dvz_graphics_vertex_binding()"},{"location":"api/vklite/#dvz_graphics_vertex_attr","text":"Add a vertex attribute. void dvz_graphics_vertex_attr ( DvzGraphics * graphics , uint32_t binding , uint32_t location , VkFormat format , VkDeviceSize offset ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index (as specified in the vertex shader) location uint32_t the location index (as specified in the vertex shader) format VkFormat the format offset VkDeviceSize the offset, in bytes","title":"dvz_graphics_vertex_attr()"},{"location":"api/vklite/#dvz_graphics_blend","text":"Set the graphics blend type. void dvz_graphics_blend ( DvzGraphics * graphics , DvzBlendType blend_type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline blend_type DvzBlendType the blend type","title":"dvz_graphics_blend()"},{"location":"api/vklite/#dvz_graphics_depth_test","text":"Set the graphics depth test. void dvz_graphics_depth_test ( DvzGraphics * graphics , DvzDepthTest depth_test ); Parameter Type Description graphics DvzGraphics* the graphics pipeline depth_test DvzDepthTest the depth test","title":"dvz_graphics_depth_test()"},{"location":"api/vklite/#dvz_graphics_pick","text":"Set whether the graphics pipeline supports picking. void dvz_graphics_pick ( DvzGraphics * graphics , bool support_pick ); Parameter Type Description graphics DvzGraphics* the graphics pipeline support_pick bool whether the graphics pipeline supports picking Note Picking support is currently all or nothing: all graphics of a canvas must either support picking or not. In addition, the canvas must have been created with the DVZ_CANVAS_FLAGS_PICK flag.","title":"dvz_graphics_pick()"},{"location":"api/vklite/#dvz_graphics_polygon_mode","text":"Set the graphics polygon mode. void dvz_graphics_polygon_mode ( DvzGraphics * graphics , VkPolygonMode polygon_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline polygon_mode VkPolygonMode the polygon mode","title":"dvz_graphics_polygon_mode()"},{"location":"api/vklite/#dvz_graphics_cull_mode","text":"Set the graphics cull mode. void dvz_graphics_cull_mode ( DvzGraphics * graphics , VkCullModeFlags cull_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline cull_mode VkCullModeFlags the cull mode","title":"dvz_graphics_cull_mode()"},{"location":"api/vklite/#dvz_graphics_front_face","text":"Set the graphics front face. void dvz_graphics_front_face ( DvzGraphics * graphics , VkFrontFace front_face ); Parameter Type Description graphics DvzGraphics* the graphics pipeline front_face VkFrontFace the front face","title":"dvz_graphics_front_face()"},{"location":"api/vklite/#dvz_graphics_create","text":"Create a graphics pipeline after it has been set up. void dvz_graphics_create ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline","title":"dvz_graphics_create()"},{"location":"api/vklite/#dvz_graphics_slot","text":"Set a binding slot for a graphics pipeline. void dvz_graphics_slot ( DvzGraphics * graphics , uint32_t idx , VkDescriptorType type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type","title":"dvz_graphics_slot()"},{"location":"api/vklite/#dvz_graphics_push","text":"Set a graphics pipeline push constant. void dvz_graphics_push ( DvzGraphics * graphics , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description graphics DvzGraphics* the graphics pipeline offset VkDeviceSize the push constant offset, in bytes offset VkDeviceSize the push size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant","title":"dvz_graphics_push()"},{"location":"api/vklite/#dvz_graphics_destroy","text":"Destroy a graphics pipeline. void dvz_graphics_destroy ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline","title":"dvz_graphics_destroy()"},{"location":"api/vklite/#compute-pipeline","text":"","title":"Compute pipeline"},{"location":"api/vklite/#dvz_compute","text":"Initialize a compute pipeline. DvzCompute dvz_compute ( DvzGpu * gpu , const char * shader_path ); Parameter Type Description gpu DvzGpu* the GPU shader_path char* (optional) the path to the .spirv file with the compute shader returns DvzCompute compute pipeline","title":"dvz_compute()"},{"location":"api/vklite/#dvz_compute_create","text":"Create a compute pipeline after it has been set up. void dvz_compute_create ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline","title":"dvz_compute_create()"},{"location":"api/vklite/#dvz_compute_code","text":"Set the GLSL code directly (the library will compile it automatically to SPIRV). void dvz_compute_code ( DvzCompute * compute , const char * code ); Parameter Type Description compute DvzCompute* the compute pipeline code char* the GLSL code defining the compute shader","title":"dvz_compute_code()"},{"location":"api/vklite/#dvz_compute_slot","text":"Declare a slot for the compute pipeline. void dvz_compute_slot ( DvzCompute * compute , uint32_t idx , VkDescriptorType type ); Parameter Type Description compute DvzCompute* the compute pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type","title":"dvz_compute_slot()"},{"location":"api/vklite/#dvz_compute_push","text":"Set up push constant. void dvz_compute_push ( DvzCompute * compute , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description compute DvzCompute* the compute pipeline offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shaders that will need to access the push constant","title":"dvz_compute_push()"},{"location":"api/vklite/#dvz_compute_bindings","text":"Associate a bindings object to a compute pipeline. void dvz_compute_bindings ( DvzCompute * compute , DvzBindings * bindings ); Parameter Type Description compute DvzCompute* the compute pipeline bindings DvzBindings* the bindings","title":"dvz_compute_bindings()"},{"location":"api/vklite/#dvz_compute_destroy","text":"Destroy a compute pipeline. void dvz_compute_destroy ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline","title":"dvz_compute_destroy()"},{"location":"api/vklite/#barrier","text":"","title":"Barrier"},{"location":"api/vklite/#dvz_barrier","text":"Initialize a synchronization barrier (usedwithin a command buffer). DvzBarrier dvz_barrier ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBarrier barrier","title":"dvz_barrier()"},{"location":"api/vklite/#dvz_barrier_stages","text":"Set the barrier stages. void dvz_barrier_stages ( DvzBarrier * barrier , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description barrier DvzBarrier* the barrier src_stage VkPipelineStageFlags the source stage dst_stage VkPipelineStageFlags the destination stage","title":"dvz_barrier_stages()"},{"location":"api/vklite/#dvz_barrier_buffer","text":"Set the barrier buffer. void dvz_barrier_buffer ( DvzBarrier * barrier , DvzBufferRegions br ); Parameter Type Description barrier DvzBarrier* the barrier br DvzBufferRegions the buffer regions","title":"dvz_barrier_buffer()"},{"location":"api/vklite/#dvz_barrier_buffer_queue","text":"Set the barrier buffer queue. void dvz_barrier_buffer_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index","title":"dvz_barrier_buffer_queue()"},{"location":"api/vklite/#dvz_barrier_buffer_access","text":"Set the barrier buffer access. void dvz_barrier_buffer_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags","title":"dvz_barrier_buffer_access()"},{"location":"api/vklite/#dvz_barrier_images","text":"Set the barrier images. void dvz_barrier_images ( DvzBarrier * barrier , DvzImages * images ); Parameter Type Description barrier DvzBarrier* the barrier images DvzImages* the images","title":"dvz_barrier_images()"},{"location":"api/vklite/#dvz_barrier_images_layout","text":"Set the barrier images layout. void dvz_barrier_images_layout ( DvzBarrier * barrier , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description barrier DvzBarrier* the barrier src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout","title":"dvz_barrier_images_layout()"},{"location":"api/vklite/#dvz_barrier_images_queue","text":"Set the barrier images queue. void dvz_barrier_images_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index","title":"dvz_barrier_images_queue()"},{"location":"api/vklite/#dvz_barrier_images_access","text":"Set the barrier images access. void dvz_barrier_images_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags","title":"dvz_barrier_images_access()"},{"location":"api/vklite/#semaphores","text":"","title":"Semaphores"},{"location":"api/vklite/#dvz_semaphores","text":"Initialize a set of semaphores (GPU-GPU synchronization). DvzSemaphores dvz_semaphores ( DvzGpu * gpu , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of semaphores returns DvzSemaphores semaphores","title":"dvz_semaphores()"},{"location":"api/vklite/#dvz_semaphores_destroy","text":"Destroy semaphores. void dvz_semaphores_destroy ( DvzSemaphores * semaphores ); Parameter Type Description semaphores DvzSemaphores* the semaphores","title":"dvz_semaphores_destroy()"},{"location":"api/vklite/#fences","text":"","title":"Fences"},{"location":"api/vklite/#dvz_fences","text":"Initialize a set of fences (CPU-GPU synchronization). DvzFences dvz_fences ( DvzGpu * gpu , uint32_t count , bool signaled ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of fences signaled bool whether the fences are created in the signaled state or not returns DvzFences fences","title":"dvz_fences()"},{"location":"api/vklite/#dvz_fences_copy","text":"Copy a fence from a set of fences to another. void dvz_fences_copy ( DvzFences * src_fences , uint32_t src_idx , DvzFences * dst_fences , uint32_t dst_idx ); Parameter Type Description src_fences DvzFences* the source fences src_idx uint32_t the fence index within the source fences dst_fences DvzFences* the destination fences dst_idx uint32_t the fence index within the destination fences","title":"dvz_fences_copy()"},{"location":"api/vklite/#dvz_fences_wait","text":"Wait on the GPU until a fence is signaled. void dvz_fences_wait ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index","title":"dvz_fences_wait()"},{"location":"api/vklite/#dvz_fences_ready","text":"Return whether a fence is ready. bool dvz_fences_ready ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index","title":"dvz_fences_ready()"},{"location":"api/vklite/#dvz_fences_reset","text":"Rset the state of a fence. void dvz_fences_reset ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index","title":"dvz_fences_reset()"},{"location":"api/vklite/#dvz_fences_destroy","text":"Destroy fences. void dvz_fences_destroy ( DvzFences * fences ); Parameter Type Description fences DvzFences* the fences","title":"dvz_fences_destroy()"},{"location":"api/vklite/#renderpass","text":"","title":"Renderpass"},{"location":"api/vklite/#dvz_renderpass","text":"Initialize a render pass. DvzRenderpass dvz_renderpass ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzRenderpass render pass","title":"dvz_renderpass()"},{"location":"api/vklite/#dvz_renderpass_clear","text":"Set the clear value of a render pass. void dvz_renderpass_clear ( DvzRenderpass * renderpass , VkClearValue value ); Parameter Type Description renderpass DvzRenderpass* the render pass value VkClearValue the clear value","title":"dvz_renderpass_clear()"},{"location":"api/vklite/#dvz_renderpass_attachment","text":"Specify a render pass attachment. void dvz_renderpass_attachment ( DvzRenderpass * renderpass , uint32_t idx , DvzRenderpassAttachmentType type , VkFormat format , VkImageLayout ref_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index type DvzRenderpassAttachmentType the attachment type format VkFormat the attachment image format ref_layout VkImageLayout the image layout","title":"dvz_renderpass_attachment()"},{"location":"api/vklite/#dvz_renderpass_attachment_layout","text":"Set the attachment layout. void dvz_renderpass_attachment_layout ( DvzRenderpass * renderpass , uint32_t idx , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout","title":"dvz_renderpass_attachment_layout()"},{"location":"api/vklite/#dvz_renderpass_attachment_ops","text":"Set the attachment load and store operations. void dvz_renderpass_attachment_ops ( DvzRenderpass * renderpass , uint32_t idx , VkAttachmentLoadOp load_op , VkAttachmentStoreOp store_op ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index load_op VkAttachmentLoadOp the load operation store_op VkAttachmentStoreOp the store operation","title":"dvz_renderpass_attachment_ops()"},{"location":"api/vklite/#dvz_renderpass_subpass_attachment","text":"Set a subpass attachment. void dvz_renderpass_subpass_attachment ( DvzRenderpass * renderpass , uint32_t subpass_idx , uint32_t attachment_idx ); Parameter Type Description renderpass DvzRenderpass* the render pass subpass_idx uint32_t the subpass index attachment_idx uint32_t the attachment index","title":"dvz_renderpass_subpass_attachment()"},{"location":"api/vklite/#dvz_renderpass_subpass_dependency","text":"Set a subpass dependency. void dvz_renderpass_subpass_dependency ( DvzRenderpass * renderpass , uint32_t dependency_idx , uint32_t src_subpass , uint32_t dst_subpass ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_subpass uint32_t the source subpass index dst_subpass uint32_t the destination subpass index","title":"dvz_renderpass_subpass_dependency()"},{"location":"api/vklite/#dvz_renderpass_subpass_dependency_access","text":"Set a subpass dependency access. void dvz_renderpass_subpass_dependency_access ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destinationaccess flags","title":"dvz_renderpass_subpass_dependency_access()"},{"location":"api/vklite/#dvz_renderpass_subpass_dependency_stage","text":"Set a subpass dependency stage. void dvz_renderpass_subpass_dependency_stage ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_stage VkPipelineStageFlags the source pipeline stages dst_stage VkPipelineStageFlags the destination pipeline stages","title":"dvz_renderpass_subpass_dependency_stage()"},{"location":"api/vklite/#dvz_renderpass_create","text":"Create a render pass after it has been set up. void dvz_renderpass_create ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass","title":"dvz_renderpass_create()"},{"location":"api/vklite/#dvz_renderpass_destroy","text":"Destroy a render pass. void dvz_renderpass_destroy ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass","title":"dvz_renderpass_destroy()"},{"location":"api/vklite/#framebuffers","text":"","title":"Framebuffers"},{"location":"api/vklite/#dvz_framebuffers","text":"Initialize a set of framebuffers. DvzFramebuffers dvz_framebuffers ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzFramebuffers framebuffers","title":"dvz_framebuffers()"},{"location":"api/vklite/#dvz_framebuffers_attachment","text":"Set framebuffers attachment. void dvz_framebuffers_attachment ( DvzFramebuffers * framebuffers , uint32_t attachment_idx , DvzImages * images ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers attachment_idx uint32_t the attachment index images DvzImages* the images","title":"dvz_framebuffers_attachment()"},{"location":"api/vklite/#dvz_framebuffers_create","text":"Create a set of framebuffers after it has been set up. void dvz_framebuffers_create ( DvzFramebuffers * framebuffers , DvzRenderpass * renderpass ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers renderpass DvzRenderpass* the render pass","title":"dvz_framebuffers_create()"},{"location":"api/vklite/#dvz_framebuffers_destroy","text":"Destroy a set of framebuffers. void dvz_framebuffers_destroy ( DvzFramebuffers * framebuffers ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers","title":"dvz_framebuffers_destroy()"},{"location":"api/vklite/#submit","text":"","title":"Submit"},{"location":"api/vklite/#dvz_submit","text":"Create a submit object, used to submit command buffers to a GPU queue. DvzSubmit dvz_submit ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSubmit submit","title":"dvz_submit()"},{"location":"api/vklite/#dvz_submit_commands","text":"Set the command buffers to submit. void dvz_submit_commands ( DvzSubmit * submit , DvzCommands * commands ); Parameter Type Description submit DvzSubmit* the submit object cmds None the set of command buffers","title":"dvz_submit_commands()"},{"location":"api/vklite/#dvz_submit_wait_semaphores","text":"Set the wait semaphores void dvz_submit_wait_semaphores ( DvzSubmit * submit , VkPipelineStageFlags stage , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object stage VkPipelineStageFlags the pipeline stage semaphores DvzSemaphores* the set of semaphores to wait on idx uint32_t the semaphore index to wait on","title":"dvz_submit_wait_semaphores()"},{"location":"api/vklite/#dvz_submit_signal_semaphores","text":"Set the signal semaphores void dvz_submit_signal_semaphores ( DvzSubmit * submit , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object semaphores DvzSemaphores* the set of semaphores to signal after the commands have completed idx uint32_t the semaphore index to signal","title":"dvz_submit_signal_semaphores()"},{"location":"api/vklite/#dvz_submit_send","text":"Submit the command buffers to their queue. void dvz_submit_send ( DvzSubmit * submit , uint32_t cmd_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description submit DvzSubmit* the submit object cmd_idx uint32_t the command buffer index to submit fences DvzFences* the fences to signal after completion fence_idx uint32_t the fence index to signal","title":"dvz_submit_send()"},{"location":"api/vklite/#dvz_submit_reset","text":"Reset a submit object. void dvz_submit_reset ( DvzSubmit * submit ); Parameter Type Description submit DvzSubmit* the submit object","title":"dvz_submit_reset()"},{"location":"api/vklite/#command-buffer-recording","text":"","title":"Command buffer recording"},{"location":"api/vklite/#dvz_cmd_begin_renderpass","text":"Begin a render pass. void dvz_cmd_begin_renderpass ( DvzCommands * cmds , uint32_t idx , DvzRenderpass * renderpass , DvzFramebuffers * framebuffers ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record renderpass DvzRenderpass* the render pass framebuffers DvzFramebuffers* the framebuffers","title":"dvz_cmd_begin_renderpass()"},{"location":"api/vklite/#dvz_cmd_end_renderpass","text":"End a render pass. void dvz_cmd_end_renderpass ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record","title":"dvz_cmd_end_renderpass()"},{"location":"api/vklite/#dvz_cmd_compute","text":"Launch a compute task. void dvz_cmd_compute ( DvzCommands * cmds , uint32_t idx , DvzCompute * compute , uvec3 size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record compute DvzCompute* the computer pipeline size uvec3 the task shape","title":"dvz_cmd_compute()"},{"location":"api/vklite/#dvz_cmd_barrier","text":"Register a barrier. void dvz_cmd_barrier ( DvzCommands * cmds , uint32_t idx , DvzBarrier * barrier ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record barrier DvzBarrier* the barrier","title":"dvz_cmd_barrier()"},{"location":"api/vklite/#dvz_cmd_copy_buffer_to_image","text":"Copy a GPU buffer to a GPU image. void dvz_cmd_copy_buffer_to_image ( DvzCommands * cmds , uint32_t idx , DvzBuffer * buffer , DvzImages * images ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record buffer DvzBuffer* the buffer images DvzImages* the image","title":"dvz_cmd_copy_buffer_to_image()"},{"location":"api/vklite/#dvz_cmd_copy_image_to_buffer","text":"Copy a GPU image to a GPU buffer. void dvz_cmd_copy_image_to_buffer ( DvzCommands * cmds , uint32_t idx , DvzImages * images , DvzBuffer * buffer ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record images DvzImages* the image buffer DvzBuffer* the buffer","title":"dvz_cmd_copy_image_to_buffer()"},{"location":"api/vklite/#dvz_cmd_copy_image","text":"Copy a GPU image to another. void dvz_cmd_copy_image ( DvzCommands * cmds , uint32_t idx , DvzImages * src_img , DvzImages * dst_img ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_img DvzImages* the source image dst_img DvzImages* the destination image","title":"dvz_cmd_copy_image()"},{"location":"api/vklite/#dvz_cmd_copy_image_region","text":"Copy a GPU image to another. void dvz_cmd_copy_image_region ( DvzCommands * cmds , uint32_t idx , DvzImages * src_img , ivec3 src_offset , DvzImages * dst_img , ivec3 dst_offset , uvec3 shape ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_img DvzImages* the source image src_offset ivec3 the offset in the source image dst_img DvzImages* the destination image dst_offset ivec3 the offset in the target image shape uvec3 the shape of the region to copy","title":"dvz_cmd_copy_image_region()"},{"location":"api/vklite/#dvz_cmd_viewport","text":"Set the viewport. void dvz_cmd_viewport ( DvzCommands * cmds , uint32_t idx , VkViewport viewport ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record viewport VkViewport the viewport","title":"dvz_cmd_viewport()"},{"location":"api/vklite/#dvz_cmd_bind_graphics","text":"Bind a graphics pipeline. void dvz_cmd_bind_graphics ( DvzCommands * cmds , uint32_t idx , DvzGraphics * graphics , DvzBindings * bindings , uint32_t dynamic_idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record graphics DvzGraphics* the graphics pipeline bindings DvzBindings* the bindings associated to the pipeline dynamic_idx uint32_t the dynamic uniform buffer index","title":"dvz_cmd_bind_graphics()"},{"location":"api/vklite/#dvz_cmd_bind_vertex_buffer","text":"Bind a vertex buffer. void dvz_cmd_bind_vertex_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes","title":"dvz_cmd_bind_vertex_buffer()"},{"location":"api/vklite/#dvz_cmd_bind_index_buffer","text":"Bind an index buffer. void dvz_cmd_bind_index_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes","title":"dvz_cmd_bind_index_buffer()"},{"location":"api/vklite/#dvz_cmd_draw","text":"Direct draw. void dvz_cmd_draw ( DvzCommands * cmds , uint32_t idx , uint32_t first_vertex , uint32_t vertex_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_vertex uint32_t index of the first vertex vertex_count uint32_t number of vertices to draw","title":"dvz_cmd_draw()"},{"location":"api/vklite/#dvz_cmd_draw_indexed","text":"Direct indexed draw. void dvz_cmd_draw_indexed ( DvzCommands * cmds , uint32_t idx , uint32_t first_index , uint32_t vertex_offset , uint32_t index_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_index uint32_t index of the first index vertex_offset uint32_t offset of the vertex index_count uint32_t number of indices to draw","title":"dvz_cmd_draw_indexed()"},{"location":"api/vklite/#dvz_cmd_draw_indirect","text":"Indirect draw. void dvz_cmd_draw_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info","title":"dvz_cmd_draw_indirect()"},{"location":"api/vklite/#dvz_cmd_draw_indexed_indirect","text":"Indirect indexed draw. void dvz_cmd_draw_indexed_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info","title":"dvz_cmd_draw_indexed_indirect()"},{"location":"api/vklite/#dvz_cmd_copy_buffer","text":"Copy a GPU buffer to another. void dvz_cmd_copy_buffer ( DvzCommands * cmds , uint32_t idx , DvzBuffer * src_buf , VkDeviceSize src_offset , DvzBuffer * dst_buf , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_buf DvzBuffer* the source buffer src_offset VkDeviceSize the offset in the source buffer dst_buf DvzBuffer* the destination buffer, in bytes dst_offset VkDeviceSize the offset in the destination buffer, in bytes size VkDeviceSize the size of the region to copy, in bytes","title":"dvz_cmd_copy_buffer()"},{"location":"api/vklite/#dvz_cmd_push","text":"Push constants. void dvz_cmd_push ( DvzCommands * cmds , uint32_t idx , DvzSlots * slots , VkShaderStageFlagBits shaders , VkDeviceSize offset , VkDeviceSize size , const void * data ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record slots DvzSlots* the slots shaders VkShaderStageFlagBits the shader stages that have access to the push constant offset VkDeviceSize the offset in the push constant, in bytes size VkDeviceSize the size in the push constant, in bytes data void* the data to send via the push constant","title":"dvz_cmd_push()"},{"location":"discussions/","text":"Discussions \u00b6 For users \u00b6 Vulkan crash course : an accessible overview of Vulkan for scientific computing, a must-read requirement before writing custom visuals, Best practices : a review of best practices when using Datoviz and writing custom visuals, FAQ : frequently-asqued questions For developers \u00b6 Library architecture : an overview of the internal organization of the code, Developer notes : notes for contributors and developers, Developer checklists : useful checklists for contributors and developers,","title":"Index"},{"location":"discussions/#discussions","text":"","title":"Discussions"},{"location":"discussions/#for-users","text":"Vulkan crash course : an accessible overview of Vulkan for scientific computing, a must-read requirement before writing custom visuals, Best practices : a review of best practices when using Datoviz and writing custom visuals, FAQ : frequently-asqued questions","title":"For users"},{"location":"discussions/#for-developers","text":"Library architecture : an overview of the internal organization of the code, Developer notes : notes for contributors and developers, Developer checklists : useful checklists for contributors and developers,","title":"For developers"},{"location":"discussions/architecture/","text":"Library architecture \u00b6 This page provides an overview of the internal architecture of Datoviz. Overview \u00b6 Datoviz is made of several modules that are relatively loosely-coupled. They can be classified into three broad categories: Core modules implement low-level functionality: vklite is a thin Vulkan wrapper, canvas implements a blank canvas providing rendering capabilities via vklite. High-level modules implement scientific visualization functionality: graphics provides a library of builtin primitive graphics (markers, paths, images, text, meshes, volumes, and so on), visuals wrap primitive graphics into higher-level ready-to-use visual elements, panels provide a way to manage multiple rectangular subplots in a 2D grid, interacts provide a library of common interactivity patterns (panzoom, arcball, camera), GUI provides a way to use the Dear ImGui library, scene brings all the modules above together. Independent modules provide useful utility functionality to the other modules. Core modules \u00b6 These modules are essentially used internally. Vklite \u00b6 Vklite is a thin wrapper on top of the Vulkan C API. It proposes a simpler, but more limited API. Only the features that are essential to scientific visualization are wrapped. The vklite API happens to be relatively close to the WebGPU specification, but it is Vulkan-specific, whereas WebGPU is compatible with other low-level graphics APIs (Metal, DirectX 12...). Context \u00b6 The context is attached to a given GPU. It is an interface to the GPU data, that can be either: GPU buffers : 1D arrays containing arbitrary binary data, GPU textures : 1D, 2D, or 3D textures. Buffer regions represent a part of a given GPU buffer. They are used extensively in Datoviz, as there is only one large buffer of every type (one vertex buffer, one uniform buffer) for all visuals and all canvases. A simplistic memory allocation system allows to allocate buffer regions depending on the needs of the Datoviz objects (graphics, visuals...). The context is also used to define compute shaders on a given GPU. The context is shared between all canvases running on a given GPU. The context provides functions to upload, download, and copy data of GPU buffers and textures. Canvas \u00b6 The canvas is a Vulkan-aware window with the following functionality: swapchain and default renderpass, command buffers, support for window resizing, main rendering event loop , synchronized data transfers , event system with synchronous or asynchronous (background thread) callback functions, mouse and keyboard events , support for Dear ImGui , video screencast with ffmpeg (optional). If there are multiple GPUs on the system, a canvas is attached to a given GPU. High-level modules \u00b6 The high-level modules are key components of the scene interface. Graphics \u00b6 A graphics pipeline wraps a vertex shader, a fragment shader, fixed GPU state, and possibly other shaders. A graphics is attached to a given canvas. Datoviz includes a set of common builtin graphics pipelines frequently used in scientific visualization. All graphics share a set of conventions that make it possible for the visuals and scene modules to use them properly: Every shader has #include \"common.glsl\" , which is a way to share GLSL code between all shaders. Binding point #0 of every shader is a uniform buffer containing the model-view-projection matrices . Binding point #1 of every shader is a uniform buffer containing the viewport . In the vertex shader, the vertex position is transformed with the transform() function implemented in common.glsl . This function basically applies the model-view-projection matrices to its input. Note This set of conventions may change slightly in the future. Visual \u00b6 A visual represents a visual element. It is based on one or several graphics pipelines, and possibly compute shaders. It is attached to a given canvas and therefore to a given GPU. A visual provides a set of visual properties, aka props . Props are used to set the visual data. For example, the marker visual has props for marker position, size, color, shape, angle, and so on. The visual is responsible for transforming the user data into a vertex buffer corresponding to the vertex attributes of the underlying graphics pipeline(s). The visual module provides the machinery to automatically update GPU objects when the visual data changes. Panel \u00b6 A panel is a rectangular area in a canvas. It defines a specific viewport. The grid arranges panels in a 2D, possibly heterogeneous, grid layout. Interact \u00b6 An interact provides functions that update model-view-projection matrices as a function of user events (mouse, keyboard). This module implements a few common interacts: panzoom, arcball, camera. GUI \u00b6 A GUI is a dialog that can be added to any canvas. It contains a set of controls . Datoviz implements a few common GUI controls that wrap Dear ImGUI functionality in an object-oriented interface. Scene \u00b6 The scene attaches visual, panel, and interact functionality to a canvas. It allows the user to easily define panels, specify interacts, add a visual, change visual data, and so on. A controller bundles together an interact and, optionally, a set of visuals. For example, the panzoom controller is just a panzoom interact. However, the axes 2D controller has also an axes visual. Independent modules \u00b6 Independent modules provide useful utility functions. Colormaps \u00b6 This module implements a library of ~150 common colormaps coming from existing scientific visualization libraries (MATLAB, matplotlib, and others). Array \u00b6 This module implements an extremely basic and limited 1D array interface that is used by the visual baking functionality. Future versions of Datoviz might instead incorporate a proper C/C++ array module. FIFO \u00b6 This module implements thread-safe FIFO queues that are used by the canvas event system and other systems internally.","title":"Library architecture"},{"location":"discussions/architecture/#library-architecture","text":"This page provides an overview of the internal architecture of Datoviz.","title":"Library architecture"},{"location":"discussions/architecture/#overview","text":"Datoviz is made of several modules that are relatively loosely-coupled. They can be classified into three broad categories: Core modules implement low-level functionality: vklite is a thin Vulkan wrapper, canvas implements a blank canvas providing rendering capabilities via vklite. High-level modules implement scientific visualization functionality: graphics provides a library of builtin primitive graphics (markers, paths, images, text, meshes, volumes, and so on), visuals wrap primitive graphics into higher-level ready-to-use visual elements, panels provide a way to manage multiple rectangular subplots in a 2D grid, interacts provide a library of common interactivity patterns (panzoom, arcball, camera), GUI provides a way to use the Dear ImGui library, scene brings all the modules above together. Independent modules provide useful utility functionality to the other modules.","title":"Overview"},{"location":"discussions/architecture/#core-modules","text":"These modules are essentially used internally.","title":"Core modules"},{"location":"discussions/architecture/#vklite","text":"Vklite is a thin wrapper on top of the Vulkan C API. It proposes a simpler, but more limited API. Only the features that are essential to scientific visualization are wrapped. The vklite API happens to be relatively close to the WebGPU specification, but it is Vulkan-specific, whereas WebGPU is compatible with other low-level graphics APIs (Metal, DirectX 12...).","title":"Vklite"},{"location":"discussions/architecture/#context","text":"The context is attached to a given GPU. It is an interface to the GPU data, that can be either: GPU buffers : 1D arrays containing arbitrary binary data, GPU textures : 1D, 2D, or 3D textures. Buffer regions represent a part of a given GPU buffer. They are used extensively in Datoviz, as there is only one large buffer of every type (one vertex buffer, one uniform buffer) for all visuals and all canvases. A simplistic memory allocation system allows to allocate buffer regions depending on the needs of the Datoviz objects (graphics, visuals...). The context is also used to define compute shaders on a given GPU. The context is shared between all canvases running on a given GPU. The context provides functions to upload, download, and copy data of GPU buffers and textures.","title":"Context"},{"location":"discussions/architecture/#canvas","text":"The canvas is a Vulkan-aware window with the following functionality: swapchain and default renderpass, command buffers, support for window resizing, main rendering event loop , synchronized data transfers , event system with synchronous or asynchronous (background thread) callback functions, mouse and keyboard events , support for Dear ImGui , video screencast with ffmpeg (optional). If there are multiple GPUs on the system, a canvas is attached to a given GPU.","title":"Canvas"},{"location":"discussions/architecture/#high-level-modules","text":"The high-level modules are key components of the scene interface.","title":"High-level modules"},{"location":"discussions/architecture/#graphics","text":"A graphics pipeline wraps a vertex shader, a fragment shader, fixed GPU state, and possibly other shaders. A graphics is attached to a given canvas. Datoviz includes a set of common builtin graphics pipelines frequently used in scientific visualization. All graphics share a set of conventions that make it possible for the visuals and scene modules to use them properly: Every shader has #include \"common.glsl\" , which is a way to share GLSL code between all shaders. Binding point #0 of every shader is a uniform buffer containing the model-view-projection matrices . Binding point #1 of every shader is a uniform buffer containing the viewport . In the vertex shader, the vertex position is transformed with the transform() function implemented in common.glsl . This function basically applies the model-view-projection matrices to its input. Note This set of conventions may change slightly in the future.","title":"Graphics"},{"location":"discussions/architecture/#visual","text":"A visual represents a visual element. It is based on one or several graphics pipelines, and possibly compute shaders. It is attached to a given canvas and therefore to a given GPU. A visual provides a set of visual properties, aka props . Props are used to set the visual data. For example, the marker visual has props for marker position, size, color, shape, angle, and so on. The visual is responsible for transforming the user data into a vertex buffer corresponding to the vertex attributes of the underlying graphics pipeline(s). The visual module provides the machinery to automatically update GPU objects when the visual data changes.","title":"Visual"},{"location":"discussions/architecture/#panel","text":"A panel is a rectangular area in a canvas. It defines a specific viewport. The grid arranges panels in a 2D, possibly heterogeneous, grid layout.","title":"Panel"},{"location":"discussions/architecture/#interact","text":"An interact provides functions that update model-view-projection matrices as a function of user events (mouse, keyboard). This module implements a few common interacts: panzoom, arcball, camera.","title":"Interact"},{"location":"discussions/architecture/#gui","text":"A GUI is a dialog that can be added to any canvas. It contains a set of controls . Datoviz implements a few common GUI controls that wrap Dear ImGUI functionality in an object-oriented interface.","title":"GUI"},{"location":"discussions/architecture/#scene","text":"The scene attaches visual, panel, and interact functionality to a canvas. It allows the user to easily define panels, specify interacts, add a visual, change visual data, and so on. A controller bundles together an interact and, optionally, a set of visuals. For example, the panzoom controller is just a panzoom interact. However, the axes 2D controller has also an axes visual.","title":"Scene"},{"location":"discussions/architecture/#independent-modules","text":"Independent modules provide useful utility functions.","title":"Independent modules"},{"location":"discussions/architecture/#colormaps","text":"This module implements a library of ~150 common colormaps coming from existing scientific visualization libraries (MATLAB, matplotlib, and others).","title":"Colormaps"},{"location":"discussions/architecture/#array","text":"This module implements an extremely basic and limited 1D array interface that is used by the visual baking functionality. Future versions of Datoviz might instead incorporate a proper C/C++ array module.","title":"Array"},{"location":"discussions/architecture/#fifo","text":"This module implements thread-safe FIFO queues that are used by the canvas event system and other systems internally.","title":"FIFO"},{"location":"discussions/checklists/","text":"Developer checklists \u00b6 Adding a new Python example \u00b6 Create a new bindings/cython/examples/mynewexample.py file Here is a template code snippet: \"\"\" # My new example This example shows ... The text here will be copied automatically to the corresponding page in the documentation. \"\"\" # Imports. import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Add your code here... # Start the event loop. run () mkdocs.yml : Add your new example to nav > Examples Test Your new example is automatically added to the Python testing suite. As such, your example will run and a screenshot will be made automatically for the documentation website. Run DVZ_DEBUG=1 pytest -vvsk mynewexample to test your example interactively. Run ./manage.sh pytest to check that the full Python testing suite passes. Run /.manage.sh docs to regenerate the documentation and run it locally. Check that your example has been automatically included in the website. Adding a new C example \u00b6 Create a new examples/mynewexample.h file Here is a template code snippet: /*************************************************************************************************/ /* My new example. */ /*************************************************************************************************/ // We include the library header file. #include <datoviz/datoviz.h> static int demo_mynewexample () { DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); DvzGpu * gpu = dvz_gpu_best ( app ); DvzCanvas * canvas = dvz_canvas ( gpu , 1280 , 1024 , 0 ); DvzScene * scene = dvz_scene ( canvas , 1 , 1 ); DvzPanel * panel = dvz_scene_panel ( scene , 0 , 0 , DVZ_CONTROLLER_PANZOOM , 0 ); // Add your code here. dvz_app_run ( app , 0 ); dvz_app_destroy ( app ); return 0 ; } examples/examples.h add #include \"mynewexample.h\" cli/main.c In demo() , add a new line with SWITCH_DEMO(mynewexample) Implementing a new visual \u00b6 Determine the graphics you'll be using, and the list of source and props vislib.h : Make sure the DvzVisualType enum exists, or create a new one visuals.h : Check that all prop types exist, otherwise add them vislib.c : Make a new section for the visual code Write the main visual function Specify the graphics pipeline(s) Specify the sources: Vertex buffer Index buffer (optional) Param buffer (optional) Textures (optional) Specify the props The cast and copy spec are not mandatory if there is a custom baking callback function Note that the special POS prop is DVEC3 and is typically cast to VEC3, but only after baking and panel transform Add a length prop if there are multiple objects Add the common props Add the param props Specify the props that need DPI scaling Specify the baking callback function (optional) Write the baking callback function Take DPI scaling into account for props that require it Add a new switch case in dvz_visual_builtin() test_vislib.h : Add a new visual test declaration test_vislib.c : Write the body of the test function main.c : Add the new test to the list of test functions Test the new visual without interactivity and save a visual screenshot Add a section in the visual reference docs/reference/visuals.md , document the props, sources, etc. pydatoviz.pyx : Add your new visual to the _VISUALS dictionary Implementing a new graphics \u00b6 graphics.h : Add the typedef of the vertex, item, params structures Add new section and structs for vertex, item, params structures Make sure all fields in the params struct have a byte size that is not 3 or divisible by 3 Put comments after each struct field (used by automatic documentation generator) vklite.h : Make sure the DvzGraphicsType enum exists, or create a new one Shaders: graphics_xxx.vert|frag : Don't forget to import common.glsl in all shaders If there are parameters, they should be implemented as a struct in the first user binding USER_BINDING Make sure the GLSL parameters struct matches exactly the one you just defined in graphics.h The next bindings should be numbered with USER_BINDING+1 etc The body of the main fragment shader function should always begin with CLIP graphics.c : Add a new section, with _graphics_xxx() and _graphics_xxx_callback() if there is a non-default graphics callback function Write the main graphics function Specify the shaders Specify the primitive type Specify the vertex attributes, should match the vertex shader Add the common slots Add slots for params/textures Specify the graphics callback function (optional) Write the graphics callback function This function is called when a new item is added to the graphics. What an \"item\" is is up to the create of a graphics. It's typically the smallest bit of data that has a meaning in the context of the graphics. The graphics callback is mostly used for pre-upload CPU-side \"triangulation\" of the data, so that the visuals that reuse this graphics don't have to know the details of the triangulation. Add the switch case in dvz_graphics_builtin() test_graphics.h : Add the new graphics test declaration test_graphics.c : Write the body of the test function Set to save the screenshot with the graphics name main.c : Add the new test to the list of test functions Test the graphics without interactivity and save the graphics screenshot Add graphics section in docs/reference/graphics.md Implementing a new GUI control \u00b6 controls.h : Add the DvzGuiControlType enum If there are control parameters: Create a DvzGuiControlXXX typedef struct Declare the struct Add it to the DvzGuiControlUnion union Declare the new dvz_gui_xxx() function, and write the docstring controls.c : Write the body of the dvz_gui_xxx() function gui.cpp : In _show_control() , add a new switch case and call _show_xxx() Implement _show_xxx() test_canvas.c : In test_canvas_gui() , add the new control with a call to dvz_gui_xxx() Try the next test with DVZ_DEBUG=1 ./manage.sh test test_canvas_gui pydatoviz.pyx : Add your new control to the _CONTROLS dictionary In _get_event_args() , add a new if statement and make the callback argument binding In Gui.control() , add a new if statement and make the binding ( Optional ) In GuiControl.get() , add a new if statement and get the control value ( Optional ) In GuiControl.set() , add a new if statement and set the control value Run ./manage.sh cython Test in a Python example gui.control('xxx', 'name', ...) Adding a new attribute to an existing graphics pipeline \u00b6 graphics_xxx.vert (GLSL vertex shader file): Choose an appropriate C type for the attribute, for example vec2 (two single-precision floating-point values) Add the attribute to the shader by adding a line with layout (location = N) in vec2 attribute_name; (use the appropriate type, the appropriate attribute number) Make sure the attributelocations are strictly increasing (0, 1, 2, 3...) graphics.h : Find the relevant DvzGraphicsXXXVertex structure Add the field with the same type and name, following the same order as in the shader attributes list graphics.c : Find the static void _graphics_xxx() function body Determine the appropriate Vulkan format corresponding to the C format that you have chosen ( see the documentation ) Add a line with ATTR(DvzGraphicsXXXVertex, VK_FORMAT_R32G32_SFLOAT, attribute_name) The following steps are optional: follow them if you want to add visual props to the visuals that depend on the graphics pipeline vislib.c : Go through all visuals involving the graphics For each visual, add a prop corresponding to the new attribute, for example: (make sure to modify the appropriate parameters when needed) // Document the prop. prop = dvz_visual_prop ( visual , DVZ_PROP_XXX , 0 , DVZ_DTYPE_VEC2 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop_copy ( prop , 1 , offsetof ( DvzGraphicsXXXVertex , attribute_name ), DVZ_ARRAY_COPY_SINGLE , 1 ); dvz_visual_prop_default ( prop , ( vec2 ){ 0 , 1 }); test_vislib.c : Go through all tests involving the affected visuals, in test_vislib_xxx() Set the prop data for the new prop Adding a new uniform parameter to an existing graphics pipeline \u00b6 graphics_xxx.yyy (GLSL shader file, vertex or fragment shader): Choose an appropriate C type for the uniform, for example vec2 (two single-precision floating-point values) Make sure not to use a type with a 3 in it , so as to avoid misalignment problems Add the uniform field to the Params structure If the params uniform is used in both the vertex and fragment shader, make sure both are updated accordingly graphics.h : Find the relevant DvzGraphicsXXXParams structure Add the field with the same type and name, following the same order as in the shader graphics.c : There's nothing to change in this file The following steps are optional: follow them if you want to add visual props to the visuals that depend on the graphics pipeline vislib.c : Go through all visuals involving the graphics For each visual, add a prop corresponding to the new uniform, for example: (make sure to modify the appropriate parameters when needed) // Document the prop. prop = dvz_visual_prop ( visual , DVZ_PROP_XXX , 0 , DVZ_DTYPE_VEC2 , DVZ_SOURCE_TYPE_PARAM , 0 ); dvz_visual_prop_copy ( prop , 1 , offsetof ( DvzGraphicsXXXParams , uniform_name ), DVZ_ARRAY_COPY_SINGLE , 1 ); dvz_visual_prop_default ( prop , ( vec2 ){ 0 , 1 }); test_vislib.c : Go through all tests involving the affected visuals, in test_vislib_xxx() Set the prop data for the new prop Adding a new texture to an existing graphics pipeline \u00b6 graphics_xxx.frag (GLSL fragment shader file): Choose an appropriate texture dimension (1D, 2D, 3D) Add a new binding slot in the shader by adding a line with layout(binding = (USER_BINDING + 2)) uniform sampler2D my_tex; (make sure to use the appropriate number in USER_BINDING + N ) Make sure you use the USER_BINDING constant rather than hard-coding values: this is the number of bindings that are shared by all graphics pipelines in Datoviz Make sure that the N is strictly increasing in the consecutive layout(binding=...) lines (N=0, 1, 2, 3...) Use the new texture in the fragment shader, with a call to texture(my_tex, in_uv) (make sure to use the appropriate texel coordinates variable) graphics.h : There's nothing to change in this file graphics.c : Find the static void _graphics_xxx() function body Before the call to the CREATE macro, add a line with: (make sure to use the same number in DVZ_USER_BINDING + N as in the shader) dvz_graphics_slot ( graphics , DVZ_USER_BINDING + 2 , VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER ); The following steps are optional: follow them if you want to add visual props to the visuals that depend on the graphics pipeline vislib.c : Go through all visuals involving the graphics For each visual, add a source corresponding to the new texture, for example: (make sure to modify the appropriate parameters when needed) dvz_visual_source ( // image visual , DVZ_SOURCE_TYPE_IMAGE , 0 , // 0 for the first sampler in the shader, 1 for the next, and so on DVZ_PIPELINE_GRAPHICS , 0 , // 0 for the first graphics pipeline of the visual, 1 for the next, and so on DVZ_USER_BINDING + 2 , sizeof ( uint8_t ), 0 ); // make sure to use the same +N as above test_vislib.c : Go through all tests involving the affected visuals, in test_vislib_xxx() Set the texture data","title":"Developer checklists"},{"location":"discussions/checklists/#developer-checklists","text":"","title":"Developer checklists"},{"location":"discussions/checklists/#adding-a-new-python-example","text":"Create a new bindings/cython/examples/mynewexample.py file Here is a template code snippet: \"\"\" # My new example This example shows ... The text here will be copied automatically to the corresponding page in the documentation. \"\"\" # Imports. import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Add your code here... # Start the event loop. run () mkdocs.yml : Add your new example to nav > Examples Test Your new example is automatically added to the Python testing suite. As such, your example will run and a screenshot will be made automatically for the documentation website. Run DVZ_DEBUG=1 pytest -vvsk mynewexample to test your example interactively. Run ./manage.sh pytest to check that the full Python testing suite passes. Run /.manage.sh docs to regenerate the documentation and run it locally. Check that your example has been automatically included in the website.","title":"Adding a new Python example"},{"location":"discussions/checklists/#adding-a-new-c-example","text":"Create a new examples/mynewexample.h file Here is a template code snippet: /*************************************************************************************************/ /* My new example. */ /*************************************************************************************************/ // We include the library header file. #include <datoviz/datoviz.h> static int demo_mynewexample () { DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); DvzGpu * gpu = dvz_gpu_best ( app ); DvzCanvas * canvas = dvz_canvas ( gpu , 1280 , 1024 , 0 ); DvzScene * scene = dvz_scene ( canvas , 1 , 1 ); DvzPanel * panel = dvz_scene_panel ( scene , 0 , 0 , DVZ_CONTROLLER_PANZOOM , 0 ); // Add your code here. dvz_app_run ( app , 0 ); dvz_app_destroy ( app ); return 0 ; } examples/examples.h add #include \"mynewexample.h\" cli/main.c In demo() , add a new line with SWITCH_DEMO(mynewexample)","title":"Adding a new C example"},{"location":"discussions/checklists/#implementing-a-new-visual","text":"Determine the graphics you'll be using, and the list of source and props vislib.h : Make sure the DvzVisualType enum exists, or create a new one visuals.h : Check that all prop types exist, otherwise add them vislib.c : Make a new section for the visual code Write the main visual function Specify the graphics pipeline(s) Specify the sources: Vertex buffer Index buffer (optional) Param buffer (optional) Textures (optional) Specify the props The cast and copy spec are not mandatory if there is a custom baking callback function Note that the special POS prop is DVEC3 and is typically cast to VEC3, but only after baking and panel transform Add a length prop if there are multiple objects Add the common props Add the param props Specify the props that need DPI scaling Specify the baking callback function (optional) Write the baking callback function Take DPI scaling into account for props that require it Add a new switch case in dvz_visual_builtin() test_vislib.h : Add a new visual test declaration test_vislib.c : Write the body of the test function main.c : Add the new test to the list of test functions Test the new visual without interactivity and save a visual screenshot Add a section in the visual reference docs/reference/visuals.md , document the props, sources, etc. pydatoviz.pyx : Add your new visual to the _VISUALS dictionary","title":"Implementing a new visual"},{"location":"discussions/checklists/#implementing-a-new-graphics","text":"graphics.h : Add the typedef of the vertex, item, params structures Add new section and structs for vertex, item, params structures Make sure all fields in the params struct have a byte size that is not 3 or divisible by 3 Put comments after each struct field (used by automatic documentation generator) vklite.h : Make sure the DvzGraphicsType enum exists, or create a new one Shaders: graphics_xxx.vert|frag : Don't forget to import common.glsl in all shaders If there are parameters, they should be implemented as a struct in the first user binding USER_BINDING Make sure the GLSL parameters struct matches exactly the one you just defined in graphics.h The next bindings should be numbered with USER_BINDING+1 etc The body of the main fragment shader function should always begin with CLIP graphics.c : Add a new section, with _graphics_xxx() and _graphics_xxx_callback() if there is a non-default graphics callback function Write the main graphics function Specify the shaders Specify the primitive type Specify the vertex attributes, should match the vertex shader Add the common slots Add slots for params/textures Specify the graphics callback function (optional) Write the graphics callback function This function is called when a new item is added to the graphics. What an \"item\" is is up to the create of a graphics. It's typically the smallest bit of data that has a meaning in the context of the graphics. The graphics callback is mostly used for pre-upload CPU-side \"triangulation\" of the data, so that the visuals that reuse this graphics don't have to know the details of the triangulation. Add the switch case in dvz_graphics_builtin() test_graphics.h : Add the new graphics test declaration test_graphics.c : Write the body of the test function Set to save the screenshot with the graphics name main.c : Add the new test to the list of test functions Test the graphics without interactivity and save the graphics screenshot Add graphics section in docs/reference/graphics.md","title":"Implementing a new graphics"},{"location":"discussions/checklists/#implementing-a-new-gui-control","text":"controls.h : Add the DvzGuiControlType enum If there are control parameters: Create a DvzGuiControlXXX typedef struct Declare the struct Add it to the DvzGuiControlUnion union Declare the new dvz_gui_xxx() function, and write the docstring controls.c : Write the body of the dvz_gui_xxx() function gui.cpp : In _show_control() , add a new switch case and call _show_xxx() Implement _show_xxx() test_canvas.c : In test_canvas_gui() , add the new control with a call to dvz_gui_xxx() Try the next test with DVZ_DEBUG=1 ./manage.sh test test_canvas_gui pydatoviz.pyx : Add your new control to the _CONTROLS dictionary In _get_event_args() , add a new if statement and make the callback argument binding In Gui.control() , add a new if statement and make the binding ( Optional ) In GuiControl.get() , add a new if statement and get the control value ( Optional ) In GuiControl.set() , add a new if statement and set the control value Run ./manage.sh cython Test in a Python example gui.control('xxx', 'name', ...)","title":"Implementing a new GUI control"},{"location":"discussions/checklists/#adding-a-new-attribute-to-an-existing-graphics-pipeline","text":"graphics_xxx.vert (GLSL vertex shader file): Choose an appropriate C type for the attribute, for example vec2 (two single-precision floating-point values) Add the attribute to the shader by adding a line with layout (location = N) in vec2 attribute_name; (use the appropriate type, the appropriate attribute number) Make sure the attributelocations are strictly increasing (0, 1, 2, 3...) graphics.h : Find the relevant DvzGraphicsXXXVertex structure Add the field with the same type and name, following the same order as in the shader attributes list graphics.c : Find the static void _graphics_xxx() function body Determine the appropriate Vulkan format corresponding to the C format that you have chosen ( see the documentation ) Add a line with ATTR(DvzGraphicsXXXVertex, VK_FORMAT_R32G32_SFLOAT, attribute_name) The following steps are optional: follow them if you want to add visual props to the visuals that depend on the graphics pipeline vislib.c : Go through all visuals involving the graphics For each visual, add a prop corresponding to the new attribute, for example: (make sure to modify the appropriate parameters when needed) // Document the prop. prop = dvz_visual_prop ( visual , DVZ_PROP_XXX , 0 , DVZ_DTYPE_VEC2 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop_copy ( prop , 1 , offsetof ( DvzGraphicsXXXVertex , attribute_name ), DVZ_ARRAY_COPY_SINGLE , 1 ); dvz_visual_prop_default ( prop , ( vec2 ){ 0 , 1 }); test_vislib.c : Go through all tests involving the affected visuals, in test_vislib_xxx() Set the prop data for the new prop","title":"Adding a new attribute to an existing graphics pipeline"},{"location":"discussions/checklists/#adding-a-new-uniform-parameter-to-an-existing-graphics-pipeline","text":"graphics_xxx.yyy (GLSL shader file, vertex or fragment shader): Choose an appropriate C type for the uniform, for example vec2 (two single-precision floating-point values) Make sure not to use a type with a 3 in it , so as to avoid misalignment problems Add the uniform field to the Params structure If the params uniform is used in both the vertex and fragment shader, make sure both are updated accordingly graphics.h : Find the relevant DvzGraphicsXXXParams structure Add the field with the same type and name, following the same order as in the shader graphics.c : There's nothing to change in this file The following steps are optional: follow them if you want to add visual props to the visuals that depend on the graphics pipeline vislib.c : Go through all visuals involving the graphics For each visual, add a prop corresponding to the new uniform, for example: (make sure to modify the appropriate parameters when needed) // Document the prop. prop = dvz_visual_prop ( visual , DVZ_PROP_XXX , 0 , DVZ_DTYPE_VEC2 , DVZ_SOURCE_TYPE_PARAM , 0 ); dvz_visual_prop_copy ( prop , 1 , offsetof ( DvzGraphicsXXXParams , uniform_name ), DVZ_ARRAY_COPY_SINGLE , 1 ); dvz_visual_prop_default ( prop , ( vec2 ){ 0 , 1 }); test_vislib.c : Go through all tests involving the affected visuals, in test_vislib_xxx() Set the prop data for the new prop","title":"Adding a new uniform parameter to an existing graphics pipeline"},{"location":"discussions/checklists/#adding-a-new-texture-to-an-existing-graphics-pipeline","text":"graphics_xxx.frag (GLSL fragment shader file): Choose an appropriate texture dimension (1D, 2D, 3D) Add a new binding slot in the shader by adding a line with layout(binding = (USER_BINDING + 2)) uniform sampler2D my_tex; (make sure to use the appropriate number in USER_BINDING + N ) Make sure you use the USER_BINDING constant rather than hard-coding values: this is the number of bindings that are shared by all graphics pipelines in Datoviz Make sure that the N is strictly increasing in the consecutive layout(binding=...) lines (N=0, 1, 2, 3...) Use the new texture in the fragment shader, with a call to texture(my_tex, in_uv) (make sure to use the appropriate texel coordinates variable) graphics.h : There's nothing to change in this file graphics.c : Find the static void _graphics_xxx() function body Before the call to the CREATE macro, add a line with: (make sure to use the same number in DVZ_USER_BINDING + N as in the shader) dvz_graphics_slot ( graphics , DVZ_USER_BINDING + 2 , VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER ); The following steps are optional: follow them if you want to add visual props to the visuals that depend on the graphics pipeline vislib.c : Go through all visuals involving the graphics For each visual, add a source corresponding to the new texture, for example: (make sure to modify the appropriate parameters when needed) dvz_visual_source ( // image visual , DVZ_SOURCE_TYPE_IMAGE , 0 , // 0 for the first sampler in the shader, 1 for the next, and so on DVZ_PIPELINE_GRAPHICS , 0 , // 0 for the first graphics pipeline of the visual, 1 for the next, and so on DVZ_USER_BINDING + 2 , sizeof ( uint8_t ), 0 ); // make sure to use the same +N as above test_vislib.c : Go through all tests involving the affected visuals, in test_vislib_xxx() Set the texture data","title":"Adding a new texture to an existing graphics pipeline"},{"location":"discussions/developer/","text":"Developer notes \u00b6 This page contains useful notes for developers and contributors. Manage script \u00b6 For Linux and macOS, a bash script manage.sh at the root folder provides useful commands for developers and contributors. For example, ./manage.sh build builds the library with CMake. Windows users A similar manage.bat Windows script is in progress. Another option would be to add Windows-specific commands to manage.sh and to require Windows users to use MSYS for running bash scripts. Help needed! Each section on this page provides the details of the supported management commands. Building \u00b6 Command Description ./manage.sh build compile the library ./manage.sh rebuild recompile the library from scratch ./manage.sh cython build the Cython bindings ./manage.sh parseheaders force reparsing the C headers (used by the Cython and documentation generators) We use CMake to build the library. Library dependencies \u00b6 Vulkan : mandatory. The Vulkan SDK is required when compiling the library (not when using it). cglm : mandatory. It is included as a git submodule in external/ . glfw : mandatory. On Linux, it needs to be installed via the package manager. On other systems, it is automatically downloaded by CMake ( FetchContent_Declare ). Dear ImGui : mandatory. It is included as a git submodule in external/ . glslc : optional . If enabled, it is automatically downloaded by CMake. libpng : optional . If enabled, it needs to be installed via the package manager. Support for other operating systems is lacking at the moment . ffmpeg : optional . If enabled, it needs to be installed via the package manager. Support for other operating systems is lacking at the moment . Dear ImGui submodule We use a fork of Dear ImGui in the Datoviz GitHub organization that we regularly keep in sync with the upstream repository. We use a datoviz branch that derives from the docking branch from the upstream repository. The only addition in the datoviz branch compared to the docking branch is that we use a patch in order to support ImGui panels (coming soon). Command-line tool \u00b6 Datoviz includes an executable called datoviz that provides a testing suite and some examples. It is implemented in the cli/ subfolder. C headers parsing \u00b6 The script utils/parse_headers.py implements a simple parser (based on the pyparsing library) of the Datoviz headers. It exports the enums, structs, and functions to a JSON file in utils/headers.json . This JSON file is used by the Cython bindings generator, and by the documentation generator (mostly for the API doc generation). Cython bindings \u00b6 Cython bindings are implemented in bindings/cython . The Cython module is built with dynamic linking to the C library libdatoviz. The bindings are done semi-automatically. Specifically, a large part of the cydatoviz.pxd Cython file is generated automatically by the utils/generate_cython.py script. This script is called automatically by the command ./manage.sh cython . Binary resource embedding \u00b6 Binary resources such as SPIR-V-compiled shaders of all included graphics, the colormap texture, fonts, etc, are bundled into the shared C library as part of the CMake build. The binary files are translated into standalone C files (generated in build/_colortex.c , build/_shaders.c , etc.) which are compiled with libdatoviz. Shaders \u00b6 The shaders of the builtin graphics pipelines are found in src/glsl/ . They are automatically compiled to SPIR-V as part of the CMake build process. They include snippets of GLSL code found in include/datoviz/glsl/ . This include path must be passed to the glslc command with the -I flag (this is done automatically by CMake). SPIR-V compiled shaders are bundled into the library as part of the binary resource embedding process described above. Linting and static analysis \u00b6 Command Description ./manage.sh format format all files with clang-format ./manage.sh valgrind build/datoviz test test_scene_empty run Valgrind to debug segmentation faults and chase down memory leaks ./manage.sh cppcheck static analysis of the codebase ./manage.sh prof inspect the profiling information saved in gmon.out Formatting \u00b6 Formatting rules are defined in .clang-format . We follow loosely this coding guide. Valgrind \u00b6 Valgrind output is saved to .valgrind.out.txt . Profiling \u00b6 By default, Datoviz is built with profiling information automatically exported to gmon.out . Use ./manage.sh prof to inspect the profiling information. Testing \u00b6 Command Description ./manage.sh test [test_array_] run all tests, or optionally only those containing a given string ./manage.sh pytest run all Python tests ./manage.sh demo [mandelbrot] run all demos, or optionally only those containing a given string C tests \u00b6 Datoviz comes with an extensive suite of unit tests, for most modules in the library. They are implemented in tests/ . Datoviz uses a custom testing suite runner. Some tests rely on automatic screenshot generation and comparison with a reference image. At the moment, the reference images are only saved locally, so they are only useful to check non-regression compared to previous runs on the same machine. Python tests \u00b6 The Datoviz Python bindings come with a minimal testing suite, implemented in bindings/cython/tests/ with pytest. Python tests also use automatic comparison with reference images saved locally. Documentation \u00b6 Command Description ./manage.sh doc rebuild the doc website in site/ ./manage.sh docs serve the website on localhost:8000 ./manage.sh publish upload the generated website to GitHub We use mkdocs, with material theme, and several markdown, theme, and mkdocs plugins. See mkdocs.yml . The site is generated in the site/ subfolder. We use GitHub Pages to serve the website. Several parts of the documentation are auto-generated, via mkdocs hooks implemented in utils/hooks.py . Building the documentation requires Python dependencies found in utils/requirements-build.txt . In particular, we use the mkdocs-simple-hooks package to make it possible to use custom Python functions as mkdocs plugin hooks. API documentation : the list of functions to document is found in the docs/api/*.md files. At documentation build time, the API doc generation script ( utils/generate_doc.py ) relies on the generated utils/headers.json (created by utils/parse_headers.py ) to extract the C docstrings and insert them at the right place in the API documentation pages. Enumerations : the documentation file api/enums.md contains a list of headers of enumerations. A script parses the enums in the library header files and inserts them in this file, at documentation build time. Colormaps : colormaps definitions are saved in a CSV file in data/textures/color_texture.csv . This file is parsed by utils/export_colormap.py and the table of all colormaps is automatically generated, using NumPy and Pillow to generate base64-encoded individual colormap images. The table is inserted at the end of docs/user/colormaps.md . Visual documentation : visuals are documented manually, screenshots are automatically generated by the testing suite. Graphics documentation : the item, vertex, params structure fields are automatically generated. The screenshots are automatically generated by the testing suite. Code snippets and screenshots : the documentation build script parses <!-- CODE_PYTHON path/to/file.py --> and <!-- IMAGE path/to/image.png --> in documentation sources and inserts the code file contents, or the image. Packaging \u00b6 Command Description ./manage.sh wheel build a wheel package ./manage.sh testwheel test the wheel package in a fresh virtual environment Warning The package creation pipeline is still a work in progress. The created wheels may not work on all systems. We aim at providing an easy-to-install wheel package of both the C library and the Cython bindings, for the most common operating systems and environments. Installing the library should be as easy as doing pip install datoviz . Note The wheels are created with no ffmpeg support for now. This will be fixed soon. Note We only build wheels for Python 3.8 at the moment, we will support more Python versions soon. Note We don't use conda for now, only Python wheels. They should be fully compatible with anaconda/miniconda distributions, however. The main complication when building a wheel for Datoviz is that the Cython module has a dynamic dependency to libdatoviz, and possibly other libraries (especially when the library is compiled with ffmpeg support). We need to make sure these libraries are found by the Cython module, either by bundling them into the wheel, or by ensuring they are found on the user's environment. Some dependencies (such as libvulkan) require GPU access and therefore cannot be bundled with the wheel. To test the wheel, the ./manage.sh testwheel script automatically creates a fresh virtual environment, installs the .whl wheel package with pip , and executes the following code: from datoviz import canvas , run canvas () . gui_demo () run () Make sure you have the latest versions of pip and virtualenv. Linux On Linux, we need to bundle dynamic libraries to the wheel, but not libvulkan as well as other graphics-related libraries. While delocate is provided for macOS, the Python developers provide the auditwheel tool to bundle dependencies into Python wheels. We need a patched version of auditwheel so that we can exclude some libraries. Another complication is that, in order to build a manylinux wheel, it is basically required to use Docker. The wheel needs to be compiled on an old Linux distribution so as to be compatible with as many Linux distributions as possible. On Linux, the ./manage.sh wheel script involves the following step: Build a Docker image based on quay.io/pypa/manylinux_2_24_x86_64 (provided by the Python developers). This image is based on Debian. Other Docker images are available, but they are based on CentOS, and Vulkan doesn't work well on old CentOS distributions. We add a few extra packages to that Docker image that are required for building Datoviz (see the /Dockerfile_wheel file), including: the Vulkan SDK, a few Python libraries, our patched version of auditwheel. We create a Docker container based on this custom image, and we mount the git repository in the container. We run a script in the container: /wheel.sh . This script does the following: Build the Datoviz C library in the /build_wheel subfolder. Copy the C headers, the build directory, and the Cython source files in a temporary directory in the container so as to avoid polluting the main Datoviz directory. Build the Cython module. Create a Python wheel. Run the patched version of auditwheel to bundle libdatoviz in it. Copy the repaired wheel to /bindings/cython/dist . The resulting manylinux wheel may be uploadable to PyPI, but we have to make sure it works on different Linux-based systems first . We're likely to run into issues and we may have to include more dependencies via auditwheel. Until then, we only upload the wheel on GitHub. macOS On macOS, in addition to running the standard wheel creation command python setup.py bdist_wheel , we also need to bundle libdatoviz.dylib into the wheel. The delocate script does just that. However, it will also bundle other dependencies such as libvulkan, which wouldn't work as Datoviz needs to use the system's libvulkan. For this reason, we provide a patch to delocate which allows us to exclude libvulkan from the wheel. The patched version of delocate needs to be installed before running ./manage.sh wheel . Windows Creating a Python wheel for Windows should be as easy as running the following commands: manage.bat build manage.bat wheel manage.bat testwheel On Windows, the setup.py script automatically bundles the file libdatoviz.dll (created by the build script) into the wheel. The wheel creating script uses the following command to create the wheel: python setup.py bdist_wheel . Environment variables \u00b6 Environment variable Description DVZ_DEBUG=1 Run demos and examples interactively DVZ_LOG_LEVEL=0 Logging level Logging levels : 0=trace, 1=debug, 2=info (default), 3=warning, 4=error","title":"Developer notes"},{"location":"discussions/developer/#developer-notes","text":"This page contains useful notes for developers and contributors.","title":"Developer notes"},{"location":"discussions/developer/#manage-script","text":"For Linux and macOS, a bash script manage.sh at the root folder provides useful commands for developers and contributors. For example, ./manage.sh build builds the library with CMake. Windows users A similar manage.bat Windows script is in progress. Another option would be to add Windows-specific commands to manage.sh and to require Windows users to use MSYS for running bash scripts. Help needed! Each section on this page provides the details of the supported management commands.","title":"Manage script"},{"location":"discussions/developer/#building","text":"Command Description ./manage.sh build compile the library ./manage.sh rebuild recompile the library from scratch ./manage.sh cython build the Cython bindings ./manage.sh parseheaders force reparsing the C headers (used by the Cython and documentation generators) We use CMake to build the library.","title":"Building"},{"location":"discussions/developer/#library-dependencies","text":"Vulkan : mandatory. The Vulkan SDK is required when compiling the library (not when using it). cglm : mandatory. It is included as a git submodule in external/ . glfw : mandatory. On Linux, it needs to be installed via the package manager. On other systems, it is automatically downloaded by CMake ( FetchContent_Declare ). Dear ImGui : mandatory. It is included as a git submodule in external/ . glslc : optional . If enabled, it is automatically downloaded by CMake. libpng : optional . If enabled, it needs to be installed via the package manager. Support for other operating systems is lacking at the moment . ffmpeg : optional . If enabled, it needs to be installed via the package manager. Support for other operating systems is lacking at the moment . Dear ImGui submodule We use a fork of Dear ImGui in the Datoviz GitHub organization that we regularly keep in sync with the upstream repository. We use a datoviz branch that derives from the docking branch from the upstream repository. The only addition in the datoviz branch compared to the docking branch is that we use a patch in order to support ImGui panels (coming soon).","title":"Library dependencies"},{"location":"discussions/developer/#command-line-tool","text":"Datoviz includes an executable called datoviz that provides a testing suite and some examples. It is implemented in the cli/ subfolder.","title":"Command-line tool"},{"location":"discussions/developer/#c-headers-parsing","text":"The script utils/parse_headers.py implements a simple parser (based on the pyparsing library) of the Datoviz headers. It exports the enums, structs, and functions to a JSON file in utils/headers.json . This JSON file is used by the Cython bindings generator, and by the documentation generator (mostly for the API doc generation).","title":"C headers parsing"},{"location":"discussions/developer/#cython-bindings","text":"Cython bindings are implemented in bindings/cython . The Cython module is built with dynamic linking to the C library libdatoviz. The bindings are done semi-automatically. Specifically, a large part of the cydatoviz.pxd Cython file is generated automatically by the utils/generate_cython.py script. This script is called automatically by the command ./manage.sh cython .","title":"Cython bindings"},{"location":"discussions/developer/#binary-resource-embedding","text":"Binary resources such as SPIR-V-compiled shaders of all included graphics, the colormap texture, fonts, etc, are bundled into the shared C library as part of the CMake build. The binary files are translated into standalone C files (generated in build/_colortex.c , build/_shaders.c , etc.) which are compiled with libdatoviz.","title":"Binary resource embedding"},{"location":"discussions/developer/#shaders","text":"The shaders of the builtin graphics pipelines are found in src/glsl/ . They are automatically compiled to SPIR-V as part of the CMake build process. They include snippets of GLSL code found in include/datoviz/glsl/ . This include path must be passed to the glslc command with the -I flag (this is done automatically by CMake). SPIR-V compiled shaders are bundled into the library as part of the binary resource embedding process described above.","title":"Shaders"},{"location":"discussions/developer/#linting-and-static-analysis","text":"Command Description ./manage.sh format format all files with clang-format ./manage.sh valgrind build/datoviz test test_scene_empty run Valgrind to debug segmentation faults and chase down memory leaks ./manage.sh cppcheck static analysis of the codebase ./manage.sh prof inspect the profiling information saved in gmon.out","title":"Linting and static analysis"},{"location":"discussions/developer/#formatting","text":"Formatting rules are defined in .clang-format . We follow loosely this coding guide.","title":"Formatting"},{"location":"discussions/developer/#valgrind","text":"Valgrind output is saved to .valgrind.out.txt .","title":"Valgrind"},{"location":"discussions/developer/#profiling","text":"By default, Datoviz is built with profiling information automatically exported to gmon.out . Use ./manage.sh prof to inspect the profiling information.","title":"Profiling"},{"location":"discussions/developer/#testing","text":"Command Description ./manage.sh test [test_array_] run all tests, or optionally only those containing a given string ./manage.sh pytest run all Python tests ./manage.sh demo [mandelbrot] run all demos, or optionally only those containing a given string","title":"Testing"},{"location":"discussions/developer/#c-tests","text":"Datoviz comes with an extensive suite of unit tests, for most modules in the library. They are implemented in tests/ . Datoviz uses a custom testing suite runner. Some tests rely on automatic screenshot generation and comparison with a reference image. At the moment, the reference images are only saved locally, so they are only useful to check non-regression compared to previous runs on the same machine.","title":"C tests"},{"location":"discussions/developer/#python-tests","text":"The Datoviz Python bindings come with a minimal testing suite, implemented in bindings/cython/tests/ with pytest. Python tests also use automatic comparison with reference images saved locally.","title":"Python tests"},{"location":"discussions/developer/#documentation","text":"Command Description ./manage.sh doc rebuild the doc website in site/ ./manage.sh docs serve the website on localhost:8000 ./manage.sh publish upload the generated website to GitHub We use mkdocs, with material theme, and several markdown, theme, and mkdocs plugins. See mkdocs.yml . The site is generated in the site/ subfolder. We use GitHub Pages to serve the website. Several parts of the documentation are auto-generated, via mkdocs hooks implemented in utils/hooks.py . Building the documentation requires Python dependencies found in utils/requirements-build.txt . In particular, we use the mkdocs-simple-hooks package to make it possible to use custom Python functions as mkdocs plugin hooks. API documentation : the list of functions to document is found in the docs/api/*.md files. At documentation build time, the API doc generation script ( utils/generate_doc.py ) relies on the generated utils/headers.json (created by utils/parse_headers.py ) to extract the C docstrings and insert them at the right place in the API documentation pages. Enumerations : the documentation file api/enums.md contains a list of headers of enumerations. A script parses the enums in the library header files and inserts them in this file, at documentation build time. Colormaps : colormaps definitions are saved in a CSV file in data/textures/color_texture.csv . This file is parsed by utils/export_colormap.py and the table of all colormaps is automatically generated, using NumPy and Pillow to generate base64-encoded individual colormap images. The table is inserted at the end of docs/user/colormaps.md . Visual documentation : visuals are documented manually, screenshots are automatically generated by the testing suite. Graphics documentation : the item, vertex, params structure fields are automatically generated. The screenshots are automatically generated by the testing suite. Code snippets and screenshots : the documentation build script parses <!-- CODE_PYTHON path/to/file.py --> and <!-- IMAGE path/to/image.png --> in documentation sources and inserts the code file contents, or the image.","title":"Documentation"},{"location":"discussions/developer/#packaging","text":"Command Description ./manage.sh wheel build a wheel package ./manage.sh testwheel test the wheel package in a fresh virtual environment Warning The package creation pipeline is still a work in progress. The created wheels may not work on all systems. We aim at providing an easy-to-install wheel package of both the C library and the Cython bindings, for the most common operating systems and environments. Installing the library should be as easy as doing pip install datoviz . Note The wheels are created with no ffmpeg support for now. This will be fixed soon. Note We only build wheels for Python 3.8 at the moment, we will support more Python versions soon. Note We don't use conda for now, only Python wheels. They should be fully compatible with anaconda/miniconda distributions, however. The main complication when building a wheel for Datoviz is that the Cython module has a dynamic dependency to libdatoviz, and possibly other libraries (especially when the library is compiled with ffmpeg support). We need to make sure these libraries are found by the Cython module, either by bundling them into the wheel, or by ensuring they are found on the user's environment. Some dependencies (such as libvulkan) require GPU access and therefore cannot be bundled with the wheel. To test the wheel, the ./manage.sh testwheel script automatically creates a fresh virtual environment, installs the .whl wheel package with pip , and executes the following code: from datoviz import canvas , run canvas () . gui_demo () run () Make sure you have the latest versions of pip and virtualenv. Linux On Linux, we need to bundle dynamic libraries to the wheel, but not libvulkan as well as other graphics-related libraries. While delocate is provided for macOS, the Python developers provide the auditwheel tool to bundle dependencies into Python wheels. We need a patched version of auditwheel so that we can exclude some libraries. Another complication is that, in order to build a manylinux wheel, it is basically required to use Docker. The wheel needs to be compiled on an old Linux distribution so as to be compatible with as many Linux distributions as possible. On Linux, the ./manage.sh wheel script involves the following step: Build a Docker image based on quay.io/pypa/manylinux_2_24_x86_64 (provided by the Python developers). This image is based on Debian. Other Docker images are available, but they are based on CentOS, and Vulkan doesn't work well on old CentOS distributions. We add a few extra packages to that Docker image that are required for building Datoviz (see the /Dockerfile_wheel file), including: the Vulkan SDK, a few Python libraries, our patched version of auditwheel. We create a Docker container based on this custom image, and we mount the git repository in the container. We run a script in the container: /wheel.sh . This script does the following: Build the Datoviz C library in the /build_wheel subfolder. Copy the C headers, the build directory, and the Cython source files in a temporary directory in the container so as to avoid polluting the main Datoviz directory. Build the Cython module. Create a Python wheel. Run the patched version of auditwheel to bundle libdatoviz in it. Copy the repaired wheel to /bindings/cython/dist . The resulting manylinux wheel may be uploadable to PyPI, but we have to make sure it works on different Linux-based systems first . We're likely to run into issues and we may have to include more dependencies via auditwheel. Until then, we only upload the wheel on GitHub. macOS On macOS, in addition to running the standard wheel creation command python setup.py bdist_wheel , we also need to bundle libdatoviz.dylib into the wheel. The delocate script does just that. However, it will also bundle other dependencies such as libvulkan, which wouldn't work as Datoviz needs to use the system's libvulkan. For this reason, we provide a patch to delocate which allows us to exclude libvulkan from the wheel. The patched version of delocate needs to be installed before running ./manage.sh wheel . Windows Creating a Python wheel for Windows should be as easy as running the following commands: manage.bat build manage.bat wheel manage.bat testwheel On Windows, the setup.py script automatically bundles the file libdatoviz.dll (created by the build script) into the wheel. The wheel creating script uses the following command to create the wheel: python setup.py bdist_wheel .","title":"Packaging"},{"location":"discussions/developer/#environment-variables","text":"Environment variable Description DVZ_DEBUG=1 Run demos and examples interactively DVZ_LOG_LEVEL=0 Logging level Logging levels : 0=trace, 1=debug, 2=info (default), 3=warning, 4=error","title":"Environment variables"},{"location":"discussions/faq/","text":"Frequently asked questions \u00b6 What is the distinction between the scene, the canvas, and the window? \u00b6 Datoviz provides three similar, but different abstractions: the scene , the canvas , the window . The scene provides a relatively high-level plotting interface that allows to arrange panels (subplots) in a grid, define controllers, and add visuals to the panels. The canvas is lower-level object that allows to use Vulkan directly via vklite. While the scene deals with visual elements, the canvas deals with Vulkan objects. The window is an abstraction provided by the backend windowing library, glfw at the moment. It is a bare window that doesn't allow for any kind rendering, unless manually creating a swapchain and so on by using Vulkan or vklite directly. Most users will only work at the scene level. Advanced users will use the canvas to create custom applications, interactive animations, or even small video games. Finally, the window is only used internally and will probably never be used directly. What is the difference between the FPS and eFPS? \u00b6 The FPS is the number of Frames Per Second . It is used to evaluate the raw rendering performance. The eFPS is the effective Frames Per Second . It indicates the rendering smoothness as perceived by the user. The eFPS is computed from the average maximum delay between two consecutive frames. If every second, five frames take 100 ms to render, but all other frames render in 1 ms, the rendering will be perceived as slow as an application at ~10 FPS, even though the total frame count would be close to 1000 FPS.","title":"FAQ"},{"location":"discussions/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"discussions/faq/#what-is-the-distinction-between-the-scene-the-canvas-and-the-window","text":"Datoviz provides three similar, but different abstractions: the scene , the canvas , the window . The scene provides a relatively high-level plotting interface that allows to arrange panels (subplots) in a grid, define controllers, and add visuals to the panels. The canvas is lower-level object that allows to use Vulkan directly via vklite. While the scene deals with visual elements, the canvas deals with Vulkan objects. The window is an abstraction provided by the backend windowing library, glfw at the moment. It is a bare window that doesn't allow for any kind rendering, unless manually creating a swapchain and so on by using Vulkan or vklite directly. Most users will only work at the scene level. Advanced users will use the canvas to create custom applications, interactive animations, or even small video games. Finally, the window is only used internally and will probably never be used directly.","title":"What is the distinction between the scene, the canvas, and the window?"},{"location":"discussions/faq/#what-is-the-difference-between-the-fps-and-efps","text":"The FPS is the number of Frames Per Second . It is used to evaluate the raw rendering performance. The eFPS is the effective Frames Per Second . It indicates the rendering smoothness as perceived by the user. The eFPS is computed from the average maximum delay between two consecutive frames. If every second, five frames take 100 ms to render, but all other frames render in 1 ms, the rendering will be perceived as slow as an application at ~10 FPS, even though the total frame count would be close to 1000 FPS.","title":"What is the difference between the FPS and eFPS?"},{"location":"discussions/practices/","text":"Best practices \u00b6 Coming soon.","title":"Best practices"},{"location":"discussions/practices/#best-practices","text":"Coming soon.","title":"Best practices"},{"location":"discussions/vulkan/","text":"Vulkan crash course \u00b6 This page proposes a high-level, simplified overview of Vulkan for beginners. Understanding the basic principles Vulkan is required when writing custom visuals or graphics, but it is not required when using existing visuals . Using the GPU for scientific visualization \u00b6 The GPU is a massively parallel computing unit dedicated to real-time graphics rendering. Vulkan is a low-level graphics API that provides extensive control on the GPU for rendering and compute. It is harder to user than older APIs like OpenGL because it proposes a relatively low level of abstraction. This design choice gives more control to the developer and helps achieving higher performance. The GPU is typically used by video games, which render complex, animated 3D meshes with real-time special effects and low latency. The GPU can also be used for scientific applications, which has quite different requirements. Scenes are typically less dynamic, there is less heterogeneity in the types of objects rendered in the scene, and high visual accuracy is an absolute requirement. How to use the GPU for scientific visualization? At a high level, the user has some scientific data: a set of 2D or 3D points, a graph, a volume, an image, and so on. On the other hand, the GPU can only render three types of primitives : points (1D), lines (2D), triangles (3D). Fortunately, the GPU gives full control on, essentially, two things: the way the data is transformed before the primitive positions are determined, the exact color of each pixel of each primitive. In practice, one specifies this via special programs called shaders , that run in parallel on the GPU. They are typically written in a C-like language called GLSL (OpenGL shading language). Note Vulkan does not work directly with GLSL, but with an intermediate representation called SPIR-V (a bit similar to LLVM). Vulkan and other third-parties propose compilers transforming GLSL code into SPIR-V. In Datoviz, all shader code is written in GLSL. It is theoretically possible to use other languages that compile to SPIR-V. The vertex shader is a GLSL program that runs on every vertex (point) of a given graphics pipeline. It must return the final point position in a reference normalized coordinate system. This point is used when generating the primitive (point, one of the two endpoints of a line, or one of the three corners of a triangle). The fragment shader is a GLSL program that runs on every pixel of every primitive (point, line, or triangle). It must return the RGBA values of that pixel. It can discard pixels altogether (for example, slicing a mesh along a plane). Note Vulkan supports other types of shaders, such as geometry shaders and tesselation shaders. However, hardware support for these more recent and advanced shader types is not universal. For example, geometry shaders are not supported on macOS (Metal). Another important type of shader is the compute shader . Compute shaders are used to implement general-purpose parallel computations on the GPU on possibly the same objects (buffer and textures) used for rendering, which allow for highly complex and custom visualization applications. There are, of course, many other parameters and details related to rendering, but these are the most important principles. 2D and 3D graphics on the GPU \u00b6 Rendering high-quality 2D graphics on the GPU is significantly harder than rendering 3D graphics. 3D rendering \u00b6 Rendering a 3D mesh is relatively straightforward. A mesh is typically defined by a set of 3D points , and a set of faces . Each face is determined by three integers: the indices of the three triangle corners within the set of 3D points. Vertex shader \u00b6 In the simplest case, the vertex shader takes as input the 3D points, and applies 3D transformation matrices to account for the camera position and perspective. By convention, there are generally three transformation 4x4 matrices: model matrix : transformation from the local coordinate system (in which the mesh is defined) into the global coordinate system (the 3D world containing the mesh), view matrix : transformation from the global coordinate system to the camera-local coordinate system, projection matrix : applies perspective with 4D homogeneous coordinates. Understanding the mathematics of these transformations is beyond the scope of this page. There are many explanations online. Here is a trivial example of a vertex shader in GLSL: #version 450 layout ( location = 0 ) in vec3 pos ; void main () { // ... define transformation matrices ... gl_Position = proj * view * model * vec4 ( pos , 1.0 ); } The variable pos is a 3D vector with the coordinates of 1 point. The GPU executes the vertex shader in parallel on many points. The output of the vertex shader is gl_Position , a vec4 vector (the last coordinate is the homogeneous coordinate, used for perspective). Fragment shader \u00b6 A trivial fragment shader could output a constant color, independently from the position of the pixel within a triangle. But typically, the fragment shader for a 3D mesh implements mathematical computations to account for lighting, which gives a much more realistic feel. While many lighting models have been created, Datoviz currently implements a classic technique called Phong shading . Again, the details are beyond the scope of this page. One can also apply a texture on a mesh. Each point comes with a pair of special coordinates called the texture coordinates , noted uv . Normalized between 0 and 1, they refer to a specific pixel position within an associated 2D texture. The fragment shader typically fetches the color of the texture pixel (texel) at this exact position. Importantly, the GPU is able to make efficient linear interpolations of these values for pixels between two vertices of a given primitive. For example, to render an image, one specifies two triangles forming a square, and sets the uv coordinates of each of the six vertices (three per triangle) to the different combinations of (0 or 1, 0 or 1) . For every pixel in the square, the correct uv coordinates will be interpolated and the relevant texel will be fetched from the texture on the GPU. 2D rendering \u00b6 Rendering 2D graphics is much trickier on the GPU. How to render a disc, a polygon patch, a thick line, text by using only points, lines, and triangles? The answer is: by leveraging the vertex shader and, more importantly, the fragment shader . One follows two steps: define the primitive type for the 2D object, which will constitute a sort of \"envelope\" of the final object, use the fragment shader to properly discard pixels that are beyond the boundaries of the final object, and compute the alpha transparency value for pixels lying on the border of the object, thereby implementing antialiasing directly on the GPU. For example, to render a thick line, one must triangulate the path, taking care of regions of high curvature and other details. On each triangle, the fragment shader computes the exact position along the path, and the distance to the border of the path. The alpha transparency value is obtained via a so-called signed distance function (a function of space giving the distance, in pixels, to the border of the object). A similar principle is used for markers and text. For text, signed distance functions of each glyph are stored in a texture and used by the fragment shader. In Datoviz, high-quality antialiased 2D graphics are implemented with GLSL code originally written by Nicolas Rougier in his Glumpy library (GPU implementation of agg , antigrain geometry), and published in computer graphics articles . A fundamental principle of Datoviz is to abstract away these low-level details to the user, who can reuse directly these existing graphics for the most common types of scientific visualizations . Vulkan for scientific visualization \u00b6 We've now seen the basic principles of using the GPU for scientific visualization. Let's turn now to Vulkan. Vulkan is a low-level graphics API that has a high entry barrier given the large number of abstractions provided. These abstractions mostly relate to internal details of GPU hardware, but they are essential when one focuses on achieving high performance, which is the main selling point of Datoviz. Here is, for your information only, the ~30 types of objects used in Vulkan: Diagram by Adam Sawicki, for gpuopen Covering all of these objects in detail is totally out of scope of this page. However, we'll briefly explain the most important objects, and how they are used in Datoviz. Importantly, Datoviz implements its own thin wrapper on top of Vulkan (called vklite), which focuses on the most important concepts only. The wrapper provides an API that is easier to use than the original Vulkan API, although it it slightly less flexible. This is acceptable given that the wrapper targets scientific applications, which are less demanding than 3D video games. We'll classify these objects in five broad categories: storing data on the GPU, defining graphics and compute pipelines with shaders, recording graphics and compute commands for the GPU, running the main rendering loop , synchronization . Storing data on the GPU \u00b6 Scientific data is typically obtained from files, from the network, or generated by simulation programs. In order for the GPU to render it, it needs to be uploaded to the GPU. A GPU typically has dedicated video memory, or shares memory with the host. For example, the NVIDIA GEFORCE RTX 2070 SUPER GPU has 8 GB of video memory. In any case, Vulkan defines several objects to control how memory is organized and how the data is stored in video memory. Datoviz has a very simple model where there are only two types of memory: GPU buffers : a GPU buffer is a memory buffer of a given size, that contains arbitrary binary bytes, GPU textures : a GPU texture is defined by a 1D, 2D, or 3D image of a given shape, by an internally-handled memory buffer with the pixel data in a given format, and a sampler which is a special GPU object that specifies how a texel is accessed and interpolated when fetched by the fragment shader. A GPU buffer abstracts away the following Vulkan objects: Buffer, BufferView. A GPU texture abstracts away the following Vulkan objects: Image, ImageView, Sampler. Uploading data from the host memory to a GPU buffer or texture, and downloading data from the GPU back to the host, are complex operations in Vulkan. Again, Datoviz abstracts these processes away in the transfer API. Note A GPU image may be represented in several ways by the GPU. For example, a texture needs to be stored in a special way in order to achieve high performance, but this internal representation is incompatible with the way the image is typically stored in a file or on the host. Vulkan provides an API to transition the image between these different formats. Uploading an image to the GPU therefore involves transitioning the image from whatever format the GPU has chosen, to a standard linear layout that matches the data uploaded from the CPU. These details are abstracted away in Datoviz. Defining pipeline with shaders \u00b6 Datoviz supports two types of pipelines: graphics pipelines (or just graphics ): for rendering points, lines, or triangles with dedicated vertex and fragment shaders, compute pipelines (or just computes ): for general-purpose GPU computations. A graphics pipeline encompasses many steps. The diagram below exposes the most important steps, and is shown for your information only: Schematic from vulkan-tutorial.com In addition to defining shaders, one needs to define the data input of the vertex shader. In Datoviz, a vertex shader accepts several kinds of inputs: attribute : a part of each vertex to process in parallel (for example, a vec3 position for the point being processed), uniform : small data (parameters) shared across all vertices in the pipeline, texture : a sampler giving a way to fetch any texel from a 1D, 2D, or 3D texture, storage buffer : an arbitrary binary buffer that may be accessed from any vertex thread, push constant : a small parameter that is set when recording the command buffer (see below). Uniforms, textures, storage buffers are special types of so-called Vulkan descriptors , that we could also call GPU resources : they represent essentially GPU buffers or textures. They can be accessed from the vertex shader or, actually, from any kind of shader. By contrast, the push constant is a different type of data that is passed to the GPU when recording a command buffer. An attribute is a type of data that is processed in parallel. Vulkan define several abstractions in order to define the way a shader may access descriptors (uniforms, textures, or storage buffers): descriptor set layouts, pipeline layouts, descriptor pools, descriptor sets... These abstractions mostly make sense when focusing on performance, and they are partly abstracted away in Datoviz. Datoviz proposes the following, simplified model for defining GPU resources accessible by shaders: a slot is defined in GLSL in each shader. It is represented by a resource index within the shader, and a resource type (uniform, storage, sampler). It must also be defined in the Datoviz C API, and the GLSL and C descriptions must imperatively match. a binding is an association of a given GPU object (buffer or texture) with a given slot in a given pipeline (graphics or compute). For example, a pipeline may declare that it expects a uniform at slot 0, and a texture sampler at slot 1. This is defined in the slots . Then, before one can render a pipeline, one also needs to declare what GPU buffer to use for slot 0, and what GPU texture to use for slot 1. This is defined in the bindings . Defining slots is done when creating a graphics or compute. Defining bindings is done when rendering an existing graphics or compute. Pipelines encompass the following Vulkan objects: ShaderModule, Pipeline, PipelineLayout, DescriptorPool, DescriptorSetLayout, DescriptorSet. Recording commands for the GPU \u00b6 Once GPU objects have been created, data has been uploaded, graphics and compute pipelines have been defined, the next step is to record commands for the GPU . This aspect of Vulkan is a significant difference with older graphics APIs such as OpenGL. One does not send commands to the GPU in real time, but one pre-records a linear succession of commands within a so-called command buffer , and submits recorded command buffers to special queues . The GPU watches these queues, receives the command buffers, and processes them in parallel. In Vulkan, recording commands are special commands starting wih vkCmd . In Datoviz, they start with dvz_cmd_ . For example, rendering a single graphics pipeline involves the following recording commands: dvz_cmd_begin (...); // begin recording the command buffer dvz_cmd_begin_renderpass (...); // begin the renderpass dvz_cmd_bind_vertex_buffer (...); // bind an existing GPU buffer as vertex buffer dvz_cmd_bind_index_buffer (...); // bind an existing GPU buffer as index buffer dvz_cmd_bind_graphics (...); // bind an existing graphics pipeline dvz_cmd_viewport (...); // set the viewport dvz_cmd_draw (...); // **perform the actual rendering of the graphics pipeline** dvz_cmd_end_renderpass (...); // end the renderpass dvz_cmd_end (...); // stop recording the command buffer Once called on a command buffer, the command buffer is recorded and can be submitted to a GPU queue. Vulkan leaves to the user the choice of defining the number and types of GPU queues for the application. This is also depends heavily on the hardware. Currently, Datoviz requests four queues, but may end up with less queues if the hardware does not support them (this is all transparent to the user): a transfer queue receives command buffers for buffer/image upload, download, copy, transitions... a compute queue receives command buffers with compute tasks, a render queue receives command buffers with either graphics and/or compute tasks, a present queue is used for the main rendering loop (swapchain). Vulkan has been designed with the idea that command buffers will be constantly recreated and/or reused. Multithreaded applications can record command buffers in parallel, and must use special synchronization primitives to efficiently submit the command buffers to the GPU. Scientific applications are typically much less dynamic than video games. Still, some amount of dynamism is expected in some applications. Therefore, Datoviz assumes that command buffers are typically not recreated at every frame, but allows for relatively efficient command buffer recreation when needed. Here are the different ways the GPU objects may change during the lifetime of an application: changing buffer or texture data : update a GPU buffer or texture, doesn't require command buffer recreation, interactivity (pan and zoom, arcball, and so on): update a uniform buffer, changing the number of vertices in a given graphics pipeline: require command buffer recreation (unless using indirect rendering , in which case this involves updating a GPU buffer), push constant change : require command buffer recreation, resize , panel change , viewport change : require command buffer recreation. Datoviz command buffers and queues are based on the following Vulkan objects: CommandPool, CommandBuffer, Queue. Main rendering loop \u00b6 Once the command buffers have been recorded, one needs to submit them to the GPU and render the scene in a window. This step must be done manually when using the Vulkan API. Again, this is abstracted away in Datoviz, at the level of the canvas . This step is actually one of the most complex ones in Vulkan, especially when there's a need to do it as efficiently as possible. First, one considers that the window size is fixed (until it is not). Resizing is a complex operation that requires destroying and recreating a large number of Vulkan objects, and it needs to be handled correctly in the rendering loop. Second, one needs to create a GPU image (like the object that is associated to a texture, but without a sampler) that the GPU will render to. This image will be presented to the screen. One must also define another special image of the same size for the depth buffer , essential with 3D rendering. Third, one must acquire a surface , a special Vulkan object that is used to render something to the window. Creating a window is an OS-dependent operation. Datoviz uses the glfw window library that abstracts these details away and offers an easy way to create windows and to deal with user inputs (mouse, keyboard). Fourth, one needs to create a swapchain . This object provides a way to implement a technique sometimes called double-buffering, or triple-buffering, depending on the number of images used in the swapchain. The idea is to avoid making the GPU wait while an image is being presented to the screen . For example, with a frame rate of 60 images per second, each image remains on screen during about 16 milliseconds. During this time, the GPU is not expected to render to the same image, unless it makes a copy. That's basically the idea of the swapchain: providing a set of 2, 3 or more images that are almost identical. While the image 0 is presented to the screen, the GPU can render the next frame on image 1. When it finishes, it presents image 1 to the screen, while image 0 is being rewritten for the next frame (double buffering), or while it waits until the GPU requests it. This logic must be, in part, implemented by the developer who uses the Vulkan API directly. Datoviz completely abstracts this process away. Fifth, one needs to define a render pass and a set of framebuffers . The render pass defines the way the GPU renders an image, in one or several steps. The framebuffers represent the links between the GPU images and the render pass steps. The render pass must be specified when recording a rendering command buffer. Sixth, one needs to implement the main rendering loop . This is typically an infinite loop where every iteration represents a frame. At every frame, the rendering loop performs the following (simplified) steps: Examine the user events (mouse, keyboard) that occurred in the window since the last frame, Perform the resize if the window size has changed since the last frame, Implement the scene logic (update internal variables as a function of user events and time), Perform the pending transfers (upload/download of GPU buffers/textures) that have been requested since last frame, possibly from a background thread, Optionally, record new command buffers, Acquire a new swapchain image for rendering, Wait until the previous frame that was using the same swapchain image (might be 2 or 3 frames before) has finished rendering, Submit the command buffers to their associated GPU queues, which will render the image, Present the image to the screen, but only after the GPU has finished rendering it (asynchronous operation). This logic is essentially implemented in: dvz_canvas_frame() dvz_canvas_frame_submit() dvz_app_run() The rendering loop involves the following Vulkan objects: SurfaceKHR, SwapchainKHR, Image, ImageView, RenderPass, Framebuffer. Synchronization \u00b6 The last important topic pertains to synchronization . The GPU should be seen as a partly independent device on which tasks are submitted asynchronously (via command buffers and queues), and that processes them in parallel. In addition, each task may involve a massively parallel architecture (for example, processing thousands of vertices or fragments in parallel). Vulkan provides an API to let the CPU communicate with the GPU. A highly inefficient way would be for the CPU to wait until the GPU is idle before submitting new tasks or uploading data. This would be done via \"hard\" synchronization primitives that are implemented in the Vulkan functions vkQueueWaitIdle() and vkDeviceWaitIdle() , and in the dvz_queue|gpu|app_wait() functions in Datoviz. Doing it this way would work and would not require any other more fine-grained synchronization primitive, but it would result in poor performance. Vulkan provides several more fine-grained synchronization primitives, of which Datoviz currently supports three: Inner command buffer synchronization , provided by barriers, GPU-GPU synchronization , provided by semaphores. CPU-GPU synchronization , provided by fences, A barrier is a way for a command buffer to let the GPU know that some recorded commands should wait for completion of other commands. For example, if a command buffer involves launching a compute shader on a buffer, then rendering to a graphics pipeline, a barrier should be defined if ever the graphics pipeline uses the same buffer as used by the compute shader. The graphics pipeline should not start reading a buffer while the same buffer is being written to by the compute pipeline. A semaphore is a way to introduce dependencies between different submissions of command buffers. They are used in the main rendering loop and swapchain logic. When the GPU has finished rendering an image, then this image should be presented to the screen. This is implemented with a semaphore. A fence is a way for the CPU to wait until the GPU has finished some task. This is also used in the main rendering loop: it wouldn't make much sense to start the current frame until the previous frame has not finished rendering (but it can start while the swapchain presents the previously rendered image to the screen). Synchronization is required when uploading data to the GPU. Since the GPU may be constantly reading from GPU buffers and textures, data should not be uploaded to these GPU objects without proper synchronization. Otherwise, the GPU might use corrupted data while rendering the scene. Technical details \u00b6 The vklite API documentation contains the documentation of all Vulkan-related functions. There is no other documentation of vklite at the moment, however you can look at the unit tests to get an idea of how to use each vklite object. GPU features and limits \u00b6 The DvzGpu structure contains a few fields with native Vulkan structures defining GPU capabilities and limits. We give here a few minimal values that we can reasonably expect on almost all devices (according to this Vulkan database ): Texture dimension Maximum allowed texture size (in any axis) 1D 16384 2D 16384 3D 2048","title":"Vulkan crash course"},{"location":"discussions/vulkan/#vulkan-crash-course","text":"This page proposes a high-level, simplified overview of Vulkan for beginners. Understanding the basic principles Vulkan is required when writing custom visuals or graphics, but it is not required when using existing visuals .","title":"Vulkan crash course"},{"location":"discussions/vulkan/#using-the-gpu-for-scientific-visualization","text":"The GPU is a massively parallel computing unit dedicated to real-time graphics rendering. Vulkan is a low-level graphics API that provides extensive control on the GPU for rendering and compute. It is harder to user than older APIs like OpenGL because it proposes a relatively low level of abstraction. This design choice gives more control to the developer and helps achieving higher performance. The GPU is typically used by video games, which render complex, animated 3D meshes with real-time special effects and low latency. The GPU can also be used for scientific applications, which has quite different requirements. Scenes are typically less dynamic, there is less heterogeneity in the types of objects rendered in the scene, and high visual accuracy is an absolute requirement. How to use the GPU for scientific visualization? At a high level, the user has some scientific data: a set of 2D or 3D points, a graph, a volume, an image, and so on. On the other hand, the GPU can only render three types of primitives : points (1D), lines (2D), triangles (3D). Fortunately, the GPU gives full control on, essentially, two things: the way the data is transformed before the primitive positions are determined, the exact color of each pixel of each primitive. In practice, one specifies this via special programs called shaders , that run in parallel on the GPU. They are typically written in a C-like language called GLSL (OpenGL shading language). Note Vulkan does not work directly with GLSL, but with an intermediate representation called SPIR-V (a bit similar to LLVM). Vulkan and other third-parties propose compilers transforming GLSL code into SPIR-V. In Datoviz, all shader code is written in GLSL. It is theoretically possible to use other languages that compile to SPIR-V. The vertex shader is a GLSL program that runs on every vertex (point) of a given graphics pipeline. It must return the final point position in a reference normalized coordinate system. This point is used when generating the primitive (point, one of the two endpoints of a line, or one of the three corners of a triangle). The fragment shader is a GLSL program that runs on every pixel of every primitive (point, line, or triangle). It must return the RGBA values of that pixel. It can discard pixels altogether (for example, slicing a mesh along a plane). Note Vulkan supports other types of shaders, such as geometry shaders and tesselation shaders. However, hardware support for these more recent and advanced shader types is not universal. For example, geometry shaders are not supported on macOS (Metal). Another important type of shader is the compute shader . Compute shaders are used to implement general-purpose parallel computations on the GPU on possibly the same objects (buffer and textures) used for rendering, which allow for highly complex and custom visualization applications. There are, of course, many other parameters and details related to rendering, but these are the most important principles.","title":"Using the GPU for scientific visualization"},{"location":"discussions/vulkan/#2d-and-3d-graphics-on-the-gpu","text":"Rendering high-quality 2D graphics on the GPU is significantly harder than rendering 3D graphics.","title":"2D and 3D graphics on the GPU"},{"location":"discussions/vulkan/#3d-rendering","text":"Rendering a 3D mesh is relatively straightforward. A mesh is typically defined by a set of 3D points , and a set of faces . Each face is determined by three integers: the indices of the three triangle corners within the set of 3D points.","title":"3D rendering"},{"location":"discussions/vulkan/#2d-rendering","text":"Rendering 2D graphics is much trickier on the GPU. How to render a disc, a polygon patch, a thick line, text by using only points, lines, and triangles? The answer is: by leveraging the vertex shader and, more importantly, the fragment shader . One follows two steps: define the primitive type for the 2D object, which will constitute a sort of \"envelope\" of the final object, use the fragment shader to properly discard pixels that are beyond the boundaries of the final object, and compute the alpha transparency value for pixels lying on the border of the object, thereby implementing antialiasing directly on the GPU. For example, to render a thick line, one must triangulate the path, taking care of regions of high curvature and other details. On each triangle, the fragment shader computes the exact position along the path, and the distance to the border of the path. The alpha transparency value is obtained via a so-called signed distance function (a function of space giving the distance, in pixels, to the border of the object). A similar principle is used for markers and text. For text, signed distance functions of each glyph are stored in a texture and used by the fragment shader. In Datoviz, high-quality antialiased 2D graphics are implemented with GLSL code originally written by Nicolas Rougier in his Glumpy library (GPU implementation of agg , antigrain geometry), and published in computer graphics articles . A fundamental principle of Datoviz is to abstract away these low-level details to the user, who can reuse directly these existing graphics for the most common types of scientific visualizations .","title":"2D rendering"},{"location":"discussions/vulkan/#vulkan-for-scientific-visualization","text":"We've now seen the basic principles of using the GPU for scientific visualization. Let's turn now to Vulkan. Vulkan is a low-level graphics API that has a high entry barrier given the large number of abstractions provided. These abstractions mostly relate to internal details of GPU hardware, but they are essential when one focuses on achieving high performance, which is the main selling point of Datoviz. Here is, for your information only, the ~30 types of objects used in Vulkan: Diagram by Adam Sawicki, for gpuopen Covering all of these objects in detail is totally out of scope of this page. However, we'll briefly explain the most important objects, and how they are used in Datoviz. Importantly, Datoviz implements its own thin wrapper on top of Vulkan (called vklite), which focuses on the most important concepts only. The wrapper provides an API that is easier to use than the original Vulkan API, although it it slightly less flexible. This is acceptable given that the wrapper targets scientific applications, which are less demanding than 3D video games. We'll classify these objects in five broad categories: storing data on the GPU, defining graphics and compute pipelines with shaders, recording graphics and compute commands for the GPU, running the main rendering loop , synchronization .","title":"Vulkan for scientific visualization"},{"location":"discussions/vulkan/#storing-data-on-the-gpu","text":"Scientific data is typically obtained from files, from the network, or generated by simulation programs. In order for the GPU to render it, it needs to be uploaded to the GPU. A GPU typically has dedicated video memory, or shares memory with the host. For example, the NVIDIA GEFORCE RTX 2070 SUPER GPU has 8 GB of video memory. In any case, Vulkan defines several objects to control how memory is organized and how the data is stored in video memory. Datoviz has a very simple model where there are only two types of memory: GPU buffers : a GPU buffer is a memory buffer of a given size, that contains arbitrary binary bytes, GPU textures : a GPU texture is defined by a 1D, 2D, or 3D image of a given shape, by an internally-handled memory buffer with the pixel data in a given format, and a sampler which is a special GPU object that specifies how a texel is accessed and interpolated when fetched by the fragment shader. A GPU buffer abstracts away the following Vulkan objects: Buffer, BufferView. A GPU texture abstracts away the following Vulkan objects: Image, ImageView, Sampler. Uploading data from the host memory to a GPU buffer or texture, and downloading data from the GPU back to the host, are complex operations in Vulkan. Again, Datoviz abstracts these processes away in the transfer API. Note A GPU image may be represented in several ways by the GPU. For example, a texture needs to be stored in a special way in order to achieve high performance, but this internal representation is incompatible with the way the image is typically stored in a file or on the host. Vulkan provides an API to transition the image between these different formats. Uploading an image to the GPU therefore involves transitioning the image from whatever format the GPU has chosen, to a standard linear layout that matches the data uploaded from the CPU. These details are abstracted away in Datoviz.","title":"Storing data on the GPU"},{"location":"discussions/vulkan/#defining-pipeline-with-shaders","text":"Datoviz supports two types of pipelines: graphics pipelines (or just graphics ): for rendering points, lines, or triangles with dedicated vertex and fragment shaders, compute pipelines (or just computes ): for general-purpose GPU computations. A graphics pipeline encompasses many steps. The diagram below exposes the most important steps, and is shown for your information only: Schematic from vulkan-tutorial.com In addition to defining shaders, one needs to define the data input of the vertex shader. In Datoviz, a vertex shader accepts several kinds of inputs: attribute : a part of each vertex to process in parallel (for example, a vec3 position for the point being processed), uniform : small data (parameters) shared across all vertices in the pipeline, texture : a sampler giving a way to fetch any texel from a 1D, 2D, or 3D texture, storage buffer : an arbitrary binary buffer that may be accessed from any vertex thread, push constant : a small parameter that is set when recording the command buffer (see below). Uniforms, textures, storage buffers are special types of so-called Vulkan descriptors , that we could also call GPU resources : they represent essentially GPU buffers or textures. They can be accessed from the vertex shader or, actually, from any kind of shader. By contrast, the push constant is a different type of data that is passed to the GPU when recording a command buffer. An attribute is a type of data that is processed in parallel. Vulkan define several abstractions in order to define the way a shader may access descriptors (uniforms, textures, or storage buffers): descriptor set layouts, pipeline layouts, descriptor pools, descriptor sets... These abstractions mostly make sense when focusing on performance, and they are partly abstracted away in Datoviz. Datoviz proposes the following, simplified model for defining GPU resources accessible by shaders: a slot is defined in GLSL in each shader. It is represented by a resource index within the shader, and a resource type (uniform, storage, sampler). It must also be defined in the Datoviz C API, and the GLSL and C descriptions must imperatively match. a binding is an association of a given GPU object (buffer or texture) with a given slot in a given pipeline (graphics or compute). For example, a pipeline may declare that it expects a uniform at slot 0, and a texture sampler at slot 1. This is defined in the slots . Then, before one can render a pipeline, one also needs to declare what GPU buffer to use for slot 0, and what GPU texture to use for slot 1. This is defined in the bindings . Defining slots is done when creating a graphics or compute. Defining bindings is done when rendering an existing graphics or compute. Pipelines encompass the following Vulkan objects: ShaderModule, Pipeline, PipelineLayout, DescriptorPool, DescriptorSetLayout, DescriptorSet.","title":"Defining pipeline with shaders"},{"location":"discussions/vulkan/#recording-commands-for-the-gpu","text":"Once GPU objects have been created, data has been uploaded, graphics and compute pipelines have been defined, the next step is to record commands for the GPU . This aspect of Vulkan is a significant difference with older graphics APIs such as OpenGL. One does not send commands to the GPU in real time, but one pre-records a linear succession of commands within a so-called command buffer , and submits recorded command buffers to special queues . The GPU watches these queues, receives the command buffers, and processes them in parallel. In Vulkan, recording commands are special commands starting wih vkCmd . In Datoviz, they start with dvz_cmd_ . For example, rendering a single graphics pipeline involves the following recording commands: dvz_cmd_begin (...); // begin recording the command buffer dvz_cmd_begin_renderpass (...); // begin the renderpass dvz_cmd_bind_vertex_buffer (...); // bind an existing GPU buffer as vertex buffer dvz_cmd_bind_index_buffer (...); // bind an existing GPU buffer as index buffer dvz_cmd_bind_graphics (...); // bind an existing graphics pipeline dvz_cmd_viewport (...); // set the viewport dvz_cmd_draw (...); // **perform the actual rendering of the graphics pipeline** dvz_cmd_end_renderpass (...); // end the renderpass dvz_cmd_end (...); // stop recording the command buffer Once called on a command buffer, the command buffer is recorded and can be submitted to a GPU queue. Vulkan leaves to the user the choice of defining the number and types of GPU queues for the application. This is also depends heavily on the hardware. Currently, Datoviz requests four queues, but may end up with less queues if the hardware does not support them (this is all transparent to the user): a transfer queue receives command buffers for buffer/image upload, download, copy, transitions... a compute queue receives command buffers with compute tasks, a render queue receives command buffers with either graphics and/or compute tasks, a present queue is used for the main rendering loop (swapchain). Vulkan has been designed with the idea that command buffers will be constantly recreated and/or reused. Multithreaded applications can record command buffers in parallel, and must use special synchronization primitives to efficiently submit the command buffers to the GPU. Scientific applications are typically much less dynamic than video games. Still, some amount of dynamism is expected in some applications. Therefore, Datoviz assumes that command buffers are typically not recreated at every frame, but allows for relatively efficient command buffer recreation when needed. Here are the different ways the GPU objects may change during the lifetime of an application: changing buffer or texture data : update a GPU buffer or texture, doesn't require command buffer recreation, interactivity (pan and zoom, arcball, and so on): update a uniform buffer, changing the number of vertices in a given graphics pipeline: require command buffer recreation (unless using indirect rendering , in which case this involves updating a GPU buffer), push constant change : require command buffer recreation, resize , panel change , viewport change : require command buffer recreation. Datoviz command buffers and queues are based on the following Vulkan objects: CommandPool, CommandBuffer, Queue.","title":"Recording commands for the GPU"},{"location":"discussions/vulkan/#main-rendering-loop","text":"Once the command buffers have been recorded, one needs to submit them to the GPU and render the scene in a window. This step must be done manually when using the Vulkan API. Again, this is abstracted away in Datoviz, at the level of the canvas . This step is actually one of the most complex ones in Vulkan, especially when there's a need to do it as efficiently as possible. First, one considers that the window size is fixed (until it is not). Resizing is a complex operation that requires destroying and recreating a large number of Vulkan objects, and it needs to be handled correctly in the rendering loop. Second, one needs to create a GPU image (like the object that is associated to a texture, but without a sampler) that the GPU will render to. This image will be presented to the screen. One must also define another special image of the same size for the depth buffer , essential with 3D rendering. Third, one must acquire a surface , a special Vulkan object that is used to render something to the window. Creating a window is an OS-dependent operation. Datoviz uses the glfw window library that abstracts these details away and offers an easy way to create windows and to deal with user inputs (mouse, keyboard). Fourth, one needs to create a swapchain . This object provides a way to implement a technique sometimes called double-buffering, or triple-buffering, depending on the number of images used in the swapchain. The idea is to avoid making the GPU wait while an image is being presented to the screen . For example, with a frame rate of 60 images per second, each image remains on screen during about 16 milliseconds. During this time, the GPU is not expected to render to the same image, unless it makes a copy. That's basically the idea of the swapchain: providing a set of 2, 3 or more images that are almost identical. While the image 0 is presented to the screen, the GPU can render the next frame on image 1. When it finishes, it presents image 1 to the screen, while image 0 is being rewritten for the next frame (double buffering), or while it waits until the GPU requests it. This logic must be, in part, implemented by the developer who uses the Vulkan API directly. Datoviz completely abstracts this process away. Fifth, one needs to define a render pass and a set of framebuffers . The render pass defines the way the GPU renders an image, in one or several steps. The framebuffers represent the links between the GPU images and the render pass steps. The render pass must be specified when recording a rendering command buffer. Sixth, one needs to implement the main rendering loop . This is typically an infinite loop where every iteration represents a frame. At every frame, the rendering loop performs the following (simplified) steps: Examine the user events (mouse, keyboard) that occurred in the window since the last frame, Perform the resize if the window size has changed since the last frame, Implement the scene logic (update internal variables as a function of user events and time), Perform the pending transfers (upload/download of GPU buffers/textures) that have been requested since last frame, possibly from a background thread, Optionally, record new command buffers, Acquire a new swapchain image for rendering, Wait until the previous frame that was using the same swapchain image (might be 2 or 3 frames before) has finished rendering, Submit the command buffers to their associated GPU queues, which will render the image, Present the image to the screen, but only after the GPU has finished rendering it (asynchronous operation). This logic is essentially implemented in: dvz_canvas_frame() dvz_canvas_frame_submit() dvz_app_run() The rendering loop involves the following Vulkan objects: SurfaceKHR, SwapchainKHR, Image, ImageView, RenderPass, Framebuffer.","title":"Main rendering loop"},{"location":"discussions/vulkan/#synchronization","text":"The last important topic pertains to synchronization . The GPU should be seen as a partly independent device on which tasks are submitted asynchronously (via command buffers and queues), and that processes them in parallel. In addition, each task may involve a massively parallel architecture (for example, processing thousands of vertices or fragments in parallel). Vulkan provides an API to let the CPU communicate with the GPU. A highly inefficient way would be for the CPU to wait until the GPU is idle before submitting new tasks or uploading data. This would be done via \"hard\" synchronization primitives that are implemented in the Vulkan functions vkQueueWaitIdle() and vkDeviceWaitIdle() , and in the dvz_queue|gpu|app_wait() functions in Datoviz. Doing it this way would work and would not require any other more fine-grained synchronization primitive, but it would result in poor performance. Vulkan provides several more fine-grained synchronization primitives, of which Datoviz currently supports three: Inner command buffer synchronization , provided by barriers, GPU-GPU synchronization , provided by semaphores. CPU-GPU synchronization , provided by fences, A barrier is a way for a command buffer to let the GPU know that some recorded commands should wait for completion of other commands. For example, if a command buffer involves launching a compute shader on a buffer, then rendering to a graphics pipeline, a barrier should be defined if ever the graphics pipeline uses the same buffer as used by the compute shader. The graphics pipeline should not start reading a buffer while the same buffer is being written to by the compute pipeline. A semaphore is a way to introduce dependencies between different submissions of command buffers. They are used in the main rendering loop and swapchain logic. When the GPU has finished rendering an image, then this image should be presented to the screen. This is implemented with a semaphore. A fence is a way for the CPU to wait until the GPU has finished some task. This is also used in the main rendering loop: it wouldn't make much sense to start the current frame until the previous frame has not finished rendering (but it can start while the swapchain presents the previously rendered image to the screen). Synchronization is required when uploading data to the GPU. Since the GPU may be constantly reading from GPU buffers and textures, data should not be uploaded to these GPU objects without proper synchronization. Otherwise, the GPU might use corrupted data while rendering the scene.","title":"Synchronization"},{"location":"discussions/vulkan/#technical-details","text":"The vklite API documentation contains the documentation of all Vulkan-related functions. There is no other documentation of vklite at the moment, however you can look at the unit tests to get an idea of how to use each vklite object.","title":"Technical details"},{"location":"discussions/vulkan/#gpu-features-and-limits","text":"The DvzGpu structure contains a few fields with native Vulkan structures defining GPU capabilities and limits. We give here a few minimal values that we can reasonably expect on almost all devices (according to this Vulkan database ): Texture dimension Maximum allowed texture size (in any axis) 1D 16384 2D 16384 3D 2048","title":"GPU features and limits"},{"location":"examples/","text":"Examples gallery \u00b6 Python examples and screenshots.","title":"Overview"},{"location":"examples/#examples-gallery","text":"Python examples and screenshots.","title":"Examples gallery"},{"location":"examples/brain/","text":"3D brain mesh \u00b6 This example shows how to render a 3D mesh of a brain obtained from the nilearn library . There is also a slider controlling the lighting parameters. # from `bindings/cython/examples/brain.py` # Imports. import numpy as np from datoviz import canvas , run , colormap , enable_ipython try : from nilearn import datasets from nilearn.surface import load_surf_data , load_surf_mesh , vol_to_surf from nilearn import plotting except ImportError : raise ImportError ( \"You need to install nilearn to run this example\" ) # Data loading # ---------------------------------------------------------------------------- # We get the data. fsaverage = datasets . fetch_surf_fsaverage () # Left hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_left' ]) coords , faces = mesh [ 0 ], mesh [ 1 ] bg_data = load_surf_data ( fsaverage [ 'sulc_left' ]) # Right hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_right' ]) coords2 , faces2 = mesh [ 0 ], mesh [ 1 ] bg_data2 = load_surf_data ( fsaverage [ 'sulc_right' ]) # Concatenate. coords = np . vstack (( coords , coords2 )) faces = np . vstack (( faces , faces2 + faces . max () + 1 )) bg_data = np . concatenate (( bg_data , bg_data2 )) # Depth background data. bg_data = ( bg_data - bg_data . min ()) / ( bg_data . max () - bg_data . min ()) N = bg_data . shape [ 0 ] # HACK: uv tex coords to fetch the right colormap value. To be improved cmap = 0 uv = np . c_ [ bg_data , np . ones ( N ) * cmap / 256.0 + . 5 / 256.0 ] # Datoviz rendering # ---------------------------------------------------------------------------- # We create a canvas. c = canvas ( show_fps = False , width = 1024 , height = 768 ) # We create an arcball panel. panel = c . scene () . panel ( controller = 'arcball' ) # We add a mesh visual. visual = panel . visual ( 'mesh' , transform = 'auto' ) # We set the data. visual . data ( 'pos' , coords ) visual . data ( 'texcoords' , uv ) visual . data ( 'index' , faces . ravel ()) # Light parameters light_params = np . zeros (( 4 , 4 )) # up to 4 lights # ambient, diffuse, specular, specular exponent light_params [ 0 , :] = ( . 4 , . 4 , . 2 , 64 ) visual . data ( 'light_params' , light_params ) # We create a GUI. gui = c . gui ( \"GUI\" ) # We add a slider to change the lighting parameters. slider = gui . control ( \"slider_float\" , \"glossy\" , value =. 2 , vmin = 0 , vmax = 1 ) @slider . connect def on_change ( value ): light_params [ 0 , 2 ] = value # first light, third parameter is specular component visual . data ( 'light_params' , light_params ) # We run the app. run ()","title":"3D brain mesh"},{"location":"examples/brain/#3d-brain-mesh","text":"This example shows how to render a 3D mesh of a brain obtained from the nilearn library . There is also a slider controlling the lighting parameters. # from `bindings/cython/examples/brain.py` # Imports. import numpy as np from datoviz import canvas , run , colormap , enable_ipython try : from nilearn import datasets from nilearn.surface import load_surf_data , load_surf_mesh , vol_to_surf from nilearn import plotting except ImportError : raise ImportError ( \"You need to install nilearn to run this example\" ) # Data loading # ---------------------------------------------------------------------------- # We get the data. fsaverage = datasets . fetch_surf_fsaverage () # Left hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_left' ]) coords , faces = mesh [ 0 ], mesh [ 1 ] bg_data = load_surf_data ( fsaverage [ 'sulc_left' ]) # Right hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_right' ]) coords2 , faces2 = mesh [ 0 ], mesh [ 1 ] bg_data2 = load_surf_data ( fsaverage [ 'sulc_right' ]) # Concatenate. coords = np . vstack (( coords , coords2 )) faces = np . vstack (( faces , faces2 + faces . max () + 1 )) bg_data = np . concatenate (( bg_data , bg_data2 )) # Depth background data. bg_data = ( bg_data - bg_data . min ()) / ( bg_data . max () - bg_data . min ()) N = bg_data . shape [ 0 ] # HACK: uv tex coords to fetch the right colormap value. To be improved cmap = 0 uv = np . c_ [ bg_data , np . ones ( N ) * cmap / 256.0 + . 5 / 256.0 ] # Datoviz rendering # ---------------------------------------------------------------------------- # We create a canvas. c = canvas ( show_fps = False , width = 1024 , height = 768 ) # We create an arcball panel. panel = c . scene () . panel ( controller = 'arcball' ) # We add a mesh visual. visual = panel . visual ( 'mesh' , transform = 'auto' ) # We set the data. visual . data ( 'pos' , coords ) visual . data ( 'texcoords' , uv ) visual . data ( 'index' , faces . ravel ()) # Light parameters light_params = np . zeros (( 4 , 4 )) # up to 4 lights # ambient, diffuse, specular, specular exponent light_params [ 0 , :] = ( . 4 , . 4 , . 2 , 64 ) visual . data ( 'light_params' , light_params ) # We create a GUI. gui = c . gui ( \"GUI\" ) # We add a slider to change the lighting parameters. slider = gui . control ( \"slider_float\" , \"glossy\" , value =. 2 , vmin = 0 , vmax = 1 ) @slider . connect def on_change ( value ): light_params [ 0 , 2 ] = value # first light, third parameter is specular component visual . data ( 'light_params' , light_params ) # We run the app. run ()","title":"3D brain mesh"},{"location":"examples/colormap/","text":"Custom colormap \u00b6 This example shows how to create and use a custom colormap. # from `bindings/cython/examples/colormap.py` import numpy as np import numpy.random as nr from datoviz import app , canvas , run , colormap # Create the canvas, panel, and visual. c = canvas ( show_fps = True ) ctx = c . gpu () . context () panel = c . scene () . panel ( controller = 'panzoom' ) visual = panel . visual ( 'path' , transform = None ) # Uniform parameters for the visual. visual . data ( 'linewidth' , np . array ([ 50 ])) visual . data ( 'cap_type' , np . array ([ 0 ])) # Create a horizontal thick line. n = 256 x = np . linspace ( - 1 , 1 , n ) y = np . zeros ( n ) z = np . zeros ( n ) pos = np . c_ [ x , y , z ] # an (N, 3) array with the coordinates of the path vertices. pos [:, 1 ] -= . 25 # Create a first custom color map, ranging from red to green. cmap = np . c_ [ np . arange ( 256 ), np . arange ( 256 )[:: - 1 ], np . zeros ( 256 ), 255 * np . ones ( 256 )] ctx . colormap ( 'mycmap0' , cmap . astype ( np . uint8 )) # Add a first line. visual . data ( 'pos' , pos ) visual . data ( 'color' , colormap ( np . linspace ( 0 , 1 , n ), cmap = 'mycmap0' )) # Create a second custom color map, ranging from green to blue. cmap = np . c_ [ np . zeros ( 256 ), np . arange ( 256 ), np . arange ( 256 )[:: - 1 ], 255 * np . ones ( 256 )] ctx . colormap ( 'mycmap1' , cmap . astype ( np . uint8 )) # Add a second line. pos [:, 1 ] += . 5 # NOTE: note the use of the .append() method here, to concatenate the array to the existing data. visual . append ( 'pos' , pos ) visual . append ( 'color' , colormap ( np . linspace ( 0 , 1 , n ), cmap = 'mycmap1' )) # Set the length of each path. visual . data ( 'length' , np . array ([ n , n ])) # Start the event loop. run ()","title":"Custom colormap"},{"location":"examples/colormap/#custom-colormap","text":"This example shows how to create and use a custom colormap. # from `bindings/cython/examples/colormap.py` import numpy as np import numpy.random as nr from datoviz import app , canvas , run , colormap # Create the canvas, panel, and visual. c = canvas ( show_fps = True ) ctx = c . gpu () . context () panel = c . scene () . panel ( controller = 'panzoom' ) visual = panel . visual ( 'path' , transform = None ) # Uniform parameters for the visual. visual . data ( 'linewidth' , np . array ([ 50 ])) visual . data ( 'cap_type' , np . array ([ 0 ])) # Create a horizontal thick line. n = 256 x = np . linspace ( - 1 , 1 , n ) y = np . zeros ( n ) z = np . zeros ( n ) pos = np . c_ [ x , y , z ] # an (N, 3) array with the coordinates of the path vertices. pos [:, 1 ] -= . 25 # Create a first custom color map, ranging from red to green. cmap = np . c_ [ np . arange ( 256 ), np . arange ( 256 )[:: - 1 ], np . zeros ( 256 ), 255 * np . ones ( 256 )] ctx . colormap ( 'mycmap0' , cmap . astype ( np . uint8 )) # Add a first line. visual . data ( 'pos' , pos ) visual . data ( 'color' , colormap ( np . linspace ( 0 , 1 , n ), cmap = 'mycmap0' )) # Create a second custom color map, ranging from green to blue. cmap = np . c_ [ np . zeros ( 256 ), np . arange ( 256 ), np . arange ( 256 )[:: - 1 ], 255 * np . ones ( 256 )] ctx . colormap ( 'mycmap1' , cmap . astype ( np . uint8 )) # Add a second line. pos [:, 1 ] += . 5 # NOTE: note the use of the .append() method here, to concatenate the array to the existing data. visual . append ( 'pos' , pos ) visual . append ( 'color' , colormap ( np . linspace ( 0 , 1 , n ), cmap = 'mycmap1' )) # Set the length of each path. visual . data ( 'length' , np . array ([ n , n ])) # Start the event loop. run ()","title":"Custom colormap"},{"location":"examples/eventloop/","text":"Asynchronous event loop \u00b6 This example shows how to make asynchronous updates to the data by using the asyncio event loop. Here, the event loop runs in Python instead of C (the default). Asynchronous HTTP requests can be done via the the aiohttp library. HTTP requests are done asynchronously and do not block the UI. Once the response is ready, we update the visual's data. # from `bindings/cython/examples/eventloop.py` import asyncio import json from pathlib import Path import aiohttp import numpy as np import numpy.random as nr from datoviz import app , canvas , run , colormap , do_async async def make_request ( url ): \"\"\"Make an asynchronous HTTP GET request and return the response as text.\"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url ) as response : return ( await response . text ()) def update_data ( N = 10_000 ): \"\"\"Update the visual's data with a given number of points.\"\"\" pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 35 , size = N ) color_values = nr . rand ( N ) color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = 'viridis' ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) # Make the canvas and visual. c = canvas ( show_fps = True ) panel = c . scene () . panel ( controller = 'axes' ) visual = panel . visual ( 'marker' ) update_data () async def update (): \"\"\"This callback function is called asynchronously when clicking on a button. It makes an asynchronous HTTP GET request to a website generating random numbers. When the reply is ready, we update the visual with the returned number of points. \"\"\" print ( \"Making HTTP request to get random number...\" ) text = await make_request ( 'https://random-data-api.com/api/number/random_number' ) n = int ( json . loads ( text )[ 'positive' ]) print ( f \"Show { n } points\" ) update_data ( n ) # GUI gui = c . gui ( \"Test GUI\" ) button = gui . control ( \"button\" , \"update the visual\" ) @button . connect def on_change ( value ): # The special do_async() function, provided by datoviz, takes an asynchronous task and runs it # in the asyncio event loop. do_async ( update ()) # Start the asyncio event loop. run ( event_loop = 'asyncio' )","title":"Async event loop"},{"location":"examples/eventloop/#asynchronous-event-loop","text":"This example shows how to make asynchronous updates to the data by using the asyncio event loop. Here, the event loop runs in Python instead of C (the default). Asynchronous HTTP requests can be done via the the aiohttp library. HTTP requests are done asynchronously and do not block the UI. Once the response is ready, we update the visual's data. # from `bindings/cython/examples/eventloop.py` import asyncio import json from pathlib import Path import aiohttp import numpy as np import numpy.random as nr from datoviz import app , canvas , run , colormap , do_async async def make_request ( url ): \"\"\"Make an asynchronous HTTP GET request and return the response as text.\"\"\" async with aiohttp . ClientSession () as session : async with session . get ( url ) as response : return ( await response . text ()) def update_data ( N = 10_000 ): \"\"\"Update the visual's data with a given number of points.\"\"\" pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 35 , size = N ) color_values = nr . rand ( N ) color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = 'viridis' ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) # Make the canvas and visual. c = canvas ( show_fps = True ) panel = c . scene () . panel ( controller = 'axes' ) visual = panel . visual ( 'marker' ) update_data () async def update (): \"\"\"This callback function is called asynchronously when clicking on a button. It makes an asynchronous HTTP GET request to a website generating random numbers. When the reply is ready, we update the visual with the returned number of points. \"\"\" print ( \"Making HTTP request to get random number...\" ) text = await make_request ( 'https://random-data-api.com/api/number/random_number' ) n = int ( json . loads ( text )[ 'positive' ]) print ( f \"Show { n } points\" ) update_data ( n ) # GUI gui = c . gui ( \"Test GUI\" ) button = gui . control ( \"button\" , \"update the visual\" ) @button . connect def on_change ( value ): # The special do_async() function, provided by datoviz, takes an asynchronous task and runs it # in the asyncio event loop. do_async ( update ()) # Start the asyncio event loop. run ( event_loop = 'asyncio' )","title":"Asynchronous event loop"},{"location":"examples/france/","text":"France departements \u00b6 This example shows how to display many polygons with a single visual. # from `bindings/cython/examples/france.py` # Imports. from pathlib import Path import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Path to the root git directory so as to load the polygon data. ROOT = Path ( __file__ ) . resolve () . parent . parent . parent . parent # The first file is a flat binary file with the 2D coordinates of all points. pos = np . fromfile ( ROOT / \"data/misc/departements.polypoints.bin\" , dtype = np . float64 ) pos = pos . reshape (( - 1 , 2 )) pos = np . c_ [ pos [:, 1 ], pos [:, 0 ], np . zeros ( pos . shape [ 0 ])] # latitude, longitude, 0 # We use a Web Mercator projection to convert from geographical coordinates to an # Euclidean coordinate system. # NOTE: a future version of Datoviz may provide a better method for non-linear # data transformations. lat , lon , _ = pos . T lonrad = lon / 180.0 * np . pi latrad = lat / 180.0 * np . pi zoom = 1 c = 256 / 2 * np . pi * 2 ** zoom x = c * ( lonrad + np . pi ) y = - c * ( np . pi - np . log ( np . tan ( np . pi / 4.0 + latrad / 2.0 ))) pos = np . c_ [ x , y , _ ] # The second file contains the length of each polygon. length = np . fromfile ( ROOT / \"data/misc/departements.polylengths.bin\" , dtype = np . uint32 ) # We make the polygon colors, with one value per polygon. N = len ( length ) # this is the number of polygons color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , cmap = 'viridis' ) # We create a canvas, a scene, and a panel. c = canvas ( width = 650 , height = 600 , show_fps = False ) panel = c . scene () . panel ( controller = 'panzoom' ) # We add a polygon visual. visual = panel . visual ( 'polygon' ) # We pass the point positions, the colors, and crucially, the length of each polygon that # is used for batch rendering. visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'length' , length ) # We run the vent loop. run ()","title":"France departements"},{"location":"examples/france/#france-departements","text":"This example shows how to display many polygons with a single visual. # from `bindings/cython/examples/france.py` # Imports. from pathlib import Path import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Path to the root git directory so as to load the polygon data. ROOT = Path ( __file__ ) . resolve () . parent . parent . parent . parent # The first file is a flat binary file with the 2D coordinates of all points. pos = np . fromfile ( ROOT / \"data/misc/departements.polypoints.bin\" , dtype = np . float64 ) pos = pos . reshape (( - 1 , 2 )) pos = np . c_ [ pos [:, 1 ], pos [:, 0 ], np . zeros ( pos . shape [ 0 ])] # latitude, longitude, 0 # We use a Web Mercator projection to convert from geographical coordinates to an # Euclidean coordinate system. # NOTE: a future version of Datoviz may provide a better method for non-linear # data transformations. lat , lon , _ = pos . T lonrad = lon / 180.0 * np . pi latrad = lat / 180.0 * np . pi zoom = 1 c = 256 / 2 * np . pi * 2 ** zoom x = c * ( lonrad + np . pi ) y = - c * ( np . pi - np . log ( np . tan ( np . pi / 4.0 + latrad / 2.0 ))) pos = np . c_ [ x , y , _ ] # The second file contains the length of each polygon. length = np . fromfile ( ROOT / \"data/misc/departements.polylengths.bin\" , dtype = np . uint32 ) # We make the polygon colors, with one value per polygon. N = len ( length ) # this is the number of polygons color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , cmap = 'viridis' ) # We create a canvas, a scene, and a panel. c = canvas ( width = 650 , height = 600 , show_fps = False ) panel = c . scene () . panel ( controller = 'panzoom' ) # We add a polygon visual. visual = panel . visual ( 'polygon' ) # We pass the point positions, the colors, and crucially, the length of each polygon that # is used for batch rendering. visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'length' , length ) # We run the vent loop. run ()","title":"France departements"},{"location":"examples/image/","text":"Image blending \u00b6 This example shows how to display two superimposed images, with simple blending done on the GPU, and a slider controlling the blending parameter. # from `bindings/cython/examples/image.py` # Imports from pathlib import Path import numpy as np import numpy.random as nr import imageio from datoviz import app , canvas , run , colormap # Path to the root git directory so as to load the images. ROOT = Path ( __file__ ) . resolve () . parent . parent . parent . parent def load_image ( path ): \"\"\"This function loads an image with imageio, and uploads it to a new GPU texture.\"\"\" img = imageio . imread ( path ) img = np . dstack (( img , 255 * np . ones ( img . shape [: 2 ]))) img = img . astype ( np . uint8 ) tex = app () . gpu () . context () . texture ( img . shape [ 0 ], img . shape [ 1 ]) tex . set_filter ( 'linear' ) tex . upload ( img ) return tex # Create the canvas, panel, and visual. c = canvas ( show_fps = True ) panel = c . scene () . panel ( controller = 'panzoom' ) visual = panel . visual ( 'image' ) # Top left, top right, bottom right, bottom left visual . data ( 'pos' , np . array ([[ - 1 , + 1 , 0 ]]), idx = 0 ) visual . data ( 'pos' , np . array ([[ + 1 , + 1 , 0 ]]), idx = 1 ) visual . data ( 'pos' , np . array ([[ + 1 , - 1 , 0 ]]), idx = 2 ) visual . data ( 'pos' , np . array ([[ - 1 , - 1 , 0 ]]), idx = 3 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 0 ]), idx = 0 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 0 ]), idx = 1 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 1 ]), idx = 2 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 1 ]), idx = 3 ) # First texture. tex0 = load_image ( ROOT / 'data/textures/earth.jpg' ) visual . texture ( tex0 , idx = 0 ) # set the first texture slot of the image visual # Second texture. tex1 = load_image ( ROOT / 'data/textures/landscape.jpg' ) visual . texture ( tex1 , idx = 1 ) # set the second texture slot of the image visual # Initial blending value. value = . 25 visual . data ( 'texcoefs' , np . array ([ 1 - value , value , 0 , 0 ])) # Control the blending via a GUI. gui = c . gui ( \"GUI\" ) slider = gui . control ( \"slider_float\" , \"GPU blending\" , value = value , vmin = 0 , vmax = 1 ) @slider . connect def on_change ( value ): # Convex combination of the two images. visual . data ( 'texcoefs' , np . array ([ 1 - value , value , 0 , 0 ])) run ()","title":"Image blending"},{"location":"examples/image/#image-blending","text":"This example shows how to display two superimposed images, with simple blending done on the GPU, and a slider controlling the blending parameter. # from `bindings/cython/examples/image.py` # Imports from pathlib import Path import numpy as np import numpy.random as nr import imageio from datoviz import app , canvas , run , colormap # Path to the root git directory so as to load the images. ROOT = Path ( __file__ ) . resolve () . parent . parent . parent . parent def load_image ( path ): \"\"\"This function loads an image with imageio, and uploads it to a new GPU texture.\"\"\" img = imageio . imread ( path ) img = np . dstack (( img , 255 * np . ones ( img . shape [: 2 ]))) img = img . astype ( np . uint8 ) tex = app () . gpu () . context () . texture ( img . shape [ 0 ], img . shape [ 1 ]) tex . set_filter ( 'linear' ) tex . upload ( img ) return tex # Create the canvas, panel, and visual. c = canvas ( show_fps = True ) panel = c . scene () . panel ( controller = 'panzoom' ) visual = panel . visual ( 'image' ) # Top left, top right, bottom right, bottom left visual . data ( 'pos' , np . array ([[ - 1 , + 1 , 0 ]]), idx = 0 ) visual . data ( 'pos' , np . array ([[ + 1 , + 1 , 0 ]]), idx = 1 ) visual . data ( 'pos' , np . array ([[ + 1 , - 1 , 0 ]]), idx = 2 ) visual . data ( 'pos' , np . array ([[ - 1 , - 1 , 0 ]]), idx = 3 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 0 ]), idx = 0 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 0 ]), idx = 1 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 1 ]), idx = 2 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 1 ]), idx = 3 ) # First texture. tex0 = load_image ( ROOT / 'data/textures/earth.jpg' ) visual . texture ( tex0 , idx = 0 ) # set the first texture slot of the image visual # Second texture. tex1 = load_image ( ROOT / 'data/textures/landscape.jpg' ) visual . texture ( tex1 , idx = 1 ) # set the second texture slot of the image visual # Initial blending value. value = . 25 visual . data ( 'texcoefs' , np . array ([ 1 - value , value , 0 , 0 ])) # Control the blending via a GUI. gui = c . gui ( \"GUI\" ) slider = gui . control ( \"slider_float\" , \"GPU blending\" , value = value , vmin = 0 , vmax = 1 ) @slider . connect def on_change ( value ): # Convex combination of the two images. visual . data ( 'texcoefs' , np . array ([ 1 - value , value , 0 , 0 ])) run ()","title":"Image blending"},{"location":"examples/quickstart/","text":"Quickstart tutorial with Python \u00b6 # from `bindings/cython/examples/quickstart.py` # Imports. import time import numpy as np import numpy.random as nr # Import the library. from datoviz import canvas , run , colormap # Create a new canvas. c = canvas ( show_fps = True ) # Create a scene, which provides plotting capabilities and allows to organize the canvas into a # grid of subplots. By default there is only a single panel spanning the whole canvas. s = c . scene () # We create a panel with 2D axes. panel = s . panel ( controller = 'axes' ) # We create a new \"marker\" visual. visual = panel . visual ( 'marker' ) # We prepare the visual properties. Here, we set the marker positions, colors (RGBA bytes), # and size (in pixels). N = 10_000 pos = nr . randn ( N , 3 ) # (N, 3) array ms = nr . uniform ( low = 2 , high = 35 , size = N ) # (N,) array # We use a built-in colormap color_values = nr . rand ( N ) alpha = . 75 * np . ones ( N ) # (N, 4) array of uint8 color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha = alpha , cmap = 'viridis' ) # We set the visual props. visual . data ( 'pos' , pos ) visual . data ( 'ms' , ms ) visual . data ( 'color' , color ) # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = s . panel_at ( x , y ) if not p : return # Then, we transform the mouse positions into the data coordinate system. # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), { '+' . join ( modifiers ) } { button } click\" ) # We create a new GUI gui = c . gui ( \"Test GUI\" ) # We add a slider controlling a floating-point value (marker size) sf = gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) # We write the Python callback function for when the slider's value changes. @sf . connect def on_change ( value ): # Every time the slider value changes, we update the visual's marker size. visual . data ( 'ms' , ms * value ) # We add a second, slider controlling an integer between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control. si = gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) # Predefined list of colormaps. cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @si . connect def on_change ( value ): # When the slider changes, we recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # We update the color visual. visual . data ( 'color' , color ) # We add a button to regenerate the marker positions. b = gui . control ( \"button\" , \"new positions\" ) @b . connect def on_change ( value ): # We update the marker positions. pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos ) # We run the main rendering loop, which will display the canvas until Escape is pressed or the # window is closed. # NOTE: there are several event loops. By default, the native datoviz event loop is used. It # is the fastest, but it doesn't allow for interactive use in IPython, and it doesn't support # asynchronous callbacks. # There are other experimental event loops: `ipython` to be used in IPython/Jupyter, and # `asyncio` which supports long-lasting I/O-bound callback functions outside of IPython. run ()","title":"Quickstart tutorial"},{"location":"examples/quickstart/#quickstart-tutorial-with-python","text":"# from `bindings/cython/examples/quickstart.py` # Imports. import time import numpy as np import numpy.random as nr # Import the library. from datoviz import canvas , run , colormap # Create a new canvas. c = canvas ( show_fps = True ) # Create a scene, which provides plotting capabilities and allows to organize the canvas into a # grid of subplots. By default there is only a single panel spanning the whole canvas. s = c . scene () # We create a panel with 2D axes. panel = s . panel ( controller = 'axes' ) # We create a new \"marker\" visual. visual = panel . visual ( 'marker' ) # We prepare the visual properties. Here, we set the marker positions, colors (RGBA bytes), # and size (in pixels). N = 10_000 pos = nr . randn ( N , 3 ) # (N, 3) array ms = nr . uniform ( low = 2 , high = 35 , size = N ) # (N,) array # We use a built-in colormap color_values = nr . rand ( N ) alpha = . 75 * np . ones ( N ) # (N, 4) array of uint8 color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha = alpha , cmap = 'viridis' ) # We set the visual props. visual . data ( 'pos' , pos ) visual . data ( 'ms' , ms ) visual . data ( 'color' , color ) # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = s . panel_at ( x , y ) if not p : return # Then, we transform the mouse positions into the data coordinate system. # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), { '+' . join ( modifiers ) } { button } click\" ) # We create a new GUI gui = c . gui ( \"Test GUI\" ) # We add a slider controlling a floating-point value (marker size) sf = gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) # We write the Python callback function for when the slider's value changes. @sf . connect def on_change ( value ): # Every time the slider value changes, we update the visual's marker size. visual . data ( 'ms' , ms * value ) # We add a second, slider controlling an integer between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control. si = gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) # Predefined list of colormaps. cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @si . connect def on_change ( value ): # When the slider changes, we recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # We update the color visual. visual . data ( 'color' , color ) # We add a button to regenerate the marker positions. b = gui . control ( \"button\" , \"new positions\" ) @b . connect def on_change ( value ): # We update the marker positions. pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos ) # We run the main rendering loop, which will display the canvas until Escape is pressed or the # window is closed. # NOTE: there are several event loops. By default, the native datoviz event loop is used. It # is the fastest, but it doesn't allow for interactive use in IPython, and it doesn't support # asynchronous callbacks. # There are other experimental event loops: `ipython` to be used in IPython/Jupyter, and # `asyncio` which supports long-lasting I/O-bound callback functions outside of IPython. run ()","title":"Quickstart tutorial with Python"},{"location":"examples/signals/","text":"Digital signals \u00b6 This example shows how to display a large number of low-quality paths with dynamic updates, similar to a real-time digital acquisition system. # from `bindings/cython/examples/signals.py` # Imports. import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Create the canvas, panel, and visual. c = canvas ( show_fps = True ) panel = c . scene () . panel ( controller = 'panzoom' ) visual = panel . visual ( 'line_strip' , transform = None ) # Parameters. n_signals = 100 n_points = 2_000 n_vert = n_signals * n_points # Create the signals data. t = np . linspace ( - 1 , 1 , n_points ) x = np . tile ( t , ( n_signals ,)) assert x . ndim == 1 coef = . 5 / n_signals y = coef * nr . randn ( n_signals , n_points ) offsets = np . tile ( np . linspace ( - 1 , + 1 , n_signals )[:, np . newaxis ], ( 1 , n_points )) y += offsets pos = np . c_ [ x , y . ravel (), np . zeros ( n_vert )] # Signal colors. color = np . repeat ( colormap ( np . linspace ( 0 , 1 , n_signals ), cmap = 'glasbey' ), n_points , axis = 0 ) # Length of each signal (batch visual). length = np . repeat ( np . array ([ n_points ]), n_signals ) assert pos . shape == ( n_vert , 3 ) assert color . shape == ( n_vert , 4 ) assert length . shape == ( n_signals ,) # Set the visual data. visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'length' , length ) # Animation function. k = 10 @c . connect def on_frame ( i ): # This function runs at every frame. i = i % ( n_points // k ) yk = coef * nr . randn ( n_signals , k ) offsets = np . tile ( np . linspace ( - 1 , + 1 , n_signals )[:, np . newaxis ], ( 1 , k )) yk += offsets y [:, i * k :( i + 1 ) * k ] = yk pos [:, 1 ] = y . ravel () visual . data ( 'pos' , pos ) run ()","title":"Digital signals"},{"location":"examples/signals/#digital-signals","text":"This example shows how to display a large number of low-quality paths with dynamic updates, similar to a real-time digital acquisition system. # from `bindings/cython/examples/signals.py` # Imports. import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Create the canvas, panel, and visual. c = canvas ( show_fps = True ) panel = c . scene () . panel ( controller = 'panzoom' ) visual = panel . visual ( 'line_strip' , transform = None ) # Parameters. n_signals = 100 n_points = 2_000 n_vert = n_signals * n_points # Create the signals data. t = np . linspace ( - 1 , 1 , n_points ) x = np . tile ( t , ( n_signals ,)) assert x . ndim == 1 coef = . 5 / n_signals y = coef * nr . randn ( n_signals , n_points ) offsets = np . tile ( np . linspace ( - 1 , + 1 , n_signals )[:, np . newaxis ], ( 1 , n_points )) y += offsets pos = np . c_ [ x , y . ravel (), np . zeros ( n_vert )] # Signal colors. color = np . repeat ( colormap ( np . linspace ( 0 , 1 , n_signals ), cmap = 'glasbey' ), n_points , axis = 0 ) # Length of each signal (batch visual). length = np . repeat ( np . array ([ n_points ]), n_signals ) assert pos . shape == ( n_vert , 3 ) assert color . shape == ( n_vert , 4 ) assert length . shape == ( n_signals ,) # Set the visual data. visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'length' , length ) # Animation function. k = 10 @c . connect def on_frame ( i ): # This function runs at every frame. i = i % ( n_points // k ) yk = coef * nr . randn ( n_signals , k ) offsets = np . tile ( np . linspace ( - 1 , + 1 , n_signals )[:, np . newaxis ], ( 1 , k )) yk += offsets y [:, i * k :( i + 1 ) * k ] = yk pos [:, 1 ] = y . ravel () visual . data ( 'pos' , pos ) run ()","title":"Digital signals"},{"location":"examples/twopanels/","text":"Two panels \u00b6 This example shows how to display two different panels (2D and 3D) with different controllers side to side. # from `bindings/cython/examples/twopanels.py` # Imports. import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Data. N = 50_000 pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 40 , size = N ) color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 ) # We create a canvas. c = canvas ( show_fps = True ) # We create a scene with one row and two columns. s = c . scene ( 1 , 2 ) # We add the two panels with different controllers. panel0 = s . panel ( 0 , 0 , controller = 'axes' ) panel1 = s . panel ( 0 , 1 , controller = 'arcball' ) # We create a visual in each panel. visual = panel0 . visual ( 'point' ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , np . array ([ 10 ])) visual1 = panel1 . visual ( 'point' , depth_test = True ) visual1 . data ( 'pos' , pos ) visual1 . data ( 'color' , color ) # Start the event loop. run ()","title":"Two panels"},{"location":"examples/twopanels/#two-panels","text":"This example shows how to display two different panels (2D and 3D) with different controllers side to side. # from `bindings/cython/examples/twopanels.py` # Imports. import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap # Data. N = 50_000 pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 40 , size = N ) color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 ) # We create a canvas. c = canvas ( show_fps = True ) # We create a scene with one row and two columns. s = c . scene ( 1 , 2 ) # We add the two panels with different controllers. panel0 = s . panel ( 0 , 0 , controller = 'axes' ) panel1 = s . panel ( 0 , 1 , controller = 'arcball' ) # We create a visual in each panel. visual = panel0 . visual ( 'point' ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , np . array ([ 10 ])) visual1 = panel1 . visual ( 'point' , depth_test = True ) visual1 . data ( 'pos' , pos ) visual1 . data ( 'color' , color ) # Start the event loop. run ()","title":"Two panels"},{"location":"howto/","text":"How to guides \u00b6 This section provides step-by-step how-to guides for intermediate to advanced users. Standalone C apps \u00b6 How to use the scene C API to create a standalone C app. How to use the canvas C API to create custom applications without using the scene API. How to use the vklite C API to create offscreen/compute applications that only use vklite, a thin Vulkan wrapper. How to use Dear ImGui directly in a C++ application . Custom visuals and graphics \u00b6 How to write a custom visual in C, without writing custom shaders. How to write a custom graphics in C and GLSL, by writing custom shaders .","title":"Index"},{"location":"howto/#how-to-guides","text":"This section provides step-by-step how-to guides for intermediate to advanced users.","title":"How to guides"},{"location":"howto/#standalone-c-apps","text":"How to use the scene C API to create a standalone C app. How to use the canvas C API to create custom applications without using the scene API. How to use the vklite C API to create offscreen/compute applications that only use vklite, a thin Vulkan wrapper. How to use Dear ImGui directly in a C++ application .","title":"Standalone C apps"},{"location":"howto/#custom-visuals-and-graphics","text":"How to write a custom visual in C, without writing custom shaders. How to write a custom graphics in C and GLSL, by writing custom shaders .","title":"Custom visuals and graphics"},{"location":"howto/graphics/","text":"How to write a custom graphics \u00b6 Warning You need to go through the Vulkan crash course before following this guide. You also need to go through the how to write a custom visual guide first. In this section, we'll show how to create a custom graphics by writing custom GLSL shaders . This is an advanced topic as it requires understanding the basic of GPU graphics programming. Note Only the C API supports custom graphics at the moment. Python bindings for custom graphics will come in an upcoming version. Datoviz already includes the code necessary to compile GLSL shaders to SPIR-V on the fly (based on Khronos glslang ). The full source code for this example can be found in examples/custom_graphics.c . As a toy example, we'll create a graphics with square points of various size and color . Specifically, we'll require each point to have a different size (which is not supported in the existing point graphics), and a color depending directly on the size and computed directly on the GPU. We'll use a single byte per vertex to store the vertex size (between 0 and 255 pixels), and we'll use no memory for the color since it will be determined directly by this value. This kind of memory optimization is one of the use-cases of writing custom graphics. Limiting memory usage is important when dealing with extremely large datasets (tens or hundreds of millions of points). Writing a custom graphics involves the following steps: Choosing the primitive type. Defining the vertex data structure and corresponding vertex shader attributes. Writing the vertex shader. Writing the fragment shader. Compiling the GLSL shaders to SPIR-V (may be done automatically in the future). Writing the custom graphics. Writing the custom visual. Writing a simple test. Note Here, we show how to create a custom graphics compatible with the scene API, so that it can be used added to the scene the same way as builtin visuals. One could however decide not to use the scene API at all, and leverage instead the vklite API directly. This allows one to create entirely custom and standalone applications. This is not documented at the moment, and one should look at the vklite unit tests to understand how to use the vklite API directly. Choosing the graphics primitive type \u00b6 Vulkan supports six major types of primitives: point list : square points with an arbitrary size, line list : disjoint aliased line segments, line strip : joined aliased line segments, triangle strip : joined triangles consecutively sharing an edge, triangle fan : joined triangles all sharing a single corner (the first vertex), triangle list : disjoint triangles, Other less common primitive types are described in the Vulkan specification . Warning Triangle fans are not supported on macOS. Schematic from the Vulkan Cookbook by Pawel Lapinski, O'Reilly Note The circular arrows in the triangles above indicate the orientation of the triangles, which is taken into account by the GPU. It is good practice to always ensure that all triangles constituting a given object are consistent. For example, when triangulating a square with two triangles, the order of the vertices should be chosen such that both triangles are directly oriented. The graphics pipeline can be configured to handle triangle orientation in a specific way. For example, one can make a graphics pipeline where indirectly oriented triangles are automatically discarded. Line primitives typically have a width of 1 pixel, although some hardware supports thicker lines. In Datoviz, thick, high-quality lines are implemented with triangles instead (line triangulation), and the antialiased thick line is drawn directly in the fragment shader. \"Basic\" line primitives are only used for testing and for special high-performance applications where scalability and performance are more important than visual quality. The most commonly-used primitive types in scientific visualization are essentially point lists and triangle lists (and to a lesser extent, triangle strips). In this example, we'll use a point list , where each point will correspond to one square. Defining the vertex data structure \u00b6 Once we know we'll use a point list as a primitive, the next step is to define the vertex data structure / vertex shader attributes. Here, we want the following attributes for each vertex: the point position (center of the square), as a vec3 , the point size (edge length of the square, in pixels), as an uint8_t . The point size will be limited to a maximum of 255 pixels in this toy example. We could have simply used a floating-point for the edge length, but that would have used four bytes instead of one. This is also to show the versatility of Vulkan and GPU programming, where we have full control on the data types used on both the GPU and CPU. Here is our vertex C structure: // We define the vertex structure for our graphics pipeline. typedef struct { vec3 pos ; // 3D point position uint8_t size ; // point size, in pixels, between 0 and 255. } PointVertex ; We also need to define the attributes in GLSL: layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0 Attribute format \u00b6 In this example, we use a uint8_t (byte) on the CPU, but a float on the GPU. Vulkan provides a way to specify the way we want to do the casting . This is done when creating the graphics pipeline below. We can just say here that we'll use the Vulkan format VK_FORMAT_R8_USCALED . This format means that: Number of components . There is a single component (scalar), the R in R8 means \"red\" component: this is the component used for scalar values. If using a pair of components, we would have both a R and G component (green). This naming convention using color names comes from the fact that these GPU formats are typically used to represent colors, but they can actually represent any type of numerical data. Number of bits per component . The 8 in R8 means that our red component is represented with 8 bits. Signedness . The U in USCALED means that we use an unsigned format. Scaling . The SCALED means that the byte, a number between 0 and 255, will be converted to a float without normalization: 255 becomes 255.0. Here are the other common scaling options provided by Vulkan when using bytes: Scaling GPU number type Range UNORM float [0.0, 1.0] SNORM float [-1.0, 1.0] USCALED float [0.0, 255.0] SSCALED float [-128.0, +127.0] (?) UINT int [0, 255] SINT int [-128, 127] (?) You'll find more information here: Full list of formats in the Vulkan spec , Hardware support of the formats : some formats are not supported by all existing GPUs. This website is quite useful to know what formats have the best hardware support. Writing the vertex shader \u00b6 We're now ready to write the vertex shader. Here is the full source code of the vertex shader: // code from `examples/glsl/custom_point.vert`: // GLSL version #version 450 // To be compatible with the scene API, all graphics shaders must include a common GLSL include // file. It defines common uniform bindings and common functions (for example, transform()). // These .glsl files are found in `include/datoviz/glsl`, so one needs to pass // `-Ipath/to/datoviz/include/datoviz/glsl` to the `glslc` command (see build.sh script). #include \"common.glsl\" // Here, we also use GLSL colormaps to compute the square color directly in the vertex shader, // without using the colormap texture. #include \"colormaps.glsl\" // Here, we describe the vertex shader attributes. layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0 // We made the unusual choice here to use a float in the shader, which corresponds to a uint8 byte // in C. We also decided not to normalize it, i.e. that the byte 255 corresponds to the float 255.0 // in the shader (VK_FORMAT_R8_USCALED format). Other choices can be made when specifying the // attribute format in the custom graphics definition. // Here, we describe the \"varying\" variables. These are special values output by the vertex shader, // and passed to the fragment shader. layout ( location = 0 ) out vec4 out_color ; // Main shader code. void main () { // Here, \"pos\" is the position of the vertex being processed. gl_Position is a special output // variable that returns the vertex final position in normalized device coordinates. It // is a vec4 vector, the fourth component is the homogeneous coordinate. // The \"transform()\" function is defined in common.glsl. It applies the model, view, proj // matrices stored in the first (common) uniform buffer (MVP buffer). gl_Position = transform ( pos ); // This special variable is an output variable that contains the point size, in pixels, // of the vertex being processed. It is reserved to graphics pipelines with a point list // primitive. gl_PointSize = size ; // Here, we set the varying variable that will be passed to the fragment shader. // The function colormap() is implemented in colormaps.glsl. It supports a few colormaps // that are implemented directly in GLSL, without using a texture. The second argument // is a value between 0 and 1, hence the normalization with the size which is in pixels. out_color = colormap ( DVZ_CMAP_HSV , size / 255.0 ); out_color . a = .25 ; // alpha component for some transparency } A few comments can be found below. Common shader resources \u00b6 The #include directive is provided for convenience by the GLSL to SPIR-V compiler glslc . It is used extensively in Datoviz. It provides a simple way of making all graphics shaders share some functions and resources. In particular, we make the convention that, in order to be compatible with the scene API, all graphics pipelines in Datoviz must have the following common slots : layout (std140, binding = 0) uniform MVP {...}; layout (std140, binding = 1) uniform Viewport {...}; Binding Descriptor type Description 0 uniform structure with the model-view-proj matrices 1 uniform structure with viewport information This is done just by including common.glsl in every shader. Note that this is not required when using completely standalone graphics pipelines that will never be used with the scene API. When one needs to add another bindings, the numbering should start at USER_BINDING , a special GLSL macro that is currently 2. Uniform alignment \u00b6 The std140 keyword refers to the alignment of the fields within the uniform structure. We're not going into the details, but we'll present some relatively arbitrary rules that we follow in Datoviz so that we don't need to think too much about memory alignment considerations when working with uniform structures: always use the std140 keyword when defining uniform resources in the shaders, NEVER use the following data types in a uniform structure : vec3 , ivec3 , mat3 , and any format with a 3 in it. If you need a vector with three components, use a vec4 and leave the last component alone. This only affects uniforms, NOT attributes. Varying variables \u00b6 The vertex shader may pass some variables to the next stage, typically the fragment shader, using varying variables . A crucial difference between the vertex and fragment shaders is that the vertex shader executes on every vertex , whereas the fragment shader executes on every pixel . When the vertex shader passes a value to the fragment shader, the GPU makes a linear interpolation for all pixels between two vertices in the same primitive. This is specific to line and triangle primitives, not points. For example, passing 0 to one vertex and 1 to the next vertex in a graphics with a line primitive would result in all pixels being passed a real value between 0 and 1 depending on the position of that pixel within that line segment. This system is used in particular with: Color gradients, Texture coordinates. Position transformation \u00b6 The common.glsl file defines (several overloaded versions of) the function transform() , which applies the model-view-proj matrices stored in the first bound resource, the MVP uniform. The associated C structure is DvzMVP : struct DvzMVP { mat4 model ; // model 4x4 matrix mat4 view ; // view 4x4 matrix mat4 proj ; // projection 4x4 matrix float time ; // elapsed time since the start of the application, in seconds }; The transformation is basically gl_Position = to_vulkan(proj * view * model * position) . The to_vulkan() internal function transforms the position from the OpenGL/Datoviz 3D coordinate system (y up, z toward the user) to the Vulkan coordinate system (y down, z toward the inside of the screen). Special GLSL variables \u00b6 We use a few special GLSL variables in the vertex shader: Name Type Description gl_Position vec4 final vertex position in normalized device coordinates gl_PointSize float size of the point, when using the point list primitive There are many more special variables available in each type of shader. You'll find the list of special GLSL variables here. Colormaps \u00b6 The colormap() function is implemented in colormaps.glsl . It provides a GLSL implementation of a few common colormaps, which allows to compute the color as a function of a scalar value without using a texture . There are a few advantages to this, mostly related to performance and avoiding edge effects when using nearest interpolation in the texture. Writing the fragment shader \u00b6 We now pass to the fragment shader. Here is the code: // code from `examples/glsl/custom_point.frag`: #version 450 #include \"common.glsl\" // The \"in\" variables here MUST correspond to the \"out\" variables from the vertex shader. layout ( location = 0 ) in vec4 in_color ; // The first output variable of the fragment shader must be a vec4 variable with the RGBA // components of the pixel being processed. layout ( location = 0 ) out vec4 out_color ; void main () { // This macro is used to implement clipping in the inner viewport, when using panel margins. // All fragment shader of all graphics must include this macro for now. CLIP // Here, we simply pass the varying color (already computed by the vertex shader) to the // output variable. // NOTE: we could also have passed the point size from the vertex shader to the fragment // shader, and compute the colormap here. HOWEVER the computation of the colormap would have // been done for each *pixel*, rather than each *vertex*. Since we're using uniform square // colors in this example, that would have resulted in wasted duplicate computations and // unjustified loss of performance. // When the pixel color is non uniform across the primitive, and not just linearly interpolated // between the vertices, one can compute the pixel color directly in the fragment shader. out_color = in_color ; } Here are a few comments. Clipping \u00b6 Datoviz panels may have margins around them. We make the distinction between: Viewport Description inner viewport area of the panel excluding the margins outer viewport area of the panel including the margins We follow the convention that the normalized coordinates [-1, +1] correspond to the inner viewport . Vertices beyond these limits will be rendered in the margins. Clipping allows to hide all pixels outside the inner viewport. This is how we implement the axes controller: graphics should not be rendered in the margins which contain the tick labels. Any graphics that should be compatible with the axes controller should therefore have the special CLIP macro at the beginning of the fragments shader (implemented in common.glsl ). This macro detects whether the current pixel is beyond the inner viewport, and if the graphics has been configured so, it discards that pixel. Special variables \u00b6 We haven't used any special variable in this fragment shader, but here are two useful variables that we could use: Name Type Description gl_FragCoord vec4 pixel position in window space gl_PointCoord vec2 coordinates of the pixel within the point primitive The gl_PointCoord variable is reserved to graphics pipelines using a point primitive. It provides the coordinates, in pixels, of the current pixel within the square. The origin is at the upper-left corner of the square. Compiling the shaders to SPIR-V \u00b6 Once the shaders have been written, they should be compiled to SPIR-V (unless using Datoviz to compile shaders provided as GLSL code, but this is a work in progress). Here is how to compile the shaders on the command-line: glslc custom_point.vert -o custom_point.vert.spv glslc custom_point.frag -o custom_point.frag.spv The glslc command is provided by the Vulkan SDK. Writing the custom graphics \u00b6 Here is the code to create a custom graphics compatible with the scene API, and to add it to a custom visual: // We create a blank graphics that will become our custom graphics. DvzGraphics * graphics = dvz_blank_graphics ( scene , 0 ); // Custom graphics creation. // The first step is to define the vertex and fragment shaders. When using // dvz_graphics_shader(), one must specify a path to the compiled SPIR-V shaders. // When writing the shaders in GLSL, it is thus necessary to compile them separately with // glslc. dvz_graphics_shader ( graphics , VK_SHADER_STAGE_VERTEX_BIT , \"custom_point.vert.spv\" ); dvz_graphics_shader ( graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"custom_point.frag.spv\" ); // We define the graphics pipeline topology: point list here. dvz_graphics_topology ( graphics , VK_PRIMITIVE_TOPOLOGY_POINT_LIST ); // Next, we declare the size of our vertex structure. dvz_graphics_vertex_binding ( graphics , 0 , sizeof ( PointVertex )); // We now declare the vertex shader attributes, that should correspond to the different // structure fields in the vertex structure. // The first attribute is a vec3 in GLSL, and a vec3 in C too. dvz_graphics_vertex_attr ( graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( PointVertex , pos )); // The second attribute is a float in GLSL, and a byte (uint8) in C. We use the special // format VK_FORMAT_R8_USCALED to declare this. dvz_graphics_vertex_attr ( graphics , 0 , 1 , VK_FORMAT_R8_USCALED , offsetof ( PointVertex , size )); // Now that we've set up the graphics, we create it. dvz_graphics_create ( graphics ); // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); As shown here, the creation of a custom graphics involves the following steps: Defining the shaders, Defining the primitive type, Declaring the vertex structure, the format of each field, and the casting between the GPU and GPU. There are further functions in the vklite API to customize the creation of the graphics pipeline. Refer to the Datoviz C API reference for more details. Writing the custom visual \u00b6 Here is how to add a custom graphics to a custom visual: // We create a blank visual, to which we'll add our custom visual. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // ... creating the custom graphics... // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); At this point, the custom visual contains common sources (vertex, MVP, viewport) and props. One could then define more sources and props. Writing a simple test \u00b6 Finally, here is how to use our custom visual with a custom graphics: // ... creating the custom visual with the custom graphics... // We add the custom visual to the panel. dvz_custom_visual ( panel , visual ); // Now, we prepare the vertex data. We could have defined and used props, but we'll show // another method instead. We create the vertex buffer directly, using the PointVertex // structure we've created. const uint32_t N = 64 ; // number of points PointVertex * vertices = calloc ( N , sizeof ( PointVertex )); // vertex buffer float t = 0 ; for ( uint32_t i = 0 ; i < N ; i ++ ) { t = i / ( float )( N - 1 ); // vertex position vertices [ i ]. pos [ 0 ] = - .75 + 1.25 * t * t ; vertices [ i ]. pos [ 1 ] = + .75 - 1.25 * t ; // vertex size, in byte, between 0 and 255. vertices [ i ]. size = 4 * i + 1 ; } // Here is the crucial bit: we bind the GPU vertex buffer with our struct array. dvz_visual_data_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , 0 , N , N , vertices ); FREE ( vertices ); Here are a few comments: Instead of using visual props, we have defined the vertex structure directly. The whole point of the visual props is to avoid doing this, which may not be particularly easy with complex vertex shaders with many attributes. Also, setting the vertex buffer directly requires to understand how the graphics is implemented on the GPU. If some form of triangulation is required, it is up to the user to do it. In this particular example, there is no triangulation as we have a one-to-one correspondance between the squares and the vertices. Note that the data buffers passed to the dvz_visual_data*() functions make a copy of the data, so we're fine freeing it. Other topics \u00b6 We didn't yet cover these other aspects: Other resources (textures, other uniforms), Other shaders (geometry shader, tesselation shader), Indexed rendering, Indirect rendering, Fixed functions, Depth testing, Dynamic states, Specialization constants, Push constants, Custom command buffers, Interaction with compute shaders, And many other topics...","title":"How to write a custom graphics"},{"location":"howto/graphics/#how-to-write-a-custom-graphics","text":"Warning You need to go through the Vulkan crash course before following this guide. You also need to go through the how to write a custom visual guide first. In this section, we'll show how to create a custom graphics by writing custom GLSL shaders . This is an advanced topic as it requires understanding the basic of GPU graphics programming. Note Only the C API supports custom graphics at the moment. Python bindings for custom graphics will come in an upcoming version. Datoviz already includes the code necessary to compile GLSL shaders to SPIR-V on the fly (based on Khronos glslang ). The full source code for this example can be found in examples/custom_graphics.c . As a toy example, we'll create a graphics with square points of various size and color . Specifically, we'll require each point to have a different size (which is not supported in the existing point graphics), and a color depending directly on the size and computed directly on the GPU. We'll use a single byte per vertex to store the vertex size (between 0 and 255 pixels), and we'll use no memory for the color since it will be determined directly by this value. This kind of memory optimization is one of the use-cases of writing custom graphics. Limiting memory usage is important when dealing with extremely large datasets (tens or hundreds of millions of points). Writing a custom graphics involves the following steps: Choosing the primitive type. Defining the vertex data structure and corresponding vertex shader attributes. Writing the vertex shader. Writing the fragment shader. Compiling the GLSL shaders to SPIR-V (may be done automatically in the future). Writing the custom graphics. Writing the custom visual. Writing a simple test. Note Here, we show how to create a custom graphics compatible with the scene API, so that it can be used added to the scene the same way as builtin visuals. One could however decide not to use the scene API at all, and leverage instead the vklite API directly. This allows one to create entirely custom and standalone applications. This is not documented at the moment, and one should look at the vklite unit tests to understand how to use the vklite API directly.","title":"How to write a custom graphics"},{"location":"howto/graphics/#choosing-the-graphics-primitive-type","text":"Vulkan supports six major types of primitives: point list : square points with an arbitrary size, line list : disjoint aliased line segments, line strip : joined aliased line segments, triangle strip : joined triangles consecutively sharing an edge, triangle fan : joined triangles all sharing a single corner (the first vertex), triangle list : disjoint triangles, Other less common primitive types are described in the Vulkan specification . Warning Triangle fans are not supported on macOS. Schematic from the Vulkan Cookbook by Pawel Lapinski, O'Reilly Note The circular arrows in the triangles above indicate the orientation of the triangles, which is taken into account by the GPU. It is good practice to always ensure that all triangles constituting a given object are consistent. For example, when triangulating a square with two triangles, the order of the vertices should be chosen such that both triangles are directly oriented. The graphics pipeline can be configured to handle triangle orientation in a specific way. For example, one can make a graphics pipeline where indirectly oriented triangles are automatically discarded. Line primitives typically have a width of 1 pixel, although some hardware supports thicker lines. In Datoviz, thick, high-quality lines are implemented with triangles instead (line triangulation), and the antialiased thick line is drawn directly in the fragment shader. \"Basic\" line primitives are only used for testing and for special high-performance applications where scalability and performance are more important than visual quality. The most commonly-used primitive types in scientific visualization are essentially point lists and triangle lists (and to a lesser extent, triangle strips). In this example, we'll use a point list , where each point will correspond to one square.","title":"Choosing the graphics primitive type"},{"location":"howto/graphics/#defining-the-vertex-data-structure","text":"Once we know we'll use a point list as a primitive, the next step is to define the vertex data structure / vertex shader attributes. Here, we want the following attributes for each vertex: the point position (center of the square), as a vec3 , the point size (edge length of the square, in pixels), as an uint8_t . The point size will be limited to a maximum of 255 pixels in this toy example. We could have simply used a floating-point for the edge length, but that would have used four bytes instead of one. This is also to show the versatility of Vulkan and GPU programming, where we have full control on the data types used on both the GPU and CPU. Here is our vertex C structure: // We define the vertex structure for our graphics pipeline. typedef struct { vec3 pos ; // 3D point position uint8_t size ; // point size, in pixels, between 0 and 255. } PointVertex ; We also need to define the attributes in GLSL: layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0","title":"Defining the vertex data structure"},{"location":"howto/graphics/#attribute-format","text":"In this example, we use a uint8_t (byte) on the CPU, but a float on the GPU. Vulkan provides a way to specify the way we want to do the casting . This is done when creating the graphics pipeline below. We can just say here that we'll use the Vulkan format VK_FORMAT_R8_USCALED . This format means that: Number of components . There is a single component (scalar), the R in R8 means \"red\" component: this is the component used for scalar values. If using a pair of components, we would have both a R and G component (green). This naming convention using color names comes from the fact that these GPU formats are typically used to represent colors, but they can actually represent any type of numerical data. Number of bits per component . The 8 in R8 means that our red component is represented with 8 bits. Signedness . The U in USCALED means that we use an unsigned format. Scaling . The SCALED means that the byte, a number between 0 and 255, will be converted to a float without normalization: 255 becomes 255.0. Here are the other common scaling options provided by Vulkan when using bytes: Scaling GPU number type Range UNORM float [0.0, 1.0] SNORM float [-1.0, 1.0] USCALED float [0.0, 255.0] SSCALED float [-128.0, +127.0] (?) UINT int [0, 255] SINT int [-128, 127] (?) You'll find more information here: Full list of formats in the Vulkan spec , Hardware support of the formats : some formats are not supported by all existing GPUs. This website is quite useful to know what formats have the best hardware support.","title":"Attribute format"},{"location":"howto/graphics/#writing-the-vertex-shader","text":"We're now ready to write the vertex shader. Here is the full source code of the vertex shader: // code from `examples/glsl/custom_point.vert`: // GLSL version #version 450 // To be compatible with the scene API, all graphics shaders must include a common GLSL include // file. It defines common uniform bindings and common functions (for example, transform()). // These .glsl files are found in `include/datoviz/glsl`, so one needs to pass // `-Ipath/to/datoviz/include/datoviz/glsl` to the `glslc` command (see build.sh script). #include \"common.glsl\" // Here, we also use GLSL colormaps to compute the square color directly in the vertex shader, // without using the colormap texture. #include \"colormaps.glsl\" // Here, we describe the vertex shader attributes. layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0 // We made the unusual choice here to use a float in the shader, which corresponds to a uint8 byte // in C. We also decided not to normalize it, i.e. that the byte 255 corresponds to the float 255.0 // in the shader (VK_FORMAT_R8_USCALED format). Other choices can be made when specifying the // attribute format in the custom graphics definition. // Here, we describe the \"varying\" variables. These are special values output by the vertex shader, // and passed to the fragment shader. layout ( location = 0 ) out vec4 out_color ; // Main shader code. void main () { // Here, \"pos\" is the position of the vertex being processed. gl_Position is a special output // variable that returns the vertex final position in normalized device coordinates. It // is a vec4 vector, the fourth component is the homogeneous coordinate. // The \"transform()\" function is defined in common.glsl. It applies the model, view, proj // matrices stored in the first (common) uniform buffer (MVP buffer). gl_Position = transform ( pos ); // This special variable is an output variable that contains the point size, in pixels, // of the vertex being processed. It is reserved to graphics pipelines with a point list // primitive. gl_PointSize = size ; // Here, we set the varying variable that will be passed to the fragment shader. // The function colormap() is implemented in colormaps.glsl. It supports a few colormaps // that are implemented directly in GLSL, without using a texture. The second argument // is a value between 0 and 1, hence the normalization with the size which is in pixels. out_color = colormap ( DVZ_CMAP_HSV , size / 255.0 ); out_color . a = .25 ; // alpha component for some transparency } A few comments can be found below.","title":"Writing the vertex shader"},{"location":"howto/graphics/#common-shader-resources","text":"The #include directive is provided for convenience by the GLSL to SPIR-V compiler glslc . It is used extensively in Datoviz. It provides a simple way of making all graphics shaders share some functions and resources. In particular, we make the convention that, in order to be compatible with the scene API, all graphics pipelines in Datoviz must have the following common slots : layout (std140, binding = 0) uniform MVP {...}; layout (std140, binding = 1) uniform Viewport {...}; Binding Descriptor type Description 0 uniform structure with the model-view-proj matrices 1 uniform structure with viewport information This is done just by including common.glsl in every shader. Note that this is not required when using completely standalone graphics pipelines that will never be used with the scene API. When one needs to add another bindings, the numbering should start at USER_BINDING , a special GLSL macro that is currently 2.","title":"Common shader resources"},{"location":"howto/graphics/#varying-variables","text":"The vertex shader may pass some variables to the next stage, typically the fragment shader, using varying variables . A crucial difference between the vertex and fragment shaders is that the vertex shader executes on every vertex , whereas the fragment shader executes on every pixel . When the vertex shader passes a value to the fragment shader, the GPU makes a linear interpolation for all pixels between two vertices in the same primitive. This is specific to line and triangle primitives, not points. For example, passing 0 to one vertex and 1 to the next vertex in a graphics with a line primitive would result in all pixels being passed a real value between 0 and 1 depending on the position of that pixel within that line segment. This system is used in particular with: Color gradients, Texture coordinates.","title":"Varying variables"},{"location":"howto/graphics/#position-transformation","text":"The common.glsl file defines (several overloaded versions of) the function transform() , which applies the model-view-proj matrices stored in the first bound resource, the MVP uniform. The associated C structure is DvzMVP : struct DvzMVP { mat4 model ; // model 4x4 matrix mat4 view ; // view 4x4 matrix mat4 proj ; // projection 4x4 matrix float time ; // elapsed time since the start of the application, in seconds }; The transformation is basically gl_Position = to_vulkan(proj * view * model * position) . The to_vulkan() internal function transforms the position from the OpenGL/Datoviz 3D coordinate system (y up, z toward the user) to the Vulkan coordinate system (y down, z toward the inside of the screen).","title":"Position transformation"},{"location":"howto/graphics/#special-glsl-variables","text":"We use a few special GLSL variables in the vertex shader: Name Type Description gl_Position vec4 final vertex position in normalized device coordinates gl_PointSize float size of the point, when using the point list primitive There are many more special variables available in each type of shader. You'll find the list of special GLSL variables here.","title":"Special GLSL variables"},{"location":"howto/graphics/#colormaps","text":"The colormap() function is implemented in colormaps.glsl . It provides a GLSL implementation of a few common colormaps, which allows to compute the color as a function of a scalar value without using a texture . There are a few advantages to this, mostly related to performance and avoiding edge effects when using nearest interpolation in the texture.","title":"Colormaps"},{"location":"howto/graphics/#writing-the-fragment-shader","text":"We now pass to the fragment shader. Here is the code: // code from `examples/glsl/custom_point.frag`: #version 450 #include \"common.glsl\" // The \"in\" variables here MUST correspond to the \"out\" variables from the vertex shader. layout ( location = 0 ) in vec4 in_color ; // The first output variable of the fragment shader must be a vec4 variable with the RGBA // components of the pixel being processed. layout ( location = 0 ) out vec4 out_color ; void main () { // This macro is used to implement clipping in the inner viewport, when using panel margins. // All fragment shader of all graphics must include this macro for now. CLIP // Here, we simply pass the varying color (already computed by the vertex shader) to the // output variable. // NOTE: we could also have passed the point size from the vertex shader to the fragment // shader, and compute the colormap here. HOWEVER the computation of the colormap would have // been done for each *pixel*, rather than each *vertex*. Since we're using uniform square // colors in this example, that would have resulted in wasted duplicate computations and // unjustified loss of performance. // When the pixel color is non uniform across the primitive, and not just linearly interpolated // between the vertices, one can compute the pixel color directly in the fragment shader. out_color = in_color ; } Here are a few comments.","title":"Writing the fragment shader"},{"location":"howto/graphics/#clipping","text":"Datoviz panels may have margins around them. We make the distinction between: Viewport Description inner viewport area of the panel excluding the margins outer viewport area of the panel including the margins We follow the convention that the normalized coordinates [-1, +1] correspond to the inner viewport . Vertices beyond these limits will be rendered in the margins. Clipping allows to hide all pixels outside the inner viewport. This is how we implement the axes controller: graphics should not be rendered in the margins which contain the tick labels. Any graphics that should be compatible with the axes controller should therefore have the special CLIP macro at the beginning of the fragments shader (implemented in common.glsl ). This macro detects whether the current pixel is beyond the inner viewport, and if the graphics has been configured so, it discards that pixel.","title":"Clipping"},{"location":"howto/graphics/#special-variables","text":"We haven't used any special variable in this fragment shader, but here are two useful variables that we could use: Name Type Description gl_FragCoord vec4 pixel position in window space gl_PointCoord vec2 coordinates of the pixel within the point primitive The gl_PointCoord variable is reserved to graphics pipelines using a point primitive. It provides the coordinates, in pixels, of the current pixel within the square. The origin is at the upper-left corner of the square.","title":"Special variables"},{"location":"howto/graphics/#compiling-the-shaders-to-spir-v","text":"Once the shaders have been written, they should be compiled to SPIR-V (unless using Datoviz to compile shaders provided as GLSL code, but this is a work in progress). Here is how to compile the shaders on the command-line: glslc custom_point.vert -o custom_point.vert.spv glslc custom_point.frag -o custom_point.frag.spv The glslc command is provided by the Vulkan SDK.","title":"Compiling the shaders to SPIR-V"},{"location":"howto/graphics/#writing-the-custom-graphics","text":"Here is the code to create a custom graphics compatible with the scene API, and to add it to a custom visual: // We create a blank graphics that will become our custom graphics. DvzGraphics * graphics = dvz_blank_graphics ( scene , 0 ); // Custom graphics creation. // The first step is to define the vertex and fragment shaders. When using // dvz_graphics_shader(), one must specify a path to the compiled SPIR-V shaders. // When writing the shaders in GLSL, it is thus necessary to compile them separately with // glslc. dvz_graphics_shader ( graphics , VK_SHADER_STAGE_VERTEX_BIT , \"custom_point.vert.spv\" ); dvz_graphics_shader ( graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"custom_point.frag.spv\" ); // We define the graphics pipeline topology: point list here. dvz_graphics_topology ( graphics , VK_PRIMITIVE_TOPOLOGY_POINT_LIST ); // Next, we declare the size of our vertex structure. dvz_graphics_vertex_binding ( graphics , 0 , sizeof ( PointVertex )); // We now declare the vertex shader attributes, that should correspond to the different // structure fields in the vertex structure. // The first attribute is a vec3 in GLSL, and a vec3 in C too. dvz_graphics_vertex_attr ( graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( PointVertex , pos )); // The second attribute is a float in GLSL, and a byte (uint8) in C. We use the special // format VK_FORMAT_R8_USCALED to declare this. dvz_graphics_vertex_attr ( graphics , 0 , 1 , VK_FORMAT_R8_USCALED , offsetof ( PointVertex , size )); // Now that we've set up the graphics, we create it. dvz_graphics_create ( graphics ); // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); As shown here, the creation of a custom graphics involves the following steps: Defining the shaders, Defining the primitive type, Declaring the vertex structure, the format of each field, and the casting between the GPU and GPU. There are further functions in the vklite API to customize the creation of the graphics pipeline. Refer to the Datoviz C API reference for more details.","title":"Writing the custom graphics"},{"location":"howto/graphics/#writing-the-custom-visual","text":"Here is how to add a custom graphics to a custom visual: // We create a blank visual, to which we'll add our custom visual. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // ... creating the custom graphics... // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); At this point, the custom visual contains common sources (vertex, MVP, viewport) and props. One could then define more sources and props.","title":"Writing the custom visual"},{"location":"howto/graphics/#writing-a-simple-test","text":"Finally, here is how to use our custom visual with a custom graphics: // ... creating the custom visual with the custom graphics... // We add the custom visual to the panel. dvz_custom_visual ( panel , visual ); // Now, we prepare the vertex data. We could have defined and used props, but we'll show // another method instead. We create the vertex buffer directly, using the PointVertex // structure we've created. const uint32_t N = 64 ; // number of points PointVertex * vertices = calloc ( N , sizeof ( PointVertex )); // vertex buffer float t = 0 ; for ( uint32_t i = 0 ; i < N ; i ++ ) { t = i / ( float )( N - 1 ); // vertex position vertices [ i ]. pos [ 0 ] = - .75 + 1.25 * t * t ; vertices [ i ]. pos [ 1 ] = + .75 - 1.25 * t ; // vertex size, in byte, between 0 and 255. vertices [ i ]. size = 4 * i + 1 ; } // Here is the crucial bit: we bind the GPU vertex buffer with our struct array. dvz_visual_data_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , 0 , N , N , vertices ); FREE ( vertices ); Here are a few comments: Instead of using visual props, we have defined the vertex structure directly. The whole point of the visual props is to avoid doing this, which may not be particularly easy with complex vertex shaders with many attributes. Also, setting the vertex buffer directly requires to understand how the graphics is implemented on the GPU. If some form of triangulation is required, it is up to the user to do it. In this particular example, there is no triangulation as we have a one-to-one correspondance between the squares and the vertices. Note that the data buffers passed to the dvz_visual_data*() functions make a copy of the data, so we're fine freeing it.","title":"Writing a simple test"},{"location":"howto/graphics/#other-topics","text":"We didn't yet cover these other aspects: Other resources (textures, other uniforms), Other shaders (geometry shader, tesselation shader), Indexed rendering, Indirect rendering, Fixed functions, Depth testing, Dynamic states, Specialization constants, Push constants, Custom command buffers, Interaction with compute shaders, And many other topics...","title":"Other topics"},{"location":"howto/standalone_canvas/","text":"How to use the canvas C API \u00b6 This example shows how to write a standalone C app using only the canvas API , not the scene API. We'll render a triangle without using existing graphics, visuals, panels, and so on. We'll follow these steps: Creating a graphics with custom shaders, Creating a function callback for command buffer refill, Creating a vertex buffer manually. // code from `examples/standalone/standalone_canvas.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /* This script opens a live canvas with a triangle rendered on the GPU. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // Objects we'll need in the refill callback. // NOTE: Using static global variables in production code is bad practice. static DvzBufferRegions vertex_buffer ; static DvzGraphics graphics ; static DvzBindings bindings ; // Refill callback. This function is called by the canvas whenever it needs to recreate its command // buffers, for example when initializing the canvas, and when resizing it. static void _triangle_refill ( DvzCanvas * canvas , DvzEvent ev ) { ASSERT ( canvas != NULL ); // The callback is passed an event object with a list of command buffers to recreate. In // this particular example, we just use a single command buffer. ASSERT ( ev . u . rf . cmd_count == 1 ); DvzCommands * cmds = ev . u . rf . cmds [ 0 ]; // There is by default just one command buffer, linked to the render queue. ASSERT ( cmds -> queue_idx == DVZ_DEFAULT_QUEUE_RENDER ); // This is the current swapchain image index for which we need to refill the command buffer. // There is one command buffer per swapchain image, so whenever a command buffer refill is // needed, this callback function is called three times for example, if using triple buffering. uint32_t idx = ev . u . rf . img_idx ; // We begin recording the command buffer here. dvz_cmd_begin ( cmds , idx ); // We begin the default render pass. dvz_cmd_begin_renderpass ( cmds , idx , & canvas -> renderpass , & canvas -> framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( cmds , idx , canvas -> viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( cmds , idx , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( cmds , idx , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( cmds , idx , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( cmds , idx ); dvz_cmd_end ( cmds , idx ); } // Entry point. int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu_best ( app ); // We create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1024 , 768 , 0 ); // Graphics pipeline. { // We create a new graphics pipeline. graphics = dvz_graphics ( gpu ); // We set the renderpass. dvz_graphics_renderpass ( & graphics , & canvas -> renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); } // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // Vertex data and GPU buffer. DvzBuffer buffer = dvz_buffer ( gpu ); { // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for // all graphics pipelines in the application. Defining many small GPU buffers is bad // practice. // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in // real applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); } // We set the command buffer refill callback, the function that will be called whenever the // canvas needs to refill its command buffers. The callback generates the GPU commands to draw // the triangle. dvz_event_callback ( canvas , DVZ_EVENT_REFILL , 0 , DVZ_EVENT_MODE_SYNC , _triangle_refill , NULL ); // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_app_destroy ( app ); return 0 ; }","title":"How to use the canvas C API"},{"location":"howto/standalone_canvas/#how-to-use-the-canvas-c-api","text":"This example shows how to write a standalone C app using only the canvas API , not the scene API. We'll render a triangle without using existing graphics, visuals, panels, and so on. We'll follow these steps: Creating a graphics with custom shaders, Creating a function callback for command buffer refill, Creating a vertex buffer manually. // code from `examples/standalone/standalone_canvas.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /* This script opens a live canvas with a triangle rendered on the GPU. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // Objects we'll need in the refill callback. // NOTE: Using static global variables in production code is bad practice. static DvzBufferRegions vertex_buffer ; static DvzGraphics graphics ; static DvzBindings bindings ; // Refill callback. This function is called by the canvas whenever it needs to recreate its command // buffers, for example when initializing the canvas, and when resizing it. static void _triangle_refill ( DvzCanvas * canvas , DvzEvent ev ) { ASSERT ( canvas != NULL ); // The callback is passed an event object with a list of command buffers to recreate. In // this particular example, we just use a single command buffer. ASSERT ( ev . u . rf . cmd_count == 1 ); DvzCommands * cmds = ev . u . rf . cmds [ 0 ]; // There is by default just one command buffer, linked to the render queue. ASSERT ( cmds -> queue_idx == DVZ_DEFAULT_QUEUE_RENDER ); // This is the current swapchain image index for which we need to refill the command buffer. // There is one command buffer per swapchain image, so whenever a command buffer refill is // needed, this callback function is called three times for example, if using triple buffering. uint32_t idx = ev . u . rf . img_idx ; // We begin recording the command buffer here. dvz_cmd_begin ( cmds , idx ); // We begin the default render pass. dvz_cmd_begin_renderpass ( cmds , idx , & canvas -> renderpass , & canvas -> framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( cmds , idx , canvas -> viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( cmds , idx , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( cmds , idx , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( cmds , idx , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( cmds , idx ); dvz_cmd_end ( cmds , idx ); } // Entry point. int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu_best ( app ); // We create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1024 , 768 , 0 ); // Graphics pipeline. { // We create a new graphics pipeline. graphics = dvz_graphics ( gpu ); // We set the renderpass. dvz_graphics_renderpass ( & graphics , & canvas -> renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); } // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // Vertex data and GPU buffer. DvzBuffer buffer = dvz_buffer ( gpu ); { // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for // all graphics pipelines in the application. Defining many small GPU buffers is bad // practice. // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in // real applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); } // We set the command buffer refill callback, the function that will be called whenever the // canvas needs to refill its command buffers. The callback generates the GPU commands to draw // the triangle. dvz_event_callback ( canvas , DVZ_EVENT_REFILL , 0 , DVZ_EVENT_MODE_SYNC , _triangle_refill , NULL ); // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_app_destroy ( app ); return 0 ; }","title":"How to use the canvas C API"},{"location":"howto/standalone_imgui/","text":"How to use Dear ImGui directly in a C++ application \u00b6 This example shows how to write a standalone C++ application using Dear ImGui directly , without using the basic wrapper provided by Datoviz. Full source code \u00b6 // code from `examples/standalone/standalone_imgui.cpp`: /*************************************************************************************************/ /* Example of a standalone C++ application using the library and Dear ImGUI directly. */ /*************************************************************************************************/ #include <IconsFontAwesome.h> // used for FontAwesome icons #include <datoviz/datoviz.h> // import Datoviz #include <imgui/imgui.h> // import Dear ImGui // Static variables. static char buf [ 256 ]; static float f ; // This is where the Dear ImGui code goes: void _gui_callback ( DvzCanvas * canvas , DvzEvent ev ) { // Code below coming directly from: https://github.com/ocornut/imgui ImGui :: Text ( \"Hello, world %d\" , 123 ); if ( ImGui :: Button ( \"Save\" )) printf ( \"Saving! \\n \" ); ImGui :: InputText ( \"string\" , buf , IM_ARRAYSIZE ( buf )); ImGui :: SliderFloat ( \"float\" , & f , 0.0f , 1.0f ); } // Entry point. int main ( int argc , char ** argv ) { // Create an app as usual. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); DvzGpu * gpu = dvz_gpu_best ( app ); // NOTE: we must set the IMGUI flag in order to use Dear ImGUI. DvzCanvas * canvas = dvz_canvas ( gpu , 1024 , 768 , DVZ_CANVAS_FLAGS_IMGUI ); // Event callback used for Dear ImGUI. It is called at every frame. The callback can call Dear // ImGui functions to create dialogs. dvz_event_callback ( canvas , DVZ_EVENT_IMGUI , 0 , DVZ_EVENT_MODE_SYNC , _gui_callback , NULL ); // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // Destroy the app. dvz_app_destroy ( app ); return 0 ; }","title":"How to use Dear ImGui directly"},{"location":"howto/standalone_imgui/#how-to-use-dear-imgui-directly-in-a-c-application","text":"This example shows how to write a standalone C++ application using Dear ImGui directly , without using the basic wrapper provided by Datoviz.","title":"How to use Dear ImGui directly in a C++ application"},{"location":"howto/standalone_imgui/#full-source-code","text":"// code from `examples/standalone/standalone_imgui.cpp`: /*************************************************************************************************/ /* Example of a standalone C++ application using the library and Dear ImGUI directly. */ /*************************************************************************************************/ #include <IconsFontAwesome.h> // used for FontAwesome icons #include <datoviz/datoviz.h> // import Datoviz #include <imgui/imgui.h> // import Dear ImGui // Static variables. static char buf [ 256 ]; static float f ; // This is where the Dear ImGui code goes: void _gui_callback ( DvzCanvas * canvas , DvzEvent ev ) { // Code below coming directly from: https://github.com/ocornut/imgui ImGui :: Text ( \"Hello, world %d\" , 123 ); if ( ImGui :: Button ( \"Save\" )) printf ( \"Saving! \\n \" ); ImGui :: InputText ( \"string\" , buf , IM_ARRAYSIZE ( buf )); ImGui :: SliderFloat ( \"float\" , & f , 0.0f , 1.0f ); } // Entry point. int main ( int argc , char ** argv ) { // Create an app as usual. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); DvzGpu * gpu = dvz_gpu_best ( app ); // NOTE: we must set the IMGUI flag in order to use Dear ImGUI. DvzCanvas * canvas = dvz_canvas ( gpu , 1024 , 768 , DVZ_CANVAS_FLAGS_IMGUI ); // Event callback used for Dear ImGUI. It is called at every frame. The callback can call Dear // ImGui functions to create dialogs. dvz_event_callback ( canvas , DVZ_EVENT_IMGUI , 0 , DVZ_EVENT_MODE_SYNC , _gui_callback , NULL ); // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // Destroy the app. dvz_app_destroy ( app ); return 0 ; }","title":"Full source code"},{"location":"howto/standalone_scene/","text":"How to use the scene C API \u00b6 This example shows how to make a scatter plot using the scene C API in a standalone application. Note A basic build script is provided in the examples/ folder. A better practice would probably be to use cmake but this is not documented yet. Help appreciated! Full source code \u00b6 // code from `examples/standalone/standalone_scene.c`: /*************************************************************************************************/ /* Example of a standalone application using the library. */ /*************************************************************************************************/ /// We import the library public header. The compiler needs to be passed the path to the headers /// and shared library, see build.sh. #include <datoviz/datoviz.h> // Entry point. int main ( int argc , char ** argv ) { // We create a singleton application using the GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We automatically choose the most capable GPU. DvzGpu * gpu = dvz_gpu_best ( app ); // We create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1024 , 768 , 0 ); // We use a white background color (RGB floating-point values in [0, 1]). dvz_canvas_clear_color ( canvas , 1 , 1 , 1 ); // We create a scene, which allows us to define several subplots (panels) organized within a // grid. Here, we just use a single panel spanning the entire canvas. DvzScene * scene = dvz_scene ( canvas , 1 , 1 ); // We get the panel at row 0, column 0, and we initialize it with an axes 2D controller. // The last argument is for optional flags. DvzPanel * panel = dvz_scene_panel ( scene , 0 , 0 , DVZ_CONTROLLER_AXES_2D , 0 ); // We add a new \"marker\" visual in the panel. // The last argument is for optional flags. DvzVisual * visual = dvz_scene_visual ( panel , DVZ_VISUAL_MARKER , 0 ); // Visual data. { // We prepare the data for the marker visual: // - marker positions (three double-precision floating point numbers for x, y, z) // - marker colors (four bytes for the RGBA value) // - marker sizes (a single precision floating point number with the marker size, in // pixels). // The visual reference guide provides all supported props. const uint32_t N = 10000 ; dvec3 * pos = ( dvec3 * ) calloc ( N , sizeof ( dvec3 )); cvec4 * color = ( cvec4 * ) calloc ( N , sizeof ( cvec4 )); float * size = ( float * ) calloc ( N , sizeof ( float )); for ( uint32_t i = 0 ; i < N ; i ++ ) { // Random gaussian position. pos [ i ][ 0 ] = dvz_rand_normal (); pos [ i ][ 1 ] = dvz_rand_normal (); // Color: random value with a colormap. dvz_colormap_scale ( DVZ_CMAP_VIRIDIS , dvz_rand_float (), 0 , 1 , color [ i ]); // A bit of transparency via the alpha channel. color [ i ][ 3 ] = 196 ; // Random marker size. size [ i ] = 2 + 38 * dvz_rand_float (); } // We pass our data to the visual props. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , N , pos ); dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , N , color ); dvz_visual_data ( visual , DVZ_PROP_MARKER_SIZE , 0 , N , size ); // We free the memory of the arrays we've created. FREE ( pos ); FREE ( color ); FREE ( size ); } // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_app_destroy ( app ); return 0 ; }","title":"How to use the scene C API"},{"location":"howto/standalone_scene/#how-to-use-the-scene-c-api","text":"This example shows how to make a scatter plot using the scene C API in a standalone application. Note A basic build script is provided in the examples/ folder. A better practice would probably be to use cmake but this is not documented yet. Help appreciated!","title":"How to use the scene C API"},{"location":"howto/standalone_scene/#full-source-code","text":"// code from `examples/standalone/standalone_scene.c`: /*************************************************************************************************/ /* Example of a standalone application using the library. */ /*************************************************************************************************/ /// We import the library public header. The compiler needs to be passed the path to the headers /// and shared library, see build.sh. #include <datoviz/datoviz.h> // Entry point. int main ( int argc , char ** argv ) { // We create a singleton application using the GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We automatically choose the most capable GPU. DvzGpu * gpu = dvz_gpu_best ( app ); // We create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1024 , 768 , 0 ); // We use a white background color (RGB floating-point values in [0, 1]). dvz_canvas_clear_color ( canvas , 1 , 1 , 1 ); // We create a scene, which allows us to define several subplots (panels) organized within a // grid. Here, we just use a single panel spanning the entire canvas. DvzScene * scene = dvz_scene ( canvas , 1 , 1 ); // We get the panel at row 0, column 0, and we initialize it with an axes 2D controller. // The last argument is for optional flags. DvzPanel * panel = dvz_scene_panel ( scene , 0 , 0 , DVZ_CONTROLLER_AXES_2D , 0 ); // We add a new \"marker\" visual in the panel. // The last argument is for optional flags. DvzVisual * visual = dvz_scene_visual ( panel , DVZ_VISUAL_MARKER , 0 ); // Visual data. { // We prepare the data for the marker visual: // - marker positions (three double-precision floating point numbers for x, y, z) // - marker colors (four bytes for the RGBA value) // - marker sizes (a single precision floating point number with the marker size, in // pixels). // The visual reference guide provides all supported props. const uint32_t N = 10000 ; dvec3 * pos = ( dvec3 * ) calloc ( N , sizeof ( dvec3 )); cvec4 * color = ( cvec4 * ) calloc ( N , sizeof ( cvec4 )); float * size = ( float * ) calloc ( N , sizeof ( float )); for ( uint32_t i = 0 ; i < N ; i ++ ) { // Random gaussian position. pos [ i ][ 0 ] = dvz_rand_normal (); pos [ i ][ 1 ] = dvz_rand_normal (); // Color: random value with a colormap. dvz_colormap_scale ( DVZ_CMAP_VIRIDIS , dvz_rand_float (), 0 , 1 , color [ i ]); // A bit of transparency via the alpha channel. color [ i ][ 3 ] = 196 ; // Random marker size. size [ i ] = 2 + 38 * dvz_rand_float (); } // We pass our data to the visual props. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , N , pos ); dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , N , color ); dvz_visual_data ( visual , DVZ_PROP_MARKER_SIZE , 0 , N , size ); // We free the memory of the arrays we've created. FREE ( pos ); FREE ( color ); FREE ( size ); } // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_app_destroy ( app ); return 0 ; }","title":"Full source code"},{"location":"howto/standalone_vklite/","text":"How to use the vklite C API \u00b6 This example shows how to write a standalone C app using only the vklite API (thin wrapper on top of the Vulkan C API), not the canvas or scene API. Creating a Vulkan-aware window is a complex operation as it requires creating a swapchain and implementing a rendering loop using proper CPU-GPU and GPU-GPU synchronization. The canvas abstracts that complexity away and there are probably few reasons not to use it. Therefore, the main reason to use the vklite API directly is probably when doing offscreen rendering and/or compute , and when reusing existing visuals and graphics in Datoviz is not desirable. On this page, we'll show how to make an offscreen render of a triangle using only the vklite API. We'll cover the following steps: Creating a GPU with custom queues. Creating a render pass. Creating GPU images for rendering. Creating framebuffers. Creating a graphics pipeline. Creating pipeline bindings. Creating a vertex buffer. Creating and recording a command buffer. Submitting a command buffer to the GPU and waiting until it has completed. Making a screenshot by creating a staging GPU image, and submitting a command buffer with transition barriers and a GPU image copy. This \"hello world\" script is about 250 lines long (without comments), about 4x smaller than by using the raw Vulkan C API. // code from `examples/standalone/standalone_vklite.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /* This script writes a triangle.png file rendered with the GPU. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // Utility function to create the renderpass for offscreen rendering. static void create_renderpass ( DvzRenderpass * renderpass ) { // Background color. VkClearValue clear_color = { 0 }; clear_color . color . float32 [ 3 ] = 1 ; VkClearValue clear_depth = { 0 }; clear_depth . depthStencil . depth = 1.0f ; dvz_renderpass_clear ( renderpass , clear_color ); dvz_renderpass_clear ( renderpass , clear_depth ); // Color attachment. dvz_renderpass_attachment ( renderpass , 0 , // DVZ_RENDERPASS_ATTACHMENT_COLOR , VK_FORMAT_B8G8R8A8_UNORM , VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( renderpass , 0 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_renderpass_attachment_ops ( renderpass , 0 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_STORE ); // Depth attachment. dvz_renderpass_attachment ( renderpass , 1 , // DVZ_RENDERPASS_ATTACHMENT_DEPTH , VK_FORMAT_D32_SFLOAT , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( renderpass , 1 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_ops ( renderpass , 1 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_DONT_CARE ); // Subpass. dvz_renderpass_subpass_attachment ( renderpass , 0 , 0 ); dvz_renderpass_subpass_attachment ( renderpass , 0 , 1 ); } // This function downloads the contents of the GPU image on which we have rendered to. static uint8_t * screenshot ( DvzImages * image ) { DvzGpu * gpu = image -> gpu ; // We create a staging image that is accessible from the CPU. DvzImages staging = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); dvz_images_format ( & staging , image -> format ); dvz_images_size ( & staging , image -> width , image -> height , image -> depth ); dvz_images_tiling ( & staging , VK_IMAGE_TILING_LINEAR ); dvz_images_usage ( & staging , VK_IMAGE_USAGE_TRANSFER_DST_BIT ); dvz_images_layout ( & staging , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_images_memory ( & staging , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); dvz_images_create ( & staging ); // We start the image transition command buffers. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); dvz_cmd_begin ( & cmds , 0 ); // We use a barrier to transition the staging image. DvzBarrier barrier = dvz_barrier ( gpu ); dvz_barrier_stages ( & barrier , VK_PIPELINE_STAGE_TRANSFER_BIT , VK_PIPELINE_STAGE_TRANSFER_BIT ); dvz_barrier_images ( & barrier , & staging ); dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_barrier_images_access ( & barrier , 0 , VK_ACCESS_TRANSFER_WRITE_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We copy the original image to the staging image. dvz_cmd_copy_image ( & cmds , 0 , image , & staging ); // We transition the staging image again. dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL , VK_IMAGE_LAYOUT_GENERAL ); dvz_barrier_images_access ( & barrier , VK_ACCESS_TRANSFER_WRITE_BIT , VK_ACCESS_MEMORY_READ_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We end the command buffer, we submit it to the GPU, and we wait until the GPU has completed // it. dvz_cmd_end ( & cmds , 0 ); dvz_cmd_submit_sync ( & cmds , 0 ); // Now, we copy the staging image back onto the host. uint8_t * rgb = ( uint8_t * ) calloc ( image -> width * image -> height , 3 ); dvz_images_download ( & staging , 0 , 1 , true , false , rgb ); // We can destroy the staging image. dvz_images_destroy ( & staging ); return rgb ; } // Entry point. int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu_best ( app ); // GPU creation. { // We specify the queues we need. Here we just need a single queue that will do the // rendering. dvz_gpu_queue ( gpu , 0 , DVZ_QUEUE_RENDER ); // Once the queues have been set up, we create the GPU. dvz_gpu_create ( gpu , 0 ); } // Framebuffer size. const uint32_t width = 800 ; const uint32_t height = 600 ; // Viewport. DvzViewport viewport = dvz_viewport_default ( width , height ); // We are going to create a renderpass. DvzRenderpass renderpass = dvz_renderpass ( gpu ); // We create a GPU image that we will render onto. DvzImages image = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We also create a GPU image for the depth buffer. DvzImages depth = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We will create the framebuffers to link these GPU images with the renderpass. DvzFramebuffers framebuffers = dvz_framebuffers ( gpu ); // Renderpass creation. create_renderpass ( & renderpass ); // Create attachments and framebuffers. { // Color attachment dvz_images_format ( & image , renderpass . attachments [ 0 ]. format ); dvz_images_size ( & image , width , height , 1 ); dvz_images_tiling ( & image , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & image , VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT ); dvz_images_memory ( & image , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_aspect ( & image , VK_IMAGE_ASPECT_COLOR_BIT ); dvz_images_layout ( & image , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_queue_access ( & image , 0 ); dvz_images_create ( & image ); // Depth attachment. dvz_images_format ( & depth , renderpass . attachments [ 1 ]. format ); dvz_images_size ( & depth , width , height , 1 ); dvz_images_tiling ( & depth , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & depth , VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ); dvz_images_memory ( & depth , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_layout ( & depth , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_aspect ( & depth , VK_IMAGE_ASPECT_DEPTH_BIT ); dvz_images_queue_access ( & depth , 0 ); dvz_images_create ( & depth ); // Create renderpass. dvz_renderpass_create ( & renderpass ); // Create framebuffers. dvz_framebuffers_attachment ( & framebuffers , 0 , & image ); dvz_framebuffers_attachment ( & framebuffers , 1 , & depth ); dvz_framebuffers_create ( & framebuffers , & renderpass ); } // We create a new graphics pipeline. DvzGraphics graphics = dvz_graphics ( gpu ); // Graphics pipeline. { // We set the renderpass. dvz_graphics_renderpass ( & graphics , & renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); } // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. DvzBindings bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for all // graphics pipelines in the application. Defining many small GPU buffers is bad practice. DvzBuffer buffer = dvz_buffer ( gpu ); DvzBufferRegions vertex_buffer ; // Vertex data and GPU buffer. { // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in // real applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); } // We create a command buffer. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); // Command buffer recording. { // We begin recording the command buffer here. dvz_cmd_begin ( & cmds , 0 ); // We begin the default render pass. dvz_cmd_begin_renderpass ( & cmds , 0 , & renderpass , & framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( & cmds , 0 , viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( & cmds , 0 , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( & cmds , 0 , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( & cmds , 0 , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( & cmds , 0 ); dvz_cmd_end ( & cmds , 0 ); } // We submit the command buffer to the GPU and we *wait* until the GPU has finished completing // it. This uses a hard synchronization primitive so this is not efficient. dvz_cmd_submit_sync ( & cmds , 0 ); // We make a screenshot and save it to a file. uint8_t * rgb = screenshot ( & image ); const char * path = \"../../docs/images/screenshots/standalone_vklite.png\" ; dvz_write_png ( path , width , height , rgb ); log_info ( \"offscreen rendered image written to: `%s`\" , path ); // We need to clean up all objects handled by Datoviz at the end. { dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_renderpass_destroy ( & renderpass ); dvz_images_destroy ( & image ); dvz_images_destroy ( & depth ); dvz_framebuffers_destroy ( & framebuffers ); dvz_bindings_destroy ( & bindings ); dvz_app_destroy ( app ); } return 0 ; }","title":"How to use the vklite C API"},{"location":"howto/standalone_vklite/#how-to-use-the-vklite-c-api","text":"This example shows how to write a standalone C app using only the vklite API (thin wrapper on top of the Vulkan C API), not the canvas or scene API. Creating a Vulkan-aware window is a complex operation as it requires creating a swapchain and implementing a rendering loop using proper CPU-GPU and GPU-GPU synchronization. The canvas abstracts that complexity away and there are probably few reasons not to use it. Therefore, the main reason to use the vklite API directly is probably when doing offscreen rendering and/or compute , and when reusing existing visuals and graphics in Datoviz is not desirable. On this page, we'll show how to make an offscreen render of a triangle using only the vklite API. We'll cover the following steps: Creating a GPU with custom queues. Creating a render pass. Creating GPU images for rendering. Creating framebuffers. Creating a graphics pipeline. Creating pipeline bindings. Creating a vertex buffer. Creating and recording a command buffer. Submitting a command buffer to the GPU and waiting until it has completed. Making a screenshot by creating a staging GPU image, and submitting a command buffer with transition barriers and a GPU image copy. This \"hello world\" script is about 250 lines long (without comments), about 4x smaller than by using the raw Vulkan C API. // code from `examples/standalone/standalone_vklite.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /* This script writes a triangle.png file rendered with the GPU. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // Utility function to create the renderpass for offscreen rendering. static void create_renderpass ( DvzRenderpass * renderpass ) { // Background color. VkClearValue clear_color = { 0 }; clear_color . color . float32 [ 3 ] = 1 ; VkClearValue clear_depth = { 0 }; clear_depth . depthStencil . depth = 1.0f ; dvz_renderpass_clear ( renderpass , clear_color ); dvz_renderpass_clear ( renderpass , clear_depth ); // Color attachment. dvz_renderpass_attachment ( renderpass , 0 , // DVZ_RENDERPASS_ATTACHMENT_COLOR , VK_FORMAT_B8G8R8A8_UNORM , VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( renderpass , 0 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_renderpass_attachment_ops ( renderpass , 0 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_STORE ); // Depth attachment. dvz_renderpass_attachment ( renderpass , 1 , // DVZ_RENDERPASS_ATTACHMENT_DEPTH , VK_FORMAT_D32_SFLOAT , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( renderpass , 1 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_ops ( renderpass , 1 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_DONT_CARE ); // Subpass. dvz_renderpass_subpass_attachment ( renderpass , 0 , 0 ); dvz_renderpass_subpass_attachment ( renderpass , 0 , 1 ); } // This function downloads the contents of the GPU image on which we have rendered to. static uint8_t * screenshot ( DvzImages * image ) { DvzGpu * gpu = image -> gpu ; // We create a staging image that is accessible from the CPU. DvzImages staging = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); dvz_images_format ( & staging , image -> format ); dvz_images_size ( & staging , image -> width , image -> height , image -> depth ); dvz_images_tiling ( & staging , VK_IMAGE_TILING_LINEAR ); dvz_images_usage ( & staging , VK_IMAGE_USAGE_TRANSFER_DST_BIT ); dvz_images_layout ( & staging , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_images_memory ( & staging , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); dvz_images_create ( & staging ); // We start the image transition command buffers. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); dvz_cmd_begin ( & cmds , 0 ); // We use a barrier to transition the staging image. DvzBarrier barrier = dvz_barrier ( gpu ); dvz_barrier_stages ( & barrier , VK_PIPELINE_STAGE_TRANSFER_BIT , VK_PIPELINE_STAGE_TRANSFER_BIT ); dvz_barrier_images ( & barrier , & staging ); dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_barrier_images_access ( & barrier , 0 , VK_ACCESS_TRANSFER_WRITE_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We copy the original image to the staging image. dvz_cmd_copy_image ( & cmds , 0 , image , & staging ); // We transition the staging image again. dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL , VK_IMAGE_LAYOUT_GENERAL ); dvz_barrier_images_access ( & barrier , VK_ACCESS_TRANSFER_WRITE_BIT , VK_ACCESS_MEMORY_READ_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We end the command buffer, we submit it to the GPU, and we wait until the GPU has completed // it. dvz_cmd_end ( & cmds , 0 ); dvz_cmd_submit_sync ( & cmds , 0 ); // Now, we copy the staging image back onto the host. uint8_t * rgb = ( uint8_t * ) calloc ( image -> width * image -> height , 3 ); dvz_images_download ( & staging , 0 , 1 , true , false , rgb ); // We can destroy the staging image. dvz_images_destroy ( & staging ); return rgb ; } // Entry point. int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu_best ( app ); // GPU creation. { // We specify the queues we need. Here we just need a single queue that will do the // rendering. dvz_gpu_queue ( gpu , 0 , DVZ_QUEUE_RENDER ); // Once the queues have been set up, we create the GPU. dvz_gpu_create ( gpu , 0 ); } // Framebuffer size. const uint32_t width = 800 ; const uint32_t height = 600 ; // Viewport. DvzViewport viewport = dvz_viewport_default ( width , height ); // We are going to create a renderpass. DvzRenderpass renderpass = dvz_renderpass ( gpu ); // We create a GPU image that we will render onto. DvzImages image = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We also create a GPU image for the depth buffer. DvzImages depth = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We will create the framebuffers to link these GPU images with the renderpass. DvzFramebuffers framebuffers = dvz_framebuffers ( gpu ); // Renderpass creation. create_renderpass ( & renderpass ); // Create attachments and framebuffers. { // Color attachment dvz_images_format ( & image , renderpass . attachments [ 0 ]. format ); dvz_images_size ( & image , width , height , 1 ); dvz_images_tiling ( & image , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & image , VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT ); dvz_images_memory ( & image , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_aspect ( & image , VK_IMAGE_ASPECT_COLOR_BIT ); dvz_images_layout ( & image , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_queue_access ( & image , 0 ); dvz_images_create ( & image ); // Depth attachment. dvz_images_format ( & depth , renderpass . attachments [ 1 ]. format ); dvz_images_size ( & depth , width , height , 1 ); dvz_images_tiling ( & depth , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & depth , VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ); dvz_images_memory ( & depth , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_layout ( & depth , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_aspect ( & depth , VK_IMAGE_ASPECT_DEPTH_BIT ); dvz_images_queue_access ( & depth , 0 ); dvz_images_create ( & depth ); // Create renderpass. dvz_renderpass_create ( & renderpass ); // Create framebuffers. dvz_framebuffers_attachment ( & framebuffers , 0 , & image ); dvz_framebuffers_attachment ( & framebuffers , 1 , & depth ); dvz_framebuffers_create ( & framebuffers , & renderpass ); } // We create a new graphics pipeline. DvzGraphics graphics = dvz_graphics ( gpu ); // Graphics pipeline. { // We set the renderpass. dvz_graphics_renderpass ( & graphics , & renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); } // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. DvzBindings bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for all // graphics pipelines in the application. Defining many small GPU buffers is bad practice. DvzBuffer buffer = dvz_buffer ( gpu ); DvzBufferRegions vertex_buffer ; // Vertex data and GPU buffer. { // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in // real applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); } // We create a command buffer. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); // Command buffer recording. { // We begin recording the command buffer here. dvz_cmd_begin ( & cmds , 0 ); // We begin the default render pass. dvz_cmd_begin_renderpass ( & cmds , 0 , & renderpass , & framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( & cmds , 0 , viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( & cmds , 0 , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( & cmds , 0 , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( & cmds , 0 , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( & cmds , 0 ); dvz_cmd_end ( & cmds , 0 ); } // We submit the command buffer to the GPU and we *wait* until the GPU has finished completing // it. This uses a hard synchronization primitive so this is not efficient. dvz_cmd_submit_sync ( & cmds , 0 ); // We make a screenshot and save it to a file. uint8_t * rgb = screenshot ( & image ); const char * path = \"../../docs/images/screenshots/standalone_vklite.png\" ; dvz_write_png ( path , width , height , rgb ); log_info ( \"offscreen rendered image written to: `%s`\" , path ); // We need to clean up all objects handled by Datoviz at the end. { dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_renderpass_destroy ( & renderpass ); dvz_images_destroy ( & image ); dvz_images_destroy ( & depth ); dvz_framebuffers_destroy ( & framebuffers ); dvz_bindings_destroy ( & bindings ); dvz_app_destroy ( app ); } return 0 ; }","title":"How to use the vklite C API"},{"location":"howto/visual/","text":"How to write a custom visual \u00b6 Warning You need to go through the Vulkan crash course before following this guide. In this section, we'll show how to create a custom visual based on an existing graphics pipeline, so without writing custom GLSL shaders . Note Only the C API supports custom visuals at the moment. Python bindings for custom visuals will come in an upcoming version. The full source code for this example can be found in examples/custom_visual.c . We'll make a square visual that makes it easy to add uniformly-colored squares to the scene. What is a visual? \u00b6 The visual is the most important abstraction in Datoviz. It abstracts away the internal details related to GPU rendering and proposes a user-friendly interface to set up visual elements. Generally speaking, adding a new visual to a panel involves the following steps: choosing one of the existing visuals on the visual reference page, preparing the data to match the format expected by the visual properties, setting the visual properties with the data. Visual properties, or \"props\" \u00b6 Each predefined visual comes with a set of predefined visual properties, also called props . For example, the marker visual has props for: point position, color, marker size, marker type, angle, and so on. The visual reference page presents the list of all predefined visuals along with their sets of props. You'll probably refer a lot to this page since it contains the most important information you'll need for your visualizations. Each prop is defined by: a name, a data type (for example float32 , uint8 ), a description of how the prop is used for rendering. Note The Python API takes care of converting each prop to the correct data type using NumPy ndarray.astype() . Most props accepting floating-point numbers require single-precision format since this is the optimal format for GPUs. The notable exception is the POS prop (position), which requires double-precision data. Datoviz provides an internal CPU-based data transformation system that requires double precision (single-precision would not be acceptable for scientific data handling). Also, visuals that implement triangulation require double precision. Datoviz converts the transformed position to single-precision at the last moment before uploading it to the GPU. Batch rendering \u00b6 Another crucial notion related to visuals is batch rendering . For performance reasons, it is recommended to use as few visuals as possible in a given scene . For example: to display a scatter plot with 100 points, use a single marker visual with 100 points, instead of 100 visuals with one point , to display 100 polygons, use a single polygon visual with 100 items (each containing an arbitrary number of points), instead of 100 visuals , similarly with paths, images, meshes, text, and so on. This allows the GPU to render all of these different objects of the same type in a single draw command (with the same GPU transformation matrices). To define multiple objects with various sizes in a given visual (for example, displaying multiple paths with the same visual), one typically concatenates all points and properties in big arrays (total size is the sum of all object sizes), and use the special prop length to define the length of each object (vector with as many elements as there are different objects). Distinction between graphics and visuals \u00b6 Datoviz makes the distinction between a graphics (graphics pipeline) and a visual : a graphics is a GPU-level object. It is defined by a vertex shader, a fragment shader, a primitive type (point, line, triangle), and other details. a visual is a user-level object. It encapsulates a particular type of visual element and abstracts away the GPU implementation details. A visual is defined by one or several graphics pipelines, optional compute pipelines, and a set of visual properties that allow the user to specify the visual's data. Importantly, the user doesn't need to know the internal implementation details of a visual to use it. It is normally sufficient to know the props specification. Making a custom visual based on existing graphics \u00b6 In this section, we'll show how to create a custom visual by reusing an existing graphics (without writing custom shaders). The main use-case for this scenario is making a visual with a custom CPU data transformation pipeline . An example is polygon triangulation: since the GPU can only render triangles, one needs to triangulate an arbitrary shape before rendering it. The triangulation is implemented at the level of the visual, so that the user can pass the polygon points without having to triangulate it manually. The visual makes the triangulation internally, and generates the triangles required by the underlying graphics pipeline. In the simple example below, we'll implement a simple square visual with a trivial triangulation (two triangles per square). The custom square visual will provide the following props: Type Index Type Description pos 0 dvec3 square center position color 0 cvec4 square color length 0 float edge length The underlying graphics will be the triangle graphics, where three successive vertices define a single independent triangle. Each square will be triangulated into two triangles, or six vertices. This square visual will be easier to use than the triangle one, since the user won't have to deal with triangulation manually. Here is the code to define the three visual props: // pos prop, dvec3 data type dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // color prop, cvec4 data type dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // length prop, float data type dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 ); Vertex shader attributes, vertex buffer, vertex structure \u00b6 To each graphics is associated a particular vertex shader. A vertex shader defines a list of attributes , which correspond to the different vertex inputs. For example, the triangle graphics we will use in this example has two attributes in its vertex shader: // This GLSL code is at the beginning of the triangle graphics vertex shader. // Two attributes: layout ( location = 0 ) in vec3 pos ; // vertex position layout ( location = 1 ) in vec4 color ; // vertex color In Datoviz, the input data feeding these vertex shader attributes is stored in a GPU buffer called the vertex buffer . The GPU buffer contains a contiguous array of structure elements that match exactly these attributes. Here, the vertex structure of the triangle graphics, and of the other basic graphics, is the standard DvzVertex structure: struct DvzVertex { vec3 pos ; // three single-precision floating-point numbers for x, y, z position cvec4 color ; // four uint8 bytes for the r, g, b, a color components } The vertex shader executes in parallel over all structure elements stored in the vertex buffer. We'll see in the custom graphics page more details about how we link this C structure to the GLSL attributes. The main role of the visual is to copy the user-specified props data into the vertex buffer . This is sometimes straightforward, like in the marker visual, where each vertex corresponds to one marker, but it is often less trivial. In the example covered in this page, where we need to transform squares into triangles, our custom visual will need to create six vertices in the vertex buffer for every square passed by the user . This is implemented in the visual baking function . Visual baking function \u00b6 Once the props are defined, the most important step when creating a custom visual is to implement the baking function . The baking function takes the props data as input, and fills in the vertex buffer , as well as, possibly, other GPU data sources (uniforms, storage buffers, textures). Here, the square baking function must recover the pos and length props in order to compute the four corner position of each square, and make the triangulation with two triangles per square. The props and the vertex buffer (and other sources) come with DvzArray instances, which are thin wrappers around 1D arrays of homogeneous data types. They support few features: no multidimensional arrays, no vectorized operations. // The following code snippet contains the body of the baking function. static void _bake_callback ( DvzVisual * visual , DvzVisualDataEvent ev ) { ASSERT ( visual != NULL ); // First, we obtain the array instances holding the prop data as specified by the user. DvzArray * arr_pos = dvz_prop_array ( visual , DVZ_PROP_POS , 0 ); DvzArray * arr_color = dvz_prop_array ( visual , DVZ_PROP_COLOR , 0 ); DvzArray * arr_length = dvz_prop_array ( visual , DVZ_PROP_LENGTH , 0 ); // We also get the array of the vertex buffer, which we'll need to fill with the triangulation. DvzArray * arr_vertex = dvz_source_array ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 ); // The number of rows in the 1D position array (set by the user) is the number of squares // requested by the user. uint32_t square_count = arr_pos -> item_count ; // We resize the vertex buffer array so that it holds six vertices per square (two triangles). dvz_array_resize ( arr_vertex , 6 * square_count ); // Pointers to the input data. dvec3 * pos = NULL ; cvec4 * color = NULL ; float * length = NULL ; // Pointer to the output vertex. DvzVertex * vertex = ( DvzVertex * ) arr_vertex -> data ; // Here, we triangulate each square by computing the position of each square corner. float hl = 0 ; for ( uint32_t i = 0 ; i < square_count ; i ++ ) { // We get a pointer to the current item in each prop array. pos = dvz_array_item ( arr_pos , i ); color = dvz_array_item ( arr_color , i ); length = dvz_array_item ( arr_length , i ); // This is the half of the square size. hl = ( * length ) / 2 ; // First triangle: // Bottom-left corner. vertex [ 6 * i + 0 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 0 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Bottom-right corner. vertex [ 6 * i + 1 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 1 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Top-right corner. vertex [ 6 * i + 2 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 2 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Second triangle: // Top-right corner again. vertex [ 6 * i + 3 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 3 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Top-left corner. vertex [ 6 * i + 4 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 4 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Bottom-left corner (again). vertex [ 6 * i + 5 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 5 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // We copy the square color to each of the six vertices making the current square. // This is a choice made in this example, and it is up to the custom visual creator // to define how the user data, passed via props, will be used to fill in the vertices. for ( uint32_t j = 0 ; j < 6 ; j ++ ) memcpy ( vertex [ 6 * i + j ]. color , color , sizeof ( cvec4 )); } } Putting everything together \u00b6 Here is the code to create the custom visual. // We create a blank visual in the scene. // For demo purposes, we disable the automatic position normalization. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // We add the existing graphics triangle graphics pipeline. dvz_visual_graphics ( visual , dvz_graphics_builtin ( canvas , DVZ_GRAPHICS_TRIANGLE , 0 )); // We add the vertex buffer source, and we must specify the same vertex struct type // as the one used by the graphics pipeline (standard vertex structure, with pos and color). dvz_visual_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , DVZ_PIPELINE_GRAPHICS , 0 , 0 , sizeof ( DvzVertex ), 0 ); // We specify the visual props. dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 ); // We declare our custom baking function. dvz_visual_callback_bake ( visual , _bake_callback ); // Finally, once the custom visual has been created, we can add it to the panel. dvz_custom_visual ( panel , visual ); Once the custom visual has been created and added to the scene, the last step consists of setting some data, as usual: // We define three squares. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , 3 , ( dvec3 []){{ - .5 , 0 , 0 }, { 0 , 0 , 0 }, { + .5 , 0 , 0 }}); // We use a different color for each square. dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , 3 , ( cvec4 []){{ 255 , 0 , 0 , 255 }, { 0 , 255 , 0 , 255 }, { 0 , 0 , 255 , 255 }}); // NOTE: we use the same length for all squares. dvz_visual_data ( visual , DVZ_PROP_LENGTH , 0 , 1 , ( float []){ .25 }); Note that we used a single value for the last prop (edge length). Datoviz uses the convention that a prop may have less values than objects, in which case the last value is repeated over . In particular, defining a prop with a single element means using the same value for all items in the visual. This is a sort of \"broadcasting\" rule (following NumPy's terminology). Other topics \u00b6 We didn't yet cover these other aspects: Position data transformation, Visual parameters stored in the uniform buffer, Visual flags.","title":"How to write a custom visual"},{"location":"howto/visual/#how-to-write-a-custom-visual","text":"Warning You need to go through the Vulkan crash course before following this guide. In this section, we'll show how to create a custom visual based on an existing graphics pipeline, so without writing custom GLSL shaders . Note Only the C API supports custom visuals at the moment. Python bindings for custom visuals will come in an upcoming version. The full source code for this example can be found in examples/custom_visual.c . We'll make a square visual that makes it easy to add uniformly-colored squares to the scene.","title":"How to write a custom visual"},{"location":"howto/visual/#what-is-a-visual","text":"The visual is the most important abstraction in Datoviz. It abstracts away the internal details related to GPU rendering and proposes a user-friendly interface to set up visual elements. Generally speaking, adding a new visual to a panel involves the following steps: choosing one of the existing visuals on the visual reference page, preparing the data to match the format expected by the visual properties, setting the visual properties with the data.","title":"What is a visual?"},{"location":"howto/visual/#visual-properties-or-props","text":"Each predefined visual comes with a set of predefined visual properties, also called props . For example, the marker visual has props for: point position, color, marker size, marker type, angle, and so on. The visual reference page presents the list of all predefined visuals along with their sets of props. You'll probably refer a lot to this page since it contains the most important information you'll need for your visualizations. Each prop is defined by: a name, a data type (for example float32 , uint8 ), a description of how the prop is used for rendering. Note The Python API takes care of converting each prop to the correct data type using NumPy ndarray.astype() . Most props accepting floating-point numbers require single-precision format since this is the optimal format for GPUs. The notable exception is the POS prop (position), which requires double-precision data. Datoviz provides an internal CPU-based data transformation system that requires double precision (single-precision would not be acceptable for scientific data handling). Also, visuals that implement triangulation require double precision. Datoviz converts the transformed position to single-precision at the last moment before uploading it to the GPU.","title":"Visual properties, or \"props\""},{"location":"howto/visual/#batch-rendering","text":"Another crucial notion related to visuals is batch rendering . For performance reasons, it is recommended to use as few visuals as possible in a given scene . For example: to display a scatter plot with 100 points, use a single marker visual with 100 points, instead of 100 visuals with one point , to display 100 polygons, use a single polygon visual with 100 items (each containing an arbitrary number of points), instead of 100 visuals , similarly with paths, images, meshes, text, and so on. This allows the GPU to render all of these different objects of the same type in a single draw command (with the same GPU transformation matrices). To define multiple objects with various sizes in a given visual (for example, displaying multiple paths with the same visual), one typically concatenates all points and properties in big arrays (total size is the sum of all object sizes), and use the special prop length to define the length of each object (vector with as many elements as there are different objects).","title":"Batch rendering"},{"location":"howto/visual/#distinction-between-graphics-and-visuals","text":"Datoviz makes the distinction between a graphics (graphics pipeline) and a visual : a graphics is a GPU-level object. It is defined by a vertex shader, a fragment shader, a primitive type (point, line, triangle), and other details. a visual is a user-level object. It encapsulates a particular type of visual element and abstracts away the GPU implementation details. A visual is defined by one or several graphics pipelines, optional compute pipelines, and a set of visual properties that allow the user to specify the visual's data. Importantly, the user doesn't need to know the internal implementation details of a visual to use it. It is normally sufficient to know the props specification.","title":"Distinction between graphics and visuals"},{"location":"howto/visual/#making-a-custom-visual-based-on-existing-graphics","text":"In this section, we'll show how to create a custom visual by reusing an existing graphics (without writing custom shaders). The main use-case for this scenario is making a visual with a custom CPU data transformation pipeline . An example is polygon triangulation: since the GPU can only render triangles, one needs to triangulate an arbitrary shape before rendering it. The triangulation is implemented at the level of the visual, so that the user can pass the polygon points without having to triangulate it manually. The visual makes the triangulation internally, and generates the triangles required by the underlying graphics pipeline. In the simple example below, we'll implement a simple square visual with a trivial triangulation (two triangles per square). The custom square visual will provide the following props: Type Index Type Description pos 0 dvec3 square center position color 0 cvec4 square color length 0 float edge length The underlying graphics will be the triangle graphics, where three successive vertices define a single independent triangle. Each square will be triangulated into two triangles, or six vertices. This square visual will be easier to use than the triangle one, since the user won't have to deal with triangulation manually. Here is the code to define the three visual props: // pos prop, dvec3 data type dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // color prop, cvec4 data type dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // length prop, float data type dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 );","title":"Making a custom visual based on existing graphics"},{"location":"howto/visual/#vertex-shader-attributes-vertex-buffer-vertex-structure","text":"To each graphics is associated a particular vertex shader. A vertex shader defines a list of attributes , which correspond to the different vertex inputs. For example, the triangle graphics we will use in this example has two attributes in its vertex shader: // This GLSL code is at the beginning of the triangle graphics vertex shader. // Two attributes: layout ( location = 0 ) in vec3 pos ; // vertex position layout ( location = 1 ) in vec4 color ; // vertex color In Datoviz, the input data feeding these vertex shader attributes is stored in a GPU buffer called the vertex buffer . The GPU buffer contains a contiguous array of structure elements that match exactly these attributes. Here, the vertex structure of the triangle graphics, and of the other basic graphics, is the standard DvzVertex structure: struct DvzVertex { vec3 pos ; // three single-precision floating-point numbers for x, y, z position cvec4 color ; // four uint8 bytes for the r, g, b, a color components } The vertex shader executes in parallel over all structure elements stored in the vertex buffer. We'll see in the custom graphics page more details about how we link this C structure to the GLSL attributes. The main role of the visual is to copy the user-specified props data into the vertex buffer . This is sometimes straightforward, like in the marker visual, where each vertex corresponds to one marker, but it is often less trivial. In the example covered in this page, where we need to transform squares into triangles, our custom visual will need to create six vertices in the vertex buffer for every square passed by the user . This is implemented in the visual baking function .","title":"Vertex shader attributes, vertex buffer, vertex structure"},{"location":"howto/visual/#visual-baking-function","text":"Once the props are defined, the most important step when creating a custom visual is to implement the baking function . The baking function takes the props data as input, and fills in the vertex buffer , as well as, possibly, other GPU data sources (uniforms, storage buffers, textures). Here, the square baking function must recover the pos and length props in order to compute the four corner position of each square, and make the triangulation with two triangles per square. The props and the vertex buffer (and other sources) come with DvzArray instances, which are thin wrappers around 1D arrays of homogeneous data types. They support few features: no multidimensional arrays, no vectorized operations. // The following code snippet contains the body of the baking function. static void _bake_callback ( DvzVisual * visual , DvzVisualDataEvent ev ) { ASSERT ( visual != NULL ); // First, we obtain the array instances holding the prop data as specified by the user. DvzArray * arr_pos = dvz_prop_array ( visual , DVZ_PROP_POS , 0 ); DvzArray * arr_color = dvz_prop_array ( visual , DVZ_PROP_COLOR , 0 ); DvzArray * arr_length = dvz_prop_array ( visual , DVZ_PROP_LENGTH , 0 ); // We also get the array of the vertex buffer, which we'll need to fill with the triangulation. DvzArray * arr_vertex = dvz_source_array ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 ); // The number of rows in the 1D position array (set by the user) is the number of squares // requested by the user. uint32_t square_count = arr_pos -> item_count ; // We resize the vertex buffer array so that it holds six vertices per square (two triangles). dvz_array_resize ( arr_vertex , 6 * square_count ); // Pointers to the input data. dvec3 * pos = NULL ; cvec4 * color = NULL ; float * length = NULL ; // Pointer to the output vertex. DvzVertex * vertex = ( DvzVertex * ) arr_vertex -> data ; // Here, we triangulate each square by computing the position of each square corner. float hl = 0 ; for ( uint32_t i = 0 ; i < square_count ; i ++ ) { // We get a pointer to the current item in each prop array. pos = dvz_array_item ( arr_pos , i ); color = dvz_array_item ( arr_color , i ); length = dvz_array_item ( arr_length , i ); // This is the half of the square size. hl = ( * length ) / 2 ; // First triangle: // Bottom-left corner. vertex [ 6 * i + 0 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 0 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Bottom-right corner. vertex [ 6 * i + 1 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 1 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Top-right corner. vertex [ 6 * i + 2 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 2 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Second triangle: // Top-right corner again. vertex [ 6 * i + 3 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 3 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Top-left corner. vertex [ 6 * i + 4 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 4 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Bottom-left corner (again). vertex [ 6 * i + 5 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 5 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // We copy the square color to each of the six vertices making the current square. // This is a choice made in this example, and it is up to the custom visual creator // to define how the user data, passed via props, will be used to fill in the vertices. for ( uint32_t j = 0 ; j < 6 ; j ++ ) memcpy ( vertex [ 6 * i + j ]. color , color , sizeof ( cvec4 )); } }","title":"Visual baking function"},{"location":"howto/visual/#putting-everything-together","text":"Here is the code to create the custom visual. // We create a blank visual in the scene. // For demo purposes, we disable the automatic position normalization. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // We add the existing graphics triangle graphics pipeline. dvz_visual_graphics ( visual , dvz_graphics_builtin ( canvas , DVZ_GRAPHICS_TRIANGLE , 0 )); // We add the vertex buffer source, and we must specify the same vertex struct type // as the one used by the graphics pipeline (standard vertex structure, with pos and color). dvz_visual_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , DVZ_PIPELINE_GRAPHICS , 0 , 0 , sizeof ( DvzVertex ), 0 ); // We specify the visual props. dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 ); // We declare our custom baking function. dvz_visual_callback_bake ( visual , _bake_callback ); // Finally, once the custom visual has been created, we can add it to the panel. dvz_custom_visual ( panel , visual ); Once the custom visual has been created and added to the scene, the last step consists of setting some data, as usual: // We define three squares. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , 3 , ( dvec3 []){{ - .5 , 0 , 0 }, { 0 , 0 , 0 }, { + .5 , 0 , 0 }}); // We use a different color for each square. dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , 3 , ( cvec4 []){{ 255 , 0 , 0 , 255 }, { 0 , 255 , 0 , 255 }, { 0 , 0 , 255 , 255 }}); // NOTE: we use the same length for all squares. dvz_visual_data ( visual , DVZ_PROP_LENGTH , 0 , 1 , ( float []){ .25 }); Note that we used a single value for the last prop (edge length). Datoviz uses the convention that a prop may have less values than objects, in which case the last value is repeated over . In particular, defining a prop with a single element means using the same value for all items in the visual. This is a sort of \"broadcasting\" rule (following NumPy's terminology).","title":"Putting everything together"},{"location":"howto/visual/#other-topics","text":"We didn't yet cover these other aspects: Position data transformation, Visual parameters stored in the uniform buffer, Visual flags.","title":"Other topics"},{"location":"reference/","text":"Reference \u00b6 This section provides a reference of: Library of visuals , Library of graphics , Library of colormaps , Library of controllers , and the list of supported event types.","title":"Index"},{"location":"reference/#reference","text":"This section provides a reference of: Library of visuals , Library of graphics , Library of colormaps , Library of controllers , and the list of supported event types.","title":"Reference"},{"location":"reference/colormaps/","text":"Colormaps \u00b6 Datoviz natively includes a collection of common colormaps, both continuous and discrete (color palettes). These colormaps come from the following sources: matplotlib bokeh colorcet Kenneth Moreland's page These colormaps are stored in a 256x256 texture. Each row contains either: a 256-color continuous colormap, a 256-color discrete color palette, eight discrete 32-color palettes. Unused space may be used for future or user-defined colormaps. The texture is always loaded both in CPU and GPU memory. It is shared between all visuals and canvases. Datoviz provides a few functions to easily make colors out of scalar values: Python import numpy as np from datoviz import colormap values = np . random . rand ( 1000 ) colors = colormap ( values , vmin = 0 , vmax = 1 , cmap = 'viridis' ) print ( colors ) # output: # [[126 210 78 255] # [ 64 68 135 255] # [ 36 170 130 255] # ... # [ 36 132 141 255] # [ 61 75 137 255] # [ 31 148 139 255]] C DvzColormap cmap = DVZ_CMAP_VIRIDIS ; cvec4 color = { 0 }; uint8_t value = 128 ; double dvalue = .5 ; // Get a single color from a byte. dvz_colormap ( cmap , 128 , color ); // Get a single color from a double, with a custom vmin-vmax range. dvz_colormap_scale ( cmap , dvalue , 0 , 1 , color ); // Get an array of colors from an array of values. const uint32_t N = 10 ; double * values = calloc ( N , sizeof ( double )); cvec4 * colors = calloc ( N , sizeof ( cvec4 )); dvz_colormap_array ( cmap , N , values , 0 , 1 , colors ); FREE ( values ); FREE ( colors ); List of colormaps and color palettes \u00b6 Note The row and col give the offset of the colormap or color palette within the 256x256 colormap texture. Name Row, Col Colormap binary 0, 0 hsv 1, 0 cividis 2, 0 inferno 3, 0 magma 4, 0 plasma 5, 0 viridis 6, 0 blues 7, 0 bugn 8, 0 bupu 9, 0 gnbu 10, 0 greens 11, 0 greys 12, 0 oranges 13, 0 orrd 14, 0 pubu 15, 0 pubugn 16, 0 purples 17, 0 rdpu 18, 0 reds 19, 0 ylgn 20, 0 ylgnbu 21, 0 ylorbr 22, 0 ylorrd 23, 0 afmhot 24, 0 autumn 25, 0 bone 26, 0 cool 27, 0 copper 28, 0 gist_heat 29, 0 gray 30, 0 hot 31, 0 pink 32, 0 spring 33, 0 summer 34, 0 winter 35, 0 wistia 36, 0 brbg 37, 0 bwr 38, 0 coolwarm 39, 0 piyg 40, 0 prgn 41, 0 puor 42, 0 rdbu 43, 0 rdgy 44, 0 rdylbu 45, 0 rdylgn 46, 0 seismic 47, 0 spectral 48, 0 twilight_shifted 49, 0 twilight 50, 0 brg 51, 0 cmrmap 52, 0 cubehelix 53, 0 flag 54, 0 gist_earth 55, 0 gist_ncar 56, 0 gist_rainbow 57, 0 gist_stern 58, 0 gnuplot2 59, 0 gnuplot 60, 0 jet 61, 0 nipy_spectral 62, 0 ocean 63, 0 prism 64, 0 rainbow 65, 0 terrain 66, 0 bkr 67, 0 bky 68, 0 cet_d10 69, 0 cet_d11 70, 0 cet_d8 71, 0 cet_d13 72, 0 cet_d3 73, 0 cet_d1a 74, 0 bjy 75, 0 gwv 76, 0 bwy 77, 0 cet_d12 78, 0 cet_r3 79, 0 cet_d9 80, 0 cwr 81, 0 cet_cbc1 82, 0 cet_cbc2 83, 0 cet_cbl1 84, 0 cet_cbl2 85, 0 cet_cbtc1 86, 0 cet_cbtc2 87, 0 cet_cbtl1 88, 0 bgy 89, 0 bgyw 90, 0 bmw 91, 0 cet_c1 92, 0 cet_c1s 93, 0 cet_c2 94, 0 cet_c4 95, 0 cet_c4s 96, 0 cet_c5 97, 0 cet_i1 98, 0 cet_i3 99, 0 cet_l10 100, 0 cet_l11 101, 0 cet_l12 102, 0 cet_l16 103, 0 cet_l17 104, 0 cet_l18 105, 0 cet_l19 106, 0 cet_l4 107, 0 cet_l7 108, 0 cet_l8 109, 0 cet_l9 110, 0 cet_r1 111, 0 cet_r2 112, 0 colorwheel 113, 0 fire 114, 0 isolum 115, 0 kb 116, 0 kbc 117, 0 kg 118, 0 kgy 119, 0 kr 120, 0 black_body 121, 0 kindlmann 122, 0 extended_kindlmann 123, 0 glasbey 176, 0 glasbey_cool 177, 0 glasbey_dark 178, 0 glasbey_hv 179, 0 glasbey_light 180, 0 glasbey_warm 181, 0 accent 240, 0 dark2 240, 32 paired 240, 64 pastel1 240, 96 pastel2 240, 128 set1 240, 160 set2 240, 192 set3 240, 224 tab10 241, 0 tab20 241, 32 tab20b 241, 64 tab20c 241, 96 category10_10 241, 128 category20_20 241, 160 category20b_20 241, 192 category20c_20 241, 224 colorblind8 242, 0","title":"Library of colormaps"},{"location":"reference/colormaps/#colormaps","text":"Datoviz natively includes a collection of common colormaps, both continuous and discrete (color palettes). These colormaps come from the following sources: matplotlib bokeh colorcet Kenneth Moreland's page These colormaps are stored in a 256x256 texture. Each row contains either: a 256-color continuous colormap, a 256-color discrete color palette, eight discrete 32-color palettes. Unused space may be used for future or user-defined colormaps. The texture is always loaded both in CPU and GPU memory. It is shared between all visuals and canvases. Datoviz provides a few functions to easily make colors out of scalar values: Python import numpy as np from datoviz import colormap values = np . random . rand ( 1000 ) colors = colormap ( values , vmin = 0 , vmax = 1 , cmap = 'viridis' ) print ( colors ) # output: # [[126 210 78 255] # [ 64 68 135 255] # [ 36 170 130 255] # ... # [ 36 132 141 255] # [ 61 75 137 255] # [ 31 148 139 255]] C DvzColormap cmap = DVZ_CMAP_VIRIDIS ; cvec4 color = { 0 }; uint8_t value = 128 ; double dvalue = .5 ; // Get a single color from a byte. dvz_colormap ( cmap , 128 , color ); // Get a single color from a double, with a custom vmin-vmax range. dvz_colormap_scale ( cmap , dvalue , 0 , 1 , color ); // Get an array of colors from an array of values. const uint32_t N = 10 ; double * values = calloc ( N , sizeof ( double )); cvec4 * colors = calloc ( N , sizeof ( cvec4 )); dvz_colormap_array ( cmap , N , values , 0 , 1 , colors ); FREE ( values ); FREE ( colors );","title":"Colormaps"},{"location":"reference/colormaps/#list-of-colormaps-and-color-palettes","text":"Note The row and col give the offset of the colormap or color palette within the 256x256 colormap texture. Name Row, Col Colormap binary 0, 0 hsv 1, 0 cividis 2, 0 inferno 3, 0 magma 4, 0 plasma 5, 0 viridis 6, 0 blues 7, 0 bugn 8, 0 bupu 9, 0 gnbu 10, 0 greens 11, 0 greys 12, 0 oranges 13, 0 orrd 14, 0 pubu 15, 0 pubugn 16, 0 purples 17, 0 rdpu 18, 0 reds 19, 0 ylgn 20, 0 ylgnbu 21, 0 ylorbr 22, 0 ylorrd 23, 0 afmhot 24, 0 autumn 25, 0 bone 26, 0 cool 27, 0 copper 28, 0 gist_heat 29, 0 gray 30, 0 hot 31, 0 pink 32, 0 spring 33, 0 summer 34, 0 winter 35, 0 wistia 36, 0 brbg 37, 0 bwr 38, 0 coolwarm 39, 0 piyg 40, 0 prgn 41, 0 puor 42, 0 rdbu 43, 0 rdgy 44, 0 rdylbu 45, 0 rdylgn 46, 0 seismic 47, 0 spectral 48, 0 twilight_shifted 49, 0 twilight 50, 0 brg 51, 0 cmrmap 52, 0 cubehelix 53, 0 flag 54, 0 gist_earth 55, 0 gist_ncar 56, 0 gist_rainbow 57, 0 gist_stern 58, 0 gnuplot2 59, 0 gnuplot 60, 0 jet 61, 0 nipy_spectral 62, 0 ocean 63, 0 prism 64, 0 rainbow 65, 0 terrain 66, 0 bkr 67, 0 bky 68, 0 cet_d10 69, 0 cet_d11 70, 0 cet_d8 71, 0 cet_d13 72, 0 cet_d3 73, 0 cet_d1a 74, 0 bjy 75, 0 gwv 76, 0 bwy 77, 0 cet_d12 78, 0 cet_r3 79, 0 cet_d9 80, 0 cwr 81, 0 cet_cbc1 82, 0 cet_cbc2 83, 0 cet_cbl1 84, 0 cet_cbl2 85, 0 cet_cbtc1 86, 0 cet_cbtc2 87, 0 cet_cbtl1 88, 0 bgy 89, 0 bgyw 90, 0 bmw 91, 0 cet_c1 92, 0 cet_c1s 93, 0 cet_c2 94, 0 cet_c4 95, 0 cet_c4s 96, 0 cet_c5 97, 0 cet_i1 98, 0 cet_i3 99, 0 cet_l10 100, 0 cet_l11 101, 0 cet_l12 102, 0 cet_l16 103, 0 cet_l17 104, 0 cet_l18 105, 0 cet_l19 106, 0 cet_l4 107, 0 cet_l7 108, 0 cet_l8 109, 0 cet_l9 110, 0 cet_r1 111, 0 cet_r2 112, 0 colorwheel 113, 0 fire 114, 0 isolum 115, 0 kb 116, 0 kbc 117, 0 kg 118, 0 kgy 119, 0 kr 120, 0 black_body 121, 0 kindlmann 122, 0 extended_kindlmann 123, 0 glasbey 176, 0 glasbey_cool 177, 0 glasbey_dark 178, 0 glasbey_hv 179, 0 glasbey_light 180, 0 glasbey_warm 181, 0 accent 240, 0 dark2 240, 32 paired 240, 64 pastel1 240, 96 pastel2 240, 128 set1 240, 160 set2 240, 192 set3 240, 224 tab10 241, 0 tab20 241, 32 tab20b 241, 64 tab20c 241, 96 category10_10 241, 128 category20_20 241, 160 category20b_20 241, 192 category20c_20 241, 224 colorblind8 242, 0","title":"List of colormaps and color palettes"},{"location":"reference/controllers/","text":"Controllers \u00b6 List of controllers \u00b6 When creating a new panel, one needs to specify a Controller . This object defines how the user interacts with the panel. The controllers currently implemented are: static : no interactivity, panzoom : pan and zoom with the mouse, axes : axes with ticks, tick labels, grid, and interactivity with pan and zoom, arcbcall : static 3D camera, model rotation with the mouse, camera : first-person 3D camera. More controllers will be implemented in the future. The C interface used to create custom controllers will be refined too. Panzoom \u00b6 The panzoom controller provides mouse interaction patterns for panning and zooming: Mouse dragging with left button : pan Mouse dragging with right button : zoom in x and y axis independently Mouse wheel : zoom in and out in both axes simultaneously Double-click with left button : reset to initial view Axes 2D \u00b6 The axes 2D controller displays ticks, tick labels, grid and provides panzoom interaction. Arcball \u00b6 The arcball controller is used to rotate a 3D object in all directions using the mouse. It is implemented with quaternions. First-person camera \u00b6 Left-dragging controls the camera, the arrow keys control the position, the Z is controlled by the mouse wheel. List of event types \u00b6 Name Description init called at the beginning of the first frame frame called at every frame refill called when the command buffers need to be recreated (e.g. window resize) resize called when the window is resized timer called in the main loop at regular time intervals mouse_press called when a mouse button is pressed mouse_release called when a mouse button is released mouse_move called when the mouse moves mouse_wheel called when the mouse wheel moves mouse_drag_begin called when a mouse drag operation begins mouse_drag_end called when a mouse drag operation ends mouse_click called after a single click mouse_double_click called after a double click key_press called when a key is pressed key_release called when a key is released","title":"Library of controllers"},{"location":"reference/controllers/#controllers","text":"","title":"Controllers"},{"location":"reference/controllers/#list-of-controllers","text":"When creating a new panel, one needs to specify a Controller . This object defines how the user interacts with the panel. The controllers currently implemented are: static : no interactivity, panzoom : pan and zoom with the mouse, axes : axes with ticks, tick labels, grid, and interactivity with pan and zoom, arcbcall : static 3D camera, model rotation with the mouse, camera : first-person 3D camera. More controllers will be implemented in the future. The C interface used to create custom controllers will be refined too.","title":"List of controllers"},{"location":"reference/controllers/#panzoom","text":"The panzoom controller provides mouse interaction patterns for panning and zooming: Mouse dragging with left button : pan Mouse dragging with right button : zoom in x and y axis independently Mouse wheel : zoom in and out in both axes simultaneously Double-click with left button : reset to initial view","title":"Panzoom"},{"location":"reference/controllers/#axes-2d","text":"The axes 2D controller displays ticks, tick labels, grid and provides panzoom interaction.","title":"Axes 2D"},{"location":"reference/controllers/#arcball","text":"The arcball controller is used to rotate a 3D object in all directions using the mouse. It is implemented with quaternions.","title":"Arcball"},{"location":"reference/controllers/#first-person-camera","text":"Left-dragging controls the camera, the arrow keys control the position, the Z is controlled by the mouse wheel.","title":"First-person camera"},{"location":"reference/controllers/#list-of-event-types","text":"Name Description init called at the beginning of the first frame frame called at every frame refill called when the command buffers need to be recreated (e.g. window resize) resize called when the window is resized timer called in the main loop at regular time intervals mouse_press called when a mouse button is pressed mouse_release called when a mouse button is released mouse_move called when the mouse moves mouse_wheel called when the mouse wheel moves mouse_drag_begin called when a mouse drag operation begins mouse_drag_end called when a mouse drag operation ends mouse_click called after a single click mouse_double_click called after a double click key_press called when a key is pressed key_release called when a key is released","title":"List of event types"},{"location":"reference/graphics/","text":"Graphics library \u00b6 This page lists all included graphics. The list is divided into: 2D graphics : high-quality antialiased 2D graphical elements, 3D graphics : meshes and volumes, Basic graphics : basic, low-quality, aliased, but fast basic primitives (points, lines, triangles), useful for demo, testing, and when dealing with tens of millions of points Note If not specified, the default vertex structure is DvzVertex : Field Type Description pos vec3 position color cvec4 color RGBA (four bytes) 2D graphics \u00b6 Marker \u00b6 DvzGraphicsMarkerVertex \u00b6 Field Type Description {'dtype': 'vec3', 'name': 'pos', 'desc': 'position'} vec3 position {'dtype': 'cvec4', 'name': 'color', 'desc': 'color'} cvec4 color {'dtype': 'float', 'name': 'size', 'desc': 'marker size, in pixels'} float marker size, in pixels {'dtype': 'uint8_t', 'name': 'marker', 'desc': 'marker type enum'} uint8_t marker type enum {'dtype': 'uint8_t', 'name': 'angle', 'desc': 'angle, between 0 (0) included and 256 (M_2PI) excluded'} uint8_t angle, between 0 (0) included and 256 (M_2PI) excluded {'dtype': 'uint8_t', 'name': 'transform', 'desc': 'transform enum'} uint8_t transform enum DvzGraphicsMarkerParams \u00b6 Field Type Description {'dtype': 'vec4', 'name': 'edge_color', 'desc': 'edge color RGBA'} vec4 edge color RGBA {'dtype': 'float', 'name': 'edge_width', 'desc': 'line width, in pixels'} float line width, in pixels Segment \u00b6 DvzGraphicsSegmentVertex \u00b6 Field Type Description {'dtype': 'vec3', 'name': 'P0', 'desc': 'start position'} vec3 start position {'dtype': 'vec3', 'name': 'P1', 'desc': 'end position'} vec3 end position {'dtype': 'vec4', 'name': 'shift', 'desc': 'shift of start (xy) and end (zw) positions, in pixels'} vec4 shift of start (xy) and end (zw) positions, in pixels {'dtype': 'cvec4', 'name': 'color', 'desc': 'color'} cvec4 color {'dtype': 'float', 'name': 'linewidth', 'desc': 'line width, in pixels'} float line width, in pixels {'dtype': 'DvzCapType', 'name': 'cap0', 'desc': 'start cap enum'} DvzCapType start cap enum {'dtype': 'DvzCapType', 'name': 'cap1', 'desc': 'end cap enum'} DvzCapType end cap enum {'dtype': 'uint8_t', 'name': 'transform', 'desc': 'transform enum'} uint8_t transform enum Path \u00b6 DvzGraphicsPathVertex \u00b6 Field Type Description {'dtype': 'vec3', 'name': 'p0', 'desc': 'previous position'} vec3 previous position {'dtype': 'vec3', 'name': 'p1', 'desc': 'current position'} vec3 current position {'dtype': 'vec3', 'name': 'p2', 'desc': 'next position'} vec3 next position {'dtype': 'vec3', 'name': 'p3', 'desc': 'next next position'} vec3 next next position {'dtype': 'cvec4', 'name': 'color', 'desc': 'point color'} cvec4 point color DvzGraphicsPathParams \u00b6 Field Type Description {'dtype': 'float', 'name': 'linewidth', 'desc': 'line width in pixels'} float line width in pixels {'dtype': 'float', 'name': 'miter_limit', 'desc': 'miter limit for joins'} float miter limit for joins {'dtype': 'int32_t', 'name': 'cap_type', 'desc': 'type of the ends of the path'} int32_t type of the ends of the path {'dtype': 'int32_t', 'name': 'round_join', 'desc': 'whether to use round joins'} int32_t whether to use round joins Text \u00b6 DvzGraphicsTextItem \u00b6 Field Type Description {'dtype': 'DvzGraphicsTextVertex', 'name': 'vertex', 'desc': 'text vertex'} DvzGraphicsTextVertex text vertex {'dtype': 'cvec4*', 'name': 'glyph_colors', 'desc': 'glyph colors'} cvec4* glyph colors {'dtype': 'float', 'name': 'font_size', 'desc': 'font size'} float font size {'dtype': 'char*', 'name': 'string', 'const': 'const', 'desc': 'text string'} const char* text string DvzGraphicsTextVertex \u00b6 Field Type Description {'dtype': 'vec3', 'name': 'pos', 'desc': 'position'} vec3 position {'dtype': 'vec2', 'name': 'shift', 'desc': 'shift, in pixels'} vec2 shift, in pixels {'dtype': 'cvec4', 'name': 'color', 'desc': 'color'} cvec4 color {'dtype': 'vec2', 'name': 'glyph_size', 'desc': 'glyph size, in pixels'} vec2 glyph size, in pixels {'dtype': 'vec2', 'name': 'anchor', 'desc': 'character anchor, in normalized coordinates'} vec2 character anchor, in normalized coordinates {'dtype': 'float', 'name': 'angle', 'desc': 'string angle'} float string angle {'dtype': 'usvec4', 'name': 'glyph', 'desc': 'glyph: char code, char index, string length, string index'} usvec4 glyph: char code, char index, string length, string index {'dtype': 'uint8_t', 'name': 'transform', 'desc': 'transform enum'} uint8_t transform enum DvzGraphicsTextParams \u00b6 Field Type Description {'dtype': 'ivec2', 'name': 'grid_size', 'desc': 'font atlas grid size (rows, columns)'} ivec2 font atlas grid size (rows, columns) {'dtype': 'ivec2', 'name': 'tex_size', 'desc': 'font atlas texture size, in pixels'} ivec2 font atlas texture size, in pixels Image \u00b6 DvzGraphicsImageItem \u00b6 Field Type Description {'dtype': 'vec3', 'name': 'pos0', 'desc': 'top left corner'} vec3 top left corner {'dtype': 'vec3', 'name': 'pos1', 'desc': 'top right corner'} vec3 top right corner {'dtype': 'vec3', 'name': 'pos2', 'desc': 'bottom right corner'} vec3 bottom right corner {'dtype': 'vec3', 'name': 'pos3', 'desc': 'bottom left corner'} vec3 bottom left corner {'dtype': 'vec2', 'name': 'uv0', 'desc': 'tex coords of the top left corner'} vec2 tex coords of the top left corner {'dtype': 'vec2', 'name': 'uv1', 'desc': 'tex coords of the top right corner'} vec2 tex coords of the top right corner {'dtype': 'vec2', 'name': 'uv2', 'desc': 'tex coords of the bottom right corner'} vec2 tex coords of the bottom right corner {'dtype': 'vec2', 'name': 'uv3', 'desc': 'tex coords of the bottom left corner'} vec2 tex coords of the bottom left corner DvzGraphicsImageVertex \u00b6 Field Type Description {'dtype': 'vec3', 'name': 'pos', 'desc': 'position'} vec3 position {'dtype': 'vec2', 'name': 'uv', 'desc': 'tex coordinates'} vec2 tex coordinates DvzGraphicsImageParams \u00b6 Field Type Description {'dtype': 'vec4', 'name': 'tex_coefs', 'desc': 'blending coefficients for the four images'} vec4 blending coefficients for the four images 3D graphics \u00b6 Mesh \u00b6 DvzGraphicsMeshVertex \u00b6 Field Type Description {'dtype': 'vec4', 'name': 'pos', 'desc': 'position'} vec4 position {'dtype': 'vec4', 'name': 'normal', 'desc': 'normal vector'} vec4 normal vector {'dtype': 'vec2', 'name': 'uv', 'desc': 'tex coords'} vec2 tex coords {'dtype': 'uint8_t', 'name': 'alpha', 'desc': 'transparency value'} uint8_t transparency value DvzGraphicsMeshParams \u00b6 Field Type Description {'dtype': 'mat4', 'name': 'lights_pos_0', 'desc': 'positions of each of the maximum four lights'} mat4 positions of each of the maximum four lights {'dtype': 'mat4', 'name': 'lights_params_0', 'desc': 'ambient, diffuse, specular coefs for each light'} mat4 ambient, diffuse, specular coefs for each light {'dtype': 'vec4', 'name': 'tex_coefs', 'desc': 'blending coefficients for the four textures'} vec4 blending coefficients for the four textures {'dtype': 'vec4', 'name': 'clip_coefs', 'desc': 'clip coefficients'} vec4 clip coefficients The mesh graphics supports the following features: Phong shading Up to four textures Customizable texture blending coefficients Transparency (but does not play well with depth test) Support for arbitrary RGB values (via cvec3 packing into vec2) Customizable plane clipping Plane clipping: when the clip vector is non-zero, the fragment shader implements the following test. If the dot product of the clip vector with the vertex position (in scene coordinates) is negative, the fragment is discarded. This feature allows to cut the mesh along any arbitrary affine plane. Basic graphics \u00b6 Points \u00b6 DvzGraphicsPointParams \u00b6 Field Type Description {'dtype': 'float', 'name': 'point_size', 'desc': 'point size, in pixels'} float point size, in pixels Lines \u00b6 Line strip \u00b6 Triangles \u00b6 Triangle strip \u00b6 Triangle fan \u00b6 Warning Triangle fan graphics is not supported on macOS and should therefore be avoided if macOS compatibility is desirable.","title":"Library of graphics"},{"location":"reference/graphics/#graphics-library","text":"This page lists all included graphics. The list is divided into: 2D graphics : high-quality antialiased 2D graphical elements, 3D graphics : meshes and volumes, Basic graphics : basic, low-quality, aliased, but fast basic primitives (points, lines, triangles), useful for demo, testing, and when dealing with tens of millions of points Note If not specified, the default vertex structure is DvzVertex : Field Type Description pos vec3 position color cvec4 color RGBA (four bytes)","title":"Graphics library"},{"location":"reference/graphics/#2d-graphics","text":"","title":"2D graphics"},{"location":"reference/graphics/#marker","text":"","title":"Marker"},{"location":"reference/graphics/#segment","text":"","title":"Segment"},{"location":"reference/graphics/#path","text":"","title":"Path"},{"location":"reference/graphics/#text","text":"","title":"Text"},{"location":"reference/graphics/#image","text":"","title":"Image"},{"location":"reference/graphics/#3d-graphics","text":"","title":"3D graphics"},{"location":"reference/graphics/#mesh","text":"","title":"Mesh"},{"location":"reference/graphics/#basic-graphics","text":"","title":"Basic graphics"},{"location":"reference/graphics/#points","text":"","title":"Points"},{"location":"reference/graphics/#lines","text":"","title":"Lines"},{"location":"reference/graphics/#line-strip","text":"","title":"Line strip"},{"location":"reference/graphics/#triangles","text":"","title":"Triangles"},{"location":"reference/graphics/#triangle-strip","text":"","title":"Triangle strip"},{"location":"reference/graphics/#triangle-fan","text":"Warning Triangle fan graphics is not supported on macOS and should therefore be avoided if macOS compatibility is desirable.","title":"Triangle fan"},{"location":"reference/visuals/","text":"Visuals \u00b6 This page lists all visuals currently implemented in the library. Important Be sure to read the technical notes at the end of this page. 2D visuals \u00b6 Marker \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 marker position color 0 cvec4 marker color marker_size 0 float marker size marker_type 0 char marker type angle 0 char marker angle, between 0 (0) and 256 ( M_2PI ) excluded transform 0 char transform enum color 1 vec4 edge color ( uniform ) line_width 0 float edge line width ( uniform ) Marker types \u00b6 Note Marker shapes are computed in real-time in the fragment shader (vector graphics rather than bitmaps). The GLSL code is from Rougier 2014, Antialiased 2D Grid, Marker, and Arrow Shaders . Marker Value Image disc 0 asterisk 1 chevron 2 clover 3 club 4 cross 5 diamond 6 arrow 7 ellipse 8 hbar 9 heart 10 infinity 11 pin 12 ring 13 spade 14 square 15 tag 16 triangle 17 vbar 18 Path \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 all path points, concatenated length 0 uint path lengths, one integer per path color 0 cvec4 point colors, one per point topology 0 DvzPathTopology (int) topology of each path (0=open, 1=closed) line_width 0 float line width of all paths ( uniform ) cap_type 0 DvzCapType (int) cap type ( uniform ) join_type 0 DvzJoinType (int) join type ( uniform ) Polygon \u00b6 This visual currently only uses a basic triangle underlying graphics. It performs a triangulation of the polygons with the earcut C++ library by mapbox. Several arbitrary-sized polygons can be specified in the same visual. Props \u00b6 Type Index Type Description pos 0 dvec3 all polygon points, concatenated length 0 uint polygon lengths, one integer per polygon color 0 cvec4 polygon colors, one per polygon Image \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 top left position pos 1 dvec3 top right position pos 2 dvec3 bottom right position pos 3 dvec3 bottom left position texcoords 0 vec3 top left texture coordinates texcoords 1 vec3 top right texture coordinates texcoords 2 vec3 bottom right texture coordinates texcoords 3 vec3 bottom left texture coordinates Sources \u00b6 Type Index Description vertex 0 vertex buffer param 0 parameter struct image 0..3 2D texture with image #i Scalar image with colormap \u00b6 This visual is similar to the image visual, except that it accepts scalar images and colormaps computed on the GPU. Props \u00b6 Type Index Type Description pos 0 dvec3 top left position pos 1 dvec3 top right position pos 2 dvec3 bottom right position pos 3 dvec3 bottom left position texcoords 0 vec3 top left texture coordinates texcoords 1 vec3 top right texture coordinates texcoords 2 vec3 bottom right texture coordinates texcoords 3 vec3 bottom left texture coordinates vrange 0 vec2 colormap range ( uniform ) cmap 0 int colormap number ( uniform ) Sources \u00b6 Type Index Description vertex 0 vertex buffer param 0 parameter struct color_texture 0 colormap texture image 0 2D texture with image Axes \u00b6 Tick level \u00b6 Index Level Description 0 minor minor ticks 1 major major ticks 2 grid grid 3 lim axes delimiters Graphics \u00b6 Index Graphics Description 0 segment ticks (minor, major, grid, lim) 1 text tick labels Props \u00b6 Type Index Type Graphics Description pos any level double segment tick positions in data coordinates color any level cvec4 segment tick colors line_width any level float segment tick line width length minor float segment minor tick length length major float segment major tick length text 0 str text tick labels text text_size 0 float text tick labels font size Sources \u00b6 Type Index Graphics Description vertex 0 segment vertex buffer for ticks index 0 segment index buffer for ticks vertex 1 text vertex buffer for labels index 1 text index buffer for labels font_atlas 0 text font atlas for labels 3D visuals \u00b6 Mesh \u00b6 Features: Up to four blendable textures Up to four lights Automatic computation of normals (cross product of face vertices) if the normal prop is not provided Props \u00b6 Type Index Type Description pos 0 dvec3 vertex position normal 0 vec3 vertex normal texcoords 0 vec2 texture coordinates color 0 cvec4 color as RGB 3-bytes alpha 0 char alpha transparency value index 0 uint32 faces, as vertex indices light_pos 0 mat4 light positions ( uniform ) light_params 0 mat4 light coefficients ( uniform ) texcoefs 0 vec4 texture blending coefficients ( uniform ) clip 0 vec4 clip vector ( uniform ) Warning The texcoords and color props are mutually exclusive. The color has precedence over the texcoords. The mesh vertex struct has no color field, only a texcoord field. When the color prop is set, special texcoords values are computed (packing 3 bytes into the second texture coordinate floating-point number). Sources \u00b6 Type Index Description vertex 0 vertex buffer (vertices) index 0 index buffer (faces) param 0 parameter struct image 0..3 2D texture with image #i Basic visuals \u00b6 The basic visuals are simpler and more efficient, but they do not support antialiasing. Point \u00b6 The point visual is a trimmed-downed version of the marker visual. It is based on the point primitive. Props \u00b6 Type Index Type Description pos 0 dvec3 point position color 0 cvec4 point color marker_size 0 float point size ( uniform ) Line \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 line start position pos 1 dvec3 line end position color 0 color line color Line strip \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 point position color 0 cvec4 point color length 0 uint32 number of points in each line strip Triangle \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 triangle position 0 pos 1 dvec3 triangle position 1 pos 2 dvec3 triangle position 2 color 0 color triangle color Triangle strip \u00b6 Props \u00b6 Type Index Type Description pos 0 dvec3 point position color 0 color point color Triangle fan \u00b6 Warning This visual is not supported on macOS. Props \u00b6 Type Index Type Description pos 0 dvec3 point position color 0 color point color Common data \u00b6 The sources and props below are shared by all builtin visuals. Common sources \u00b6 Type Index Description mvp 0 DvzMVP structure with model-view-proj matrices viewport 0 DvzViewport structure with viewport info Common props \u00b6 Type Index Type Source Description model 0 mat4 mvp model transformation matrix view 0 mat4 mvp view transformation matrix proj 0 mat4 mvp proj transformation matrix time 0 float mvp time since app start, in seconds Common enums \u00b6 Visual transform \u00b6 Visual clip \u00b6 Data types \u00b6 Data type Component size Type size Description char 8 8 1 byte (unsigned byte) cvec2 8 16 2 bytes cvec3 8 24 3 bytes cvec4 8 32 4 bytes ushort 16 16 1 unsigned short integer usvec2 16 32 2 ushort usvec3 16 48 3 ushort usvec4 16 64 4 ushort short 16 16 1 signed short integer svec2 16 32 2 short svec3 16 48 3 short svec4 16 64 4 short uint 32 32 1 unsigned long integer uvec2 32 64 2 uint uvec3 32 96 3 uint uvec4 32 128 4 uint int 32 32 1 long integer ivec2 32 64 2 int ivec3 32 96 3 int ivec4 32 128 4 int float 32 32 1 single-precision floating-point number vec2 32 64 2 float vec3 32 96 3 float vec4 32 128 4 float double 64 64 1 double-precision floating-point number dvec2 64 128 2 double dvec3 64 192 3 double dvec4 64 256 4 double mat2 32 128 2x2 matrix of floats mat3 32 288 3x3 matrix of floats mat4 32 512 4x4 matrix of floats custom - - used by structured/record arrays (heterogeneous types) str 64 64 pointer to char Technical notes \u00b6 In a given visual, a prop is entirely defined by its type and its index. A visual may have multiple props of the same type. For example, the segment visual has a first prop pos with the segment start position, and another with the segment end position. The tables below specify the role of these indices in each case. A visual source corresponds to a GPU object holding the data for the visual. Common source types include: vertex buffer, index buffer, uniform buffer, texture. In a given visual, a source is entirely defined by its type and its index. Each prop is typically linked to a given source. Most props correspond either to shader attributes, in which case they are associated with the vertex buffer, or to global variables, in which case they are associated with uniform buffers. A visual is composed of one or several pipelines : graphics pipelines (or just graphics ), and optionally compute pipelines (or just computes ). A graphics pipeline corresponds to a vertex shader, a fragment shader, and possibly other shaders. In a given visual, each pipeline is entirely defined by its type (graphics or compute) and its index. The tables below specify the different pipelines when there are several of them in a given visual. For example, the axes visual contains a segment graphics for tick segments, and a text graphics for tick labels. Props marked uniform below can only receive a single value. They correspond to struct fields in a uniform buffer, and they are thus shared across all vertices of a given visual.","title":"Library of visuals"},{"location":"reference/visuals/#visuals","text":"This page lists all visuals currently implemented in the library. Important Be sure to read the technical notes at the end of this page.","title":"Visuals"},{"location":"reference/visuals/#2d-visuals","text":"","title":"2D visuals"},{"location":"reference/visuals/#marker","text":"","title":"Marker"},{"location":"reference/visuals/#path","text":"","title":"Path"},{"location":"reference/visuals/#polygon","text":"This visual currently only uses a basic triangle underlying graphics. It performs a triangulation of the polygons with the earcut C++ library by mapbox. Several arbitrary-sized polygons can be specified in the same visual.","title":"Polygon"},{"location":"reference/visuals/#image","text":"","title":"Image"},{"location":"reference/visuals/#scalar-image-with-colormap","text":"This visual is similar to the image visual, except that it accepts scalar images and colormaps computed on the GPU.","title":"Scalar image with colormap"},{"location":"reference/visuals/#axes","text":"","title":"Axes"},{"location":"reference/visuals/#3d-visuals","text":"","title":"3D visuals"},{"location":"reference/visuals/#mesh","text":"Features: Up to four blendable textures Up to four lights Automatic computation of normals (cross product of face vertices) if the normal prop is not provided","title":"Mesh"},{"location":"reference/visuals/#basic-visuals","text":"The basic visuals are simpler and more efficient, but they do not support antialiasing.","title":"Basic visuals"},{"location":"reference/visuals/#point","text":"The point visual is a trimmed-downed version of the marker visual. It is based on the point primitive.","title":"Point"},{"location":"reference/visuals/#line","text":"","title":"Line"},{"location":"reference/visuals/#line-strip","text":"","title":"Line strip"},{"location":"reference/visuals/#triangle","text":"","title":"Triangle"},{"location":"reference/visuals/#triangle-strip","text":"","title":"Triangle strip"},{"location":"reference/visuals/#triangle-fan","text":"Warning This visual is not supported on macOS.","title":"Triangle fan"},{"location":"reference/visuals/#common-data","text":"The sources and props below are shared by all builtin visuals.","title":"Common data"},{"location":"reference/visuals/#common-sources","text":"Type Index Description mvp 0 DvzMVP structure with model-view-proj matrices viewport 0 DvzViewport structure with viewport info","title":"Common sources"},{"location":"reference/visuals/#common-props","text":"Type Index Type Source Description model 0 mat4 mvp model transformation matrix view 0 mat4 mvp view transformation matrix proj 0 mat4 mvp proj transformation matrix time 0 float mvp time since app start, in seconds","title":"Common props"},{"location":"reference/visuals/#common-enums","text":"","title":"Common enums"},{"location":"reference/visuals/#visual-transform","text":"","title":"Visual transform"},{"location":"reference/visuals/#visual-clip","text":"","title":"Visual clip"},{"location":"reference/visuals/#data-types","text":"Data type Component size Type size Description char 8 8 1 byte (unsigned byte) cvec2 8 16 2 bytes cvec3 8 24 3 bytes cvec4 8 32 4 bytes ushort 16 16 1 unsigned short integer usvec2 16 32 2 ushort usvec3 16 48 3 ushort usvec4 16 64 4 ushort short 16 16 1 signed short integer svec2 16 32 2 short svec3 16 48 3 short svec4 16 64 4 short uint 32 32 1 unsigned long integer uvec2 32 64 2 uint uvec3 32 96 3 uint uvec4 32 128 4 uint int 32 32 1 long integer ivec2 32 64 2 int ivec3 32 96 3 int ivec4 32 128 4 int float 32 32 1 single-precision floating-point number vec2 32 64 2 float vec3 32 96 3 float vec4 32 128 4 float double 64 64 1 double-precision floating-point number dvec2 64 128 2 double dvec3 64 192 3 double dvec4 64 256 4 double mat2 32 128 2x2 matrix of floats mat3 32 288 3x3 matrix of floats mat4 32 512 4x4 matrix of floats custom - - used by structured/record arrays (heterogeneous types) str 64 64 pointer to char","title":"Data types"},{"location":"reference/visuals/#technical-notes","text":"In a given visual, a prop is entirely defined by its type and its index. A visual may have multiple props of the same type. For example, the segment visual has a first prop pos with the segment start position, and another with the segment end position. The tables below specify the role of these indices in each case. A visual source corresponds to a GPU object holding the data for the visual. Common source types include: vertex buffer, index buffer, uniform buffer, texture. In a given visual, a source is entirely defined by its type and its index. Each prop is typically linked to a given source. Most props correspond either to shader attributes, in which case they are associated with the vertex buffer, or to global variables, in which case they are associated with uniform buffers. A visual is composed of one or several pipelines : graphics pipelines (or just graphics ), and optionally compute pipelines (or just computes ). A graphics pipeline corresponds to a vertex shader, a fragment shader, and possibly other shaders. In a given visual, each pipeline is entirely defined by its type (graphics or compute) and its index. The tables below specify the different pipelines when there are several of them in a given visual. For example, the axes visual contains a segment graphics for tick segments, and a text graphics for tick labels. Props marked uniform below can only receive a single value. They correspond to struct fields in a uniform buffer, and they are thus shared across all vertices of a given visual.","title":"Technical notes"},{"location":"tutorials/","text":"Getting started \u00b6 This section proposes the following guides: Installing Datoviz Getting started with Datoviz in Python","title":"Index"},{"location":"tutorials/#getting-started","text":"This section proposes the following guides: Installing Datoviz Getting started with Datoviz in Python","title":"Getting started"},{"location":"tutorials/install/","text":"Installation \u00b6 How to install Datoviz? \u00b6 Note Binary packages are still experimental. They are currently uploaded on GitHub releases, but not yet on PyPI. They will, once they have been sufficiently tested. In the meantime, please open an issue on GitHub if you have any problem. Linux If you don't already have a Python distribution , install one. For example, download the miniconda installer for Linux 64-bit and install it. Open a terminal. Type the following to install Datoviz: pip install http://dl.datoviz.org/v0.1.0-alpha.1/datoviz-0.1.0a1-cp38-cp38-manylinux_2_24_x86_64.whl Type the following to test Datoviz: python -c \"import datoviz; datoviz.demo()\" macOS Install the Vulkan SDK for macOS (we'll try to remove this requirement in the near future) If you don't already have a Python distribution , install one. For example, download the miniconda pkg installer for macOS and install it. Open a terminal. Type the following to install Datoviz: pip install http://dl.datoviz.org/v0.1.0-alpha.1/datoviz-0.1.0a1-cp38-cp38-macosx_10_14_x86_64.whl Type the following to test Datoviz: python -c \"import datoviz; datoviz.demo()\" Windows If you don't already have a Python distribution , install one. For example, download the miniconda installer for Windows 64-bit and install it. Open an Anaconda prompt. Type the following to install Datoviz: pip install http://dl.datoviz.org/v0.1.0-alpha.1/datoviz-0.1.0a1-cp38-cp38-win_amd64.whl Type the following to test Datoviz: python -c \"import datoviz; datoviz.demo()\" How to build Datoviz from source? \u00b6 Datoviz is made of: a C library (also called libdatoviz), a Python wrapper (written in Cython) The philosophy of Datoviz is to implement all the logic and functionality in C , and provide minimal bindings in high-level languages. This will ensure that all wrappers share the same functionality. Linux Note Only Ubuntu 20.04 has been tested so far. Install the latest graphics drivers. Install the build tools: sudo apt install build-essential cmake ninja-build \\ xcb libx11-xcb-dev libxcursor-dev libxi-dev patchelf Install the optional dependencies: sudo apt install libpng-dev libavcodec-dev libavformat-dev \\ libavfilter-dev libavutil-dev libswresample-dev \\ libqt5opengl5-dev libfreetype6-dev Install the latest Lunarg Vulkan SDK (tarball SDK), for example in ~/vulkan . Export the Vulkan environment variables: source ~/vulkan/setup-env.sh Add source ~/vulkan/setup-env.sh to your ~/.bashrc so that the $VULKAN_SDK environment variable and other variables are properly set in your terminal. Copy the Vulkan headers and libraries to your system: sudo cp -r $VULKAN_SDK /include/vulkan/ /usr/local/include/ sudo cp -P $VULKAN_SDK /lib/libvulkan.so* /usr/local/lib/ sudo cp $VULKAN_SDK /lib/libVkLayer_*.so /usr/local/lib/ sudo mkdir -p /usr/local/share/vulkan/explicit_layer.d sudo cp $VULKAN_SDK /etc/vulkan/explicit_layer.d/VkLayer_*.json /usr/local/share/vulkan/explicit_layer.d Clone the Datoviz repository: git clone --recursive https://github.com/datoviz/datoviz.git cd datoviz Build the C library: ./manage.sh build Check that the compilation worked by running an example: ./manage.sh demo scatter Once the C library is compiled, you need to compile the Cython module: ./manage.sh cython Export the shared library path to your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py macOS Open a terminal. Type git to install git. Install Xcode. Install Homebrew . Install the build dependencies: brew install cmake ninja libpng Download the latest Vulkan SDK . Install it. Clone the Datoviz repository: git clone --recursive https://github.com/datoviz/datoviz.git cd datoviz Build the C library: ./manage.sh build Check that the compilation worked by running an example: ./manage.sh demo scatter Once the C library is compiled, you need to compile the Cython module: ./manage.sh cython Export the shared library path to your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py Windows 10 Warning Only mingw-w64 is supported at the moment. Microsoft Visual C++ is not yet supported. Note Help needed to add more details to the install instructions below. Install the latest graphics drivers for your system and hardware. Install Winlibs , a Windows port of gcc, using mingw-w64. Make sure the mingw executable is in the PATH. Install CMake for Windows . Install the Windows Universal C Runtime . Install the latest Lunarg Vulkan SDK ( .exe executable). Install git for Windows and open a Git-aware Windows terminal. Clone the Datoviz repository: git clone --recursive https://github.com/datoviz/datoviz.git cd datoviz Build the C library: manage.bat build Build the Cython module and create a wheel: manage.bat wheel Try a Python example: python bindings\\cython\\examples\\quickstart.py How to update Datoviz when it was compiled from source? \u00b6 git pull ./manage.sh build ./manage.sh parseheaders ./manage.sh cython What are the dependencies of Datoviz? \u00b6 Mandatory dependencies are required for compilation: LunarG Vulkan SDK 1.2.170+ cmake 3.16+ (build) Optional dependencies : ninja (build) freetype (font support) libpng (screenshot) ffmpeg (screencasts) Qt5 (upcoming Qt backend (work in progress) Built-in dependencies : glfw3 3.3+ : cross-platform windowing system cglm : basic types and math computations on vectors and matrices stb_image : image file input and output Dear ImGui : rich graphical user interfaces earcut.hpp : triangulation of polygons triangle : triangulation of complex polygons and planar straight-line graphs (PSLG) tiny_obj_loader : loading of .obj mesh files CPU emulation with Swiftshader \u00b6 Note Swiftshader support is still experimental. Software emulation of Vulkan is useful on computers with no GPUs or on continuous integration servers, for testing purposes. Datoviz has preliminary support for Swiftshader , an emulation library developed by Google. Compile Datoviz with Swiftshader support. Compile Swiftshader. Temporarily override your native Vulkan driver with the SwiftShader one: Linux: export LD_LIBRARY_PATH=/path/to/swiftshader/build/Linux/:$LD_LIBRARY_PATH Run your Datoviz script or application.","title":"Installation"},{"location":"tutorials/install/#installation","text":"","title":"Installation"},{"location":"tutorials/install/#how-to-install-datoviz","text":"Note Binary packages are still experimental. They are currently uploaded on GitHub releases, but not yet on PyPI. They will, once they have been sufficiently tested. In the meantime, please open an issue on GitHub if you have any problem. Linux If you don't already have a Python distribution , install one. For example, download the miniconda installer for Linux 64-bit and install it. Open a terminal. Type the following to install Datoviz: pip install http://dl.datoviz.org/v0.1.0-alpha.1/datoviz-0.1.0a1-cp38-cp38-manylinux_2_24_x86_64.whl Type the following to test Datoviz: python -c \"import datoviz; datoviz.demo()\" macOS Install the Vulkan SDK for macOS (we'll try to remove this requirement in the near future) If you don't already have a Python distribution , install one. For example, download the miniconda pkg installer for macOS and install it. Open a terminal. Type the following to install Datoviz: pip install http://dl.datoviz.org/v0.1.0-alpha.1/datoviz-0.1.0a1-cp38-cp38-macosx_10_14_x86_64.whl Type the following to test Datoviz: python -c \"import datoviz; datoviz.demo()\" Windows If you don't already have a Python distribution , install one. For example, download the miniconda installer for Windows 64-bit and install it. Open an Anaconda prompt. Type the following to install Datoviz: pip install http://dl.datoviz.org/v0.1.0-alpha.1/datoviz-0.1.0a1-cp38-cp38-win_amd64.whl Type the following to test Datoviz: python -c \"import datoviz; datoviz.demo()\"","title":"How to install Datoviz?"},{"location":"tutorials/install/#how-to-build-datoviz-from-source","text":"Datoviz is made of: a C library (also called libdatoviz), a Python wrapper (written in Cython) The philosophy of Datoviz is to implement all the logic and functionality in C , and provide minimal bindings in high-level languages. This will ensure that all wrappers share the same functionality. Linux Note Only Ubuntu 20.04 has been tested so far. Install the latest graphics drivers. Install the build tools: sudo apt install build-essential cmake ninja-build \\ xcb libx11-xcb-dev libxcursor-dev libxi-dev patchelf Install the optional dependencies: sudo apt install libpng-dev libavcodec-dev libavformat-dev \\ libavfilter-dev libavutil-dev libswresample-dev \\ libqt5opengl5-dev libfreetype6-dev Install the latest Lunarg Vulkan SDK (tarball SDK), for example in ~/vulkan . Export the Vulkan environment variables: source ~/vulkan/setup-env.sh Add source ~/vulkan/setup-env.sh to your ~/.bashrc so that the $VULKAN_SDK environment variable and other variables are properly set in your terminal. Copy the Vulkan headers and libraries to your system: sudo cp -r $VULKAN_SDK /include/vulkan/ /usr/local/include/ sudo cp -P $VULKAN_SDK /lib/libvulkan.so* /usr/local/lib/ sudo cp $VULKAN_SDK /lib/libVkLayer_*.so /usr/local/lib/ sudo mkdir -p /usr/local/share/vulkan/explicit_layer.d sudo cp $VULKAN_SDK /etc/vulkan/explicit_layer.d/VkLayer_*.json /usr/local/share/vulkan/explicit_layer.d Clone the Datoviz repository: git clone --recursive https://github.com/datoviz/datoviz.git cd datoviz Build the C library: ./manage.sh build Check that the compilation worked by running an example: ./manage.sh demo scatter Once the C library is compiled, you need to compile the Cython module: ./manage.sh cython Export the shared library path to your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py macOS Open a terminal. Type git to install git. Install Xcode. Install Homebrew . Install the build dependencies: brew install cmake ninja libpng Download the latest Vulkan SDK . Install it. Clone the Datoviz repository: git clone --recursive https://github.com/datoviz/datoviz.git cd datoviz Build the C library: ./manage.sh build Check that the compilation worked by running an example: ./manage.sh demo scatter Once the C library is compiled, you need to compile the Cython module: ./manage.sh cython Export the shared library path to your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py Windows 10 Warning Only mingw-w64 is supported at the moment. Microsoft Visual C++ is not yet supported. Note Help needed to add more details to the install instructions below. Install the latest graphics drivers for your system and hardware. Install Winlibs , a Windows port of gcc, using mingw-w64. Make sure the mingw executable is in the PATH. Install CMake for Windows . Install the Windows Universal C Runtime . Install the latest Lunarg Vulkan SDK ( .exe executable). Install git for Windows and open a Git-aware Windows terminal. Clone the Datoviz repository: git clone --recursive https://github.com/datoviz/datoviz.git cd datoviz Build the C library: manage.bat build Build the Cython module and create a wheel: manage.bat wheel Try a Python example: python bindings\\cython\\examples\\quickstart.py","title":"How to build Datoviz from source?"},{"location":"tutorials/install/#how-to-update-datoviz-when-it-was-compiled-from-source","text":"git pull ./manage.sh build ./manage.sh parseheaders ./manage.sh cython","title":"How to update Datoviz when it was compiled from source?"},{"location":"tutorials/install/#what-are-the-dependencies-of-datoviz","text":"Mandatory dependencies are required for compilation: LunarG Vulkan SDK 1.2.170+ cmake 3.16+ (build) Optional dependencies : ninja (build) freetype (font support) libpng (screenshot) ffmpeg (screencasts) Qt5 (upcoming Qt backend (work in progress) Built-in dependencies : glfw3 3.3+ : cross-platform windowing system cglm : basic types and math computations on vectors and matrices stb_image : image file input and output Dear ImGui : rich graphical user interfaces earcut.hpp : triangulation of polygons triangle : triangulation of complex polygons and planar straight-line graphs (PSLG) tiny_obj_loader : loading of .obj mesh files","title":"What are the dependencies of Datoviz?"},{"location":"tutorials/install/#cpu-emulation-with-swiftshader","text":"Note Swiftshader support is still experimental. Software emulation of Vulkan is useful on computers with no GPUs or on continuous integration servers, for testing purposes. Datoviz has preliminary support for Swiftshader , an emulation library developed by Google. Compile Datoviz with Swiftshader support. Compile Swiftshader. Temporarily override your native Vulkan driver with the SwiftShader one: Linux: export LD_LIBRARY_PATH=/path/to/swiftshader/build/Linux/:$LD_LIBRARY_PATH Run your Datoviz script or application.","title":"CPU emulation with Swiftshader"},{"location":"tutorials/quickstart/","text":"Quickstart: using Datoviz in Python \u00b6 In this tutorial, we'll cover the most important features of Datoviz by creating a 2D raster plot in Python . We'll cover the following steps: how to create an application, how to create a canvas, how to create a panel with an axes controller, how to add a visual, how to use a colormap, how to set visual data, how to run the application, how to create a graphical user interface (GUI), how to specify event callbacks, how to implement mouse picking. More advanced topics are covered in the How to section of the documentation. Importing the library \u00b6 Datoviz can be used from a Python script, or interactively in IPython. Note Interactive use in IPython is still experimental. First, we import NumPy and datoviz: import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap Creating a canvas \u00b6 We create a canvas : c = canvas () The canvas() function accepts a few keyword arguments, including width and height for the window's initial size. Creating a scene \u00b6 In order to draw something on the canvas, we need to define a scene which implements plotting functionality: s = c.scene() The scene contains subplots (also known as panels ) organized in a two-dimensional grid layout. The number of rows and columns may be specified by the rows and cols keyword arguments to the c.scene() method. By default, rows=1 and cols=1 . Canvas vs Scene Why is there a distinction between the canvas and the scene? The canvas may be used by advanced users who need direct Vulkan access for anything that is not standard scientific visualization (interactive demos, video games, animations...) and who don't need/want the overhead of the scene API. Creating a panel \u00b6 Each \"cell\" in the grid layout of the scene is a panel. Every panel has a controller which defines how we interact with the panel's visuals. There are several built-in controllers. In particular, the axes controller displays axes and ticks for 2D graphics: panel = c . panel ( controller = 'axes' ) Note The controllers that are currently supported are: static , panzoom , axes , arcbcall , camera . Choosing one of the existing visuals \u00b6 The next step is to add a visual to a panel . Here, we'll make a scatter plot with random points in different colors and sizes. Datoviz comes with a library of built-in visuals . For our scatter plot, we'll choose a marker visual : visual = panel . visual ( 'marker' ) Note We could also have used a point visual , which is faster and more lightweight, but only supports square markers. Another limitation is that all squares must have the same size in the visual (this limitation may be lifted in the future). Preparing the visual data \u00b6 Once the visual has been created and added to the panel, we need to set its data. Visual data is specified with visual props (properties). The visual documentation provides all props supported by each visual. Except from the universal pos prop which refers to the point positions, most props are optional and come with sensible defaults. In this example, we'll just set: pos : the marker positions , ms : the marker sizes , color : the marker colors . We generate the data as NumPy arrays, and we pass them to the visual. Marker positions \u00b6 N = 10_000 pos = nr . randn ( N , 3 ) Note that positions always have three dimensions in Datoviz. When using 2D plotting, we just set the third component to zero. Datoviz uses the standard OpenGL 3D coordinate system, with coordinates in [-1, +1] : Datoviz coordinate system Note Vulkan uses a slightly different coordinate system, the main differences are: y and z go in the opposition direction, z is in [0, 1] . The conventions chosen in Datoviz are closer to existing graphics libraries. The transformation from the Datoviz coordinate system to the Vulkan coordinate system is done at the final stage of data transformation in the vertex shader of all included visuals. The point positions that are passed to Datoviz are defined in a data coordinate system . Datoviz takes care of the transformation into a normalized coordinate system that is more amenable to GPU interactive graphics. Note The data transformation pipeline in Datoviz only supports linear transformations at the moment. It will be improved soon. Marker sizes \u00b6 We define random marker sizes (in pixels) as an array of floating-point values: ms = nr . uniform ( low = 2 , high = 40 , size = N ) Marker colors \u00b6 In Datoviz, colors are specified as either: arbitrary RGBA components, as uint8 bytes (four bytes per color), colormaps . Datoviz includes a library of ~150 colormaps commonly used in popular scientific plotting software . You can also define a custom colormap manually. Here, we'll use the viridis colormap . First, we define a scalar value for each point, which will be mapped to the colormap afterwards: color_values = nr . rand ( N ) We also prepare the alpha channel for transparency, from 0 (invisible) to 1 (opaque): alpha = . 75 * np . ones ( N ) Next, we compute the RGBA colors using the colormap: color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha = alpha , cmap = 'viridis' ) The variable color is an (N, 4) array of uint8 (byte values between 0 and 255). It can be passed directly to the color prop of our visual. Set the visual data \u00b6 Once the data has been prepared, we can pass it to the visual: visual . data ( 'pos' , pos ) visual . data ( 'ms' , ms ) visual . data ( 'color' , color ) Running the application \u00b6 Finally, we run the application by starting the main event loop: run () IPython integration If you are in IPython's interactive terminal, you should do %gui datoviz first, and omit the call to run() . Event callbacks and mouse picking \u00b6 Important From now on, all of the code snippets need to be added before run() . We'll write a callback function that runs whenever the user clicks somewhere in the canvas. It will display the coordinates of the clicked point in the original data coordinate system. # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = s . panel_at ( x , y ) if not p : return # Then, we transform the mouse positions into the data coordinate system. # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), { '+' . join ( modifiers ) } { button } click\" ) Clicking somewhere shows in the terminal output: Pick at (0.4605, -0.1992), modifiers=() Coordinate systems \u00b6 By default, the panel.pick() function converts coordinates from the window coordinate system (used by the event callbacks) to the data coordinate system. There are other coordinate systems that you can convert to using the target_cds keyword argument to pick() : Name Description data original coordinates of the data scene the coordinates before controller transformation (panzoom etc) in [-1, +1] vulkan the coordinates after controller transformation, in [-1, +1] framebuffer the coordinates in framebuffer pixel coordinates window the coordinates in screen pixel coordinates A few technical notes: The scene coordinate system corresponds to the vertex shader input . The vulkan coordinate system corresponds to the vertex shader output . There's a difference between the framebuffer and window systems with high-DPI monitors. This depends on the OS. For now, DPI support is semi-manual. Datoviz supports a special dpi_scaling variable that rescales the visual elements depending on this value, and that can be adjusted manually (to be documented later). Adding a graphical user interface \u00b6 Datoviz supports built-in GUIs via the Dear ImGui library . Note Dear ImGui allows you to create minimal GUIs without needing large dependencies such as Qt. However, full Qt support is also planned in the near future. Adding a GUI dialog \u00b6 We create a new GUI dialog: gui = c . gui ( \"Test GUI\" ) # the argument is the dialog's title Adding a control to the GUI \u00b6 We add a slider to change the visual marker size. sf = gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) # We write the Python callback function for when the slider's value changes. @sf . connect def on_change ( value ): # Every time the slider value changes, we update the visual's marker size. visual . data ( 'ms' , ms * value ) We add another slider, using integers this time, to change the colormap. # We add a second, slider controlling an integer between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control. si = gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) # Predefined list of colormaps. cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @si . connect def on_change ( value ): # When the slider changes, we recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # We update the color visual. visual . data ( 'color' , color ) Finally we add a button to regenerate the marker positions. b = gui . control ( \"button\" , \"new positions\" ) @b . connect def on_change ( value ): # We update the marker positions. pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos ) Asynchronous callbacks By default, callbacks are synchronous and run in the main thread. As such, they will block the user interface is they take too long to run. Currently, the only way of implementing an asynchronous callback is to use the asyncio event loop. Look at the eventloop code example .","title":"Quickstart"},{"location":"tutorials/quickstart/#quickstart-using-datoviz-in-python","text":"In this tutorial, we'll cover the most important features of Datoviz by creating a 2D raster plot in Python . We'll cover the following steps: how to create an application, how to create a canvas, how to create a panel with an axes controller, how to add a visual, how to use a colormap, how to set visual data, how to run the application, how to create a graphical user interface (GUI), how to specify event callbacks, how to implement mouse picking. More advanced topics are covered in the How to section of the documentation.","title":"Quickstart: using Datoviz in Python"},{"location":"tutorials/quickstart/#importing-the-library","text":"Datoviz can be used from a Python script, or interactively in IPython. Note Interactive use in IPython is still experimental. First, we import NumPy and datoviz: import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap","title":"Importing the library"},{"location":"tutorials/quickstart/#creating-a-canvas","text":"We create a canvas : c = canvas () The canvas() function accepts a few keyword arguments, including width and height for the window's initial size.","title":"Creating a canvas"},{"location":"tutorials/quickstart/#creating-a-scene","text":"In order to draw something on the canvas, we need to define a scene which implements plotting functionality: s = c.scene() The scene contains subplots (also known as panels ) organized in a two-dimensional grid layout. The number of rows and columns may be specified by the rows and cols keyword arguments to the c.scene() method. By default, rows=1 and cols=1 . Canvas vs Scene Why is there a distinction between the canvas and the scene? The canvas may be used by advanced users who need direct Vulkan access for anything that is not standard scientific visualization (interactive demos, video games, animations...) and who don't need/want the overhead of the scene API.","title":"Creating a scene"},{"location":"tutorials/quickstart/#creating-a-panel","text":"Each \"cell\" in the grid layout of the scene is a panel. Every panel has a controller which defines how we interact with the panel's visuals. There are several built-in controllers. In particular, the axes controller displays axes and ticks for 2D graphics: panel = c . panel ( controller = 'axes' ) Note The controllers that are currently supported are: static , panzoom , axes , arcbcall , camera .","title":"Creating a panel"},{"location":"tutorials/quickstart/#choosing-one-of-the-existing-visuals","text":"The next step is to add a visual to a panel . Here, we'll make a scatter plot with random points in different colors and sizes. Datoviz comes with a library of built-in visuals . For our scatter plot, we'll choose a marker visual : visual = panel . visual ( 'marker' ) Note We could also have used a point visual , which is faster and more lightweight, but only supports square markers. Another limitation is that all squares must have the same size in the visual (this limitation may be lifted in the future).","title":"Choosing one of the existing visuals"},{"location":"tutorials/quickstart/#preparing-the-visual-data","text":"Once the visual has been created and added to the panel, we need to set its data. Visual data is specified with visual props (properties). The visual documentation provides all props supported by each visual. Except from the universal pos prop which refers to the point positions, most props are optional and come with sensible defaults. In this example, we'll just set: pos : the marker positions , ms : the marker sizes , color : the marker colors . We generate the data as NumPy arrays, and we pass them to the visual.","title":"Preparing the visual data"},{"location":"tutorials/quickstart/#marker-positions","text":"N = 10_000 pos = nr . randn ( N , 3 ) Note that positions always have three dimensions in Datoviz. When using 2D plotting, we just set the third component to zero. Datoviz uses the standard OpenGL 3D coordinate system, with coordinates in [-1, +1] : Datoviz coordinate system Note Vulkan uses a slightly different coordinate system, the main differences are: y and z go in the opposition direction, z is in [0, 1] . The conventions chosen in Datoviz are closer to existing graphics libraries. The transformation from the Datoviz coordinate system to the Vulkan coordinate system is done at the final stage of data transformation in the vertex shader of all included visuals. The point positions that are passed to Datoviz are defined in a data coordinate system . Datoviz takes care of the transformation into a normalized coordinate system that is more amenable to GPU interactive graphics. Note The data transformation pipeline in Datoviz only supports linear transformations at the moment. It will be improved soon.","title":"Marker positions"},{"location":"tutorials/quickstart/#marker-sizes","text":"We define random marker sizes (in pixels) as an array of floating-point values: ms = nr . uniform ( low = 2 , high = 40 , size = N )","title":"Marker sizes"},{"location":"tutorials/quickstart/#marker-colors","text":"In Datoviz, colors are specified as either: arbitrary RGBA components, as uint8 bytes (four bytes per color), colormaps . Datoviz includes a library of ~150 colormaps commonly used in popular scientific plotting software . You can also define a custom colormap manually. Here, we'll use the viridis colormap . First, we define a scalar value for each point, which will be mapped to the colormap afterwards: color_values = nr . rand ( N ) We also prepare the alpha channel for transparency, from 0 (invisible) to 1 (opaque): alpha = . 75 * np . ones ( N ) Next, we compute the RGBA colors using the colormap: color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha = alpha , cmap = 'viridis' ) The variable color is an (N, 4) array of uint8 (byte values between 0 and 255). It can be passed directly to the color prop of our visual.","title":"Marker colors"},{"location":"tutorials/quickstart/#set-the-visual-data","text":"Once the data has been prepared, we can pass it to the visual: visual . data ( 'pos' , pos ) visual . data ( 'ms' , ms ) visual . data ( 'color' , color )","title":"Set the visual data"},{"location":"tutorials/quickstart/#running-the-application","text":"Finally, we run the application by starting the main event loop: run () IPython integration If you are in IPython's interactive terminal, you should do %gui datoviz first, and omit the call to run() .","title":"Running the application"},{"location":"tutorials/quickstart/#event-callbacks-and-mouse-picking","text":"Important From now on, all of the code snippets need to be added before run() . We'll write a callback function that runs whenever the user clicks somewhere in the canvas. It will display the coordinates of the clicked point in the original data coordinate system. # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = s . panel_at ( x , y ) if not p : return # Then, we transform the mouse positions into the data coordinate system. # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), { '+' . join ( modifiers ) } { button } click\" ) Clicking somewhere shows in the terminal output: Pick at (0.4605, -0.1992), modifiers=()","title":"Event callbacks and mouse picking"},{"location":"tutorials/quickstart/#coordinate-systems","text":"By default, the panel.pick() function converts coordinates from the window coordinate system (used by the event callbacks) to the data coordinate system. There are other coordinate systems that you can convert to using the target_cds keyword argument to pick() : Name Description data original coordinates of the data scene the coordinates before controller transformation (panzoom etc) in [-1, +1] vulkan the coordinates after controller transformation, in [-1, +1] framebuffer the coordinates in framebuffer pixel coordinates window the coordinates in screen pixel coordinates A few technical notes: The scene coordinate system corresponds to the vertex shader input . The vulkan coordinate system corresponds to the vertex shader output . There's a difference between the framebuffer and window systems with high-DPI monitors. This depends on the OS. For now, DPI support is semi-manual. Datoviz supports a special dpi_scaling variable that rescales the visual elements depending on this value, and that can be adjusted manually (to be documented later).","title":"Coordinate systems"},{"location":"tutorials/quickstart/#adding-a-graphical-user-interface","text":"Datoviz supports built-in GUIs via the Dear ImGui library . Note Dear ImGui allows you to create minimal GUIs without needing large dependencies such as Qt. However, full Qt support is also planned in the near future.","title":"Adding a graphical user interface"},{"location":"tutorials/quickstart/#adding-a-gui-dialog","text":"We create a new GUI dialog: gui = c . gui ( \"Test GUI\" ) # the argument is the dialog's title","title":"Adding a GUI dialog"},{"location":"tutorials/quickstart/#adding-a-control-to-the-gui","text":"We add a slider to change the visual marker size. sf = gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) # We write the Python callback function for when the slider's value changes. @sf . connect def on_change ( value ): # Every time the slider value changes, we update the visual's marker size. visual . data ( 'ms' , ms * value ) We add another slider, using integers this time, to change the colormap. # We add a second, slider controlling an integer between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control. si = gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) # Predefined list of colormaps. cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @si . connect def on_change ( value ): # When the slider changes, we recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # We update the color visual. visual . data ( 'color' , color ) Finally we add a button to regenerate the marker positions. b = gui . control ( \"button\" , \"new positions\" ) @b . connect def on_change ( value ): # We update the marker positions. pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos ) Asynchronous callbacks By default, callbacks are synchronous and run in the main thread. As such, they will block the user interface is they take too long to run. Currently, the only way of implementing an asynchronous callback is to use the asyncio event loop. Look at the eventloop code example .","title":"Adding a control to the GUI"}]}