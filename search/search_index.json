{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Datoviz: high-performance GPU scientific data visualization C/C++ library","text":"<p>[Installation] [Usage] [User guide] [Examples] [API reference] </p> <p>\u26a1\ufe0f Datoviz is a cross-platform, open-source, high-performance GPU scientific data visualization library written in C/C++ on top of the Khronos Vulkan graphics API and the glfw window library. It provides raw ctypes bindings in Python \ud83d\udc0d. In the long term, Datoviz will mostly be used as a VisPy 2.0 backend.</p> <p>Designed for speed, visual quality, and scalability to datasets comprising millions of points, it supports 2D/3D interactive rendering and minimal GUIs via Dear ImGui.</p> <p>\u26a0\ufe0f Warning: Although Datoviz has been years in the making, it is still in its early stages and would greatly benefit from increased community feedback, particularly concerning package and hardware compatibility. The API is still evolving, so expect regular (though hopefully minimal) breaking changes for now. The current version is v0.2. The previous v0.1 version is now deprecated.</p> <p>\ud83d\udd50 Roadmap. In the medium term: increasing OS and hardware compatibility, providing more visuals, interactivity patterns, and GUI controls. In the long term: picking, custom visuals and shaders, nonlinear transforms, WebGPU/WebAssembly compatibility, integration with IPython, Jupyter and Qt.</p>"},{"location":"#screenshots-from-the-v01-version","title":"\ud83d\uddbc\ufe0f Screenshots from the v0.1 version","text":"<p> Credits: mouse brain volume: Allen SDK. France: Natural Earth. Molecule: Crystal structure of S. pyogenes Cas9 from PDB (thanks to Eric for conversion to OBJ mesh). Earth: Pixabay. Raster plot: IBL. 3D human brain: Anneke Alkemade et al. 2020, thanks to Pierre-Louis Bazin and Julia Huntenburg.</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udcca High-quality antialiased 2D visuals: markers, lines, paths, glyphs</li> <li>\ud83c\udf10 3D visuals: meshes, volumes, volume slices</li> <li>\ud83c\udf08 150 colormaps included (from matplotlib, colorcet, MATLAB)</li> <li>\ud83d\uddb1\ufe0f High-level interactivity: pan &amp; zoom for 2D, arcball for 3D (more later)</li> <li>\ud83c\udfa5 Manual control of cameras: custom interactivity</li> <li>\ud80c\ude08 Figure subplots (aka \"panels\")</li> <li>\ud83d\udda5\ufe0f Minimal GUIs using Dear ImGui</li> </ul>"},{"location":"#list-of-visuals","title":"List of visuals","text":""},{"location":"#work-in-progress","title":"Work in progress","text":"<p>These features are currently planned for v0.3:</p> <ul> <li>\u2795 Axes: ticks, grids, labels</li> <li>\ud83c\udfa8 Colorbars</li> <li>\ud83d\uddb1\ufe0f More interactivity patterns</li> <li>\ud83d\udcd6 More documentation</li> </ul>"},{"location":"#future-work","title":"Future work","text":"<p>These features are currently planned for v0.4 and later:</p> <ul> <li>\ud83d\udcd0 More visuals: arrows, polygons, planar straight-line graphs (PSLG), histograms, areas, graphs</li> <li>\ud83c\udfaf Picking</li> <li>\ud83d\udcc8 Nonlinear transforms</li> <li>\ud83d\udd8c\ufe0f Dynamic shaders</li> <li>\ud83c\udf10 WebGPU/WebAssembly compatibility</li> <li>\ud83e\uddee Compute shaders</li> <li>\ud83d\udc0d IPython, Jupyter, Qt integration</li> </ul>"},{"location":"#installation-instructions","title":"\ud83d\udee0\ufe0f Installation instructions","text":"<p>Requirements:</p> <ul> <li>A supported OS (Linux, macOS 12+, Windows 10+)</li> <li>A Vulkan-capable graphics chipset (either integrated or dedicated graphics process unit)</li> <li>Python and NumPy</li> </ul> <p>Note: You no longer need to install the Vulkan SDK or to manually build the library. Precompiled wheels for Linux, Windows, and macOS have been uploaded to PyPI.</p> <pre><code>pip install datoviz\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":"<p>Simple scatter plot example (points with random positions, colors, and sizes) in Python, which closely follow the C API.</p> <pre><code>import numpy as np\nimport datoviz as dvz\n\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\nfigure = dvz.figure(scene, 800, 600, 0)\npanel = dvz.panel_default(figure)\ndvz.panel_panzoom(panel)\nvisual = dvz.point(batch, 0)\n\nn = 100_000\ndvz.point_alloc(visual, n)\n\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.point_position(visual, 0, n, pos, 0)\n\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ndvz.point_color(visual, 0, n, color, 0)\n\nsize = np.random.uniform(size=(n,), low=10, high=30).astype(np.float32)\ndvz.point_size(visual, 0, n, size, 0)\n\ndvz.panel_visual(panel, visual, 0)\ndvz.scene_run(scene, app, 0)\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre> <p></p> <p>Check out the examples documentation for more usage examples.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>\ud83d\udcd6 User guide</li> <li>\ud83d\udc0d Examples</li> <li>\ud83d\udcda API reference</li> <li>\ud83c\udfdb\ufe0f Architecture overview</li> <li>\ud83c\udfd7\ufe0f Build instructions</li> <li>\ud83d\udc65 Contributors instructions</li> <li>\ud83d\udee0\ufe0f Maintainers instructions</li> </ul>"},{"location":"#history-and-current-status","title":"\ud83d\udd70\ufe0f History and current status","text":"<p>In 2012, developers of various GPU scientific visualization libraries (Galry, Glumpy, pyqtgraph, visvis) collaborated to create VisPy, an OpenGL-based scientific visualization library for Python.</p> <p>In 2015, Vulkan, the successor to OpenGL, was announced by Khronos, sparking the idea of a future Vulkan-based visualization library.</p> <p>In 2019, Cyrille Rossant, one of the original VisPy developers, began experimenting with Vulkan.</p> <p>In 2021, the first experimental version of Datoviz v0.1 was released. This initial release laid the groundwork for further development.</p> <p>Over the next three years, the technology matured, aided by a Chan Zuckerberg Initiative (CZI) grant awarded to VisPy in 2021.</p> <p>In 2024, Datoviz v0.2 is released. This version is redesigned from the ground up to enhance modularity and stability, ensuring it can keep pace with the continuous advancements in GPU hardware and graphics rendering APIs. It features a modular architecture that will allow the porting of Datoviz technology to non-Vulkan environments, such as WebGPU-enabled web browsers (thanks to a second CZI grant).</p> <p>Datoviz is closely related to VisPy, as it is being developed by one of the VisPy cofounders. VisPy 2.0, initiated by Cyrille Rossant and Nicolas Rougier, will offer a high-level scientific API on top of Datoviz, matplotlib, and other renderers via a common medium-level visualization layer called \"graphics server protocol (GSP)\".</p> <p>The long-term vision is for high-performance GPU-based 2D/3D scientific visualization to be uniformly available across multiple platforms, environments (desktop, web, cloud-based remote visualization), and programming languages (C/C++, Python, Julia, Rust, etc.).</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>See the contributing notes.</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>See the MIT license.</p>"},{"location":"#credits","title":"\ud83d\ude4f Credits","text":"<p>Datoviz is developed by Cyrille Rossant at the International Brain Laboratory, a consortium of neuroscience research labs around the world.</p> <p>It is funded notably by Chan Zuckerberg Initiative's Essential Open Source Software for Science program.</p>"},{"location":"ARCHITECTURE/","title":"Architecture","text":"<p>This document provides a high-level overview of the Datoviz v0.2x code architecture.</p>"},{"location":"ARCHITECTURE/#main-components","title":"Main components","text":"<p>The main components are:</p> <ul> <li>vklite (<code>include/datoviz/vklite.h</code>): A lightweight C Vulkan wrapper that provides essential GPU compute and visualization functionality for scientific visualization.</li> <li>Renderer (<code>include/datoviz/renderer.h</code>): A C/C++ Vulkan-based GPU visualization engine that offers a GLFW-based event loop, processing visualization requests in real time.</li> <li>Requests (<code>include/datoviz/requests.h</code>): A C API that generates real-time visualization requests to be sent to the renderer.</li> <li>Visuals (<code>includes/datoviz/scene/visuals/</code>): A comprehensive C/GLSL library of high-quality GPU graphical primitives, including points, markers, paths, images, glyphs, meshes, and volumes.</li> <li>Scene (<code>include/datoviz.h</code>): A C/C++ library providing scientific visualization functionality that generates requests to be sent to the renderer.</li> </ul> <p>These components are organized around the Datoviz Intermediate Protocol, an intermediate-level, message-based visualization protocol that decouples high-level scientific visualization logic from low-level Vulkan rendering implementation.</p> <p>While the former can be developed and maintained by research software engineers and scientists, the latter requires deep technical expertise, more commonly found in the video game industry and among game engine developers than in scientific fields.</p> <p>This architecture also ensures that high-level scientific visualization logic can evolve independently from ongoing innovations in graphics hardware and APIs (OpenGL, Vulkan, Metal, DirectX, WebGPU, wgpu, etc.). Notably, with support from a generous Chan Zuckerberg Initiative (CZI) grant awarded to the VisPy project in 2024, this architecture will enable us to port Datoviz technology to non-Vulkan environments, such as WebGPU-enabled web browsers, in the coming years.</p> <p>This will help us achieve a long-term vision where high-performance GPU-based 2D/3D scientific visualization is accessible across local and remote multi-platform environments (distributed rendering, web-based visualization), capable of working with both local and cloud-based data, and supporting language-agnostic visualization code (C/C++, Python, Julia, Rust, etc.).</p>"},{"location":"ARCHITECTURE/#renderer","title":"Renderer","text":"<p>The bottomest layer is the raw Vulkan C API, which is known for its extreme verbosity and complexity.</p>"},{"location":"ARCHITECTURE/#vklite","title":"vklite","text":"<p>We built vklite, a thin wrapper on top of the Vulkan C API, that provides the most essential Vulkan functionality (<code>vklite.h</code>):</p> <ul> <li>Device control and event loops:<ul> <li>Device discovery (<code>dvz_gpu</code>)</li> <li>Swapchain presentation (<code>dvz_swapchain</code>, <code>dvz_renderpass</code>, <code>dvz_framebuffers</code>, <code>dvz_surface</code>)</li> <li>Synchronization primitives (<code>dvz_barrier</code>, <code>dvz_semaphores</code>, <code>dvz_fences</code>)</li> </ul> </li> <li>GPU memory:<ul> <li>GPU data buffers (<code>dvz_buffers</code>)</li> <li>GPU images (<code>dvz_images</code>)</li> <li>Samplers (<code>dvz_sampler</code>)</li> </ul> </li> <li>Pipelines and shaders:<ul> <li>Compute pipelines (<code>dvz_compute</code>)</li> <li>Graphics pipelines (<code>dvz_graphics</code>) with fixed pipeline and custom shaders</li> <li>Slots and bindings or descriptors (<code>dvz_slots</code>, <code>dvz_descriptors</code>)</li> </ul> </li> <li>Command buffers:<ul> <li>Command buffer creation and submission (<code>dvz_commands</code>, <code>dvz_submit</code>)</li> <li>Command buffer recording (<code>dvz_cmd</code>)</li> </ul> </li> </ul> <p>Broadly speaking, these low-level functions allow one to create objects on the GPU, mostly data buffers and textures (images and samplers), to define GPU compute and graphics pipelines via custom SPIR-V shaders (compiled from GLSL), and to send compute and rendering jobs to the GPU by asynchronously submitting recorded command buffers to a dedicated event loop displaying graphics on screen.</p>"},{"location":"ARCHITECTURE/#gpu-resources-and-data-transfers","title":"GPU resources and data transfers","text":"<p>A major part of the renderer is device management of GPU-stored data and CPU-GPU data transfers (<code>resources.h</code>, <code>context.h</code>, <code>alloc.h</code>, <code>transfers.h</code>...).</p> <p>Vulkan and vklite support two main types of data: buffers (linear contiguous blocks of memory) and images (1D, 2D, or 3D).</p> <p>Buffers store vertex positions and other attributes, as well as shader parameters. Arbitrary GPU buffers may also be created for direct access from the shaders (storage buffers).</p> <p>Images typically store textures or rendered images.</p> <p>Vulkan only provides low-level primitives for CPU-GPU data transfers (creation and deletion of buffers and images, memory mapping techniques, submission of command buffers with buffer/image copy operations...). Datoviz provides a dedicated data transfer engine that provides a simpler interface that mostly deals with \"upload\" (CPU-&gt;GPU), \"download\" (GPU-&gt;CPU), and \"copy\" (GPU-&gt;GPU) of buffers and images.</p> <p>Datoviz also implements a custom memory allocator that avoids the overhead of creating and managing a large number of GPU buffers when handling small amounts of data. It is indeed good practice in Vulkan to define a few large buffers of different types and manually handle chunks of data in these buffers, although this comes with a somewhat increased internal complexity.</p> <p>Datoviz simply defines dats (chunks of data on the GPU) and texs (images on the GPU) that can be created, resized, deleted, and to which one can upload/download data.</p>"},{"location":"ARCHITECTURE/#datoviz-intermediate-protocol-renderer","title":"Datoviz Intermediate Protocol Renderer","text":"<p>The Renderer processes Datoviz Intermediate Protocol requests using the low-level components discussed earlier (vklite, data transfers...).</p> <p>It implements an object hash table mapping unique IDs identifiying each object created in the requests, to the actual underlying objects.</p>"},{"location":"ARCHITECTURE/#client","title":"Client","text":"<p>Datoviz implements a GPU-agnostic glfw-based client providing basic interactive event loop functionality: window creation and management, mouse and keyboard interactivity (<code>window.h</code>, <code>client.h</code>, <code>fifo.h</code>, <code>mouse.h</code>, <code>keyboard.h</code>, <code>input.h</code>...).</p> <p>The client provides a thread-safe FIFO queue on which window and input events are sent.</p> <p>The GPU-agnostic client and the client-agnostic (static) renderer are linked together via the presenter, which allows dynamic processing of the incoming requests by the renderer and appropriate event loop synchronization.</p>"},{"location":"ARCHITECTURE/#datoviz-intermediate-protocol","title":"Datoviz Intermediate Protocol","text":"<p>The Datoviz Intermediate Protocol is entirely defined in <code>request.h</code>.</p> <p>It provides a generic intermediate-level GPU visualization library that is somewhat similar to the WebGPU API. It deals exclusively with GPU objects, NOT visual objects. The protocol comes with NO graphical primitives, it supports arbitrary shaders and graphics pipelines. Graphical primitives and higher-level visualization constructs are implemented in the Visuals library and the Scene API described below</p> <p>Note: although compute shaders are already mostly supported in the renderer, they are not yet implemented in the Datoviz Intermediate Protocol. They will be in the future, depending on user feedback. This should be fairly straightforward (adding functions in <code>requests.h</code>, implementing them in <code>renderer.cpp</code>, writing tests and documentation...).</p> <p>Requests are linearly collected in a batch, which is then sent to the renderer for dynamic processing at the next event loop iteration.</p> <p>The main objects and notions defined in the Datoviz Intermediate Protocol are:</p> <ul> <li>canvas: a window associated to a Vulkan surface for GPU rendering and presentation</li> <li>board: an offscreen canvas for static rendering independently from the event loop</li> <li>dat: a GPU memory buffer (actually implemented as a data chunk of a larger Datoviz-handled buffer)</li> <li>tex: a GPU image buffer (1D, 2D, or 3D)</li> <li>sampler: a GPU object providing nearest or linear filtering on a tex</li> <li>shader: a SPIR-V shader</li> <li>graphics: a graphics pipeline defined by a fixed state pipeline, a vertex shader, a fragment shader...</li> <li>bindings: bindings between dats and shader uniforms</li> <li>command buffer recording: essentially viewport definition and graphics pipeline drawing commands (compute buffers to come later)</li> </ul>"},{"location":"ARCHITECTURE/#scene-api","title":"Scene API","text":"<p>The Scene API provides higher-level scientific visualization constructs that are directly exposed to users of the Datoviz C API (contrary to the underlying machinery).</p>"},{"location":"ARCHITECTURE/#visuals-api","title":"Visuals API","text":"<p>A Visual is an abstraction representing a graphical object, or a collection of similar objects, and encapsulating a graphics pipeline defined by pair of vertex and fragment shaders, along with descriptor bindings for uniform buffers, an associated vertex buffer, and custom visual-specific logic for CPU-based data \"baking\".</p> <p>Visuals typically support natively collections of objects: points, markers, glyphs, images, meshes, and so on (see the Visuals library below for more details). This is a crucially important notion: batch-rendering of many objects of the same type, but with various data attributes (positions, colors, sizes...), is the key to achieving high-performance rendering on the GPU.</p> <p>Each visual comes with a pair of custom shaders (vertex shader and fragment shader), originally contributed by Nicolas Rougier's research in computer graphics (rendering high-quality visual primitives efficiently on the GPU is an active area of research). The vertex shader typically requires preprocessing of the data to make it amenable to GPU rendering: this is the so-called \"baking\" of the data.</p> <p>A visual involves several consecutive abstractions:</p> <ul> <li>The array holds a 1D data buffer on the CPU. It has a data type (scalar or multiple components, floating-point or integer) and a size.</li> <li>The dual associates a CPU-based array with a GPU-based dat (chunk of a GPU buffer). It handles synchronization between the two and emits a data upload request when the CPU part of the array changes.</li> <li>The baker provides facilities for generating one (or several) multiplexed vertex buffer(s) from the original user-supplied visual data (positions, colors, other attributes).</li> <li>The generic visual provides facilities for creating a visual bundling together a graphics primitive, shaders, a baker, a vertex buffer, optional uniform-based parameters.</li> <li>The custom visual leverages the generic visual to define a dedicated visual API to create a specific visual (marker, image, mesh...), set its data, and render it when rendering a command buffer.</li> </ul>"},{"location":"ARCHITECTURE/#visuals-library","title":"Visuals library","text":"<p>Datoviz comes with a built-in library of visuals commonly used in scientific rendering:</p> <ul> <li>Basic visuals rely on the built-in OpenGL/Vulkan graphical primitives:</li> <li>Basic point: pixel or plain square</li> <li>Basic line: aliased thin lines: line list, line strip</li> <li> <p>Basic triangle: aliased triangles: triangle list, triangle strip, triangle fan (warning: not supported on macOS)</p> </li> <li> <p>0D visuals represent points in a 2D or 3D space:</p> <ul> <li>Pixel: collection of pixels (position, color)</li> <li>Point: collection of discs (position, color, size)</li> <li>Marker: collection of markers (position, color, size, angle, shape, filled/stroke/outline, edge color, edge width)</li> <li>Glyph: collection of text glyphs (position, color, size, angle...)</li> </ul> </li> <li> <p>1D visuals represent lines:</p> <ul> <li>Segment: collection of rigid line segments (initial and terminal position, color, line width, cap type)</li> <li>Path: collection of variable-size curved paths (position, line width, color)</li> </ul> </li> <li> <p>2D visuals represent images:</p> <ul> <li>Image: collection of textured squares (corner positions, sampler filtering, texture image)</li> </ul> </li> <li> <p>3D visuals represent meshes (or \"fake\" meshes, volumes):</p> <ul> <li>Mesh: triangular meshes (vertex position, normal, color, texture coordinates, face indices, light position and parameters)</li> <li>Sphere: collection of \"fake\" spheres rendered as 2D sprites with 3D illusion (position, color, size, light position)</li> <li>Volume: volume rendering</li> <li>Slice: images in 3D space showing slices of a 3D volume (corner position, texture coordinates)</li> </ul> </li> </ul>"},{"location":"ARCHITECTURE/#transforms","title":"Transforms","text":"<p>Datoviz provides a basic transform system, currently limited to standard matrix-view-projection linear transforms (this is still a work in progress, support for more complex, e.g. nonlinear, transforms may be implemented later).</p> <p>The system provides standalone components implementing pan-zoom (2D) and arcball (3D rotations) interactivity. Future components may implement a subjective camera (e.g. fly mode, FPS-type camera).</p>"},{"location":"ARCHITECTURE/#scene","title":"Scene","text":"<p>The Scene puts all components together in the main public API of Datoviz:</p> <ul> <li>The Scene is the root object.</li> <li>The Figure represents a scene-aware window.</li> <li>The Panel represents a full or partial rectangular portion of a Figure (subplot).</li> <li>The Panel is specified a transform and interactivity mode (panzoom, arcball).</li> <li>One or several visuals are added to a Panel.</li> </ul> <p>The viewset takes care of tracking all of these objects and building a command buffer for drawing all visuals in all panels.</p>"},{"location":"ARCHITECTURE/#specialized-components","title":"Specialized components","text":"<p>The Scene API also comes with a set of specialized components that are used by some visuals or transforms.</p> <ul> <li> <p>Text components:</p> <ul> <li>The Font wraps the freetype library to handle text composition on the basis of a builtin or custom TTF font.</li> <li>The Atlas wraps Viktor Chlumsk\u00fd's msdfgen-atlas library to generate an atlas texture with multi-channel signed distance field (MSDF) representing font glyphs to be rendered on the GPU in the fragment shader.</li> </ul> </li> <li> <p>GUI components:</p> <ul> <li>The GUI wraps Omar Cornut's Dear ImGui library to provide basic interactive GUI components. It should be straightforward to support the entire Dear ImGui API when using Datoviz in C++ (testing required).</li> </ul> </li> <li> <p>Axis components: (note: work in progress)</p> <ul> <li>Ticks: implement an automatic tick positioning system (extended Wilkinson algorithm)</li> <li>Labels: generate tick labels</li> <li>Axis: handle an axis with ticks and labels</li> <li>Axes: handle multiple Axis components</li> </ul> </li> </ul>"},{"location":"BUILD/","title":"Building instructions","text":"<p>If packages are not available on your system, you can build Datoviz yourself.</p>"},{"location":"BUILD/#ubuntu-2404","title":"Ubuntu 24.04","text":"<pre><code># Install the build and system dependencies.\nsudo apt install build-essential cmake gcc ccache ninja-build xorg-dev clang-format patchelf tree libtinyxml2-dev libfreetype-dev\n\n# Install just, see https://github.com/casey/just\ncurl --proto '=https' --tlsv1.2 -sSf https://just.systems/install.sh | bash\n\n# Clone the Datoviz repo and build.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"BUILD/#macos-arm64","title":"macOS (arm64)","text":"<pre><code># Install brew if you don't have it already.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n    eval \"$(/opt/homebrew/bin/brew shellenv)\"\n\n# Install build dependencies.\nbrew install just cmake ccache ninja freetype clang-format tree cloc\n\n# Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"BUILD/#macos-intel-x86-64","title":"macOS (Intel x86-64)","text":"<pre><code># Install brew if you don't have it already.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n    eval \"$(/opt/homebrew/bin/brew shellenv)\"\n\n# Install build dependencies.\nbrew install just cmake ccache ninja freetype clang-format tree cloc\n\n# Clone the Datoviz repo.\ngit clone https://github.com/datoviz/datoviz.git --recursive\ncd datoviz\n\n# Build Python requirements\npip install -r requirements-dev.txt\n\n# NOTE: this call will fail, but the build will succeed the second time.\n# Fix welcome (see https://github.com/Chlumsky/msdf-atlas-gen/issues/98)\njust build\n\n# That one should succeed.\njust build\n\n# Try a demo.\njust demo\n\n# Compile and run a C example.\njust example scatter\n\n# Run the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"BUILD/#windows","title":"Windows","text":"<p>Note: we have less experience with Windows, improvements welcome.</p> <p>Requirements:</p> <ul> <li>Git for Windows.</li> <li>WinLibs: download and install the latest gcc UCRT version with POSIX threads..</li> <li>just.</li> <li>LunarG Vulkan SDK for Windows.</li> <li>WSL2.</li> <li>vcpkg. The <code>VCPKG_ROOT</code> environment variable should be set and should be in the <code>PATH</code>.</li> <li>Python (e.g. conda).</li> </ul> <p>Instructions:</p> <ol> <li>Copy the decompressed <code>just.exe</code> into <code>C:\\mingw64\\bin</code> (which should have been created by WinLibs).</li> <li>Open a Git Bash terminal.</li> <li>Add this to your <code>~/.bash_profile</code>: <code>export VCPKG_ROOT=/path/to/vcpkg</code> after putting the path to vcpkg.</li> <li>Clone the Datoviz GitHub repository in a folder.</li> <li>Go to that folder in the terminal.</li> <li>Type:</li> </ol> <pre><code>wsl.exe --install\nwsl.exe --update\npip install -r requirements-dev.txt\njust build  # this one may fail, try again below:\njust build\n# Try the builtin demo.\nbuild\\datoviz.exe demo\n# Try running the demo from Python.\npython -c \"import datoviz; datoviz.demo()\"\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing notes","text":"<p>This document is a work in progress.</p>"},{"location":"CONTRIBUTING/#management-commands","title":"Management commands","text":"<p>We use the just tool for all management commands. The commands are implemented in <code>justfile</code>.</p>"},{"location":"CONTRIBUTING/#branches","title":"Branches","text":"<ul> <li>The <code>main</code> branch is reserved to stable releases.</li> <li>Development occurs in the <code>dev</code> branch.</li> </ul>"},{"location":"CONTRIBUTING/#python-bindings","title":"Python bindings","text":"<p>The Python (ctypes) bindings are automatically generated into <code>datoviz/__init__.py</code> which is commmitted in the repository, but should not be manually edited.</p>"},{"location":"CONTRIBUTING/#continuous-integrationcontinuous-delivery","title":"Continuous integration/continuous delivery","text":"<p>GitHub Actions-based CI/CD is not yet active in this repository. In the near future, we intend to activate it for:</p> <ul> <li>cross-platform automated testing of the C library and Python bindings ;</li> <li>automated build of the Python wheels on all supported platforms ;</li> <li>automated build of the documentation and gallery.</li> </ul>"},{"location":"CONTRIBUTING/#debugging","title":"Debugging","text":""},{"location":"CONTRIBUTING/#console-logging","title":"Console logging","text":"<p>Set this environment variable:</p> <ul> <li><code>DVZ_LOG_LEVEL=2</code>: info logging level, default</li> <li><code>DVZ_LOG_LEVEL=1</code>: debug logging level</li> <li><code>DVZ_LOG_LEVEL=0</code>: trace logging level (caution: extremely verbose)</li> </ul>"},{"location":"CONTRIBUTING/#datoviz-intermediate-protocol-requests","title":"Datoviz Intermediate Protocol requests","text":"<p>User-exposed Datoviz commands generate an internal stream of rendering requests which are processed in real time by the Datoviz Vulkan renderer. You can inspect these commands for debugging purposes, and depending on whether the requests are correct, determine whether the bug occurs in the high-level code generating these requests (most frequent case), or in the Vulkan renderer.</p> <ul> <li><code>DVZ_VERBOSE=prt</code>: print a YAML representation of the requests to the standard output.</li> </ul>"},{"location":"CONTRIBUTING/#screenshot","title":"Screenshot","text":"<p>Set this environment variable to force offscreen rendering of all Datoviz applications:</p> <ul> <li><code>DVZ_CAPTURE_PNG=path/to/image.png</code>: save the figure to a PNG file.</li> </ul>"},{"location":"CONTRIBUTING/#performance","title":"Performance","text":"<p>Set these environment variable to display some performance statistics</p> <ul> <li><code>DVZ_FPS=1</code>: display an FPS counter (frames per second).</li> <li><code>DVZ_MONITOR=1</code>: display a memory monitor (allocated GPU memory).</li> </ul> <p>Note: the FPS computation algorithm is currently suboptimal, it will be improved later. Contributions welcome.</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021-2024 Cyrille Rossant</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"MAINTAINERS/","title":"Maintainers instructions","text":""},{"location":"MAINTAINERS/#packaging","title":"Packaging","text":"<p>This section provides instructions for maintainers who need to create binary packages and Python wheels.</p>"},{"location":"MAINTAINERS/#ubuntu-2404","title":"Ubuntu 24.04","text":"<p>Requirements:</p> <ul> <li>Docker</li> <li>just</li> <li><code>sudo apt-get install dpkg-dev fakeroot nvidia-container-toolkit</code></li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.deb</code> Debian installable package for development (with C headers and shared libraries):</p> <pre><code>just deb\n</code></pre> <p>To test the <code>.deb</code> package in an isolated Docker container:</p> <pre><code>just testdeb\n</code></pre> <p>To build a <code>manylinux</code> wheel (using <code>manylinux_2_28_x86_64</code>, based on AlmaLinux 8):</p> <pre><code># Build Datoviz in the manylinux container.\njust buildmany\n\n# Build a Python wheel in that container (saved in dist/).\njust wheelmany\n</code></pre> <p>To test the <code>manylinux</code> wheel:</p> <pre><code>just testwheel\n</code></pre>"},{"location":"MAINTAINERS/#macos-arm64","title":"macOS (arm64)","text":"<p>Requirements:</p> <ul> <li>Homebrew</li> <li>just</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.pkg</code> macOS installable package for development (with C headers and shared libraries):</p> <pre><code>just pkg\n</code></pre> <p>To build a macOS Python wheel:</p> <pre><code>just wheel\n</code></pre> <p>To test the macOS package in an isolated environment:</p> <ol> <li> <p>Install sshpass:</p> <pre><code>brew install sshpass\n</code></pre> </li> <li> <p>Install UTM.</p> </li> <li>Create a new macOS virtual machine (VM) with at least 64 GB storage (for Xcode).</li> <li>Install macOS in the virtual machine. For simplicity, use your <code>$USER</code> as the login and password.</li> <li>Once installed, find the IP address in the VM macOS system preferences and write it down (for example, <code>192.168.64.4</code>).</li> <li>Set up remote access via SSH in the VM macOS system preferences to set up a SSH server.</li> <li> <p>Open a terminal in the VM and type:</p> <pre><code>type: xcode-select --install\n</code></pre> </li> </ol> <p>Go back to the host machine and type:</p> <pre><code># Test the .pkg installation in an UTM virtual machine, using the IP address you wrote down earlier.\njust testpkg 192.168.64.4\n</code></pre> <p>The virtual machine should show the Datoviz demo in a window.</p> <p>To test the macOS wheel, you can either test in a virtual Python environment, or in a virtual machine using UTM.</p> <p>To test the macOS wheel in a virtual Python environment:</p> <pre><code>just testwheel\n</code></pre> <p>To test the macOS wheel in a virtual machine, set up the virtual machine as indicated above, then run (replacing the IP address with your virtual machine's IP):</p> <pre><code>just testwheel 192.168.64.4\n</code></pre>"},{"location":"MAINTAINERS/#macos-intel-x86-64","title":"macOS (Intel x86-64)","text":"<p>Requirements:</p> <ul> <li>Homebrew</li> <li>just</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just pydev\njust release\n</code></pre> <p>To build a <code>.pkg</code> macOS installable package for development (with C headers and shared libraries):</p> <pre><code>just pkg\n</code></pre> <p>To build a macOS Python wheel:</p> <pre><code>just wheel\n</code></pre>"},{"location":"MAINTAINERS/#windows","title":"Windows","text":"<p>Requirements:</p> <ul> <li>Git for Windows</li> <li>WinLibs</li> <li>just</li> <li>LunarG Vulkan SDK for Windows</li> <li>WSL2</li> <li>vcpkg</li> </ul> <p>To build a release binary, see the build instructions:</p> <pre><code>just release\n</code></pre> <p>To build a Windows Python wheel, open a Git Bash and type:</p> <pre><code># see https://stackoverflow.com/a/36530750/1595060\necho \"alias python='winpty python.exe'\" &gt;&gt; ~/.bash_profile\njust pydev\njust wheel\n</code></pre> <p>To test the wheel in a Python virtual environment:</p> <pre><code>just testwheel\n</code></pre>"},{"location":"MAINTAINERS/#release-checklist","title":"Release checklist","text":"<ol> <li>Build in release mode with <code>just release</code>.</li> <li>Run the C testing suite with <code>just test</code>.</li> <li>Run the Python testing suite with <code>just pytest</code>.</li> <li>Write the <code>CHANGELOG.md</code>.</li> <li>Bump to the new version with <code>just bump x.y.z</code>.</li> <li>Commit and tag.</li> <li>Build and test packages.</li> <li>Linux<ul> <li><code>just release</code></li> <li><code>just deb</code></li> <li><code>just testdeb</code></li> <li><code>just manylinux</code></li> <li><code>just testwheel</code></li> <li>Wheel is in <code>dist/</code></li> </ul> </li> <li>macOS ARM &amp; Intel<ul> <li><code>just release</code></li> <li><code>just pkg</code></li> <li><code>just wheel</code></li> <li><code>just testwheel</code></li> <li>Wheel is in <code>dist/</code></li> </ul> </li> <li>Windows<ul> <li><code>just release</code></li> <li><code>just wheel</code></li> <li><code>just testwheel</code></li> <li>Wheel is in <code>dist/</code></li> </ul> </li> <li>Upload packages.</li> <li>Bump to the new development version with <code>just bump a.b.c-dev</code>.</li> <li>Announcement.</li> </ol>"},{"location":"api/","title":"C API Reference","text":""},{"location":"api/#functions","title":"Functions","text":""},{"location":"api/#dvz_app","title":"<code>dvz_app()</code>","text":"<p>Create an app.</p> <pre><code>DvzApp* dvz_app(  // returns: the app\n    int flags,  // the app creation flags\n)\n</code></pre>"},{"location":"api/#dvz_app_batch","title":"<code>dvz_app_batch()</code>","text":"<p>Return the app batch.</p> <pre><code>DvzBatch* dvz_app_batch(  // returns: the batch\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_destroy","title":"<code>dvz_app_destroy()</code>","text":"<p>Destroy the app.</p> <pre><code>void dvz_app_destroy(\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_frame","title":"<code>dvz_app_frame()</code>","text":"<p>Run one frame.</p> <pre><code>void dvz_app_frame(\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_gui","title":"<code>dvz_app_gui()</code>","text":"<p>Register a GUI callback.</p> <pre><code>void dvz_app_gui(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the canvas ID\n    DvzAppGuiCallback callback,  // the GUI callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onframe","title":"<code>dvz_app_onframe()</code>","text":"<p>Register a frame callback.</p> <pre><code>void dvz_app_onframe(\n    DvzApp* app,  // the app\n    DvzAppFrameCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onkeyboard","title":"<code>dvz_app_onkeyboard()</code>","text":"<p>Register a keyboard callback.</p> <pre><code>void dvz_app_onkeyboard(\n    DvzApp* app,  // the app\n    DvzAppKeyboardCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onmouse","title":"<code>dvz_app_onmouse()</code>","text":"<p>Register a mouse callback.</p> <pre><code>void dvz_app_onmouse(\n    DvzApp* app,  // the app\n    DvzAppMouseCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_onresize","title":"<code>dvz_app_onresize()</code>","text":"<p>Register a resize callback.</p> <pre><code>void dvz_app_onresize(\n    DvzApp* app,  // the app\n    DvzAppResizeCallback callback,  // the callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_ontimer","title":"<code>dvz_app_ontimer()</code>","text":"<p>Register a timer callback.</p> <pre><code>void dvz_app_ontimer(\n    DvzApp* app,  // the app\n    DvzAppTimerCallback callback,  // the timer callback\n    void* user_data,  // the user data\n)\n</code></pre>"},{"location":"api/#dvz_app_run","title":"<code>dvz_app_run()</code>","text":"<p>Start the application event loop.</p> <pre><code>void dvz_app_run(\n    DvzApp* app,  // the app\n    uint64_t n_frames,  // the maximum number of frames, 0 for infinite loop\n)\n</code></pre>"},{"location":"api/#dvz_app_screenshot","title":"<code>dvz_app_screenshot()</code>","text":"<p>Make a screenshot of a canvas.</p> <pre><code>void dvz_app_screenshot(\n    DvzApp* app,  // the app\n    DvzId canvas_id,  // the ID of the canvas\n    char* filename,  // the path to the PNG file with the screenshot\n)\n</code></pre>"},{"location":"api/#dvz_app_submit","title":"<code>dvz_app_submit()</code>","text":"<p>Submit the current batch to the application.</p> <pre><code>void dvz_app_submit(\n    DvzApp* app,  // the app\n)\n</code></pre>"},{"location":"api/#dvz_app_timer","title":"<code>dvz_app_timer()</code>","text":"<p>Create a timer.</p> <pre><code>DvzTimerItem* dvz_app_timer(  // returns: the timer\n    DvzApp* app,  // the app\n    double delay,  // the delay, in seconds, until the first event\n    double period,  // the period, in seconds, between two events\n    uint64_t max_count,  // the maximum number of events\n)\n</code></pre>"},{"location":"api/#dvz_arcball_angles","title":"<code>dvz_arcball_angles()</code>","text":"<p>Get the current arcball angles.</p> <pre><code>void dvz_arcball_angles(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_constrain","title":"<code>dvz_arcball_constrain()</code>","text":"<p>Add arcball constraints.</p> <pre><code>void dvz_arcball_constrain(\n    DvzArcball* arcball,  // the arcball\n    vec3 constrain,  // the constrain values\n)\n</code></pre>"},{"location":"api/#dvz_arcball_end","title":"<code>dvz_arcball_end()</code>","text":"<p>Finalize arcball position update.</p> <pre><code>void dvz_arcball_end(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_flags","title":"<code>dvz_arcball_flags()</code>","text":"<p>Set the arcball flags.</p> <pre><code>void dvz_arcball_flags(\n    DvzArcball* arcball,  // the arcball\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_arcball_initial","title":"<code>dvz_arcball_initial()</code>","text":"<p>Set the initial arcball angles.</p> <pre><code>void dvz_arcball_initial(\n    DvzArcball* arcball,  // the arcball\n    vec3 angles,  // the initial angles\n)\n</code></pre>"},{"location":"api/#dvz_arcball_model","title":"<code>dvz_arcball_model()</code>","text":"<p>Return the model matrix of an arcball.</p> <pre><code>void dvz_arcball_model(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_mvp","title":"<code>dvz_arcball_mvp()</code>","text":"<p>Apply an MVP matrix to an arcball (only the model matrix).</p> <pre><code>void dvz_arcball_mvp(\n    DvzArcball* arcball,  // the arcball\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_arcball_print","title":"<code>dvz_arcball_print()</code>","text":"<p>Display information about an arcball.</p> <pre><code>void dvz_arcball_print(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_reset","title":"<code>dvz_arcball_reset()</code>","text":"<p>Reset an arcball to its initial position.</p> <pre><code>void dvz_arcball_reset(\n    DvzArcball* arcball,  // the arcball\n)\n</code></pre>"},{"location":"api/#dvz_arcball_resize","title":"<code>dvz_arcball_resize()</code>","text":"<p>Inform an arcball of a panel resize.</p> <pre><code>void dvz_arcball_resize(\n    DvzArcball* arcball,  // the arcball\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_arcball_rotate","title":"<code>dvz_arcball_rotate()</code>","text":"<p>Apply a rotation to an arcball.</p> <pre><code>void dvz_arcball_rotate(\n    DvzArcball* arcball,  // the arcball\n    vec2 cur_pos,  // the initial position\n    vec2 last_pos,  // the final position\n)\n</code></pre>"},{"location":"api/#dvz_arcball_set","title":"<code>dvz_arcball_set()</code>","text":"<p>Set the arcball angles.</p> <pre><code>void dvz_arcball_set(\n    DvzArcball* arcball,  // the arcball\n    vec3 angles,  // the angles\n)\n</code></pre>"},{"location":"api/#dvz_atlas_font","title":"<code>dvz_atlas_font()</code>","text":"<p>Load the default atlas and font.</p> <pre><code>DvzAtlasFont dvz_atlas_font(  // returns: a DvzAtlasFont struct with DvzAtlas and DvzFont objects.\n    double font_size,  // the font size\n)\n</code></pre>"},{"location":"api/#dvz_basic","title":"<code>dvz_basic()</code>","text":"<p>Create a basic visual using the few GPU visual primitives (point, line, triangles).</p> <pre><code>DvzVisual* dvz_basic(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    DvzPrimitiveTopology topology,  // the primitive topology\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_basic_alloc","title":"<code>dvz_basic_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_basic_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_basic_color","title":"<code>dvz_basic_color()</code>","text":"<p>Set the vertex colors.</p> <pre><code>void dvz_basic_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_basic_position","title":"<code>dvz_basic_position()</code>","text":"<p>Set the vertex positions.</p> <pre><code>void dvz_basic_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_camera_initial","title":"<code>dvz_camera_initial()</code>","text":"<p>Set the initial camera parameters.</p> <pre><code>void dvz_camera_initial(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the initial position\n    vec3 lookat,  // the lookat position\n    vec3 up,  // the up vector\n)\n</code></pre>"},{"location":"api/#dvz_camera_lookat","title":"<code>dvz_camera_lookat()</code>","text":"<p>Set a camera lookat position.</p> <pre><code>void dvz_camera_lookat(\n    DvzCamera* camera,  // the camera\n    vec3 lookat,  // the lookat position\n)\n</code></pre>"},{"location":"api/#dvz_camera_mvp","title":"<code>dvz_camera_mvp()</code>","text":"<p>Apply an MVP to a camera.</p> <pre><code>void dvz_camera_mvp(\n    DvzCamera* camera,  // the camera\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_camera_ortho","title":"<code>dvz_camera_ortho()</code>","text":"<p>Make an orthographic camera.</p> <pre><code>void dvz_camera_ortho(\n    DvzCamera* camera,  // the camera\n    float left,  // the left value\n    float right,  // the right value\n    float bottom,  // the bottom value\n    float top,  // the top value\n)\n</code></pre>"},{"location":"api/#dvz_camera_perspective","title":"<code>dvz_camera_perspective()</code>","text":"<p>Set a camera perspective.</p> <pre><code>void dvz_camera_perspective(\n    DvzCamera* camera,  // the camera\n    float fov,  // the field of view angle (in radians)\n)\n</code></pre>"},{"location":"api/#dvz_camera_position","title":"<code>dvz_camera_position()</code>","text":"<p>Set a camera position.</p> <pre><code>void dvz_camera_position(\n    DvzCamera* camera,  // the camera\n    vec3 pos,  // the pos\n)\n</code></pre>"},{"location":"api/#dvz_camera_print","title":"<code>dvz_camera_print()</code>","text":"<p>Display information about a camera.</p> <pre><code>void dvz_camera_print(\n    DvzCamera* camera,  // the camera\n)\n</code></pre>"},{"location":"api/#dvz_camera_reset","title":"<code>dvz_camera_reset()</code>","text":"<p>Reset a camera.</p> <pre><code>void dvz_camera_reset(\n    DvzCamera* camera,  // the camera\n)\n</code></pre>"},{"location":"api/#dvz_camera_resize","title":"<code>dvz_camera_resize()</code>","text":"<p>Inform a camera of a panel resize.</p> <pre><code>void dvz_camera_resize(\n    DvzCamera* camera,  // the camera\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_camera_up","title":"<code>dvz_camera_up()</code>","text":"<p>Set a camera up vector.</p> <pre><code>void dvz_camera_up(\n    DvzCamera* camera,  // the camera\n    vec3 up,  // the up vector\n)\n</code></pre>"},{"location":"api/#dvz_camera_viewproj","title":"<code>dvz_camera_viewproj()</code>","text":"<p>Return the view and proj matrices of the camera.</p> <pre><code>void dvz_camera_viewproj(\n    DvzCamera* camera,  // the camera\n)\n</code></pre>"},{"location":"api/#dvz_camera_zrange","title":"<code>dvz_camera_zrange()</code>","text":"<p>Set the camera zrange.</p> <pre><code>void dvz_camera_zrange(\n    DvzCamera* camera,  // the camera\n    float near,  // the near value\n    float far,  // the far value\n)\n</code></pre>"},{"location":"api/#dvz_circular_2d","title":"<code>dvz_circular_2D()</code>","text":"<p>Generate a 2D circular motion.</p> <pre><code>void dvz_circular_2D(\n    vec2 center,  // the circle center\n    float radius,  // the circle radius\n    float angle,  // the initial angle\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_circular_3d","title":"<code>dvz_circular_3D()</code>","text":"<p>Generate a 3D circular motion.</p> <pre><code>void dvz_circular_3D(\n    vec3 center,  // the circle center\n    vec3 u,  // the first 3D vector defining the plane containing the circle\n    vec3 v,  // the second 3D vector defining the plane containing the circle\n    float radius,  // the circle radius\n    float angle,  // the initial angle\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_colormap","title":"<code>dvz_colormap()</code>","text":"<p>Fetch a color from a colormap and a value.</p> <pre><code>void dvz_colormap(\n    DvzColormap cmap,  // the colormap\n    uint8_t value,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_colormap_array","title":"<code>dvz_colormap_array()</code>","text":"<p>Fetch colors from a colormap and an array of values.</p> <pre><code>void dvz_colormap_array(\n    DvzColormap cmap,  // the colormap\n    uint32_t count,  // the number of values\n    float* values,  // pointer to the array of float numbers\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n)\n</code></pre>"},{"location":"api/#dvz_colormap_scale","title":"<code>dvz_colormap_scale()</code>","text":"<p>Fetch a color from a colormap and an interpolated value.</p> <pre><code>void dvz_colormap_scale(\n    DvzColormap cmap,  // the colormap\n    float value,  // the value\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n)\n</code></pre>"},{"location":"api/#dvz_demo","title":"<code>dvz_demo()</code>","text":"<p>Run a demo.</p> <pre><code>void dvz_demo(\n\n)\n</code></pre>"},{"location":"api/#dvz_easing","title":"<code>dvz_easing()</code>","text":"<p>Apply an easing function to a normalized value.</p> <pre><code>double dvz_easing(  // returns: the eased value\n    DvzEasing easing,  // the easing mode\n    double t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_figure","title":"<code>dvz_figure()</code>","text":"<p>Create a figure, a desktop window with panels and visuals.</p> <pre><code>DvzFigure* dvz_figure(  // returns: the figure\n    DvzScene* scene,  // the scene\n    uint32_t width,  // the window width\n    uint32_t height,  // the window height\n    int flags,  // the figure creation flags (not yet stabilized)\n)\n</code></pre>"},{"location":"api/#dvz_figure_destroy","title":"<code>dvz_figure_destroy()</code>","text":"<p>Destroy a figure.</p> <pre><code>void dvz_figure_destroy(\n    DvzFigure* figure,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_figure_id","title":"<code>dvz_figure_id()</code>","text":"<p>Return a figure ID.</p> <pre><code>DvzId dvz_figure_id(  // returns: the figure ID\n    DvzFigure* figure,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_figure_resize","title":"<code>dvz_figure_resize()</code>","text":"<p>Resize a figure.</p> <pre><code>void dvz_figure_resize(\n    DvzFigure* fig,  // the figure\n    uint32_t width,  // the window width\n    uint32_t height,  // the window height\n)\n</code></pre>"},{"location":"api/#dvz_figure_update","title":"<code>dvz_figure_update()</code>","text":"<p>Update a figure after the composition of the panels and visuals has changed.</p> <pre><code>void dvz_figure_update(\n    DvzFigure* figure,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_font","title":"<code>dvz_font()</code>","text":"<p>Create a font.</p> <pre><code>DvzFont* dvz_font(  // returns: the font\n    long ttf_size,  // size in bytes of a TTF font raw buffer\n    char* ttf_bytes,  // TTF font raw buffer\n)\n</code></pre>"},{"location":"api/#dvz_font_ascii","title":"<code>dvz_font_ascii()</code>","text":"<p>Compute the shift of each glyph in an ASCII string, using the Freetype library.</p> <pre><code>vec4* dvz_font_ascii(  // returns: an array of (x,y,w,h) shifts\n    DvzFont* font,  // the font\n    char* string,  // the ASCII string\n)\n</code></pre>"},{"location":"api/#dvz_font_destroy","title":"<code>dvz_font_destroy()</code>","text":"<p>Destroy a font.</p> <pre><code>void dvz_font_destroy(\n    DvzFont* font,  // the font\n)\n</code></pre>"},{"location":"api/#dvz_font_draw","title":"<code>dvz_font_draw()</code>","text":"<p>Render a string using Freetype.</p> <pre><code>uint8_t* dvz_font_draw(  // returns: an RGBA array allocated by this function and that MUST be freed by the caller\n    DvzFont* font,  // the font\n    uint32_t length,  // the number of glyphs\n    uint32_t* codepoints,  // the Unicode codepoints of the glyphs\n    vec4* xywh,  // an array of (x,y,w,h) shifts, returned by dvz_font_layout()\n)\n</code></pre>"},{"location":"api/#dvz_font_layout","title":"<code>dvz_font_layout()</code>","text":"<p>Compute the shift of each glyph in a Unicode string, using the Freetype library.</p> <pre><code>vec4* dvz_font_layout(  // returns: an array of (x,y,w,h) shifts\n    DvzFont* font,  // the font\n    uint32_t length,  // the number of glyphs\n    uint32_t* codepoints,  // the Unicode codepoints of the glyphs\n)\n</code></pre>"},{"location":"api/#dvz_font_size","title":"<code>dvz_font_size()</code>","text":"<p>Set the font size.</p> <pre><code>void dvz_font_size(\n    DvzFont* font,  // the font\n    double size,  // the font size\n)\n</code></pre>"},{"location":"api/#dvz_free","title":"<code>dvz_free()</code>","text":"<p>Free a pointer.</p> <pre><code>void dvz_free(\n    void* pointer,  // a pointer\n)\n</code></pre>"},{"location":"api/#dvz_glyph","title":"<code>dvz_glyph()</code>","text":"<p>Create a glyph visual.</p> <pre><code>DvzVisual* dvz_glyph(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_alloc","title":"<code>dvz_glyph_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_glyph_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_glyph_anchor","title":"<code>dvz_glyph_anchor()</code>","text":"<p>Set the glyph anchors.</p> <pre><code>void dvz_glyph_anchor(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the anchors (x and y) of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_angle","title":"<code>dvz_glyph_angle()</code>","text":"<p>Set the glyph angles.</p> <pre><code>void dvz_glyph_angle(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the angles of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_ascii","title":"<code>dvz_glyph_ascii()</code>","text":"<p>Set the glyph ascii characters.</p> <pre><code>void dvz_glyph_ascii(\n    DvzVisual* visual,  // the visual\n    char* string,  // the characters\n)\n</code></pre>"},{"location":"api/#dvz_glyph_atlas","title":"<code>dvz_glyph_atlas()</code>","text":"<p>Associate an atlas with a glyph visual.</p> <pre><code>void dvz_glyph_atlas(\n    DvzVisual* visual,  // the visual\n    DvzAtlas* atlas,  // the atlas\n)\n</code></pre>"},{"location":"api/#dvz_glyph_axis","title":"<code>dvz_glyph_axis()</code>","text":"<p>Set the glyph axes.</p> <pre><code>void dvz_glyph_axis(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D axis vectors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_bgcolor","title":"<code>dvz_glyph_bgcolor()</code>","text":"<p>Set the glyph background color.</p> <pre><code>void dvz_glyph_bgcolor(\n    DvzVisual* visual,  // the visual\n    vec4 bgcolor,  // the background color\n)\n</code></pre>"},{"location":"api/#dvz_glyph_color","title":"<code>dvz_glyph_color()</code>","text":"<p>Set the glyph colors.</p> <pre><code>void dvz_glyph_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_groupsize","title":"<code>dvz_glyph_groupsize()</code>","text":"<p>Set the glyph group size.</p> <pre><code>void dvz_glyph_groupsize(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the glyph group sizes\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_position","title":"<code>dvz_glyph_position()</code>","text":"<p>Set the glyph positions.</p> <pre><code>void dvz_glyph_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_shift","title":"<code>dvz_glyph_shift()</code>","text":"<p>Set the glyph shifts.</p> <pre><code>void dvz_glyph_shift(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the shifts (x and y) of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_size","title":"<code>dvz_glyph_size()</code>","text":"<p>Set the glyph sizes.</p> <pre><code>void dvz_glyph_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec2* values,  // the sizes (width and height) of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_texcoords","title":"<code>dvz_glyph_texcoords()</code>","text":"<p>Set the glyph texture coordinates.</p> <pre><code>void dvz_glyph_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* coords,  // the x,y,w,h texture coordinates\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_glyph_texture","title":"<code>dvz_glyph_texture()</code>","text":"<p>Assign a texture to a glyph visual.</p> <pre><code>void dvz_glyph_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n)\n</code></pre>"},{"location":"api/#dvz_glyph_unicode","title":"<code>dvz_glyph_unicode()</code>","text":"<p>Set the glyph unicode code points.</p> <pre><code>void dvz_glyph_unicode(\n    DvzVisual* visual,  // the visual\n    uint32_t count,  // the number of glyphs\n    uint32_t* codepoints,  // the unicode codepoints\n)\n</code></pre>"},{"location":"api/#dvz_glyph_xywh","title":"<code>dvz_glyph_xywh()</code>","text":"<p>Set the xywh parameters of each glyph.</p> <pre><code>void dvz_glyph_xywh(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the xywh values of each glyph\n    vec2 offset,  // the xy offsets of each glyph\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_alpha","title":"<code>dvz_gui_alpha()</code>","text":"<p>Set the alpha transparency of the next GUI dialog.</p> <pre><code>void dvz_gui_alpha(\n    float alpha,  // the alpha transparency value\n)\n</code></pre>"},{"location":"api/#dvz_gui_begin","title":"<code>dvz_gui_begin()</code>","text":"<p>Start a new dialog.</p> <pre><code>void dvz_gui_begin(\n    char* title,  // the dialog title\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_button","title":"<code>dvz_gui_button()</code>","text":"<p>Add a button.</p> <pre><code>bool dvz_gui_button(  // returns: whether the button was pressed\n    char* name,  // the button name\n    float width,  // the button width\n    float height,  // the button height\n)\n</code></pre>"},{"location":"api/#dvz_gui_checkbox","title":"<code>dvz_gui_checkbox()</code>","text":"<p>Add a checkbox.</p> <pre><code>bool dvz_gui_checkbox(  // returns: whether the checkbox's state has changed\n    char* name,  // the button name\n     width,  // the button width\n     height,  // the button height\n)\n</code></pre>"},{"location":"api/#dvz_gui_corner","title":"<code>dvz_gui_corner()</code>","text":"<p>Set the corner position of the next GUI dialog.</p> <pre><code>void dvz_gui_corner(\n    DvzCorner corner,  // which corner\n    vec2 pad,  // the pad\n)\n</code></pre>"},{"location":"api/#dvz_gui_demo","title":"<code>dvz_gui_demo()</code>","text":"<p>Show the demo GUI.</p> <pre><code>void dvz_gui_demo(\n\n)\n</code></pre>"},{"location":"api/#dvz_gui_end","title":"<code>dvz_gui_end()</code>","text":"<p>Stop the creation of the dialog.</p> <pre><code>void dvz_gui_end(\n\n)\n</code></pre>"},{"location":"api/#dvz_gui_flags","title":"<code>dvz_gui_flags()</code>","text":"<p>Set the flags of the next GUI dialog.</p> <pre><code>int dvz_gui_flags(\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_gui_image","title":"<code>dvz_gui_image()</code>","text":"<p>Add an image in a GUI dialog.</p> <pre><code>void dvz_gui_image(\n    DvzTex* tex,  // the texture\n    float width,  // the image width\n    float height,  // the image height\n)\n</code></pre>"},{"location":"api/#dvz_gui_pos","title":"<code>dvz_gui_pos()</code>","text":"<p>Set the position of the next GUI dialog.</p> <pre><code>void dvz_gui_pos(\n    vec2 pos,  // the dialog position\n    vec2 pivot,  // the pivot\n)\n</code></pre>"},{"location":"api/#dvz_gui_size","title":"<code>dvz_gui_size()</code>","text":"<p>Set the size of the next GUI dialog.</p> <pre><code>void dvz_gui_size(\n    vec2 size,  // the size\n)\n</code></pre>"},{"location":"api/#dvz_gui_slider","title":"<code>dvz_gui_slider()</code>","text":"<p>Add a slider.</p> <pre><code>bool dvz_gui_slider(  // returns: whether the value has changed\n    char* name,  // the slider name\n    float vmin,  // the minimum value\n    float vmax,  // the maximum value\n    float* value,  // the pointer to the value\n)\n</code></pre>"},{"location":"api/#dvz_image","title":"<code>dvz_image()</code>","text":"<p>Create an image visual.</p> <pre><code>DvzVisual* dvz_image(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_image_alloc","title":"<code>dvz_image_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_image_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of images to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_image_position","title":"<code>dvz_image_position()</code>","text":"<p>Set the image positions.</p> <pre><code>void dvz_image_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* ul_lr,  // the 2D positions of the upper-left and lower-right corners (vec4 x0,y0,x1,y1)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_texcoords","title":"<code>dvz_image_texcoords()</code>","text":"<p>Set the image texture coordinates.</p> <pre><code>void dvz_image_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* ul_lr,  // the tex coordinates of the upper-left and lower-right corners (vec4 u0,v0,u1,v1)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_image_texture","title":"<code>dvz_image_texture()</code>","text":"<p>Assign a texture to an image visual.</p> <pre><code>void dvz_image_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_interpolate","title":"<code>dvz_interpolate()</code>","text":"<p>Make a linear interpolation between two scalar value.</p> <pre><code>float dvz_interpolate(  // returns: the interpolated value\n    float p0,  // the first value\n    float p1,  // the second value\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_interpolate_2d","title":"<code>dvz_interpolate_2D()</code>","text":"<p>Make a linear interpolation between two 2D points.</p> <pre><code>void dvz_interpolate_2D(  // returns: the interpolated point\n    vec2 p0,  // the first point\n    vec2 p1,  // the second point\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_interpolate_3d","title":"<code>dvz_interpolate_3D()</code>","text":"<p>Make a linear interpolation between two 3D points.</p> <pre><code>void dvz_interpolate_3D(  // returns: the interpolated point\n    vec3 p0,  // the first point\n    vec3 p1,  // the second point\n    float t,  // the normalized value\n)\n</code></pre>"},{"location":"api/#dvz_marker","title":"<code>dvz_marker()</code>","text":"<p>Create a marker visual.</p> <pre><code>DvzVisual* dvz_marker(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_alloc","title":"<code>dvz_marker_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_marker_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_marker_angle","title":"<code>dvz_marker_angle()</code>","text":"<p>Set the marker angles.</p> <pre><code>void dvz_marker_angle(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the angles of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_aspect","title":"<code>dvz_marker_aspect()</code>","text":"<p>Set the marker aspect.</p> <pre><code>void dvz_marker_aspect(\n    DvzVisual* visual,  // the visual\n    DvzMarkerAspect aspect,  // the marker aspect, one of DVZ_MARKER_ASPECT_FILLED, DVZ_MARKER_ASPECT_STROKE,\n)\n</code></pre>"},{"location":"api/#dvz_marker_color","title":"<code>dvz_marker_color()</code>","text":"<p>Set the marker colors.</p> <pre><code>void dvz_marker_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_edge_color","title":"<code>dvz_marker_edge_color()</code>","text":"<p>Set the marker edge color.</p> <pre><code>void dvz_marker_edge_color(\n    DvzVisual* visual,  // the visual\n    cvec4 value,  // the edge color\n)\n</code></pre>"},{"location":"api/#dvz_marker_edge_width","title":"<code>dvz_marker_edge_width()</code>","text":"<p>Set the marker edge width.</p> <pre><code>void dvz_marker_edge_width(\n    DvzVisual* visual,  // the visual\n    float value,  // the edge width\n)\n</code></pre>"},{"location":"api/#dvz_marker_mode","title":"<code>dvz_marker_mode()</code>","text":"<p>Set the marker mode.</p> <pre><code>void dvz_marker_mode(\n    DvzVisual* visual,  // the visual\n    DvzMarkerMode mode,  // the marker mode, one of DVZ_MARKER_MODE_CODE, DVZ_MARKER_MODE_BITMAP,\n)\n</code></pre>"},{"location":"api/#dvz_marker_position","title":"<code>dvz_marker_position()</code>","text":"<p>Set the marker positions.</p> <pre><code>void dvz_marker_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_shape","title":"<code>dvz_marker_shape()</code>","text":"<p>Set the marker shape.</p> <pre><code>void dvz_marker_shape(\n    DvzVisual* visual,  // the visual\n    DvzMarkerShape shape,  // the marker shape\n)\n</code></pre>"},{"location":"api/#dvz_marker_size","title":"<code>dvz_marker_size()</code>","text":"<p>Set the marker sizes.</p> <pre><code>void dvz_marker_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_marker_tex","title":"<code>dvz_marker_tex()</code>","text":"<p>Set the marker texture.</p> <pre><code>void dvz_marker_tex(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzId sampler,  // the sampler ID\n)\n</code></pre>"},{"location":"api/#dvz_marker_tex_scale","title":"<code>dvz_marker_tex_scale()</code>","text":"<p>Set the texture scale.</p> <pre><code>void dvz_marker_tex_scale(\n    DvzVisual* visual,  // the visual\n    float value,  // the texture scale\n)\n</code></pre>"},{"location":"api/#dvz_mesh","title":"<code>dvz_mesh()</code>","text":"<p>Create a mesh visual.</p> <pre><code>DvzVisual* dvz_mesh(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_alloc","title":"<code>dvz_mesh_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_mesh_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t vertex_count,  // the number of vertices\n    uint32_t index_count,  // the number of indices\n)\n</code></pre>"},{"location":"api/#dvz_mesh_color","title":"<code>dvz_mesh_color()</code>","text":"<p>Set the mesh colors.</p> <pre><code>void dvz_mesh_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the vertex colors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_index","title":"<code>dvz_mesh_index()</code>","text":"<p>Set the mesh indices.</p> <pre><code>void dvz_mesh_index(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzIndex* values,  // the face indices (three vertex indices per triangle)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_light_params","title":"<code>dvz_mesh_light_params()</code>","text":"<p>Set the mesh light parameters.</p> <pre><code>void dvz_mesh_light_params(\n    DvzVisual* visual,  // the mesh\n    vec4 params,  // the light parameters (vec4 ambient, diffuse, specular, exponent)\n)\n</code></pre>"},{"location":"api/#dvz_mesh_light_pos","title":"<code>dvz_mesh_light_pos()</code>","text":"<p>Set the mesh light position.</p> <pre><code>void dvz_mesh_light_pos(\n    DvzVisual* visual,  // the mesh\n    vec3 pos,  // the light position\n)\n</code></pre>"},{"location":"api/#dvz_mesh_normal","title":"<code>dvz_mesh_normal()</code>","text":"<p>Set the mesh normals.</p> <pre><code>void dvz_mesh_normal(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the vertex normal vectors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_position","title":"<code>dvz_mesh_position()</code>","text":"<p>Set the mesh vertex positions.</p> <pre><code>void dvz_mesh_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D vertex positions\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_reshape","title":"<code>dvz_mesh_reshape()</code>","text":"<p>Update a mesh once a shape has been updated.</p> <pre><code>void dvz_mesh_reshape(\n    DvzVisual* visual,  // the mesh\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_mesh_shape","title":"<code>dvz_mesh_shape()</code>","text":"<p>Create a mesh out of a shape.</p> <pre><code>DvzVisual* dvz_mesh_shape(  // returns: the mesh\n    DvzBatch* batch,  // the batch\n    DvzShape* shape,  // the shape\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_texcoords","title":"<code>dvz_mesh_texcoords()</code>","text":"<p>Set the mesh texture coordinates.</p> <pre><code>void dvz_mesh_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the vertex texture coordinates (vec4 u,v,*,alpha)\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_mesh_texture","title":"<code>dvz_mesh_texture()</code>","text":"<p>Assign a 2D texture to a mesh visual.</p> <pre><code>void dvz_mesh_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_mvp","title":"<code>dvz_mvp()</code>","text":"<p>Create a MVP structure.</p> <pre><code>DvzMVP dvz_mvp(  // returns: the MVP structure\n    mat4 model,  // the model matrix\n    mat4 view,  // the view matrix\n    mat4 proj,  // the projection matrix\n)\n</code></pre>"},{"location":"api/#dvz_panel","title":"<code>dvz_panel()</code>","text":"<p>Create a panel in a figure (partial or complete rectangular portion of a figure).</p> <pre><code>DvzPanel* dvz_panel(\n    DvzFigure* fig,  // the figure\n    float x,  // the x coordinate of the top-left corner, in pixels\n    float y,  // the y coordinate of the top-left corner, in pixels\n    float width,  // the panel width, in pixels\n    float height,  // the panel height, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel_arcball","title":"<code>dvz_panel_arcball()</code>","text":"<p>Set arcball interactivity for a panel.</p> <pre><code>DvzArcball* dvz_panel_arcball(  // returns: the arcball\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_at","title":"<code>dvz_panel_at()</code>","text":"<p>Return the panel containing a given point.</p> <pre><code>DvzPanel* dvz_panel_at(  // returns: the panel containing the point, or NULL if there is none\n    DvzFigure* figure,  // the figure\n    vec2 pos,  // the position\n)\n</code></pre>"},{"location":"api/#dvz_panel_camera","title":"<code>dvz_panel_camera()</code>","text":"<p>Set a camera for a panel.</p> <pre><code>DvzCamera* dvz_panel_camera(  // returns: the camera\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_contains","title":"<code>dvz_panel_contains()</code>","text":"<p>Return whether a point is inside a panel.</p> <pre><code>bool dvz_panel_contains(  // returns: true if the position lies within the panel\n    DvzPanel* panel,  // the panel\n    vec2 pos,  // the position\n)\n</code></pre>"},{"location":"api/#dvz_panel_default","title":"<code>dvz_panel_default()</code>","text":"<p>Return the default full panel spanning an entire figure.</p> <pre><code>DvzPanel* dvz_panel_default(  // returns: the panel spanning the entire figure\n    DvzFigure* fig,  // the figure\n)\n</code></pre>"},{"location":"api/#dvz_panel_destroy","title":"<code>dvz_panel_destroy()</code>","text":"<p>Destroy a panel.</p> <pre><code>void dvz_panel_destroy(\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_margins","title":"<code>dvz_panel_margins()</code>","text":"<p>Set the margins of a panel.</p> <pre><code>void dvz_panel_margins(\n    DvzPanel* panel,  // the panel\n    float top,  // the top margin, in pixels\n    float right,  // the right margin, in pixels\n    float bottom,  // the bottom margin, in pixels\n    float left,  // the left margin, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel_mvp","title":"<code>dvz_panel_mvp()</code>","text":"<p>Assign a MVP structure to a panel.</p> <pre><code>void dvz_panel_mvp(\n    DvzPanel* panel,  // the panel\n    DvzMVP* mvp,  // a pointer to the MVP structure\n)\n</code></pre>"},{"location":"api/#dvz_panel_mvpmat","title":"<code>dvz_panel_mvpmat()</code>","text":"<p>Assign the model-view-proj matrices to a panel.</p> <pre><code>void dvz_panel_mvpmat(\n    DvzPanel* panel,  // the panel\n    mat4 model,  // the model matrix\n    mat4 view,  // the view matrix\n    mat4 proj,  // the projection matrix\n)\n</code></pre>"},{"location":"api/#dvz_panel_panzoom","title":"<code>dvz_panel_panzoom()</code>","text":"<p>Set panzoom interactivity for a panel.</p> <pre><code>DvzPanzoom* dvz_panel_panzoom(  // returns: the panzoom\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_resize","title":"<code>dvz_panel_resize()</code>","text":"<p>Resize a panel.</p> <pre><code>void dvz_panel_resize(\n    DvzPanel* panel,  // the panel\n    float x,  // the x coordinate of the top-left corner, in pixels\n    float y,  // the y coordinate of the top-left corner, in pixels\n    float width,  // the panel width, in pixels\n    float height,  // the panel height, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panel_transform","title":"<code>dvz_panel_transform()</code>","text":"<p>Assign a transform to a panel.</p> <pre><code>void dvz_panel_transform(\n    DvzPanel* panel,  // the panel\n    DvzTransform* tr,  // the transform\n)\n</code></pre>"},{"location":"api/#dvz_panel_update","title":"<code>dvz_panel_update()</code>","text":"<p>Trigger a panel update.</p> <pre><code>void dvz_panel_update(\n    DvzPanel* panel,  // the panel\n)\n</code></pre>"},{"location":"api/#dvz_panel_visual","title":"<code>dvz_panel_visual()</code>","text":"<p>Add a visual to a panel.</p> <pre><code>void dvz_panel_visual(\n    DvzPanel* panel,  // the panel\n    DvzVisual* visual,  // the visual\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_end","title":"<code>dvz_panzoom_end()</code>","text":"<p>End a panzoom interaction.</p> <pre><code>void dvz_panzoom_end(\n    DvzPanzoom* pz,  // the panzoom\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_flags","title":"<code>dvz_panzoom_flags()</code>","text":"<p>Set the panzoom flags.</p> <pre><code>void dvz_panzoom_flags(\n    DvzPanzoom* pz,  // the panzoom\n    int flags,  // the flags\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_mvp","title":"<code>dvz_panzoom_mvp()</code>","text":"<p>Apply an MVP matrix to a panzoom.</p> <pre><code>void dvz_panzoom_mvp(\n    DvzPanzoom* pz,  // the panzoom\n    DvzMVP* mvp,  // the MVP\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_pan","title":"<code>dvz_panzoom_pan()</code>","text":"<p>Apply a pan value to a panzoom.</p> <pre><code>void dvz_panzoom_pan(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 pan,  // the pan, in NDC\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_pan_shift","title":"<code>dvz_panzoom_pan_shift()</code>","text":"<p>Apply a pan shift to a panzoom.</p> <pre><code>void dvz_panzoom_pan_shift(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_reset","title":"<code>dvz_panzoom_reset()</code>","text":"<p>Reset a panzoom.</p> <pre><code>void dvz_panzoom_reset(\n    DvzPanzoom* pz,  // the panzoom\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_resize","title":"<code>dvz_panzoom_resize()</code>","text":"<p>Inform a panzoom of a panel resize.</p> <pre><code>void dvz_panzoom_resize(\n    DvzPanzoom* pz,  // the panzoom\n    float width,  // the panel width\n    float height,  // the panel height\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_xlim","title":"<code>dvz_panzoom_xlim()</code>","text":"<p>Set a panzoom x limits.</p> <pre><code>void dvz_panzoom_xlim(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 xlim,  // the xlim (FLOAT_MIN/MAX=no lim)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_xrange","title":"<code>dvz_panzoom_xrange()</code>","text":"<p>Get or set the xrange.</p> <pre><code>void dvz_panzoom_xrange(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 xrange,  // the xrange (get if (0,0), set otherwise)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_ylim","title":"<code>dvz_panzoom_ylim()</code>","text":"<p>Set a panzoom y limits.</p> <pre><code>void dvz_panzoom_ylim(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 ylim,  // the ylim (FLOAT_MIN/MAX=no lim)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_yrange","title":"<code>dvz_panzoom_yrange()</code>","text":"<p>Get or set the yrange.</p> <pre><code>void dvz_panzoom_yrange(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 yrange,  // the yrange (get if (0,0), set otherwise)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zlim","title":"<code>dvz_panzoom_zlim()</code>","text":"<p>Set a panzoom z limits.</p> <pre><code>void dvz_panzoom_zlim(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 zlim,  // the zlim (FLOAT_MIN/MAX=no lim)\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zoom","title":"<code>dvz_panzoom_zoom()</code>","text":"<p>Apply a zoom value to a panzoom.</p> <pre><code>void dvz_panzoom_zoom(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 zoom,  // the zoom, in NDC\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zoom_shift","title":"<code>dvz_panzoom_zoom_shift()</code>","text":"<p>Apply a zoom shift to a panzoom.</p> <pre><code>void dvz_panzoom_zoom_shift(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 shift_px,  // the shift value, in pixels\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_panzoom_zoom_wheel","title":"<code>dvz_panzoom_zoom_wheel()</code>","text":"<p>Apply a wheel zoom to a panzoom.</p> <pre><code>void dvz_panzoom_zoom_wheel(\n    DvzPanzoom* pz,  // the panzoom\n    vec2 dir,  // the wheel direction\n    vec2 center_px,  // the center position, in pixels\n)\n</code></pre>"},{"location":"api/#dvz_path","title":"<code>dvz_path()</code>","text":"<p>Create a path visual.</p> <pre><code>DvzVisual* dvz_path(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_path_alloc","title":"<code>dvz_path_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_path_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t total_point_count,  // the total number of points to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_path_color","title":"<code>dvz_path_color()</code>","text":"<p>Set the path colors.</p> <pre><code>void dvz_path_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_path_linewidth","title":"<code>dvz_path_linewidth()</code>","text":"<p>Set the path line width.</p> <pre><code>void dvz_path_linewidth(\n    DvzVisual* visual,  // the visual\n    float value,  // the line width\n)\n</code></pre>"},{"location":"api/#dvz_path_position","title":"<code>dvz_path_position()</code>","text":"<p>Set the path positions. Note: all path point positions must be updated at once for now.</p> <pre><code>void dvz_path_position(\n    DvzVisual* visual,  // the visual\n     vertex_count,  // the total number of points across all paths\n    vec3* positions,  // the path point positions\n    uint32_t path_count,  // the number of different paths\n    uint32_t* path_lengths,  // the number of points in each path\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_pixel","title":"<code>dvz_pixel()</code>","text":"<p>Create a pixel visual.</p> <pre><code>DvzVisual* dvz_pixel(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_pixel_alloc","title":"<code>dvz_pixel_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_pixel_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_pixel_color","title":"<code>dvz_pixel_color()</code>","text":"<p>Set the pixel colors.</p> <pre><code>void dvz_pixel_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_pixel_position","title":"<code>dvz_pixel_position()</code>","text":"<p>Set the pixel positions.</p> <pre><code>void dvz_pixel_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_point","title":"<code>dvz_point()</code>","text":"<p>Create a point visual.</p> <pre><code>DvzVisual* dvz_point(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_point_alloc","title":"<code>dvz_point_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_point_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_point_color","title":"<code>dvz_point_color()</code>","text":"<p>Set the point colors.</p> <pre><code>void dvz_point_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_point_position","title":"<code>dvz_point_position()</code>","text":"<p>Set the point positions.</p> <pre><code>void dvz_point_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* values,  // the 3D positions of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_point_size","title":"<code>dvz_point_size()</code>","text":"<p>Set the point sizes.</p> <pre><code>void dvz_point_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the sizes of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_resample","title":"<code>dvz_resample()</code>","text":"<p>Normalize a value in an interval.</p> <pre><code>double dvz_resample(  // returns: the normalized value between 0 and 1\n    double t0,  // the interval start\n    double t1,  // the interval end\n    double t,  // the value within the interval\n)\n</code></pre>"},{"location":"api/#dvz_scene","title":"<code>dvz_scene()</code>","text":"<p>Create a scene.</p> <pre><code>DvzScene* dvz_scene(  // returns: the scene\n    DvzBatch* batch,  // the batch\n)\n</code></pre>"},{"location":"api/#dvz_scene_destroy","title":"<code>dvz_scene_destroy()</code>","text":"<p>Destroy a scene.</p> <pre><code>void dvz_scene_destroy(\n    DvzScene* scene,  // the scene\n)\n</code></pre>"},{"location":"api/#dvz_scene_figure","title":"<code>dvz_scene_figure()</code>","text":"<p>Get a figure from its id.</p> <pre><code>DvzFigure* dvz_scene_figure(  // returns: the figure\n    DvzScene* scene,  // the scene\n    DvzId id,  // the figure id\n)\n</code></pre>"},{"location":"api/#dvz_scene_run","title":"<code>dvz_scene_run()</code>","text":"<p>Start the event loop and render the scene in a window.</p> <pre><code>void dvz_scene_run(\n    DvzScene* scene,  // the scene\n    DvzApp* app,  // the app\n    uint64_t n_frames,  // the maximum number of frames, 0 for infinite loop\n)\n</code></pre>"},{"location":"api/#dvz_segment","title":"<code>dvz_segment()</code>","text":"<p>Create a segment visual.</p> <pre><code>DvzVisual* dvz_segment(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_alloc","title":"<code>dvz_segment_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_segment_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of items to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_segment_cap","title":"<code>dvz_segment_cap()</code>","text":"<p>Set the segment cap types.</p> <pre><code>void dvz_segment_cap(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    DvzCapType* initial,  // the initial segment cap types\n    DvzCapType* terminal,  // the terminal segment cap types\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_color","title":"<code>dvz_segment_color()</code>","text":"<p>Set the segment colors.</p> <pre><code>void dvz_segment_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* values,  // the colors of the items to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_linewidth","title":"<code>dvz_segment_linewidth()</code>","text":"<p>Set the segment line widths.</p> <pre><code>void dvz_segment_linewidth(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* values,  // the segment line widths\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_position","title":"<code>dvz_segment_position()</code>","text":"<p>Set the segment positions.</p> <pre><code>void dvz_segment_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* initial,  // the initial 3D positions of the segments\n    vec3* terminal,  // the terminal 3D positions of the segments\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_segment_shift","title":"<code>dvz_segment_shift()</code>","text":"<p>Set the segment shift.</p> <pre><code>void dvz_segment_shift(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec4* values,  // the dx0,dy0,dx1,dy1 shift quadriplets of the segments to update\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_shape_begin","title":"<code>dvz_shape_begin()</code>","text":"<p>Start a transformation sequence.</p> <pre><code>void dvz_shape_begin(\n    DvzShape* shape,  // the shape\n    uint32_t first,  // the first vertex to modify\n    uint32_t count,  // the number of vertices to modify\n)\n</code></pre>"},{"location":"api/#dvz_shape_cone","title":"<code>dvz_shape_cone()</code>","text":"<p>Create a cone shape.</p> <pre><code>DvzShape dvz_shape_cone(  // returns: the shape\n    uint32_t count,  // the number of points along the disc border\n    cvec4 color,  // the cone color\n)\n</code></pre>"},{"location":"api/#dvz_shape_cube","title":"<code>dvz_shape_cube()</code>","text":"<p>Create a cube shape.</p> <pre><code>DvzShape dvz_shape_cube(  // returns: the shape\n    cvec4* colors,  // the colors of the six faces\n)\n</code></pre>"},{"location":"api/#dvz_shape_cylinder","title":"<code>dvz_shape_cylinder()</code>","text":"<p>Create a cylinder shape.</p> <pre><code>DvzShape dvz_shape_cylinder(  // returns: the shape\n    uint32_t count,  // the number of points along the cylinder border\n    cvec4 color,  // the cylinder color\n)\n</code></pre>"},{"location":"api/#dvz_shape_destroy","title":"<code>dvz_shape_destroy()</code>","text":"<p>Destroy a shape.</p> <pre><code>void dvz_shape_destroy(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_disc","title":"<code>dvz_shape_disc()</code>","text":"<p>Create a disc shape.</p> <pre><code>DvzShape dvz_shape_disc(  // returns: the shape\n    uint32_t count,  // the number of points along the disc border\n    cvec4 color,  // the disc color\n)\n</code></pre>"},{"location":"api/#dvz_shape_end","title":"<code>dvz_shape_end()</code>","text":"<p>Apply the transformation sequence and reset it.</p> <pre><code>void dvz_shape_end(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_merge","title":"<code>dvz_shape_merge()</code>","text":"<p>Merge two shapes.</p> <pre><code>void dvz_shape_merge(\n    DvzShape* merged,  // the shape to append the other shape to\n    DvzShape* to_merge,  // the shape appended to the first shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_normalize","title":"<code>dvz_shape_normalize()</code>","text":"<p>Normalize a shape.</p> <pre><code>void dvz_shape_normalize(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_normals","title":"<code>dvz_shape_normals()</code>","text":"<p>Recompute the face normals.</p> <pre><code>void dvz_shape_normals(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_obj","title":"<code>dvz_shape_obj()</code>","text":"<p>Load a .obj shape.</p> <pre><code>DvzShape dvz_shape_obj(  // returns: the shape\n    char* file_path,  // the path to the .obj file\n)\n</code></pre>"},{"location":"api/#dvz_shape_print","title":"<code>dvz_shape_print()</code>","text":"<p>Show information about a shape.</p> <pre><code>void dvz_shape_print(\n    DvzShape* shape,  // the shape\n)\n</code></pre>"},{"location":"api/#dvz_shape_rescaling","title":"<code>dvz_shape_rescaling()</code>","text":"<p>Compute the rescaling factor to renormalize a shape.</p> <pre><code>float dvz_shape_rescaling(\n    DvzShape* shape,  // the shape\n    int flags,  // the rescaling flags\n)\n</code></pre>"},{"location":"api/#dvz_shape_rotate","title":"<code>dvz_shape_rotate()</code>","text":"<p>Append a rotation to a shape.</p> <pre><code>void dvz_shape_rotate(\n    DvzShape* shape,  // the shape\n    float angle,  // the rotation angle\n    vec3 axis,  // the rotation axis\n)\n</code></pre>"},{"location":"api/#dvz_shape_scale","title":"<code>dvz_shape_scale()</code>","text":"<p>Append a scaling transform to a shape.</p> <pre><code>void dvz_shape_scale(\n    DvzShape* shape,  // the shape\n    vec3 scale,  // the scaling factors\n)\n</code></pre>"},{"location":"api/#dvz_shape_sphere","title":"<code>dvz_shape_sphere()</code>","text":"<p>Create a sphere shape.</p> <pre><code>DvzShape dvz_shape_sphere(  // returns: the shape\n    uint32_t rows,  // the number of rows\n    uint32_t cols,  // the number of columns\n    cvec4 color,  // the sphere color\n)\n</code></pre>"},{"location":"api/#dvz_shape_square","title":"<code>dvz_shape_square()</code>","text":"<p>Create a square shape.</p> <pre><code>DvzShape dvz_shape_square(  // returns: the shape\n    cvec4 color,  // the square color\n)\n</code></pre>"},{"location":"api/#dvz_shape_surface","title":"<code>dvz_shape_surface()</code>","text":"<p>Create a grid shape.</p> <pre><code>DvzShape dvz_shape_surface(  // returns: the shape\n    uint32_t row_count,  // number of rows\n    uint32_t col_count,  // number of cols\n    float* heights,  // a pointer to row_count*col_count height values (floats)\n    cvec4* colors,  // a pointer to row_count*col_count color values (cvec4)\n    vec3 o,  // the origin\n    vec3 u,  // the unit vector parallel to each column\n    vec3 v,  // the unit vector parallel to each row\n    int flags,  // the grid creation flags\n)\n</code></pre>"},{"location":"api/#dvz_shape_transform","title":"<code>dvz_shape_transform()</code>","text":"<p>Append an arbitrary transformation.</p> <pre><code>void dvz_shape_transform(\n    DvzShape* shape,  // the shape\n    mat4 transform,  // the transform mat4 matrix\n)\n</code></pre>"},{"location":"api/#dvz_shape_translate","title":"<code>dvz_shape_translate()</code>","text":"<p>Append a translation to a shape.</p> <pre><code>void dvz_shape_translate(\n    DvzShape* shape,  // the shape\n    vec3 translate,  // the translation vector\n)\n</code></pre>"},{"location":"api/#dvz_slice","title":"<code>dvz_slice()</code>","text":"<p>Create a slice visual (multiple 2D images with slices of a 3D texture).</p> <pre><code>DvzVisual* dvz_slice(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_slice_alloc","title":"<code>dvz_slice_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_slice_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of slices to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_slice_alpha","title":"<code>dvz_slice_alpha()</code>","text":"<p>Set the slice transparency alpha value.</p> <pre><code>void dvz_slice_alpha(\n    DvzVisual* visual,  // the visual\n    float alpha,  // the alpha value\n)\n</code></pre>"},{"location":"api/#dvz_slice_position","title":"<code>dvz_slice_position()</code>","text":"<p>Set the slice positions.</p> <pre><code>void dvz_slice_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* p0,  // the 3D positions of the upper-left corner\n    vec3* p1,  // the 3D positions of the upper-right corner\n    vec3* p2,  // the 3D positions of the lower-left corner\n    vec3* p3,  // the 3D positions of the lower-right corner\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_slice_texcoords","title":"<code>dvz_slice_texcoords()</code>","text":"<p>Set the slice texture coordinates.</p> <pre><code>void dvz_slice_texcoords(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* uvw0,  // the 3D texture coordinates of the upper-left corner\n    vec3* uvw1,  // the 3D texture coordinates of the upper-right corner\n    vec3* uvw2,  // the 3D texture coordinates of the lower-left corner\n    vec3* uvw3,  // the 3D texture coordinates of the lower-right corner\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_slice_texture","title":"<code>dvz_slice_texture()</code>","text":"<p>Assign a texture to a slice visual.</p> <pre><code>void dvz_slice_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_sphere","title":"<code>dvz_sphere()</code>","text":"<p>Create a sphere visual.</p> <pre><code>DvzVisual* dvz_sphere(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_sphere_alloc","title":"<code>dvz_sphere_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_sphere_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of spheres to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_sphere_color","title":"<code>dvz_sphere_color()</code>","text":"<p>Set the sphere colors.</p> <pre><code>void dvz_sphere_color(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    cvec4* color,  // the sphere colors\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_sphere_light_params","title":"<code>dvz_sphere_light_params()</code>","text":"<p>Set the sphere light parameters.</p> <pre><code>void dvz_sphere_light_params(\n    DvzVisual* visual,  // the visual\n    vec4 params,  // the light parameters (vec4 ambient, diffuse, specular, exponent)\n)\n</code></pre>"},{"location":"api/#dvz_sphere_light_pos","title":"<code>dvz_sphere_light_pos()</code>","text":"<p>Set the sphere light position.</p> <pre><code>void dvz_sphere_light_pos(\n    DvzVisual* visual,  // the visual\n    vec3 pos,  // the light position\n)\n</code></pre>"},{"location":"api/#dvz_sphere_position","title":"<code>dvz_sphere_position()</code>","text":"<p>Set the sphere positions.</p> <pre><code>void dvz_sphere_position(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    vec3* pos,  // the 3D positions of the sphere centers\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_sphere_size","title":"<code>dvz_sphere_size()</code>","text":"<p>Set the sphere sizes.</p> <pre><code>void dvz_sphere_size(\n    DvzVisual* visual,  // the visual\n    uint32_t first,  // the index of the first item to update\n    uint32_t count,  // the number of items to update\n    float* size,  // the radius of the spheres\n    int flags,  // the data update flags\n)\n</code></pre>"},{"location":"api/#dvz_tex_image","title":"<code>dvz_tex_image()</code>","text":"<p>Create a 2D texture to be used in an image visual.</p> <pre><code>DvzId dvz_tex_image(  // returns: the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    void* data,  // the texture data to upload\n)\n</code></pre>"},{"location":"api/#dvz_tex_slice","title":"<code>dvz_tex_slice()</code>","text":"<p>Create a 3D texture to be used in a slice visual.</p> <pre><code>DvzId dvz_tex_slice(  // returns: the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    uint32_t depth,  // the texture depth\n    void* data,  // the texture data to upload\n)\n</code></pre>"},{"location":"api/#dvz_tex_volume","title":"<code>dvz_tex_volume()</code>","text":"<p>Create a 3D texture to be used in a volume visual.</p> <pre><code>DvzId dvz_tex_volume(  // returns: the texture ID\n    DvzBatch* batch,  // the batch\n    DvzFormat format,  // the texture format\n    uint32_t width,  // the texture width\n    uint32_t height,  // the texture height\n    uint32_t depth,  // the texture depth\n    void* data,  // the texture data to upload\n)\n</code></pre>"},{"location":"api/#dvz_version","title":"<code>dvz_version()</code>","text":"<p>Return the current version string.</p> <pre><code>char* dvz_version(  // returns: the version string\n\n)\n</code></pre>"},{"location":"api/#dvz_visual_clip","title":"<code>dvz_visual_clip()</code>","text":"<p>Set the visual clipping.</p> <pre><code>void dvz_visual_clip(\n    DvzVisual* visual,  // the visual\n    DvzViewportClip clip,  // the viewport clipping\n)\n</code></pre>"},{"location":"api/#dvz_visual_depth","title":"<code>dvz_visual_depth()</code>","text":"<p>Set the visual depth.</p> <pre><code>void dvz_visual_depth(\n    DvzVisual* visual,  // the visual\n    DvzDepthTest depth_test,  // whether to activate the depth test\n)\n</code></pre>"},{"location":"api/#dvz_visual_fixed","title":"<code>dvz_visual_fixed()</code>","text":"<p>Fix some axes in a visual.</p> <pre><code>void dvz_visual_fixed(\n    DvzVisual* visual,  // the visual\n    bool fixed_x,  // whether the x axis should be fixed\n    bool fixed_y,  // whether the y axis should be fixed\n    bool fixed_z,  // whether the z axis should be fixed\n)\n</code></pre>"},{"location":"api/#dvz_visual_show","title":"<code>dvz_visual_show()</code>","text":"<p>Set the visibility of a visual.</p> <pre><code>void dvz_visual_show(\n    DvzVisual* visual,  // the visual\n    bool is_visible,  // the visual visibility\n)\n</code></pre>"},{"location":"api/#dvz_visual_update","title":"<code>dvz_visual_update()</code>","text":"<p>Update a visual after its data has changed.</p> <pre><code>void dvz_visual_update(\n    DvzVisual* visual,  // the visual\n)\n</code></pre>"},{"location":"api/#dvz_volume","title":"<code>dvz_volume()</code>","text":"<p>Create a volume visual.</p> <pre><code>DvzVisual* dvz_volume(  // returns: the visual\n    DvzBatch* batch,  // the batch\n    int flags,  // the visual creation flags\n)\n</code></pre>"},{"location":"api/#dvz_volume_alloc","title":"<code>dvz_volume_alloc()</code>","text":"<p>Allocate memory for a visual.</p> <pre><code>void dvz_volume_alloc(\n    DvzVisual* visual,  // the visual\n    uint32_t item_count,  // the total number of volumes to allocate for this visual\n)\n</code></pre>"},{"location":"api/#dvz_volume_size","title":"<code>dvz_volume_size()</code>","text":"<p>Set the volume size.</p> <pre><code>void dvz_volume_size(\n    DvzVisual* visual,  // the visual\n    float w,  // the texture width\n    float h,  // the texture height\n    float d,  // the texture depth\n)\n</code></pre>"},{"location":"api/#dvz_volume_texcoords","title":"<code>dvz_volume_texcoords()</code>","text":"<p>Set the texture coordinates of two corner points.</p> <pre><code>void dvz_volume_texcoords(\n    DvzVisual* visual,  // the visual\n    vec3 uvw0,  // coordinates of one of the corner points\n    vec3 uvw1,  // coordinates of one of the corner points\n)\n</code></pre>"},{"location":"api/#dvz_volume_texture","title":"<code>dvz_volume_texture()</code>","text":"<p>Assign a 3D texture to a volume visual.</p> <pre><code>void dvz_volume_texture(\n    DvzVisual* visual,  // the visual\n    DvzId tex,  // the texture ID\n    DvzFilter filter,  // the texture filtering mode\n    DvzSamplerAddressMode address_mode,  // the texture address mode\n)\n</code></pre>"},{"location":"api/#dvz_volume_transfer","title":"<code>dvz_volume_transfer()</code>","text":"<p>Set the volume size.</p> <pre><code>void dvz_volume_transfer(\n    DvzVisual* visual,  // the visual\n    vec4 transfer,  // transfer function, for now `vec4(x, 0, 0, 0)` where x is a scaling factor\n)\n</code></pre>"},{"location":"api/#dvz_mean","title":"<code>dvz_mean()</code>","text":"<p>Compute the mean of an array of double values.</p> <pre><code>double dvz_mean(  // returns: the mean\n    uint32_t n,  // the number of values\n    double* values,  // an array of double numbers\n)\n</code></pre>"},{"location":"api/#dvz_min_max","title":"<code>dvz_min_max()</code>","text":"<p>Compute the min and max of an array of float values.</p> <pre><code>void dvz_min_max(  // returns: the mean\n    uint32_t n,  // the number of values\n    float* values,  // an array of float numbers\n    vec2 out_min_max,  // the min and max\n)\n</code></pre>"},{"location":"api/#dvz_mock_band","title":"<code>dvz_mock_band()</code>","text":"<p>Generate points on a band.</p> <pre><code>vec3* dvz_mock_band(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    vec2 size,  // the size of the band\n)\n</code></pre>"},{"location":"api/#dvz_mock_circle","title":"<code>dvz_mock_circle()</code>","text":"<p>Generate points on a circle.</p> <pre><code>vec3* dvz_mock_circle(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    float radius,  // the radius of the circle\n)\n</code></pre>"},{"location":"api/#dvz_mock_cmap","title":"<code>dvz_mock_cmap()</code>","text":"<p>Generate a set of HSV colors.</p> <pre><code>cvec4* dvz_mock_cmap(  // returns: colors\n    uint32_t count,  // the number of colors to generate\n    uint8_t alpha,  // the alpha value\n)\n</code></pre>"},{"location":"api/#dvz_mock_color","title":"<code>dvz_mock_color()</code>","text":"<p>Generate a set of random colors.</p> <pre><code>cvec4* dvz_mock_color(  // returns: random colors\n    uint32_t count,  // the number of colors to generate\n    uint8_t alpha,  // the alpha value\n)\n</code></pre>"},{"location":"api/#dvz_mock_fixed","title":"<code>dvz_mock_fixed()</code>","text":"<p>Generate identical 3D positions.</p> <pre><code>vec3* dvz_mock_fixed(  // returns: the repeated positions\n    uint32_t count,  // the number of positions to generate\n    vec3 fixed,  // the position\n)\n</code></pre>"},{"location":"api/#dvz_mock_full","title":"<code>dvz_mock_full()</code>","text":"<p>Generate an array with the same value.</p> <pre><code>float* dvz_mock_full(  // returns: the values\n    uint32_t count,  // the number of scalars to generate\n    float value,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_mock_line","title":"<code>dvz_mock_line()</code>","text":"<p>Generate 3D positions on a line.</p> <pre><code>vec3* dvz_mock_line(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    vec3 p0,  // initial position\n    vec3 p1,  // terminal position\n)\n</code></pre>"},{"location":"api/#dvz_mock_linspace","title":"<code>dvz_mock_linspace()</code>","text":"<p>Generate an array ranging from an initial value to a final value.</p> <pre><code>float* dvz_mock_linspace(  // returns: the values\n    uint32_t count,  // the number of scalars to generate\n    float initial,  // the initial value\n    float final,  // the final value\n)\n</code></pre>"},{"location":"api/#dvz_mock_monochrome","title":"<code>dvz_mock_monochrome()</code>","text":"<p>Repeat a color in an array.</p> <pre><code>cvec4* dvz_mock_monochrome(  // returns: colors\n    uint32_t count,  // the number of colors to generate\n    cvec4 mono,  // the color to repeat\n)\n</code></pre>"},{"location":"api/#dvz_mock_pos2d","title":"<code>dvz_mock_pos2D()</code>","text":"<p>Generate a set of random 2D positions.</p> <pre><code>vec3* dvz_mock_pos2D(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    float std,  // the standard deviation\n)\n</code></pre>"},{"location":"api/#dvz_mock_pos3d","title":"<code>dvz_mock_pos3D()</code>","text":"<p>Generate a set of random 3D positions.</p> <pre><code>vec3* dvz_mock_pos3D(  // returns: the positions\n    uint32_t count,  // the number of positions to generate\n    float std,  // the standard deviation\n)\n</code></pre>"},{"location":"api/#dvz_mock_range","title":"<code>dvz_mock_range()</code>","text":"<p>Generate an array of consecutive positive numbers.</p> <pre><code>uint32_t* dvz_mock_range(  // returns: the values\n    uint32_t count,  // the number of consecutive integers to generate\n    uint32_t initial,  // the initial value\n)\n</code></pre>"},{"location":"api/#dvz_mock_uniform","title":"<code>dvz_mock_uniform()</code>","text":"<p>Generate a set of uniformly random scalar values.</p> <pre><code>float* dvz_mock_uniform(  // returns: the values\n    uint32_t count,  // the number of values to generate\n    float vmin,  // the minimum value of the interval\n    float vmax,  // the maximum value of the interval\n)\n</code></pre>"},{"location":"api/#dvz_next_pow2","title":"<code>dvz_next_pow2()</code>","text":"<p>Return the smallest power of 2 larger or equal than a positive integer.</p> <pre><code>uint64_t dvz_next_pow2(  // returns: the power of 2\n    uint64_t x,  // the value\n)\n</code></pre>"},{"location":"api/#dvz_normalize_bytes","title":"<code>dvz_normalize_bytes()</code>","text":"<p>Normalize the array.</p> <pre><code>uint8_t* dvz_normalize_bytes(  // returns: the normalized array\n    uint32_t count,  // the number of values\n    float* values,  // an array of float numbers\n)\n</code></pre>"},{"location":"api/#dvz_rand_byte","title":"<code>dvz_rand_byte()</code>","text":"<p>Return a random integer number between 0 and 255.</p> <pre><code>uint8_t dvz_rand_byte(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_double","title":"<code>dvz_rand_double()</code>","text":"<p>Return a random floating-point number between 0 and 1.</p> <pre><code>double dvz_rand_double(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_float","title":"<code>dvz_rand_float()</code>","text":"<p>Return a random floating-point number between 0 and 1.</p> <pre><code>float dvz_rand_float(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_int","title":"<code>dvz_rand_int()</code>","text":"<p>Return a random integer number.</p> <pre><code>int dvz_rand_int(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_rand_normal","title":"<code>dvz_rand_normal()</code>","text":"<p>Return a random normal floating-point number.</p> <pre><code>double dvz_rand_normal(  // returns: random number\n\n)\n</code></pre>"},{"location":"api/#dvz_range","title":"<code>dvz_range()</code>","text":"<p>Compute the range of an array of double values.</p> <pre><code>void dvz_range(\n    uint32_t n,  // the number of values\n    double* values,  // an array of double numbers\n)\n</code></pre>"},{"location":"api/#enumerations","title":"Enumerations","text":""},{"location":"api/#dvzappflags","title":"<code>DvzAppFlags</code>","text":"<pre><code>DVZ_APP_FLAGS_NONE\nDVZ_APP_FLAGS_OFFSCREEN\nDVZ_APP_FLAGS_WHITE_BACKGROUND\n</code></pre>"},{"location":"api/#dvzarcballflags","title":"<code>DvzArcballFlags</code>","text":"<pre><code>DVZ_ARCBALL_FLAGS_NONE\nDVZ_ARCBALL_FLAGS_CONSTRAIN\n</code></pre>"},{"location":"api/#dvzcanvasflags","title":"<code>DvzCanvasFlags</code>","text":"<pre><code>DVZ_CANVAS_FLAGS_NONE\nDVZ_CANVAS_FLAGS_IMGUI\nDVZ_CANVAS_FLAGS_FPS\nDVZ_CANVAS_FLAGS_MONITOR\nDVZ_CANVAS_FLAGS_VSYNC\nDVZ_CANVAS_FLAGS_PICK\n</code></pre>"},{"location":"api/#dvzcaptype","title":"<code>DvzCapType</code>","text":"<pre><code>DVZ_CAP_TYPE_NONE\nDVZ_CAP_ROUND\nDVZ_CAP_TRIANGLE_IN\nDVZ_CAP_TRIANGLE_OUT\nDVZ_CAP_SQUARE\nDVZ_CAP_BUTT\nDVZ_CAP_COUNT\n</code></pre>"},{"location":"api/#dvzcolormap","title":"<code>DvzColormap</code>","text":"<pre><code>DVZ_CMAP_BINARY\nDVZ_CMAP_HSV\nDVZ_CMAP_CIVIDIS\nDVZ_CMAP_INFERNO\nDVZ_CMAP_MAGMA\nDVZ_CMAP_PLASMA\nDVZ_CMAP_VIRIDIS\nDVZ_CMAP_BLUES\nDVZ_CMAP_BUGN\nDVZ_CMAP_BUPU\nDVZ_CMAP_GNBU\nDVZ_CMAP_GREENS\nDVZ_CMAP_GREYS\nDVZ_CMAP_ORANGES\nDVZ_CMAP_ORRD\nDVZ_CMAP_PUBU\nDVZ_CMAP_PUBUGN\nDVZ_CMAP_PURPLES\nDVZ_CMAP_RDPU\nDVZ_CMAP_REDS\nDVZ_CMAP_YLGN\nDVZ_CMAP_YLGNBU\nDVZ_CMAP_YLORBR\nDVZ_CMAP_YLORRD\nDVZ_CMAP_AFMHOT\nDVZ_CMAP_AUTUMN\nDVZ_CMAP_BONE\nDVZ_CMAP_COOL\nDVZ_CMAP_COPPER\nDVZ_CMAP_GIST_HEAT\nDVZ_CMAP_GRAY\nDVZ_CMAP_HOT\nDVZ_CMAP_PINK\nDVZ_CMAP_SPRING\nDVZ_CMAP_SUMMER\nDVZ_CMAP_WINTER\nDVZ_CMAP_WISTIA\nDVZ_CMAP_BRBG\nDVZ_CMAP_BWR\nDVZ_CMAP_COOLWARM\nDVZ_CMAP_PIYG\nDVZ_CMAP_PRGN\nDVZ_CMAP_PUOR\nDVZ_CMAP_RDBU\nDVZ_CMAP_RDGY\nDVZ_CMAP_RDYLBU\nDVZ_CMAP_RDYLGN\nDVZ_CMAP_SEISMIC\nDVZ_CMAP_SPECTRAL\nDVZ_CMAP_TWILIGHT_SHIFTED\nDVZ_CMAP_TWILIGHT\nDVZ_CMAP_BRG\nDVZ_CMAP_CMRMAP\nDVZ_CMAP_CUBEHELIX\nDVZ_CMAP_FLAG\nDVZ_CMAP_GIST_EARTH\nDVZ_CMAP_GIST_NCAR\nDVZ_CMAP_GIST_RAINBOW\nDVZ_CMAP_GIST_STERN\nDVZ_CMAP_GNUPLOT2\nDVZ_CMAP_GNUPLOT\nDVZ_CMAP_JET\nDVZ_CMAP_NIPY_SPECTRAL\nDVZ_CMAP_OCEAN\nDVZ_CMAP_PRISM\nDVZ_CMAP_RAINBOW\nDVZ_CMAP_TERRAIN\nDVZ_CMAP_BKR\nDVZ_CMAP_BKY\nDVZ_CMAP_CET_D10\nDVZ_CMAP_CET_D11\nDVZ_CMAP_CET_D8\nDVZ_CMAP_CET_D13\nDVZ_CMAP_CET_D3\nDVZ_CMAP_CET_D1A\nDVZ_CMAP_BJY\nDVZ_CMAP_GWV\nDVZ_CMAP_BWY\nDVZ_CMAP_CET_D12\nDVZ_CMAP_CET_R3\nDVZ_CMAP_CET_D9\nDVZ_CMAP_CWR\nDVZ_CMAP_CET_CBC1\nDVZ_CMAP_CET_CBC2\nDVZ_CMAP_CET_CBL1\nDVZ_CMAP_CET_CBL2\nDVZ_CMAP_CET_CBTC1\nDVZ_CMAP_CET_CBTC2\nDVZ_CMAP_CET_CBTL1\nDVZ_CMAP_BGY\nDVZ_CMAP_BGYW\nDVZ_CMAP_BMW\nDVZ_CMAP_CET_C1\nDVZ_CMAP_CET_C1S\nDVZ_CMAP_CET_C2\nDVZ_CMAP_CET_C4\nDVZ_CMAP_CET_C4S\nDVZ_CMAP_CET_C5\nDVZ_CMAP_CET_I1\nDVZ_CMAP_CET_I3\nDVZ_CMAP_CET_L10\nDVZ_CMAP_CET_L11\nDVZ_CMAP_CET_L12\nDVZ_CMAP_CET_L16\nDVZ_CMAP_CET_L17\nDVZ_CMAP_CET_L18\nDVZ_CMAP_CET_L19\nDVZ_CMAP_CET_L4\nDVZ_CMAP_CET_L7\nDVZ_CMAP_CET_L8\nDVZ_CMAP_CET_L9\nDVZ_CMAP_CET_R1\nDVZ_CMAP_CET_R2\nDVZ_CMAP_COLORWHEEL\nDVZ_CMAP_FIRE\nDVZ_CMAP_ISOLUM\nDVZ_CMAP_KB\nDVZ_CMAP_KBC\nDVZ_CMAP_KG\nDVZ_CMAP_KGY\nDVZ_CMAP_KR\nDVZ_CMAP_BLACK_BODY\nDVZ_CMAP_KINDLMANN\nDVZ_CMAP_EXTENDED_KINDLMANN\nDVZ_CPAL256_GLASBEY\nDVZ_CPAL256_GLASBEY_COOL\nDVZ_CPAL256_GLASBEY_DARK\nDVZ_CPAL256_GLASBEY_HV\nDVZ_CPAL256_GLASBEY_LIGHT\nDVZ_CPAL256_GLASBEY_WARM\nDVZ_CPAL032_ACCENT\nDVZ_CPAL032_DARK2\nDVZ_CPAL032_PAIRED\nDVZ_CPAL032_PASTEL1\nDVZ_CPAL032_PASTEL2\nDVZ_CPAL032_SET1\nDVZ_CPAL032_SET2\nDVZ_CPAL032_SET3\nDVZ_CPAL032_TAB10\nDVZ_CPAL032_TAB20\nDVZ_CPAL032_TAB20B\nDVZ_CPAL032_TAB20C\nDVZ_CPAL032_CATEGORY10_10\nDVZ_CPAL032_CATEGORY20_20\nDVZ_CPAL032_CATEGORY20B_20\nDVZ_CPAL032_CATEGORY20C_20\nDVZ_CPAL032_COLORBLIND8\n</code></pre>"},{"location":"api/#dvzcorner","title":"<code>DvzCorner</code>","text":"<pre><code>DVZ_DIALOG_CORNER_UPPER_LEFT\nDVZ_DIALOG_CORNER_UPPER_RIGHT\nDVZ_DIALOG_CORNER_LOWER_LEFT\nDVZ_DIALOG_CORNER_LOWER_RIGHT\n</code></pre>"},{"location":"api/#dvzdatflags","title":"<code>DvzDatFlags</code>","text":"<pre><code>DVZ_DAT_FLAGS_NONE\nDVZ_DAT_FLAGS_STANDALONE\nDVZ_DAT_FLAGS_MAPPABLE\nDVZ_DAT_FLAGS_DUP\nDVZ_DAT_FLAGS_KEEP_ON_RESIZE\nDVZ_DAT_FLAGS_PERSISTENT_STAGING\n</code></pre>"},{"location":"api/#dvzdepthtest","title":"<code>DvzDepthTest</code>","text":"<pre><code>DVZ_DEPTH_TEST_DISABLE\nDVZ_DEPTH_TEST_ENABLE\n</code></pre>"},{"location":"api/#dvzdialogflags","title":"<code>DvzDialogFlags</code>","text":"<pre><code>DVZ_DIALOG_FLAGS_NONE\nDVZ_DIALOG_FLAGS_OVERLAY\n</code></pre>"},{"location":"api/#dvzeasing","title":"<code>DvzEasing</code>","text":"<pre><code>DVZ_EASING_NONE\nDVZ_EASING_IN_SINE\nDVZ_EASING_OUT_SINE\nDVZ_EASING_IN_OUT_SINE\nDVZ_EASING_IN_QUAD\nDVZ_EASING_OUT_QUAD\nDVZ_EASING_IN_OUT_QUAD\nDVZ_EASING_IN_CUBIC\nDVZ_EASING_OUT_CUBIC\nDVZ_EASING_IN_OUT_CUBIC\nDVZ_EASING_IN_QUART\nDVZ_EASING_OUT_QUART\nDVZ_EASING_IN_OUT_QUART\nDVZ_EASING_IN_QUINT\nDVZ_EASING_OUT_QUINT\nDVZ_EASING_IN_OUT_QUINT\nDVZ_EASING_IN_EXPO\nDVZ_EASING_OUT_EXPO\nDVZ_EASING_IN_OUT_EXPO\nDVZ_EASING_IN_CIRC\nDVZ_EASING_OUT_CIRC\nDVZ_EASING_IN_OUT_CIRC\nDVZ_EASING_IN_BACK\nDVZ_EASING_OUT_BACK\nDVZ_EASING_IN_OUT_BACK\nDVZ_EASING_IN_ELASTIC\nDVZ_EASING_OUT_ELASTIC\nDVZ_EASING_IN_OUT_ELASTIC\nDVZ_EASING_IN_BOUNCE\nDVZ_EASING_OUT_BOUNCE\nDVZ_EASING_IN_OUT_BOUNCE\nDVZ_EASING_COUNT\n</code></pre>"},{"location":"api/#dvzfilter","title":"<code>DvzFilter</code>","text":"<pre><code>DVZ_FILTER_NEAREST\nDVZ_FILTER_LINEAR\nDVZ_FILTER_CUBIC_IMG\n</code></pre>"},{"location":"api/#dvzformat","title":"<code>DvzFormat</code>","text":"<pre><code>DVZ_FORMAT_NONE\nDVZ_FORMAT_R8_UNORM\nDVZ_FORMAT_R8_SNORM\nDVZ_FORMAT_R8_UINT\nDVZ_FORMAT_R8G8B8_UNORM\nDVZ_FORMAT_R8G8B8A8_UNORM\nDVZ_FORMAT_R8G8B8A8_UINT\nDVZ_FORMAT_B8G8R8A8_UNORM\nDVZ_FORMAT_R16_UNORM\nDVZ_FORMAT_R16_SNORM\nDVZ_FORMAT_R32_UINT\nDVZ_FORMAT_R32_SINT\nDVZ_FORMAT_R32_SFLOAT\nDVZ_FORMAT_R32G32_SFLOAT\nDVZ_FORMAT_R32G32B32_SFLOAT\nDVZ_FORMAT_R32G32B32A32_SFLOAT\n</code></pre>"},{"location":"api/#dvzjointype","title":"<code>DvzJoinType</code>","text":"<pre><code>DVZ_JOIN_SQUARE\nDVZ_JOIN_ROUND\n</code></pre>"},{"location":"api/#dvzkeyboardeventtype","title":"<code>DvzKeyboardEventType</code>","text":"<pre><code>DVZ_KEYBOARD_EVENT_NONE\nDVZ_KEYBOARD_EVENT_PRESS\nDVZ_KEYBOARD_EVENT_REPEAT\nDVZ_KEYBOARD_EVENT_RELEASE\n</code></pre>"},{"location":"api/#dvzkeyboardmodifiers","title":"<code>DvzKeyboardModifiers</code>","text":"<pre><code>DVZ_KEY_MODIFIER_NONE\nDVZ_KEY_MODIFIER_SHIFT\nDVZ_KEY_MODIFIER_CONTROL\nDVZ_KEY_MODIFIER_ALT\nDVZ_KEY_MODIFIER_SUPER\n</code></pre>"},{"location":"api/#dvzmarkeraspect","title":"<code>DvzMarkerAspect</code>","text":"<pre><code>DVZ_MARKER_ASPECT_FILLED\nDVZ_MARKER_ASPECT_STROKE\nDVZ_MARKER_ASPECT_OUTLINE\n</code></pre>"},{"location":"api/#dvzmarkermode","title":"<code>DvzMarkerMode</code>","text":"<pre><code>DVZ_MARKER_MODE_NONE\nDVZ_MARKER_MODE_CODE\nDVZ_MARKER_MODE_BITMAP\nDVZ_MARKER_MODE_SDF\nDVZ_MARKER_MODE_MSDF\nDVZ_MARKER_MODE_MTSDF\n</code></pre>"},{"location":"api/#dvzmarkershape","title":"<code>DvzMarkerShape</code>","text":"<pre><code>DVZ_MARKER_SHAPE_DISC\nDVZ_MARKER_SHAPE_ASTERISK\nDVZ_MARKER_SHAPE_CHEVRON\nDVZ_MARKER_SHAPE_CLOVER\nDVZ_MARKER_SHAPE_CLUB\nDVZ_MARKER_SHAPE_CROSS\nDVZ_MARKER_SHAPE_DIAMOND\nDVZ_MARKER_SHAPE_ARROW\nDVZ_MARKER_SHAPE_ELLIPSE\nDVZ_MARKER_SHAPE_HBAR\nDVZ_MARKER_SHAPE_HEART\nDVZ_MARKER_SHAPE_INFINITY\nDVZ_MARKER_SHAPE_PIN\nDVZ_MARKER_SHAPE_RING\nDVZ_MARKER_SHAPE_SPADE\nDVZ_MARKER_SHAPE_SQUARE\nDVZ_MARKER_SHAPE_TAG\nDVZ_MARKER_SHAPE_TRIANGLE\nDVZ_MARKER_SHAPE_VBAR\nDVZ_MARKER_SHAPE_COUNT\n</code></pre>"},{"location":"api/#dvzmeshflags","title":"<code>DvzMeshFlags</code>","text":"<pre><code>DVZ_MESH_FLAGS_NONE\nDVZ_MESH_FLAGS_TEXTURED\nDVZ_MESH_FLAGS_LIGHTING\n</code></pre>"},{"location":"api/#dvzmousebutton","title":"<code>DvzMouseButton</code>","text":"<pre><code>DVZ_MOUSE_BUTTON_NONE\nDVZ_MOUSE_BUTTON_LEFT\nDVZ_MOUSE_BUTTON_MIDDLE\nDVZ_MOUSE_BUTTON_RIGHT\n</code></pre>"},{"location":"api/#dvzmouseeventtype","title":"<code>DvzMouseEventType</code>","text":"<pre><code>DVZ_MOUSE_EVENT_RELEASE\nDVZ_MOUSE_EVENT_PRESS\nDVZ_MOUSE_EVENT_MOVE\nDVZ_MOUSE_EVENT_CLICK\nDVZ_MOUSE_EVENT_DOUBLE_CLICK\nDVZ_MOUSE_EVENT_DRAG_START\nDVZ_MOUSE_EVENT_DRAG\nDVZ_MOUSE_EVENT_DRAG_STOP\nDVZ_MOUSE_EVENT_WHEEL\nDVZ_MOUSE_EVENT_ALL\n</code></pre>"},{"location":"api/#dvzmousestate","title":"<code>DvzMouseState</code>","text":"<pre><code>DVZ_MOUSE_STATE_RELEASE\nDVZ_MOUSE_STATE_PRESS\nDVZ_MOUSE_STATE_CLICK\nDVZ_MOUSE_STATE_CLICK_PRESS\nDVZ_MOUSE_STATE_DOUBLE_CLICK\nDVZ_MOUSE_STATE_DRAGGING\n</code></pre>"},{"location":"api/#dvzpanzoomflags","title":"<code>DvzPanzoomFlags</code>","text":"<pre><code>DVZ_PANZOOM_FLAGS_NONE\nDVZ_PANZOOM_FLAGS_KEEP_ASPECT\nDVZ_PANZOOM_FLAGS_FIXED_X\nDVZ_PANZOOM_FLAGS_FIXED_Y\n</code></pre>"},{"location":"api/#dvzpathtopology","title":"<code>DvzPathTopology</code>","text":"<pre><code>DVZ_PATH_OPEN\nDVZ_PATH_CLOSED\n</code></pre>"},{"location":"api/#dvzprimitivetopology","title":"<code>DvzPrimitiveTopology</code>","text":"<pre><code>DVZ_PRIMITIVE_TOPOLOGY_POINT_LIST\nDVZ_PRIMITIVE_TOPOLOGY_LINE_LIST\nDVZ_PRIMITIVE_TOPOLOGY_LINE_STRIP\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP\nDVZ_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN\n</code></pre>"},{"location":"api/#dvzsampleraddressmode","title":"<code>DvzSamplerAddressMode</code>","text":"<pre><code>DVZ_SAMPLER_ADDRESS_MODE_REPEAT\nDVZ_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT\nDVZ_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE\nDVZ_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER\nDVZ_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE\n</code></pre>"},{"location":"api/#dvzshapetype","title":"<code>DvzShapeType</code>","text":"<pre><code>DVZ_SHAPE_NONE\nDVZ_SHAPE_SQUARE\nDVZ_SHAPE_DISC\nDVZ_SHAPE_CUBE\nDVZ_SHAPE_SPHERE\nDVZ_SHAPE_CYLINDER\nDVZ_SHAPE_CONE\nDVZ_SHAPE_SURFACE\nDVZ_SHAPE_OBJ\nDVZ_SHAPE_OTHER\n</code></pre>"},{"location":"api/#dvztexflags","title":"<code>DvzTexFlags</code>","text":"<pre><code>DVZ_TEX_FLAGS_NONE\nDVZ_TEX_FLAGS_PERSISTENT_STAGING\n</code></pre>"},{"location":"api/#dvzuploadflags","title":"<code>DvzUploadFlags</code>","text":"<pre><code>DVZ_UPLOAD_FLAGS_NOCOPY\n</code></pre>"},{"location":"api/#dvzviewflags","title":"<code>DvzViewFlags</code>","text":"<pre><code>DVZ_VIEW_FLAGS_NONE\nDVZ_VIEW_FLAGS_STATIC\n</code></pre>"},{"location":"api/#dvzviewportclip","title":"<code>DvzViewportClip</code>","text":"<pre><code>DVZ_VIEWPORT_CLIP_INNER\nDVZ_VIEWPORT_CLIP_OUTER\nDVZ_VIEWPORT_CLIP_BOTTOM\nDVZ_VIEWPORT_CLIP_LEFT\n</code></pre>"},{"location":"api/#dvzvisualflags","title":"<code>DvzVisualFlags</code>","text":"<pre><code>DVZ_VISUAL_FLAGS_DEFAULT\nDVZ_VISUAL_FLAGS_INDEXED\nDVZ_VISUAL_FLAGS_INDIRECT\nDVZ_VISUAL_FLAGS_VERTEX_MAPPABLE\nDVZ_VISUAL_FLAGS_INDEX_MAPPABLE\n</code></pre>"},{"location":"api/#dvzvolumeflags","title":"<code>DvzVolumeFlags</code>","text":"<pre><code>DVZ_VOLUME_FLAGS_NONE\nDVZ_VOLUME_FLAGS_RGBA\nDVZ_VOLUME_FLAGS_COLORMAP\nDVZ_VOLUME_FLAGS_BACK_FRONT\n</code></pre>"},{"location":"api/#dvzkeycode","title":"<code>DvzKeyCode</code>","text":"<pre><code>DVZ_KEY_UNKNOWN\nDVZ_KEY_NONE\nDVZ_KEY_SPACE\nDVZ_KEY_APOSTROPHE\nDVZ_KEY_COMMA\nDVZ_KEY_MINUS\nDVZ_KEY_PERIOD\nDVZ_KEY_SLASH\nDVZ_KEY_0\nDVZ_KEY_1\nDVZ_KEY_2\nDVZ_KEY_3\nDVZ_KEY_4\nDVZ_KEY_5\nDVZ_KEY_6\nDVZ_KEY_7\nDVZ_KEY_8\nDVZ_KEY_9\nDVZ_KEY_SEMICOLON\nDVZ_KEY_EQUAL\nDVZ_KEY_A\nDVZ_KEY_B\nDVZ_KEY_C\nDVZ_KEY_D\nDVZ_KEY_E\nDVZ_KEY_F\nDVZ_KEY_G\nDVZ_KEY_H\nDVZ_KEY_I\nDVZ_KEY_J\nDVZ_KEY_K\nDVZ_KEY_L\nDVZ_KEY_M\nDVZ_KEY_N\nDVZ_KEY_O\nDVZ_KEY_P\nDVZ_KEY_Q\nDVZ_KEY_R\nDVZ_KEY_S\nDVZ_KEY_T\nDVZ_KEY_U\nDVZ_KEY_V\nDVZ_KEY_W\nDVZ_KEY_X\nDVZ_KEY_Y\nDVZ_KEY_Z\nDVZ_KEY_LEFT_BRACKET\nDVZ_KEY_BACKSLASH\nDVZ_KEY_RIGHT_BRACKET\nDVZ_KEY_GRAVE_ACCENT\nDVZ_KEY_WORLD_1\nDVZ_KEY_WORLD_2\nDVZ_KEY_ESCAPE\nDVZ_KEY_ENTER\nDVZ_KEY_TAB\nDVZ_KEY_BACKSPACE\nDVZ_KEY_INSERT\nDVZ_KEY_DELETE\nDVZ_KEY_RIGHT\nDVZ_KEY_LEFT\nDVZ_KEY_DOWN\nDVZ_KEY_UP\nDVZ_KEY_PAGE_UP\nDVZ_KEY_PAGE_DOWN\nDVZ_KEY_HOME\nDVZ_KEY_END\nDVZ_KEY_CAPS_LOCK\nDVZ_KEY_SCROLL_LOCK\nDVZ_KEY_NUM_LOCK\nDVZ_KEY_PRINT_SCREEN\nDVZ_KEY_PAUSE\nDVZ_KEY_F1\nDVZ_KEY_F2\nDVZ_KEY_F3\nDVZ_KEY_F4\nDVZ_KEY_F5\nDVZ_KEY_F6\nDVZ_KEY_F7\nDVZ_KEY_F8\nDVZ_KEY_F9\nDVZ_KEY_F10\nDVZ_KEY_F11\nDVZ_KEY_F12\nDVZ_KEY_F13\nDVZ_KEY_F14\nDVZ_KEY_F15\nDVZ_KEY_F16\nDVZ_KEY_F17\nDVZ_KEY_F18\nDVZ_KEY_F19\nDVZ_KEY_F20\nDVZ_KEY_F21\nDVZ_KEY_F22\nDVZ_KEY_F23\nDVZ_KEY_F24\nDVZ_KEY_F25\nDVZ_KEY_KP_0\nDVZ_KEY_KP_1\nDVZ_KEY_KP_2\nDVZ_KEY_KP_3\nDVZ_KEY_KP_4\nDVZ_KEY_KP_5\nDVZ_KEY_KP_6\nDVZ_KEY_KP_7\nDVZ_KEY_KP_8\nDVZ_KEY_KP_9\nDVZ_KEY_KP_DECIMAL\nDVZ_KEY_KP_DIVIDE\nDVZ_KEY_KP_MULTIPLY\nDVZ_KEY_KP_SUBTRACT\nDVZ_KEY_KP_ADD\nDVZ_KEY_KP_ENTER\nDVZ_KEY_KP_EQUAL\nDVZ_KEY_LEFT_SHIFT\nDVZ_KEY_LEFT_CONTROL\nDVZ_KEY_LEFT_ALT\nDVZ_KEY_LEFT_SUPER\nDVZ_KEY_RIGHT_SHIFT\nDVZ_KEY_RIGHT_CONTROL\nDVZ_KEY_RIGHT_ALT\nDVZ_KEY_RIGHT_SUPER\nDVZ_KEY_MENU\nDVZ_KEY_LAST\n</code></pre>"},{"location":"api/#structures","title":"Structures","text":""},{"location":"api/#dvzatlasfont","title":"<code>DvzAtlasFont</code>","text":"<pre><code>struct DvzAtlasFont\n    unsigned long ttf_size\n    unsigned char* ttf_bytes\n    DvzAtlas* atlas\n    DvzFont* font\n</code></pre>"},{"location":"api/#dvzframeevent","title":"<code>DvzFrameEvent</code>","text":"<pre><code>struct DvzFrameEvent\n    uint64_t frame_idx\n    double time\n    double interval\n    void* user_data\n</code></pre>"},{"location":"api/#dvzguievent","title":"<code>DvzGuiEvent</code>","text":"<pre><code>struct DvzGuiEvent\n    void* user_data\n</code></pre>"},{"location":"api/#dvzkeyboardevent","title":"<code>DvzKeyboardEvent</code>","text":"<pre><code>struct DvzKeyboardEvent\n    DvzKeyboardEventType type\n    DvzKeyCode key\n    int mods\n    void* user_data\n</code></pre>"},{"location":"api/#dvzmvp","title":"<code>DvzMVP</code>","text":"<pre><code>struct DvzMVP\n    mat4 model\n    mat4 view\n    mat4 proj\n</code></pre>"},{"location":"api/#dvzmousebuttonevent","title":"<code>DvzMouseButtonEvent</code>","text":"<pre><code>struct DvzMouseButtonEvent\n    DvzMouseButton button\n</code></pre>"},{"location":"api/#dvzmouseclickevent","title":"<code>DvzMouseClickEvent</code>","text":"<pre><code>struct DvzMouseClickEvent\n    DvzMouseButton button\n</code></pre>"},{"location":"api/#dvzmousedragevent","title":"<code>DvzMouseDragEvent</code>","text":"<pre><code>struct DvzMouseDragEvent\n    DvzMouseButton button\n    vec2 press_pos\n    vec2 shift\n</code></pre>"},{"location":"api/#dvzmouseevent","title":"<code>DvzMouseEvent</code>","text":"<pre><code>struct DvzMouseEvent\n    DvzMouseEventType type\n    DvzMouseEventUnion content\n    vec2 pos\n    int mods\n    float content_scale\n    void* user_data\n</code></pre>"},{"location":"api/#dvzmouseeventunion","title":"<code>DvzMouseEventUnion</code>","text":"<pre><code>union DvzMouseEventUnion\n    DvzMouseButtonEvent b\n    DvzMouseWheelEvent w\n    DvzMouseDragEvent d\n    DvzMouseClickEvent c\n</code></pre>"},{"location":"api/#dvzmousewheelevent","title":"<code>DvzMouseWheelEvent</code>","text":"<pre><code>struct DvzMouseWheelEvent\n    vec2 dir\n</code></pre>"},{"location":"api/#dvzrequestsevent","title":"<code>DvzRequestsEvent</code>","text":"<pre><code>struct DvzRequestsEvent\n    DvzBatch* batch\n    void* user_data\n</code></pre>"},{"location":"api/#dvzshape","title":"<code>DvzShape</code>","text":"<pre><code>struct DvzShape\n    mat4 transform\n    uint32_t first\n    uint32_t count\n    DvzShapeType type\n    uint32_t vertex_count\n    uint32_t index_count\n    vec3* pos\n    vec3* normal\n    cvec4* color\n    vec4* texcoords\n    DvzIndex* index\n</code></pre>"},{"location":"api/#dvztimerevent","title":"<code>DvzTimerEvent</code>","text":"<pre><code>struct DvzTimerEvent\n    uint32_t timer_idx\n    DvzTimerItem* timer_item\n    uint64_t step_idx\n    double time\n    void* user_data\n</code></pre>"},{"location":"api/#dvzwindowevent","title":"<code>DvzWindowEvent</code>","text":"<pre><code>struct DvzWindowEvent\n    uint32_t framebuffer_width\n    uint32_t framebuffer_height\n    uint32_t screen_width\n    uint32_t screen_height\n    int flags\n    void* user_data\n</code></pre>"},{"location":"colormaps/","title":"Colormaps","text":"<p>Datoviz natively includes a collection of common colormaps (continuous) and color palettes (discrete). They come from:</p> <ul> <li>matplotlib</li> <li>bokeh</li> <li>colorcet</li> <li>Kenneth Moreland's page</li> </ul> Name Row, Col Colormap <code>binary</code> 0, 0 <code>hsv</code> 1, 0 <code>cividis</code> 2, 0 <code>inferno</code> 3, 0 <code>magma</code> 4, 0 <code>plasma</code> 5, 0 <code>viridis</code> 6, 0 <code>blues</code> 7, 0 <code>bugn</code> 8, 0 <code>bupu</code> 9, 0 <code>gnbu</code> 10, 0 <code>greens</code> 11, 0 <code>greys</code> 12, 0 <code>oranges</code> 13, 0 <code>orrd</code> 14, 0 <code>pubu</code> 15, 0 <code>pubugn</code> 16, 0 <code>purples</code> 17, 0 <code>rdpu</code> 18, 0 <code>reds</code> 19, 0 <code>ylgn</code> 20, 0 <code>ylgnbu</code> 21, 0 <code>ylorbr</code> 22, 0 <code>ylorrd</code> 23, 0 <code>afmhot</code> 24, 0 <code>autumn</code> 25, 0 <code>bone</code> 26, 0 <code>cool</code> 27, 0 <code>copper</code> 28, 0 <code>gist_heat</code> 29, 0 <code>gray</code> 30, 0 <code>hot</code> 31, 0 <code>pink</code> 32, 0 <code>spring</code> 33, 0 <code>summer</code> 34, 0 <code>winter</code> 35, 0 <code>wistia</code> 36, 0 <code>brbg</code> 37, 0 <code>bwr</code> 38, 0 <code>coolwarm</code> 39, 0 <code>piyg</code> 40, 0 <code>prgn</code> 41, 0 <code>puor</code> 42, 0 <code>rdbu</code> 43, 0 <code>rdgy</code> 44, 0 <code>rdylbu</code> 45, 0 <code>rdylgn</code> 46, 0 <code>seismic</code> 47, 0 <code>spectral</code> 48, 0 <code>twilight_shifted</code> 49, 0 <code>twilight</code> 50, 0 <code>brg</code> 51, 0 <code>cmrmap</code> 52, 0 <code>cubehelix</code> 53, 0 <code>flag</code> 54, 0 <code>gist_earth</code> 55, 0 <code>gist_ncar</code> 56, 0 <code>gist_rainbow</code> 57, 0 <code>gist_stern</code> 58, 0 <code>gnuplot2</code> 59, 0 <code>gnuplot</code> 60, 0 <code>jet</code> 61, 0 <code>nipy_spectral</code> 62, 0 <code>ocean</code> 63, 0 <code>prism</code> 64, 0 <code>rainbow</code> 65, 0 <code>terrain</code> 66, 0 <code>bkr</code> 67, 0 <code>bky</code> 68, 0 <code>cet_d10</code> 69, 0 <code>cet_d11</code> 70, 0 <code>cet_d8</code> 71, 0 <code>cet_d13</code> 72, 0 <code>cet_d3</code> 73, 0 <code>cet_d1a</code> 74, 0 <code>bjy</code> 75, 0 <code>gwv</code> 76, 0 <code>bwy</code> 77, 0 <code>cet_d12</code> 78, 0 <code>cet_r3</code> 79, 0 <code>cet_d9</code> 80, 0 <code>cwr</code> 81, 0 <code>cet_cbc1</code> 82, 0 <code>cet_cbc2</code> 83, 0 <code>cet_cbl1</code> 84, 0 <code>cet_cbl2</code> 85, 0 <code>cet_cbtc1</code> 86, 0 <code>cet_cbtc2</code> 87, 0 <code>cet_cbtl1</code> 88, 0 <code>bgy</code> 89, 0 <code>bgyw</code> 90, 0 <code>bmw</code> 91, 0 <code>cet_c1</code> 92, 0 <code>cet_c1s</code> 93, 0 <code>cet_c2</code> 94, 0 <code>cet_c4</code> 95, 0 <code>cet_c4s</code> 96, 0 <code>cet_c5</code> 97, 0 <code>cet_i1</code> 98, 0 <code>cet_i3</code> 99, 0 <code>cet_l10</code> 100, 0 <code>cet_l11</code> 101, 0 <code>cet_l12</code> 102, 0 <code>cet_l16</code> 103, 0 <code>cet_l17</code> 104, 0 <code>cet_l18</code> 105, 0 <code>cet_l19</code> 106, 0 <code>cet_l4</code> 107, 0 <code>cet_l7</code> 108, 0 <code>cet_l8</code> 109, 0 <code>cet_l9</code> 110, 0 <code>cet_r1</code> 111, 0 <code>cet_r2</code> 112, 0 <code>colorwheel</code> 113, 0 <code>fire</code> 114, 0 <code>isolum</code> 115, 0 <code>kb</code> 116, 0 <code>kbc</code> 117, 0 <code>kg</code> 118, 0 <code>kgy</code> 119, 0 <code>kr</code> 120, 0 <code>black_body</code> 121, 0 <code>kindlmann</code> 122, 0 <code>extended_kindlmann</code> 123, 0 <code>glasbey</code> 176, 0 <code>glasbey_cool</code> 177, 0 <code>glasbey_dark</code> 178, 0 <code>glasbey_hv</code> 179, 0 <code>glasbey_light</code> 180, 0 <code>glasbey_warm</code> 181, 0 <code>accent</code> 240, 0 <code>dark2</code> 240, 32 <code>paired</code> 240, 64 <code>pastel1</code> 240, 96 <code>pastel2</code> 240, 128 <code>set1</code> 240, 160 <code>set2</code> 240, 192 <code>set3</code> 240, 224 <code>tab10</code> 241, 0 <code>tab20</code> 241, 32 <code>tab20b</code> 241, 64 <code>tab20c</code> 241, 96 <code>category10_10</code> 241, 128 <code>category20_20</code> 241, 160 <code>category20b_20</code> 241, 192 <code>category20c_20</code> 241, 224 <code>colorblind8</code> 242, 0"},{"location":"examples/","title":"Examples","text":"<ul> <li>Basic visual example</li> <li>GUI example</li> <li>Image example</li> <li>Mesh example</li> <li>Path offscreen example</li> <li>Panels example</li> <li>Scatter plot example</li> <li>Spheres example</li> <li>Surface example</li> <li>Volume example</li> </ul>"},{"location":"examples/#basic-visual-example","title":"Basic visual example","text":"<p>Show a colored triangle using a basic visual.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Basic visual</li> <li>Vertex color interpolation</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/basic.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Basic visual.\nvisual = dvz.basic(batch, dvz.PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, 0)\n\n# Visual data allocation.\ndvz.basic_alloc(visual, 3)\n\n# Positions.\npos = np.array([\n    [-1, -1, 0],\n    [0, 1, 0],\n    [+1, -1, 0],\n]).astype(np.float32)\ndvz.basic_position(visual, 0, 3, pos, 0)\n\n# Colors.\ncolor = np.array(\n    [[255, 0, 0, 255],\n     [0, 255, 0, 255],\n     [0, 0, 255, 255],\n     ]).astype(np.uint8)\ndvz.basic_color(visual, 0, 3, color, 0)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#gui-example","title":"GUI example","text":"<p>Display a simple GUI to control the size of a mesh.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Shape</li> <li>Mesh visual and shape mesh</li> <li>GUI callback</li> <li>GUI dialog</li> <li>GUI buttons</li> <li>Shape transforms</li> <li>Dynamic shape and mesh update</li> </ul> <p>Note: the screenshot does not show the GUI at the moment, this will be fixed soon.</p> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/gui.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import (\n    S_,  # Python string to ctypes char*\n    vec2,\n    vec3,\n    vec4,\n)\n\n\n# GUI callback function.\n@dvz.gui\ndef ongui(app, fid, ev):\n    # Set the size of the next GUI dialog.\n    dvz.gui_size(vec2(170, 110))\n\n    # Start a GUI dialog with a dialog title.\n    dvz.gui_begin(S_(\"My GUI\"), 0)\n\n    # Add two buttons. The functions return whether the button was pressed.\n    incr = dvz.gui_button(S_(\"Increase\"), 150, 30)\n    decr = dvz.gui_button(S_(\"Decrease\"), 150, 30)\n\n    # Scaling factor.\n    scale = 1.0\n    if incr:\n        scale = 1.1\n    elif decr:\n        scale = 0.9\n    if incr or decr:\n\n        # Start recording shape transforms for all vertices in the shape (first=0, count=0=all).\n        dvz.shape_begin(shape, 0, 0)\n\n        # Scaling transform.\n        dvz.shape_scale(shape, vec3(scale, scale, scale))\n\n        # Stop recording the shape transforms.\n        dvz.shape_end(shape)\n\n        # Update the mesh visual data with the new shape's data.\n        dvz.mesh_reshape(visual, shape)\n\n        # Update the visual after its data has changed.\n        dvz.visual_update(visual)\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure.\n# NOTE: to use a GUI, use this flag. Don't use it if there is no GUI.\nfigure = dvz.figure(scene, 800, 800, dvz.CANVAS_FLAGS_IMGUI)\npanel = dvz.panel_default(figure)\narcball = dvz.panel_arcball(panel)\n\n# Cube colors.\ncolors = np.array([\n    [255, 0, 0, 255],\n    [0, 255, 0, 255],\n    [0, 0, 255, 255],\n    [255, 255, 0, 255],\n    [255, 0, 255, 255],\n    [0, 255, 255, 255],\n], dtype=np.uint8)\nshape = dvz.shape_cube(colors)\n\n# Create a mesh visual directly instantiated with the shape data.\nvisual = dvz.mesh_shape(batch, shape, dvz.MESH_FLAGS_LIGHTING)\ndvz.mesh_light_pos(visual, vec3(-1, +1, +10))\ndvz.mesh_light_params(visual, vec4(.5, .5, .5, 16))\n\n# Add the visual to the panel.\ndvz.panel_visual(panel, visual, 0)\n\n# Associate a GUI callback function with a figure.\ndvz.app_gui(app, dvz.figure_id(figure), ongui, None)\n\n# Initial arcball angles.\ndvz.arcball_initial(arcball, vec3(+0.6, -1.2, +3.0))\ndvz.panel_update(panel)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.shape_destroy(shape)\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#image-example","title":"Image example","text":"<p>Show an image.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Loading a PNG image with pillow</li> <li>Image visual</li> <li>Creating a texture</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/image.py</code> <pre><code>from pathlib import Path\nimport numpy as np\nfrom PIL import Image\n\nimport datoviz as dvz\nfrom datoviz import A_\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 1000x1000.\nfigure = dvz.figure(scene, 1000, 1000, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Panzoom interactivity.\npz = dvz.panel_panzoom(panel)\n\n# Image visual.\nvisual = dvz.image(batch, 0)\n\n# One image in this visual, there could be multiple images sharing the same underlying texture.\ndvz.image_alloc(visual, 1)\n\n# xy coordinates of the upper left corner, and lower right corner\npos = np.array([[-1, +1, +1, -1]], dtype=np.float32)\ndvz.image_position(visual, 0, 1, pos, 0)\n\n# uv coordinates of the upper left corner, and lower right corner\ntexcoords = np.array([[0, 0, 1, 1]], dtype=np.float32)\ndvz.image_texcoords(visual, 0, 1, texcoords, 0)\n\n# Load a PNG image.\nCURDIR = Path(__file__).parent\nfilepath = CURDIR / \"../data/textures/image.png\"\nwith Image.open(filepath) as f:\n    image = np.array(f.convert('RGBA'), dtype=np.uint8)\n    height, width = image.shape[:2]\n\n    # Texture parameters.\n    format = dvz.FORMAT_R8G8B8A8_UNORM\n    address_mode = dvz.SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER\n    filter = dvz.FILTER_LINEAR\n\n    # Create a texture out of a RGB image.\n    tex = dvz.tex_image(batch, format, width, height, A_(image))\n\n    # Assign the texture to the visual.\n    dvz.image_texture(visual, tex, filter, address_mode)\n\n    # Add the visual.\n    dvz.panel_visual(panel, visual, 0)\n\n    # Run the application.\n    dvz.scene_run(scene, app, 0)\n\n    # Cleanup.\n    dvz.scene_destroy(scene)\n    dvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#mesh-example","title":"Mesh example","text":"<p>Show a 3D mesh.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Arcball interactivity</li> <li>Loading a .OBJ mesh file</li> <li>3D shape</li> <li>Mesh visual and shape mesh</li> <li>Colormaps</li> <li>Manual mesh colors</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/mesh.py</code> <pre><code>from pathlib import Path\nimport numpy as np\nimport datoviz as dvz\nfrom datoviz import vec3, vec4, S_\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Arcball interactivity.\narcball = dvz.panel_arcball(panel)\n\n# Load a .OBJ mesh file.\nCURDIR = Path(__file__).parent\nfilepath = (CURDIR / \"../data/mesh/brain.obj\").resolve()\nshape = dvz.shape_obj(S_(filepath))\n\n# Fill artificial colors.\nnv = shape.vertex_count\nni = shape.index_count\nprint(f\"Loaded {filepath} with {nv} vertices and {ni // 3} faces.\")\n\n# Create the mesh visual from the surface shape.\nflags = dvz.MESH_FLAGS_LIGHTING\nvisual = dvz.mesh_shape(batch, shape, flags)\n\n# Set artificial vertex colors.\nt = np.linspace(0, 1, nv).astype(np.float32)\ncolors = np.empty((nv, 4), dtype=np.uint8)\ndvz.colormap_array(dvz.CMAP_BWR, nv, t, 0, 1, colors)\ndvz.mesh_color(visual, 0, nv, colors, 0)\n\n# Lighting parameters.\ndvz.mesh_light_pos(visual, vec3(-1, +1, +10))\ndvz.mesh_light_params(visual, vec4(.5, .5, .5, 16))\n\n# Add the visual to the panel.\ndvz.panel_visual(panel, visual, 0)\n\n# Initial arcball angles.\ndvz.arcball_initial(arcball, vec3(+0.6, -1.2, +3.0))\ndvz.panel_update(panel)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#path-offscreen-example","title":"Path offscreen example","text":"<p>This path example illustrates how to generate an offscreen image and save it as a PNG.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Path visual</li> <li>Offscreen rendering (save to a PNG image)</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/offscreen.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import (\n    S_,  # Python string to ctypes char*\n)\n\noffscreen = True\n\n# Boilerplate.\napp = dvz.app(dvz.APP_FLAGS_OFFSCREEN if offscreen else 0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure.\nfigure = dvz.figure(scene, 400, 800, 0)\npanel = dvz.panel_default(figure)\n\n# Panzoom interactivity.\npz = dvz.panel_panzoom(panel)\n\n# Path visual.\nvisual = dvz.path(batch, 0)\n\n# Multiple paths.\nn_paths = 100\npath_size = 1000\nn = n_paths * path_size\npath_lengths = np.full(n_paths, path_size, dtype=np.uint32)\ndvz.path_alloc(visual, n)\n\n# Positions.\nx = np.linspace(-1, +1, path_size)\nx = np.tile(x, (n_paths, 1))\nw = np.random.uniform(size=(n_paths, 1), low=20, high=100)\nd = 0.5 / (n_paths - 1)\ny = d * np.sin(w * x)\ny += np.linspace(-1, 1, n_paths).reshape((-1, 1))\nz = np.zeros((n_paths, path_size))\npos = np.c_[x.flat, y.flat, z.flat].astype(np.float32)\ndvz.path_position(visual, n, pos, n_paths, path_lengths, 0)\n\n# Colors.\nt = np.linspace(0, 1, n_paths).astype(np.float32)\ncolor = np.full((n_paths, 4), 255, dtype=np.uint8)\ndvz.colormap_array(dvz.CMAP_HSV, n_paths, t, 0, 1, color)\ncolor = np.repeat(color, path_size, axis=0)\ndvz.path_color(visual, 0, n, color, 0)\n\n# Line width.\ndvz.path_linewidth(visual, 3.0)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Screenshot to ./offscreen.png.\nif offscreen:\n    dvz.app_screenshot(app, dvz.figure_id(figure), S_(\"offscreen_python.png\"))\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#panels-example","title":"Panels example","text":"<p>Show visuals in two different panels.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Point visual</li> <li>Marker visual</li> <li>Multiple panels</li> <li>Mixing 2D and 3D in the same window</li> <li>GUI checkbox</li> <li>Show/hide a visual</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/panels.py</code> <pre><code>import ctypes\nimport numpy as np\nimport datoviz as dvz\nfrom datoviz import vec2, vec3, S_, V_\n\n\n# -------------------------------------------------------------------------------------------------\n# 1. Creating the scene\n# -------------------------------------------------------------------------------------------------\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nw, h = 800, 600\nfigure = dvz.figure(scene, w, h, dvz.CANVAS_FLAGS_IMGUI)\n\n\n# -------------------------------------------------------------------------------------------------\n# 2. First visual\n# -------------------------------------------------------------------------------------------------\n\n# Point visual.\nvisual0 = dvz.point(batch, 0)\n\n# Visual data allocation.\nn = 10_000\ndvz.point_alloc(visual0, n)\n\n# Point positions.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.point_position(visual0, 0, n, pos, 0)\n\n# Point colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ncolor[:, 3] = 240\ndvz.point_color(visual0, 0, n, color, 0)\n\n# Point sizes.\nsize = np.random.uniform(size=(n,), low=10, high=30).astype(np.float32)\ndvz.point_size(visual0, 0, n, size, 0)\n\ndvz.visual_depth(visual0, dvz.DEPTH_TEST_ENABLE)\n\n\n# -------------------------------------------------------------------------------------------------\n# 3. Second visual\n# -------------------------------------------------------------------------------------------------\n\n# Point visual.\nvisual1 = dvz.marker(batch, 0)\n\n# Visual data allocation.\nn = 1_000\ndvz.marker_alloc(visual1, n)\n\n# Marker positions.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.marker_position(visual1, 0, n, pos, 0)\n\n# Marker colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ncolor[:, 3] = 240\ndvz.marker_color(visual1, 0, n, color, 0)\n\n# Marker sizes.\nsize = np.random.uniform(size=(n,), low=30, high=60).astype(np.float32)\ndvz.marker_size(visual1, 0, n, size, 0)\n\n# Marker parameters.\ndvz.marker_aspect(visual1, dvz.MARKER_ASPECT_OUTLINE)\ndvz.marker_shape(visual1, dvz.MARKER_SHAPE_CROSS)\n# dvz.marker_edge_color(visual1, cvec4(255, 255, 255, 255))\n# dvz.marker_edge_width(visual1, 3.0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 4. Panels\n# -------------------------------------------------------------------------------------------------\n\n# Panels.\npanel0 = dvz.panel(figure, 0, 0, w / 2, h)\npanel1 = dvz.panel(figure, w / 2, 0, w / 2, h)\n\ndvz.panel_arcball(panel0)\ndvz.panel_panzoom(panel1)\n\ndvz.panel_visual(panel0, visual0, 0)\ndvz.panel_visual(panel1, visual1, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 5. GUI with checkbox\n# -------------------------------------------------------------------------------------------------\n\n# There are four steps to add a GUI with a checkbox.\n# i.    Initialize the figure with the flag `dvz.CANVAS_FLAGS_IMGUI``\n# ii.   Define a global-scoped object representing the variable to be updated by the GUI.\n# iii.  Define the GUI callback.\n# iv.   Call `dvz.app_gui(...)`\n\n# A wrapped boolean value with initial value False.\nchecked = V_(True, ctypes.c_bool)\n\n\n@dvz.gui\ndef ongui(app, fid, ev):\n    \"\"\"GUI callback function.\"\"\"\n\n    # Set the size of the next GUI dialog.\n    dvz.gui_size(vec2(170, 110))\n\n    # Start a GUI dialog with a dialog title.\n    dvz.gui_begin(S_(\"My GUI\"), 0)\n\n    # Add a checkbox\n    with checked:  # Wrap the boolean value.\n        # Return True if the checkbox's state has changed.\n        if dvz.gui_checkbox(S_(\"Show visual\"), checked.P_):\n            #                                  ^^^^^^^^^^ pass a C pointer to our wrapped bool\n            is_checked = checked.value  # Python variable with the checkbox's state\n\n            # Show/hide the visual.\n            dvz.visual_show(visual0, is_checked)\n\n            # Update the figure after its composition has changed.\n            dvz.figure_update(figure)\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n\n# Associate a GUI callback function with a figure.\ndvz.app_gui(app, dvz.figure_id(figure), ongui, None)\n\n\n# -------------------------------------------------------------------------------------------------\n# 6. Run and cleanup\n# -------------------------------------------------------------------------------------------------\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#scatter-plot-example","title":"Scatter plot example","text":"<p>Show points in 2D with various colors and sizes.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Panzoom interactivity</li> <li>Point visual</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/scatter.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Panzoom interactivity.\npz = dvz.panel_panzoom(panel)\n\n# Point visual.\nvisual = dvz.point(batch, 0)\n\n# Visual data allocation.\nn = 100_000\ndvz.point_alloc(visual, n)\n\n# Point positions.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\ndvz.point_position(visual, 0, n, pos, 0)\n\n# Point colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=240).astype(np.uint8)\ndvz.point_color(visual, 0, n, color, 0)\n\n# Point sizes.\nsize = np.random.uniform(size=(n,), low=10, high=30).astype(np.float32)\ndvz.point_size(visual, 0, n, size, 0)\n\n# Add the visual.\ndvz.panel_visual(panel, visual, 0)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#spheres-example","title":"Spheres example","text":"<p>Show fake 3D spheres and static text with manual camera control.</p> <p>Illustrates:</p> <ul> <li>Adding multiple visuals to a panel</li> <li>Sphere visual</li> <li>Glyph (text) visual</li> <li>Dynamic and static visual (visual opting out of the global panel transform)</li> <li>Keyboard event callbacks</li> <li>Manual camera control</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/spheres.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import vec2, vec3, vec4, S_\n\n\n# -------------------------------------------------------------------------------------------------\n# 1. Creating the scene\n# -------------------------------------------------------------------------------------------------\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure.\nfigure = dvz.figure(scene, 1000, 1000, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# 3D camera.\ncamera = dvz.panel_camera(panel)\n\n\n# -------------------------------------------------------------------------------------------------\n# 2. Text\n# -------------------------------------------------------------------------------------------------\n\n# Show a static glyph.\nglyph = dvz.glyph(batch, 0)\n\n# First, we load the default font (Roboto) with a given font size, and we load the pre-generated\n# glyph atlas.\n# NOTE: generating custom atlases dynamically with arbitrary TTF fonts (using the msdfgen library)\n# is possible but undocumented yet.\nfont_size = 32\naf = dvz.atlas_font(font_size)\ndvz.glyph_atlas(glyph, af.atlas)\n\n# Glyph text.\ntext = \"Press the arrow keys!\"\n\n# We specify the number of glyphs.\nn = len(text)\ndvz.glyph_alloc(glyph, n)\n\n# When displaying a single string, all glyph share the exact same position in 3D space, BUT\n# each glyph has a fixed pixel offset due to its relative position within the string (see below).\n# Here, the string will be displayed at (1, 1, 0) (we will not use the panel camera transform).\npos = np.c_[np.ones(n), np.ones(n), np.zeros(n)].astype(np.float32)\ndvz.glyph_position(glyph, 0, n, pos, 0)\n\n# We can assign a different color per glyph.\ncolor = np.full((n, 4), 255, dtype=np.uint8)\ndvz.glyph_color(glyph, 0, n, color, 0)\n\n# We specify the ASCII string (we could also specify unicode uint32 codepoints with glyph_unicode)\n# NOTE: we need to use S_() to pass a Python string to this ctypes-wrapped C function expecting\n# a const char*.\ndvz.glyph_ascii(glyph, S_(text))\n\n# Now we compute the glyph shifts (called \"xywh\") using our font.\nxywh = dvz.font_ascii(af.font, S_(text))\n# We also define a global relative anchor point, in pixels (xy), for the string.\n# \u00a0By default, the anchor is (0, 0) which represents the lower left corner of the string. The\n# anchor position is the string position defined above (1, 1, 0).\nanchor = vec2(-.5 * font_size * len(text), -2 * font_size)\ndvz.glyph_xywh(glyph, 0, n, xywh, anchor, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 3. Spheres\n# -------------------------------------------------------------------------------------------------\n\n# Now we define a fake sphere visual, similar to markers, but with a fake 3D effect to simulate\n# spheres whereas they are really 2D bitmap sprites in a 3D world.\n# See https://paroj.github.io/gltut/Illumination/Tutorial%2013.html\nvisual = dvz.sphere(batch, 0)\n\n# Sphere data allocation (100 000 spheres).\nn = 100_000\ndvz.sphere_alloc(visual, n)\n\n# Sphere random positions.\npos = np.random.uniform(size=(n, 3), low=-1, high=+1).astype(np.float32)\npos *= np.array([100, 1, 100])\ndvz.sphere_position(visual, 0, n, pos, 0)\n\n# Sphere random colors.\ncolor = np.random.uniform(size=(n, 4), low=50, high=200).astype(np.uint8)\ncolor[:, 3] = 255\ndvz.sphere_color(visual, 0, n, color, 0)\n\n# Sphere sizes in pixels.\nsize = np.random.uniform(size=(n,), low=50, high=100).astype(np.float32)\ndvz.sphere_size(visual, 0, n, size, 0)\n\n# Light position.\ndvz.sphere_light_pos(visual, vec3(-5, +5, +100))\n\n# Light parameters.\ndvz.sphere_light_params(visual, vec4(.4, .8, 2, 32))\n\n\n# -------------------------------------------------------------------------------------------------\n# 4. Panel composition\n# -------------------------------------------------------------------------------------------------\n\n# We add the sphere visual.\ndvz.panel_visual(panel, visual, 0)\n\n# We add the glyph visual and we opt out of the panel transform (3D movable camera).\ndvz.panel_visual(panel, glyph, dvz.VIEW_FLAGS_STATIC)\n\n\n# -------------------------------------------------------------------------------------------------\n# 5. Manual camera control\n# -------------------------------------------------------------------------------------------------\n\n# Custom camera manipulation with the keyboard.\n# NOTE: a similar interaction pattern will be soon provided as a builtin option in Datoviz\n# (similar to the existing panzoom and arcball).\n\n# Initial camera position.\neye = vec3(0, 0, 4)\n\n# Camera movement offset.\nd = .2\n\n\n# Keyboard event callback function.\n@dvz.keyboard\ndef on_keyboard(app, window_id, ev):\n    global eye\n    # Keyboard events are PRESS, RELEASE, and REPEAT.\n    if ev.type != dvz.KEYBOARD_EVENT_RELEASE:\n        # Move the camera position depending on the pressed keys.\n        if ev.key == dvz.KEY_UP:\n            eye[2] -= d\n        elif ev.key == dvz.KEY_DOWN:\n            eye[2] += d\n        elif ev.key == dvz.KEY_LEFT:\n            eye[0] -= d\n        elif ev.key == dvz.KEY_RIGHT:\n            eye[0] += d\n\n        # Update the camera position.\n        dvz.camera_position(camera, eye)\n\n        # Update the lookat position (just forward looking).\n        lookat = vec3(*eye)\n        lookat[2] -= 1\n        dvz.camera_lookat(camera, lookat)\n\n        # Important: we must update the panel after the panel transformation parameters\n        # have changed.\n        dvz.panel_update(panel)\n\n\n# We register the keyboard callback function.\ndvz.app_onkeyboard(app, on_keyboard, None)\n\n\n# -------------------------------------------------------------------------------------------------\n# 6. Run and cleanup\n# -------------------------------------------------------------------------------------------------\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#surface-example","title":"Surface example","text":"<p>Show a rotating surface in 3D.</p> <p>Illustrates:</p> <ul> <li>White background</li> <li>Surface shape</li> <li>Mesh visual and surface mesh</li> <li>Arcball interactivity</li> <li>Initial arcball angles</li> <li>Manual arcball parameter update</li> <li>Timers and timer callbacks</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/surface.py</code> <pre><code>import numpy as np\nimport datoviz as dvz\nfrom datoviz import vec3, vec4\n\n# Boilerplate.\napp = dvz.app(dvz.APP_FLAGS_WHITE_BACKGROUND)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Arcball interactivity.\narcball = dvz.panel_arcball(panel)\n\n# Grid parameters.\nrow_count = 250\ncol_count = row_count\nn = row_count * col_count\no = vec3(-1, 0, -1)\nu = vec3(2.0 / (row_count - 1), 0, 0)\nv = vec3(0, 0, 2.0 / (col_count - 1))\n\n# Allocate heights and colors arrays.\ngrid = np.meshgrid(row_count, col_count)\nshape = (row_count, col_count)\nheights = np.zeros(shape, dtype=np.float32)\n\n# Create grid of coordinates\nx = np.arange(col_count)\ny = np.arange(row_count)\nxv, yv = np.meshgrid(x, y)\n\n# Distances.\ncenter_x = col_count / 2\ncenter_y = row_count / 2\nd = np.sqrt((xv - center_x) ** 2 + (yv - center_y) ** 2)\n\n# Heights.\na = 4.0 * 2 * np.pi / row_count\nb = 3.0 * 2 * np.pi / col_count\nc = .5\nhmin = -.5\nhmax = +.5\nheights = np.exp(-.0001 * d ** 2) * np.sin(a*xv) * np.cos(b*yv)\nheights = heights.ravel().astype(np.float32)\n\n# Colors.\ncolors = np.empty((n, 4), dtype=np.uint8)\ndvz.colormap_array(\n    dvz.CMAP_PLASMA, n, -heights, -hmax, -hmin, colors)\n\n# Create the surface shape.\nshape = dvz.shape_surface(row_count, col_count, heights, colors, o, u, v, 0)\n\n# Create the mesh visual from the surface shape.\nflags = dvz.MESH_FLAGS_LIGHTING\nvisual = dvz.mesh_shape(batch, shape, flags)\n\n# Lighting parameters.\ndvz.mesh_light_pos(visual, vec3(-1, +1, +10))\ndvz.mesh_light_params(visual, vec4(.5, .5, .5, 16))\n\n# Add the visual to the panel.\ndvz.panel_visual(panel, visual, 0)\n\n# Initial arcball angles.\nangle = -0.39686\ndvz.arcball_initial(arcball, vec3(0.42339, angle, -0.00554))\ndvz.panel_update(panel)\n\n\n# Timer callback: update the arcball angles in real time.\n@dvz.timer\ndef _on_timer(app, window_id, ev):\n    global angle\n    angle += .01\n    dvz.arcball_set(arcball, vec3(0.42339, angle, -0.00554))\n    dvz.panel_update(panel)\n\n\n# Create a timer (60 events per second).\ndvz.app_timer(app, 0, 1. / 60., 0)\n\n# Register a timer callback.\ndvz.app_ontimer(app, _on_timer, None)\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"examples/#volume-example","title":"Volume example","text":"<p>Show a 3D volume.</p> <p>Illustrates:</p> <ul> <li>Creating a figure, panel</li> <li>Arcball interactivity</li> <li>Loading a volume from file</li> <li>Creating a 3D texture</li> <li>Volume visual</li> </ul> <p></p> \ud83d\udc68\u200d\ud83d\udcbb Expand the code from <code>examples/volume.py</code> <pre><code>import gzip\nfrom pathlib import Path\nimport numpy as np\nimport datoviz as dvz\nfrom datoviz import A_, vec3, vec4\n\n\n# -------------------------------------------------------------------------------------------------\n# 1. Creating the scene\n# -------------------------------------------------------------------------------------------------\n\n# Boilerplate.\napp = dvz.app(0)\nbatch = dvz.app_batch(app)\nscene = dvz.scene(batch)\n\n# Create a figure 800x600.\nfigure = dvz.figure(scene, 800, 600, 0)\n\n# Panel spanning the entire window.\npanel = dvz.panel_default(figure)\n\n# Arcball interactivity.\narcball = dvz.panel_arcball(panel)\n\n\n# -------------------------------------------------------------------------------------------------\n# 2. Loading the volume and creating the 3D GPU texture\n# -------------------------------------------------------------------------------------------------\n\n# Load a volume file.\nCURDIR = Path(__file__).parent\nfilepath = (CURDIR / \"../data/volumes/allen_mouse_brain_rgba.npy.gz\").resolve()\nwith gzip.open(filepath, 'rb') as f:\n    volume_data = np.load(f)\nshape = volume_data.shape\n\n# Volume parameters.\nMOUSE_D, MOUSE_H, MOUSE_W = shape[:3]\nscaling = 1.0 / MOUSE_D\n\n# Create the 3D texture.\nformat = dvz.FORMAT_R8G8B8A8_UNORM\ntex = dvz.tex_volume(batch, format, MOUSE_W, MOUSE_H, MOUSE_D, A_(volume_data))\n\n\n# -------------------------------------------------------------------------------------------------\n# 3. Volume visual\n# -------------------------------------------------------------------------------------------------\n\n# Create the volume visual.\nvisual = dvz.volume(batch, dvz.VOLUME_FLAGS_RGBA)\n\n# Visual data allocation (1 volumetric object).\ndvz.volume_alloc(visual, 1)\n\n# Bind the volume texture to the visual.\nvolume_tex = dvz.volume_texture(\n    visual, tex, dvz.FILTER_LINEAR, dvz.SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE)\n\n# Volume parameters.\ndvz.volume_size(visual, MOUSE_W * scaling, MOUSE_H * scaling, 1)\ndvz.volume_transfer(visual, vec4(1, 0, 0, 0))\n\n\n# Add the visual to the panel AFTER setting the visual's data.\ndvz.panel_visual(panel, visual, 0)\n\n\n# -------------------------------------------------------------------------------------------------\n# 4. Initial panel parameters\n# -------------------------------------------------------------------------------------------------\n\n# Initial arcball angles.\ndvz.arcball_initial(arcball, vec3(-2.25, 0.65, 1.5))\n\n# Initial camera position.\ncamera = dvz.panel_camera(panel)\ndvz.camera_initial(camera, vec3(0, 0, 1.5), vec3(), vec3(0, 1, 0))\n\n# Update the panel after updating the arcball and camera.\ndvz.panel_update(panel)\n\n\n# -------------------------------------------------------------------------------------------------\n# 5. Run and cleanup\n# -------------------------------------------------------------------------------------------------\n\n# Run the application.\ndvz.scene_run(scene, app, 0)\n\n# Cleanup.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre>"},{"location":"userguide/","title":"User guide","text":"<p>Datoviz is a C-first library. It provides auto-generated Python ctypes bindings that closely follow the Datoviz C API.</p> <p>While this user guide focuses on Python for convenience, it can be readily translated into C.</p> <p>To use a Datoviz C function in Python, you typically need to replace the <code>dvz_</code> (functions), <code>DVZ_</code> (enumerations), or <code>Dvz</code> (structures) prefix with <code>dvz.</code> after importing Datoviz with <code>import datoviz as dvz</code>.</p> <p>Please note that this user guide is a work in progress. We strongly recommend looking at the examples (located in the <code>examples/</code> subfolder of the repository) and the auto-generated C API reference (found in <code>docs/api.md</code>).</p>"},{"location":"userguide/#overview","title":"Overview","text":"<p>Creating a GPU-based interactive visualization script with Datoviz in Python typically involves the following steps:</p> <ol> <li>Creating an <code>app</code> and a <code>scene</code>.</li> <li>Creating one or several <code>figures</code> (window).</li> <li>Creating one or several <code>panels</code> (subplots) in each figure, defined by their offset and size in pixels.</li> <li>Creating <code>visuals</code> of predefined types.</li> <li>Setting the visual data (position, size, color, groups...).</li> <li>Optionally, setting up event callbacks (mouse, keyboard, timers...).</li> <li>Optionally, creating GUIs.</li> <li>Running the application.</li> <li>Closing and destroying the <code>scene</code> and <code>app</code>.</li> </ol> <p>GPU knowledge is not required when using this interface. The lower-level GPU-based layers are not yet exposed in the <code>datoviz.h</code> public header file. Contact us if you would be interested in using them in your application.</p>"},{"location":"userguide/#app-and-scene","title":"App and scene","text":"<p>The <code>app</code> handles the window, user events, event loop.</p> <p>The <code>scene</code> handles the panels, visuals, and data.</p> <p>A visualization script is typically organized as follows:</p> <pre><code># This imports the binary libdatoviz shared library.\nimport datoviz as dvz\n\n# Create an application. The argument is reserved to optional flags, like dvz.APP_FLAGS_OFFSCREEN\n# for running an offscreen application (without a window, saving a figure to a PNG file).\n# See the offscreen.py example.\napp = dvz.app(0)\n\n# Retrieve the app's batch, which contains a stream of Datoviz Intermediate Protocol requests that\n# will be processed at the next frame by the app's event loop. It's used to create visuals.\nbatch = dvz.app_batch(app)\n\n# Create a scene, which handles the plotting objects (figures, panels, visuals, data, callbacks).\nscene = dvz.scene(batch)\n\n# ... your code here ...\n\n# Run the application. The last argument is the number of frames (0 = infinite loop).\ndvz.scene_run(scene, app, 0)\n\n# App and scene clean up, memory freeing, etc.\ndvz.scene_destroy(scene)\ndvz.app_destroy(app)\n</code></pre> <p>Internally, the <code>scene</code> API generates a stream of Datoviz Intermediate Protocol (DIP) requests and sends them to the Datoviz Vulkan renderer (managed by the <code>app</code>). The DIP closely resembles the WebGPU specification. This decoupled architecture ensures that, in the future, the <code>scene</code> API can be implemented on top of other non-Vulkan DIP renderers (including a future JavaScript-based one).</p> <p>Although the architecture is designed with multithreading in mind (allowing for data computation and transfers without blocking the event loop), our primary focus has been on single-threaded applications so far. Multithreading functionality will be provided and documented at a later time.</p>"},{"location":"userguide/#figures","title":"Figures","text":"<p>A <code>Figure</code> is a window on which to draw visuals. It is created as follows:</p> <pre><code># Create a figure with size 800 x 600 and no optional flags.\nfigure = dvz.figure(scene, 800, 600, 0)\n</code></pre>"},{"location":"userguide/#panels","title":"Panels","text":"<p>A <code>Panel</code> is a rectangular portion of a <code>Figure</code> on which to render visuals.</p> <p>You can create a default panel spanning the entire figure as follows:</p> <pre><code>panel = dvz.panel_default(figure)\n</code></pre> <p>Create an arbitrary panel as follows:</p> <pre><code># x, y is the offset of the top-left panel corner.\n# w, h is the size in pixels of the panel.\npanel = dvz.panel(figure, x, y, w, h)\n</code></pre>"},{"location":"userguide/#visuals","title":"Visuals","text":"<p>The <code>Visual</code> is the most important object type in Datoviz. It represents a visual collection of similar elements, such as points, markers, segments, glyphs (text), paths, images, meshes, and more.</p> <p>The concept of a collection is crucial for high-performance rendering with GPUs. Visual elements of the same type should be grouped within the same <code>Visual</code> to optimize performance.</p> <p>The primary limitation of grouping elements together is that they currently share the same transform, meaning they share the same coordinate system.</p> <p>Datoviz offers a predefined set of common visuals:</p> <ul> <li>Basic visuals (faster but lower quality than other visuals): <code>basic</code> with an adequate <code>dvz.PRIMITIVE_TOPOLOGY_*</code> enumeration, supporting pixels (<code>POINT_LIST</code>), aliased thin lines (<code>LINE_LIST</code>, <code>LINE_STRIP</code>), triangles (<code>TRIANGLE_LIST</code>, <code>TRIANGLE_STRIP</code>);</li> <li>0D visuals: <code>pixel</code>, <code>point</code> (disc), <code>marker</code>, <code>glyph</code> (string characters rendered on the GPU with multichannel signed distance fields);</li> <li>1D visuals: <code>segment</code>, <code>path</code>;</li> <li>2D visuals: <code>image</code>;</li> <li>3D visuals: <code>mesh</code>, <code>sphere</code> (2D sprites with \"fake\" 3D rendering, also known as impostors), <code>volume</code> (currently using a basic GPU raymarching algorithm), <code>slice</code> (volume image slices).</li> </ul> <p></p> <p>The visuals are implemented on the GPU using advanced antialiasing techniques within the shaders.</p> <p>Additional visuals and the ability to create custom visuals via user-provided shaders will be added in the future.</p> <p>To create a visual, use this:</p> <pre><code># Create a `point` visual with no optional flags.\nvisual = dvz.point(batch, 0)\n</code></pre>"},{"location":"userguide/#visual-data","title":"Visual data","text":"<p>Once a visual is created, you can specify its data using the provided visual-specific functions.</p> <p>The most common types of visual properties are point positions and colors, but each visual has its own specific data properties (e.g., size, shape, groups). For more details, refer to the C API reference.</p>"},{"location":"userguide/#terminology","title":"Terminology","text":"<p>We use the following terminology:</p> <ul> <li>item: A single visual element, such as a particular point, marker, or a single image within an <code>image</code> visual. Each visual represents a collection of elements, so an <code>image</code> visual may represent one or multiple images.</li> <li>group: A consecutive sequence of items that share common properties. This concept is mostly used in the <code>path</code> visual, where a group refers to an entire path, while an item refers to a point within that path. Thus, a <code>path</code> visual contains a set of points (items) organized into one or multiple disjoint paths (groups).</li> <li>vertex: A 3D point sent to the GPU, which is managed transparently by Datoviz. For example, a single image is represented by two triangles and six vertices. Datoviz automatically handles the triangulation, so you typically don't need to concern yourself with vertices.</li> <li>index: In the mesh visual, an index refers to the set of vertices. A mesh is primarily defined by (1) a set of 3D points (vertices), and (2) a set of index triplets (three indices) that define a triangular face.</li> </ul> <p>A visual represents a collection of <code>n</code> items, indexed from <code>0</code> to <code>n-1</code>.</p>"},{"location":"userguide/#python-ctypes-bindings","title":"Python ctypes bindings","text":"<p>C visual data functions expect pointers to arrays of a specific type, such as an array of <code>vec3</code> (three <code>float32</code> values) for positions, or an array of <code>cvec4</code> (four <code>char</code>, representing RGBA <code>uint8</code> unsigned bytes) for colors.</p> <p>Python ctypes bindings are auto-generated and expect a NumPy array when a C visual data function expects a pointer to an array of values. Currently, the ctypes bindings check the <code>dtype</code>, shape, and C-contiguity of the provided arrays.</p>"},{"location":"userguide/#position","title":"Position","text":"<p>The <code>position</code> property specifies the 3D coordinates of visual points. Some visuals require the point positions in a specific format. For instance, segment positions are defined by the 3D coordinates of the start and end points of each segment. Image positions are currently defined by the 2D coordinates of the upper left and lower right corners, though this may change based on user feedback.</p> <p>To set the positions of a visual, for example the <code>point</code> visual, use this:</p> <p><pre><code># Define a (N, 3) NumPy array of float32 values (one row = one point).\n# Note that the C function dvz_point_position() expects a vec3 array.\npos = np.random.normal(size=(n, 3), scale=.25).astype(np.float32)\n\n# Set the positions of `n` items starting with item #0.\n# The last argument represents the optional data transfer flags (typically 0).\ndvz.point_position(visual, 0, n, pos, 0)\n</code></pre> The coordinate system is defined as follows:</p> <ul> <li>x: left to right <code>[-1, +1]</code></li> <li>y: bottom to top <code>[-1, +1]</code></li> <li>z: front to back <code>[-1, +1]</code></li> </ul> <p>Positions must be provided in a normalized coordinate system, known as normalized device coordinates (NDC) in computer graphics terminology. Since your data is typically not in this range, you'll need to manually normalize it to the <code>[-1, +1]</code> interval before passing it to Datoviz.</p> <p>Datoviz v0.2 does not yet include built-in axes or data normalization features, but these will be introduced in v0.3.</p>"},{"location":"userguide/#color","title":"Color","text":"<p>Colors are passed as RGBA values, each represented by four <code>uint8</code> values. Use opacity values less than 255 in the last component (the alpha channel, <code>a</code>) to create transparent elements.</p>"},{"location":"userguide/#textures","title":"Textures","text":"<p>Textures are used in the <code>image</code> (2D textures), <code>mesh</code> (2D textures), and <code>volume</code> (3D textures) visuals. Refer to the examples for more details.</p> <p>For example, here\u2019s how to create a 2D texture and apply it to an <code>image</code> visual:</p> <pre><code># Assuming rgba is a 3D NumPy array (height, width, 4).\nheight, width = rgba.shape[:2]\n\n# Texture parameters.\nformat = dvz.FORMAT_R8G8B8A8_UNORM  # The Vulkan format corresponds to 4*uint8 values.\naddress_mode = dvz.SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER  # Texture address mode.\nfilter = dvz.FILTER_LINEAR  # Linear filtering, use dvz.FILTER_NEAREST to disable.\n\n# Create a texture out of a RGB image.\n# NOTE: since dvz_tex_image() accepts any type of pointer, we need to manually convert the NumPy\n# array to a void* pointer. This is done with the `A_()` function (`from datoviz import A_`).\ntex = dvz.tex_image(batch, format, width, height, A_(image))\n\n# Finally, we assign this texture to the image visual.\ndvz.image_texture(visual, tex, filter, address_mode)\n</code></pre>"},{"location":"userguide/#data-sharing","title":"Data sharing","text":"<p>Since textures are decoupled from visuals, they can be easily shared across different visuals.</p> <p>However, it is not yet straightforward to share other types of data between visuals. While the underlying architecture is designed to support this, the user-facing API does not currently offer this capability.</p>"},{"location":"userguide/#dynamic-data-updates","title":"Dynamic data updates","text":"<p>You can modify the data of a visual dynamically while the event loop is running, such as in an event callback. After updating a visual, you need to apply the changes with the following call:</p> <pre><code>dvz.visual_update(visual)\n</code></pre>"},{"location":"userguide/#shapes","title":"Shapes","text":"<p>The <code>mesh</code> visual can be directly used with properties such as vertices, indices, colors, normals, and texture coordinates. Alternatively, you can use the <code>Shape</code> structure, which encapsulates these arrays. Shapes can be created using functions for predefined forms, along with affine transforms, merging, and other operations.</p>"},{"location":"userguide/#interactivity","title":"Interactivity","text":"<p>Two types of interactivity patterns are currently supported:</p> <ul> <li>Panzoom (2D): Pan with left mouse drag, zoom with right mouse drag.</li> <li>Arcball (3D): Rotate with left mouse drag.</li> </ul> <p>Additional interactivity patterns will be implemented in the future.</p> <p>To define the interactivity pattern in a panel:</p> <pre><code>pz = dvz.panel_panzoom(panel)\n# or\narcball = dvz.panel_arcball(panel)\n</code></pre> <p>Refer to the C API reference for functions you can use to manually control the panzoom or arcball. After updating these interactivity objects, you need to update the panel to apply your changes:</p> <pre><code>dvz.panel_update(panel)\n</code></pre>"},{"location":"userguide/#event-callbacks","title":"Event callbacks","text":"<p>You can define custom event callbacks to respond to mouse and keyboard interactions, as well as set up timers.</p>"},{"location":"userguide/#mouse","title":"Mouse","text":"<p>Define a mouse callback as follows:</p> <pre><code>@dvz.mouse\ndef on_mouse(app, window_id, ev):\n    # Access the mouse event structure.\n    # Mouse position.\n    x, y = ev.pos\n    print(f\"Position {x:.0f},{y:.0f}\")\n    # Detect mouse event type.\n    if ev.type == dvz.MOUSE_EVENT_CLICK:\n        # Identify mouse click button.\n        button = ev.content.b.button\n        print(f\"Clicked with button {button}\")\n</code></pre> <p>The mouse event types are:</p> <pre><code>MOUSE_EVENT_RELEASE             b       DvzMouseButtonEvent\nMOUSE_EVENT_PRESS               b       DvzMouseButtonEvent\nMOUSE_EVENT_MOVE\nMOUSE_EVENT_CLICK               c       DvzMouseClickEvent\nMOUSE_EVENT_DOUBLE_CLICK        c       DvzMouseClickEvent\nMOUSE_EVENT_DRAG_START          d       DvzMouseDragEvent\nMOUSE_EVENT_DRAG                d       DvzMouseDragEvent\nMOUSE_EVENT_DRAG_STOP           d       DvzMouseDragEvent\nMOUSE_EVENT_WHEEL               w       DvzMouseWheelEvent\n</code></pre> <p>Use the corresponding letter after <code>ev.content.</code>, such as <code>ev.content.b</code> for a <code>DvzMouseButtonEvent</code> structure. Refer to the C API reference for more details about the fields in these structures.</p> <p>The mouse buttons are:</p> <pre><code>MOUSE_BUTTON_LEFT = 1\nMOUSE_BUTTON_MIDDLE = 2\nMOUSE_BUTTON_RIGHT = 3\n</code></pre> <p>Datoviz currently does not provide built-in picking functionality. The only information available in mouse event callbacks is the pixel coordinates of the mouse cursor.</p>"},{"location":"userguide/#keyboard","title":"Keyboard","text":"<p>Define a keyboard callback as follows:</p> <pre><code># Keyboard event callback function.\n@dvz.keyboard\ndef on_keyboard(app, window_id, ev):\n\n    # Get the key code (refer to the C API reference).\n    key = ev.key\n\n    # Determine modifier flags.\n    mods = {\n        'shift': ev.mods &amp; dvz.KEY_MODIFIER_SHIFT != 0,\n        'control': ev.mods &amp; dvz.KEY_MODIFIER_CONTROL != 0,\n        'alt': ev.mods &amp; dvz.KEY_MODIFIER_ALT != 0,\n        'sup': ev.mods &amp; dvz.KEY_MODIFIER_SUPER != 0,\n    }\n    mods = '+'.join(key for key, val in mods.items() if val)\n\n    # Identify the keyboard event type (PRESS, RELEASE, REPEAT).\n    type = {\n        dvz.KEYBOARD_EVENT_PRESS: 'press',\n        dvz.KEYBOARD_EVENT_REPEAT: 'repeat',\n        dvz.KEYBOARD_EVENT_RELEASE: 'release',\n    }\n    type = type.get(ev.type, '')\n\n    print(f\"{type} {mods} {key}\")\n\n# Register the keyboard callback function.\ndvz.app_onkeyboard(app, on_keyboard, None)\n</code></pre>"},{"location":"userguide/#timer","title":"Timer","text":"<p>Define a timer as follows:</p> <pre><code># Timer callback.\n@dvz.timer\ndef on_timer(app, window_id, ev):\n    # Use the timer index for identifying multiple timers.\n    idx = ev.timer_idx\n    step = ev.step_idx\n    time = ev.time\n    print(f\"{time:.3f}: timer #{idx}, step {step}\")\n\n# Set the timer frequency.\nfrequency = 4\n\n# Define a timer with this frequency, starting after 0.5 seconds, stopping after 50 ticks.\n# Use 0 as the last argument for an infinite timer.\ndvz.app_timer(app, 0.5, 1. / frequency, 50)\n\n# Register the timer callback.\ndvz.app_ontimer(app, on_timer, None)\n</code></pre>"},{"location":"userguide/#manual-3d-camera-control","title":"Manual 3D camera control","text":"<p>By default, a panel is 2D. To define a 3D panel, you can either use an arcball (see above) or a generic 3D perspective camera. Here's how to define a 3D perspective camera:</p> <pre><code>from datoviz import vec3\n\n# Define a 3D perspective camera.\ncamera = dvz.panel_camera(panel)\n\n# Set the camera position.\ndvz.camera_position(camera, vec3(x, y, z))\n\n# Set the position of the point the camera is looking at.\ndvz.camera_lookat(camera, vec3(lx, ly, lz))\n</code></pre> <p>You can implement custom 3D camera control by calling these functions within mouse and keyboard callbacks. After these camera functions are called, it is crucial to apply the changes to the panel:</p> <pre><code>dvz.panel_update(panel)\n</code></pre>"},{"location":"userguide/#graphical-user-interfaces","title":"Graphical User Interfaces","text":"<p>Datoviz includes basic GUI capabilities via the Dear ImGui C++ library. A future version of Datoviz may allow more direct use of Dear ImGui functionalities beyond the current wrappers.</p> <p>To display a GUI dialog, follow these steps:</p> <ol> <li>Use the <code>dvz.CANVAS_FLAGS_IMGUI</code> flag when creating a figure (last argument of <code>dvz.figure()</code>).</li> <li>Define a GUI callback function.</li> <li>Register the GUI callback function.</li> </ol> <p>Example:</p> <pre><code>from datoviz import vec2, S_\n\n@dvz.gui\ndef on_gui(app, fid, ev):\n    \"\"\"GUI callback function.\"\"\"\n\n    # Set the size of the next GUI dialog.\n    dvz.gui_size(vec2(200, 100))\n\n    # Start a GUI dialog with a title.\n    # Use `S_()` to pass a Python string to a C function expecting a const char*.\n    dvz.gui_begin(S_(\"My GUI dialog\"), 0)\n\n    # Display a button.\n    clicked = dvz.gui_button(S_(\"Click me\"), 150, 30)\n    if clicked:\n        print(\"Clicked!\")\n\n    # End the GUI dialog.\n    dvz.gui_end()\n\n# Associate a GUI callback function with a figure.\ndvz.app_gui(app, dvz.figure_id(figure), on_gui, None)\n</code></pre> <p>The GUI callback function is called on every frame. To avoid blocking the main event loop, ensure there is no long-lasting computation within it. Dear ImGui recreates the entire GUI at each frame (immediate mode rendering). GUI widget functions like <code>dvz.gui_button()</code> typically return a boolean indicating whether the widget's state has changed.</p>"},{"location":"userguide/#using-datoviz-in-a-cc-application","title":"Using Datoviz in a C/C++ application","text":"<p>This section provides general instructions for C/C++ developers who want to use Datoviz in their library or application.</p>"},{"location":"userguide/#ubuntu","title":"Ubuntu","text":"<p>Note: to be completed.</p> <p>Install the <code>.deb</code> package and look at the <code>.c</code> examples in <code>examples/</code>.</p>"},{"location":"userguide/#macos-arm64","title":"macOS (arm64)","text":"<p>Looking at the <code>justfile</code> (<code>pkg</code> and <code>testpkg</code> commands) may be helpful. To build an application using Datoviz:</p> <ol> <li>You need to link your application to <code>libdatoviz.dylib</code>, that you can build yourself or find in the provided <code>.pkg</code> installation file.</li> <li>You also need to link to the non-system dependencies of Datoviz, for now they are <code>libvulkan</code>, <code>libMoltenVK</code> (\"emulating\" Vulkan on top of Apple Metal), <code>libpng</code> and <code>freetype</code>. You can see the dependencies with <code>just deps</code> (which uses <code>otool</code> on <code>libdatoviz.dylib</code>). You'll find these dependencies in <code>libs/vulkan/macos</code> in the GitHub repository.</li> <li>You should bundle these <code>dylib</code> dependencies alongside your application, and that will depend on how your application is built and distributed.</li> <li>Note that the <code>just pkg</code> script modifies the rpath of <code>libdatoviz.dylib</code> with <code>install_name_tool</code> before building the <code>.pkg</code> package to declare that its dependencies are to be found in the same directory.</li> <li>Another thing to keep in mind is that, for now, the <code>VK_DRIVER_FILES</code> environment variable needs to be set to the absolute path to <code>libs/vulkan/macos/MoltenVK_icd.json</code> (available in this GitHub repository). The <code>.pkg</code> package installs it to <code>/usr/local/lib/datoviz/MoltenVK_icd.json</code>. Right now, <code>datoviz.h</code> automatically sets this environment variable if it's included in the source file implementing your <code>main()</code> entry-point. These complications are necessary to avoid requiring the end-users to install the Vulkan SDK manually.</li> </ol>"},{"location":"userguide/#windows","title":"Windows","text":"<p>To be completed.</p>"},{"location":"userguide/#technical-notes-for-cc-developers","title":"Technical notes for C/C++ developers","text":"<ul> <li>\ud83e\udde0 Memory management. Datoviz uses opaque pointers and manages its own memory. Porting the relatively light high-level code of Datoviz (scene API) to a more modern and safer language may be considered in the future.</li> <li>\ud83d\udcbb C/C++ usage. Datoviz employs a restricted and straightforward usage of C, with very limited C++ functionality (mostly common dynamic data structures, in ~10% of the code).</li> <li>\ud83d\udcc2 Data copies. When passing data to visuals, data is copied by default to Datoviz for memory safety reasons. This might impact performance and memory usage when handling large datasets (tens of millions of points). We will soon document how to avoid these extra copies and prevent crashes related to Datoviz accessing deallocated memory.</li> <li>\ud83c\udfd7\ufe0f Modular architecture. Datoviz v0.2+ features a modular architecture where the low-level Vulkan-specific rendering engine is decoupled from the higher-level visual and interactive logic. A private asynchronous message-based protocol is used internally, enabling a future Javascript/WebAssembly/WebGPU port of Datoviz, which we plan to work on in the coming years.</li> <li>\ud83d\udc65 Contributing. This modular architecture allows C/C++ contributors without GPU knowledge to propose improvements and new functionality in the higher-level parts.</li> <li>\ud83d\udd17 Bindings. While we provide raw ctypes bindings in Python to the Datoviz C API, our goal is to implement as much functionality in C/C++ to offer the same functionality to other languages that may provide Datoviz bindings in the future (Julia, Rust, R, MATLAB...).</li> </ul>"}]}