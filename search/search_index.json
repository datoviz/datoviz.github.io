{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Datoviz: GPU interactive scientific data visualization with Vulkan \u00b6 Datoviz is an open-source high-performance interactive scientific data visualization library leveraging the graphics processing unit ( GPU ) for speed, visual quality, and scalability. It supports both 2D and 3D rendering, as well as minimal graphical user interfaces (using the Dear ImGUI library ). Written in C , Datoviz has been designed from the group up for performance . It provides native Python bindings (based on Cython). Bindings to other languages could be developed thanks to community efforts (Julia, R, MATLAB, Rust, C#, and so on). Datoviz uses the Vulkan graphics API created by the Khronos consortium, successor of OpenGL. Supporting other modern graphics API, such as WebGPU, would constitute interesting developments. Datoviz is currently being developed mostly by Cyrille Rossant at the International Brain Laboratory , a consortium of neuroscience research labs around the world. Datoviz is at an early stage of development. The library is quite usable but evolves quickly. Datoviz has been tested on Linux, macOS (Intel), and to a lesser extent, Windows. It should work on most computers, with or without a discrete GPU (but with up-to-date graphics drivers). Many more features will come later and the documentation will be improved. Contributions are highly welcome! Screenshots \u00b6 Credits: mouse brain volume: Allen SDK . France: Natural Earth . Molecule: Crystal structure of S. pyogenes Cas9 from PDB (thanks to Eric for conversion to OBJ mesh). Earth: Pixabay . Raster plot: IBL. 3D human brain: Anneke Alkemade et al. 2020 , thanks to Pierre-Louis Bazin and Julia Huntenburg. Documentation \u00b6 The documentation is divided into: Installation : install guide (no precompiled packages yet, coming soon), Tutorials : quickstart Python tutorial, Examples : gallery of screenshots and associated Python code, How to guides : advanced topics for expert users, explaining how to use C and Vulkan for making custom visuals and applications, Reference : comprehensive list of included colormaps, visuals, and graphics, C API reference : list of all publicly available C functions, Discussions : explanations, Vulkan crash course, and notes. Preliminary performance results \u00b6 scatter plot with 10M points: 250 FPS ( point visual) high-resolution 3D mesh with 10M triangles and 5M vertices: 400 FPS 1000 signals with 30K points each (30M vertices): 200 FPS GPU: 2019 NVIDIA GeForce RTX 2070 SUPER. Window size: 1024x768. Features \u00b6 High-quality antialiased 2D visuals : markers, paths, lines, text, polygons, and more (visuals originally implemented in Glumpy ) 3D visuals : meshes, surfaces, volumes Mixing 2D and 3D plots seamlessly in the same window ~150 colormaps included (from matplotlib, colorcet, MATLAB) High-level interactivity : pan & zoom, mouse arcball, first-person cameras Axes : ticks, grids, labels Subplots organized in a grid layout DPI-aware : partial support for high-resolution monitors GUIs integrated via the Dear ImGUI C++ library (Qt or other backends not required) Custom visuals , with custom shaders and/or custom data transformations Mouse picking Initial support for multiple canvases Initial builtin support for screencasts and video recording with ffmpeg (optional dependency) Initial support for offscreen rendering and CPU emulation via swiftshader Upcoming features: More visuals: arrows, triangulations, planar straight-line graphs (PSLG), histograms, areas, graphs... Further data transformations: logarithmic, polar, basic Earth coordinate systems for geographical data Colorbars 3D axes Better support of multiple GPUs Qt integration Continuous integration, more robust testing Long-term future (or shorter if there are community contributions): Support for other languages (Julia, R, MATLAB, Rust...) Jupyter notebook integration Web integration via WebGPU? Remote desktop integration? Credits and related projects \u00b6 Datoviz is developed primarily by Cyrille Rossant at the International Brain Laboratory . The logo was graciously created by Chiara Zini . Datoviz borrows heavily ideas and code from other projects. VisPy \u00b6 VisPy is a Python scientific visualization library created in 2013 by Luke Campagnola (developer of pyqtgraph ), Almar Klein (developer of visvis ), Nicolas Rougier (developer of glumpy ), and myself (Cyrille Rossant, developer of galry ). We joined forces to create a single library unifying all of our approaches, which proved to be challenging. There is today a community of users and projects based on VisPy ( napari ), and the library is currently being maintained by David Hoese, Eric Larson, and others. VisPy recently received funding from the Chan Zuckerberg Initiative to improve the documentation and knowledge base. VisPy is written entirely in Python and it is based on OpenGL, an almost 30 year old technology. Vulkan was first released in 2016 by the Khronos consortium and it can be seen, to some extent, as a successor to OpenGL. However, Vulkan is a lower-level library and it is harder to use. This is the price to pay to reach better GPU performance. Datoviz may be seen as a ground-up reincarnation of VisPy, with two fundamental differences: it is written in C rather than Python, and it uses Vulkan rather than OpenGL. The main advantages of C compared to Python are: ability to bind to any other language beyond Python; performance; possibility to use the Vulkan C API directly rather than via a wrapper. The main advantages of Vulkan compared to OpenGL are: modern API, more adapted to today's hardware; performance. However, it is more complex and less user-friendly. Datoviz abstracts a lot of that complexity away. Glumpy \u00b6 Glumpy, developed by Nicolas Rougier, provides efficient implementations of high-quality 2D visuals on the GPU , using algorithms from the antigrain geometry library. The GPU code of most 2D visuals in Datoviz comes directly from Glumpy. Dependencies and algorithms \u00b6 LunarG Vulkan SDK (mandatory) GLFW (mandatory) ffmpeg (optional), for making live screencasts libpng (optional), for making PNG screenshots glslang (optional), for compiling GLSL shaders to SPIR-V on the fly earcut (included), developed by Mapbox, for polygon triangulations triangle (included), developed by Jonathan Richard Shewchuk, for Delaunay triangulations extended Wilkinson algorithm (included) for tick placement Dear ImGUI (included) antigrain geometry ( GLSL implementation included) msdfgen : multi-channel signed distance field (to do: bundle as submodule?) An upcoming version will also have the following dependencies: freetype (optional) Related projects \u00b6 mayavi VTK napari vedo ipygany ipyvolume Makie.jl Glossary:","title":"Home"},{"location":"#datoviz-gpu-interactive-scientific-data-visualization-with-vulkan","text":"Datoviz is an open-source high-performance interactive scientific data visualization library leveraging the graphics processing unit ( GPU ) for speed, visual quality, and scalability. It supports both 2D and 3D rendering, as well as minimal graphical user interfaces (using the Dear ImGUI library ). Written in C , Datoviz has been designed from the group up for performance . It provides native Python bindings (based on Cython). Bindings to other languages could be developed thanks to community efforts (Julia, R, MATLAB, Rust, C#, and so on). Datoviz uses the Vulkan graphics API created by the Khronos consortium, successor of OpenGL. Supporting other modern graphics API, such as WebGPU, would constitute interesting developments. Datoviz is currently being developed mostly by Cyrille Rossant at the International Brain Laboratory , a consortium of neuroscience research labs around the world. Datoviz is at an early stage of development. The library is quite usable but evolves quickly. Datoviz has been tested on Linux, macOS (Intel), and to a lesser extent, Windows. It should work on most computers, with or without a discrete GPU (but with up-to-date graphics drivers). Many more features will come later and the documentation will be improved. Contributions are highly welcome!","title":"Datoviz: GPU interactive scientific data visualization with Vulkan"},{"location":"#screenshots","text":"Credits: mouse brain volume: Allen SDK . France: Natural Earth . Molecule: Crystal structure of S. pyogenes Cas9 from PDB (thanks to Eric for conversion to OBJ mesh). Earth: Pixabay . Raster plot: IBL. 3D human brain: Anneke Alkemade et al. 2020 , thanks to Pierre-Louis Bazin and Julia Huntenburg.","title":"Screenshots"},{"location":"#documentation","text":"The documentation is divided into: Installation : install guide (no precompiled packages yet, coming soon), Tutorials : quickstart Python tutorial, Examples : gallery of screenshots and associated Python code, How to guides : advanced topics for expert users, explaining how to use C and Vulkan for making custom visuals and applications, Reference : comprehensive list of included colormaps, visuals, and graphics, C API reference : list of all publicly available C functions, Discussions : explanations, Vulkan crash course, and notes.","title":"Documentation"},{"location":"#preliminary-performance-results","text":"scatter plot with 10M points: 250 FPS ( point visual) high-resolution 3D mesh with 10M triangles and 5M vertices: 400 FPS 1000 signals with 30K points each (30M vertices): 200 FPS GPU: 2019 NVIDIA GeForce RTX 2070 SUPER. Window size: 1024x768.","title":"Preliminary performance results"},{"location":"#features","text":"High-quality antialiased 2D visuals : markers, paths, lines, text, polygons, and more (visuals originally implemented in Glumpy ) 3D visuals : meshes, surfaces, volumes Mixing 2D and 3D plots seamlessly in the same window ~150 colormaps included (from matplotlib, colorcet, MATLAB) High-level interactivity : pan & zoom, mouse arcball, first-person cameras Axes : ticks, grids, labels Subplots organized in a grid layout DPI-aware : partial support for high-resolution monitors GUIs integrated via the Dear ImGUI C++ library (Qt or other backends not required) Custom visuals , with custom shaders and/or custom data transformations Mouse picking Initial support for multiple canvases Initial builtin support for screencasts and video recording with ffmpeg (optional dependency) Initial support for offscreen rendering and CPU emulation via swiftshader Upcoming features: More visuals: arrows, triangulations, planar straight-line graphs (PSLG), histograms, areas, graphs... Further data transformations: logarithmic, polar, basic Earth coordinate systems for geographical data Colorbars 3D axes Better support of multiple GPUs Qt integration Continuous integration, more robust testing Long-term future (or shorter if there are community contributions): Support for other languages (Julia, R, MATLAB, Rust...) Jupyter notebook integration Web integration via WebGPU? Remote desktop integration?","title":"Features"},{"location":"#credits-and-related-projects","text":"Datoviz is developed primarily by Cyrille Rossant at the International Brain Laboratory . The logo was graciously created by Chiara Zini . Datoviz borrows heavily ideas and code from other projects.","title":"Credits and related projects"},{"location":"#vispy","text":"VisPy is a Python scientific visualization library created in 2013 by Luke Campagnola (developer of pyqtgraph ), Almar Klein (developer of visvis ), Nicolas Rougier (developer of glumpy ), and myself (Cyrille Rossant, developer of galry ). We joined forces to create a single library unifying all of our approaches, which proved to be challenging. There is today a community of users and projects based on VisPy ( napari ), and the library is currently being maintained by David Hoese, Eric Larson, and others. VisPy recently received funding from the Chan Zuckerberg Initiative to improve the documentation and knowledge base. VisPy is written entirely in Python and it is based on OpenGL, an almost 30 year old technology. Vulkan was first released in 2016 by the Khronos consortium and it can be seen, to some extent, as a successor to OpenGL. However, Vulkan is a lower-level library and it is harder to use. This is the price to pay to reach better GPU performance. Datoviz may be seen as a ground-up reincarnation of VisPy, with two fundamental differences: it is written in C rather than Python, and it uses Vulkan rather than OpenGL. The main advantages of C compared to Python are: ability to bind to any other language beyond Python; performance; possibility to use the Vulkan C API directly rather than via a wrapper. The main advantages of Vulkan compared to OpenGL are: modern API, more adapted to today's hardware; performance. However, it is more complex and less user-friendly. Datoviz abstracts a lot of that complexity away.","title":"VisPy"},{"location":"#glumpy","text":"Glumpy, developed by Nicolas Rougier, provides efficient implementations of high-quality 2D visuals on the GPU , using algorithms from the antigrain geometry library. The GPU code of most 2D visuals in Datoviz comes directly from Glumpy.","title":"Glumpy"},{"location":"#dependencies-and-algorithms","text":"LunarG Vulkan SDK (mandatory) GLFW (mandatory) ffmpeg (optional), for making live screencasts libpng (optional), for making PNG screenshots glslang (optional), for compiling GLSL shaders to SPIR-V on the fly earcut (included), developed by Mapbox, for polygon triangulations triangle (included), developed by Jonathan Richard Shewchuk, for Delaunay triangulations extended Wilkinson algorithm (included) for tick placement Dear ImGUI (included) antigrain geometry ( GLSL implementation included) msdfgen : multi-channel signed distance field (to do: bundle as submodule?) An upcoming version will also have the following dependencies: freetype (optional)","title":"Dependencies and algorithms"},{"location":"#related-projects","text":"mayavi VTK napari vedo ipygany ipyvolume Makie.jl Glossary:","title":"Related projects"},{"location":"api/","text":"C API documentation \u00b6 Scene API Visual API Controller API GUI API Canvas API GPU API vklite API Misc API Enumerations","title":"Index"},{"location":"api/#c-api-documentation","text":"Scene API Visual API Controller API GUI API Canvas API GPU API vklite API Misc API Enumerations","title":"C API documentation"},{"location":"api/canvas/","text":"Canvas API \u00b6 Canvas \u00b6 dvz_canvas_commands() \u00b6 Create a set of Vulkan command buffers on a given GPU queue. DvzCommands * dvz_canvas_commands ( DvzCanvas * canvas , uint32_t queue_idx , uint32_t count ); Parameter Type Description canvas DvzCanvas* the canvas queue_idx uint32_t the index of the GPU queue within the GPU context count uint32_t number of command buffers to create returns DvzCommands* set of created command buffers dvz_canvas_clear_color() \u00b6 Change the background color of a canvas. void dvz_canvas_clear_color ( DvzCanvas * canvas , float red , float green , float blue ); Parameter Type Description canvas DvzCanvas* the canvas red float the red component, between 0 and 1 green float the green component, between 0 and 1 blue float the blue component, between 0 and 1 Note A command buffer refill will be triggered so as to record them again with the updated clear color value. dvz_canvas_size() \u00b6 Get the canvas size. void dvz_canvas_size ( DvzCanvas * canvas , DvzCanvasSizeType type , uvec2 size ); Parameter Type Description canvas DvzCanvas* the canvas type DvzCanvasSizeType the unit of the requested screen size size uvec2 the size vector filled by this function dvz_canvas_close_on_esc() \u00b6 Whether the canvas should close when Escape is pressed. void dvz_canvas_close_on_esc ( DvzCanvas * canvas , bool value ); Parameter Type Description canvas DvzCanvas* the canvas value bool the boolean value dvz_canvas_recreate() \u00b6 Recreate the canvas GPU resources and swapchain. void dvz_canvas_recreate ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas to recreate dvz_canvas_to_refill() \u00b6 Trigger a canvas refill at the next frame. void dvz_canvas_to_refill ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_canvas_to_close() \u00b6 Close the canvas at the next frame. void dvz_canvas_to_close ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_canvases_destroy() \u00b6 Destroy all canvases. void dvz_canvases_destroy ( DvzContainer * canvases ); Parameter Type Description canvases DvzContainer* the container with the canvases. Misc \u00b6 dvz_viewport_full() \u00b6 Get the viewport corresponding to the full canvas. DvzViewport dvz_viewport_full ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzViewport viewport dvz_viewport_default() \u00b6 Create a default viewport. DvzViewport dvz_viewport_default ( uint32_t width , uint32_t height ); Parameter Type Description width uint32_t the framebuffer width height uint32_t the framebuffer height returns DvzViewport viewport Event emitting \u00b6 dvz_event_mouse_press() \u00b6 Emit a mouse press event. void dvz_event_mouse_press ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_release() \u00b6 Emit a mouse release event. void dvz_event_mouse_release ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_move() \u00b6 Emit a mouse move event. void dvz_event_mouse_move ( DvzCanvas * canvas , vec2 pos , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the current mouse position, in pixels modifiers int flags with the active keyboard modifiers dvz_event_mouse_wheel() \u00b6 Emit a mouse wheel event. void dvz_event_mouse_wheel ( DvzCanvas * canvas , vec2 dir , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas dir vec2 the mouse wheel direction modifiers int flags with the active keyboard modifiers dvz_event_mouse_click() \u00b6 Emit a mouse click event. void dvz_event_mouse_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_double_click() \u00b6 Emit a mouse double-click event. void dvz_event_mouse_double_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the double-click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_drag() \u00b6 Emit a mouse drag event. void dvz_event_mouse_drag ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag start position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_mouse_drag_end() \u00b6 Emit a mouse drag end event. void dvz_event_mouse_drag_end ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag end position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers dvz_event_key_press() \u00b6 Emit a key press event. void dvz_event_key_press ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers dvz_event_key_release() \u00b6 Emit a key release event. void dvz_event_key_release ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers dvz_event_frame() \u00b6 Emit a frame event. void dvz_event_frame ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the frame index time double the current time interval double the interval since the last frame event Typically raised at every canvas frame. dvz_event_timer() \u00b6 Emit a timer event. void dvz_event_timer ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the timer event index time double the current time interval double the interval since the last timer event Screencast \u00b6 dvz_screencast() \u00b6 Prepare the canvas for a screencast. void dvz_screencast ( DvzCanvas * canvas , double interval , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas interval double screencast events interval has_alpha bool whether the screencast array is RGB or RGBA A screencast is a live record of one or several frames of the canvas during the interactive execution of the app. Creating a screencast is required for: - screenshots, - video records (requires ffmpeg) This command creates a host-coherent GPU image with the same size as the current framebuffer size. If the interval is non-zero, the canvas will raise periodic SCREENCAST events every interval seconds. The event payload will contain a pointer to the grabbed framebuffer image. dvz_screencast_destroy() \u00b6 Destroy the screencast. void dvz_screencast_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_screenshot() \u00b6 Make a screenshot. uint8_t * dvz_screenshot ( DvzCanvas * canvas , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas returns uint8_t* pointer to the 24-bit RGB framebuffer. This function creates a screencast if there isn't one already. It is implemented with hard synchronization commands so this command should not be used for creating many successive screenshots. For that, one should register a SCREENCAST event callback. Important The caller MUST free the output pointer. dvz_screenshot_file() \u00b6 Make a screenshot and save it to a PNG file. void dvz_screenshot_file ( DvzCanvas * canvas , char * png_path ); Parameter Type Description canvas DvzCanvas* the canvas png_path char* the path to the PNG file to create Note This function uses full GPU synchronization methods so it is relatively inefficient. More efficient methods are not yet implemented. dvz_canvas_video() \u00b6 Record a live screencast video of the canvas. void dvz_canvas_video ( DvzCanvas * canvas , int framerate , int bitrate , char * path , bool record ); Parameter Type Description canvas DvzCanvas* the canvas framerate int the framerate in images per second (30 recommended) bitrate int the bitrate, in bytes (10000000 for high quality) path char* path to the file (.mp4 extension recommended) record bool whether to start recording immediately or not This function should be run before calling dvz_app_run() . dvz_canvas_pause() \u00b6 Pause the live video screencast. void dvz_canvas_pause ( DvzCanvas * canvas , bool record ); Parameter Type Description canvas DvzCanvas* the canvas record bool whether to pause or continue the recording dvz_canvas_stop() \u00b6 Stop the live video screencast and save the file. void dvz_canvas_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas Internal event loop \u00b6 dvz_canvas_frame() \u00b6 Process a single frame in the event loop. void dvz_canvas_frame ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas This function probably never needs to be called directly, unless writing a custom backend. dvz_canvas_frame_submit() \u00b6 Submit the rendered frame to the swapchain system. void dvz_canvas_frame_submit ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas Internal event system \u00b6 dvz_event_callback() \u00b6 Register a callback for canvas events. void dvz_event_callback ( DvzCanvas * canvas , DvzEventType type , double param , DvzEventMode mode , DvzEventCallback callback , void * user_data ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type param double time interval for TIMER events, in seconds mode DvzEventMode whether the callback is sync or async callback DvzEventCallback the callback function user_data void* a pointer to arbitrary user data These user callbacks run either in the main thread ( sync callbacks) or in the background thread * ( async callbacks). Callbacks can access the DvzMouse and DvzKeyboard structures with the current state of the mouse and keyboard. Callback function signature: void(DvzCanvas*, DvzEvent) The event object has a field with the user-specified pointer user_data . dvz_event_pending() \u00b6 Return the number of pending events. int dvz_event_pending ( DvzCanvas * canvas , DvzEventType type ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type returns int number of pending events This is the number of events of the given type that are still being processed or pending in the queue. dvz_event_stop() \u00b6 Stop the background event loop. void dvz_event_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas This function sends a special \"closing\" event to the event loop, causing it to stop. dvz_mouse() \u00b6 Create the mouse object holding the current mouse state. DvzMouse dvz_mouse ( void ); | returns | DvzMouse | object | dvz_mouse_reset() \u00b6 Reset the mouse state. void dvz_mouse_reset ( DvzMouse * mouse ); Parameter Type Description mouse DvzMouse* the mouse object dvz_mouse_event() \u00b6 Emit a mouse event. void dvz_mouse_event ( DvzMouse * mouse , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description mouse DvzMouse* the mouse object canvas DvzCanvas* the canvas ev DvzEvent the mouse event dvz_mouse_local() \u00b6 Convert mouse coordinates from global to local. void dvz_mouse_local ( DvzMouse * mouse , DvzMouseLocal * mouse_local , DvzCanvas * canvas , DvzViewport viewport ); Parameter Type Description mouse DvzMouse* the mouse object mouse_local DvzMouseLocal* the mouse local object canvas DvzCanvas* the canvas viewport DvzViewport the viewport defining the local coordinates Global coordinates: in pixels, origin at the top-left corner of the window. Local coordinates: in normalize coordinates [-1, 1], origin at the center of a given viewport, taking viewport margins into account dvz_keyboard() \u00b6 Create the keyboard object holding the current keyboard state. DvzKeyboard dvz_keyboard ( void ); | returns | DvzKeyboard | object | dvz_keyboard_reset() \u00b6 Reset the keyboard state void dvz_keyboard_reset ( DvzKeyboard * keyboard ); | returns | void | object | dvz_keyboard_event() \u00b6 Emit a keyboard event. void dvz_keyboard_event ( DvzKeyboard * keyboard , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description keyboard DvzKeyboard* the keyboard object canvas DvzCanvas* the canvas ev DvzEvent the keyboard event","title":"Canvas API"},{"location":"api/canvas/#canvas-api","text":"","title":"Canvas API"},{"location":"api/canvas/#canvas","text":"","title":"Canvas"},{"location":"api/canvas/#dvz_canvas_commands","text":"Create a set of Vulkan command buffers on a given GPU queue. DvzCommands * dvz_canvas_commands ( DvzCanvas * canvas , uint32_t queue_idx , uint32_t count ); Parameter Type Description canvas DvzCanvas* the canvas queue_idx uint32_t the index of the GPU queue within the GPU context count uint32_t number of command buffers to create returns DvzCommands* set of created command buffers","title":"dvz_canvas_commands()"},{"location":"api/canvas/#dvz_canvas_clear_color","text":"Change the background color of a canvas. void dvz_canvas_clear_color ( DvzCanvas * canvas , float red , float green , float blue ); Parameter Type Description canvas DvzCanvas* the canvas red float the red component, between 0 and 1 green float the green component, between 0 and 1 blue float the blue component, between 0 and 1 Note A command buffer refill will be triggered so as to record them again with the updated clear color value.","title":"dvz_canvas_clear_color()"},{"location":"api/canvas/#dvz_canvas_size","text":"Get the canvas size. void dvz_canvas_size ( DvzCanvas * canvas , DvzCanvasSizeType type , uvec2 size ); Parameter Type Description canvas DvzCanvas* the canvas type DvzCanvasSizeType the unit of the requested screen size size uvec2 the size vector filled by this function","title":"dvz_canvas_size()"},{"location":"api/canvas/#dvz_canvas_close_on_esc","text":"Whether the canvas should close when Escape is pressed. void dvz_canvas_close_on_esc ( DvzCanvas * canvas , bool value ); Parameter Type Description canvas DvzCanvas* the canvas value bool the boolean value","title":"dvz_canvas_close_on_esc()"},{"location":"api/canvas/#dvz_canvas_recreate","text":"Recreate the canvas GPU resources and swapchain. void dvz_canvas_recreate ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas to recreate","title":"dvz_canvas_recreate()"},{"location":"api/canvas/#dvz_canvas_to_refill","text":"Trigger a canvas refill at the next frame. void dvz_canvas_to_refill ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_to_refill()"},{"location":"api/canvas/#dvz_canvas_to_close","text":"Close the canvas at the next frame. void dvz_canvas_to_close ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_to_close()"},{"location":"api/canvas/#dvz_canvases_destroy","text":"Destroy all canvases. void dvz_canvases_destroy ( DvzContainer * canvases ); Parameter Type Description canvases DvzContainer* the container with the canvases.","title":"dvz_canvases_destroy()"},{"location":"api/canvas/#misc","text":"","title":"Misc"},{"location":"api/canvas/#dvz_viewport_full","text":"Get the viewport corresponding to the full canvas. DvzViewport dvz_viewport_full ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzViewport viewport","title":"dvz_viewport_full()"},{"location":"api/canvas/#dvz_viewport_default","text":"Create a default viewport. DvzViewport dvz_viewport_default ( uint32_t width , uint32_t height ); Parameter Type Description width uint32_t the framebuffer width height uint32_t the framebuffer height returns DvzViewport viewport","title":"dvz_viewport_default()"},{"location":"api/canvas/#event-emitting","text":"","title":"Event emitting"},{"location":"api/canvas/#dvz_event_mouse_press","text":"Emit a mouse press event. void dvz_event_mouse_press ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_press()"},{"location":"api/canvas/#dvz_event_mouse_release","text":"Emit a mouse release event. void dvz_event_mouse_release ( DvzCanvas * canvas , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_release()"},{"location":"api/canvas/#dvz_event_mouse_move","text":"Emit a mouse move event. void dvz_event_mouse_move ( DvzCanvas * canvas , vec2 pos , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the current mouse position, in pixels modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_move()"},{"location":"api/canvas/#dvz_event_mouse_wheel","text":"Emit a mouse wheel event. void dvz_event_mouse_wheel ( DvzCanvas * canvas , vec2 dir , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas dir vec2 the mouse wheel direction modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_wheel()"},{"location":"api/canvas/#dvz_event_mouse_click","text":"Emit a mouse click event. void dvz_event_mouse_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_click()"},{"location":"api/canvas/#dvz_event_mouse_double_click","text":"Emit a mouse double-click event. void dvz_event_mouse_double_click ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the double-click position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_double_click()"},{"location":"api/canvas/#dvz_event_mouse_drag","text":"Emit a mouse drag event. void dvz_event_mouse_drag ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag start position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_drag()"},{"location":"api/canvas/#dvz_event_mouse_drag_end","text":"Emit a mouse drag end event. void dvz_event_mouse_drag_end ( DvzCanvas * canvas , vec2 pos , DvzMouseButton button , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas pos vec2 the drag end position button DvzMouseButton the mouse button modifiers int flags with the active keyboard modifiers","title":"dvz_event_mouse_drag_end()"},{"location":"api/canvas/#dvz_event_key_press","text":"Emit a key press event. void dvz_event_key_press ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers","title":"dvz_event_key_press()"},{"location":"api/canvas/#dvz_event_key_release","text":"Emit a key release event. void dvz_event_key_release ( DvzCanvas * canvas , DvzKeyCode key_code , int modifiers ); Parameter Type Description canvas DvzCanvas* the canvas key_code DvzKeyCode the key modifiers int flags with the active keyboard modifiers","title":"dvz_event_key_release()"},{"location":"api/canvas/#dvz_event_frame","text":"Emit a frame event. void dvz_event_frame ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the frame index time double the current time interval double the interval since the last frame event Typically raised at every canvas frame.","title":"dvz_event_frame()"},{"location":"api/canvas/#dvz_event_timer","text":"Emit a timer event. void dvz_event_timer ( DvzCanvas * canvas , uint64_t idx , double time , double interval ); Parameter Type Description canvas DvzCanvas* the canvas idx uint64_t the timer event index time double the current time interval double the interval since the last timer event","title":"dvz_event_timer()"},{"location":"api/canvas/#screencast","text":"","title":"Screencast"},{"location":"api/canvas/#dvz_screencast","text":"Prepare the canvas for a screencast. void dvz_screencast ( DvzCanvas * canvas , double interval , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas interval double screencast events interval has_alpha bool whether the screencast array is RGB or RGBA A screencast is a live record of one or several frames of the canvas during the interactive execution of the app. Creating a screencast is required for: - screenshots, - video records (requires ffmpeg) This command creates a host-coherent GPU image with the same size as the current framebuffer size. If the interval is non-zero, the canvas will raise periodic SCREENCAST events every interval seconds. The event payload will contain a pointer to the grabbed framebuffer image.","title":"dvz_screencast()"},{"location":"api/canvas/#dvz_screencast_destroy","text":"Destroy the screencast. void dvz_screencast_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_screencast_destroy()"},{"location":"api/canvas/#dvz_screenshot","text":"Make a screenshot. uint8_t * dvz_screenshot ( DvzCanvas * canvas , bool has_alpha ); Parameter Type Description canvas DvzCanvas* the canvas returns uint8_t* pointer to the 24-bit RGB framebuffer. This function creates a screencast if there isn't one already. It is implemented with hard synchronization commands so this command should not be used for creating many successive screenshots. For that, one should register a SCREENCAST event callback. Important The caller MUST free the output pointer.","title":"dvz_screenshot()"},{"location":"api/canvas/#dvz_screenshot_file","text":"Make a screenshot and save it to a PNG file. void dvz_screenshot_file ( DvzCanvas * canvas , char * png_path ); Parameter Type Description canvas DvzCanvas* the canvas png_path char* the path to the PNG file to create Note This function uses full GPU synchronization methods so it is relatively inefficient. More efficient methods are not yet implemented.","title":"dvz_screenshot_file()"},{"location":"api/canvas/#dvz_canvas_video","text":"Record a live screencast video of the canvas. void dvz_canvas_video ( DvzCanvas * canvas , int framerate , int bitrate , char * path , bool record ); Parameter Type Description canvas DvzCanvas* the canvas framerate int the framerate in images per second (30 recommended) bitrate int the bitrate, in bytes (10000000 for high quality) path char* path to the file (.mp4 extension recommended) record bool whether to start recording immediately or not This function should be run before calling dvz_app_run() .","title":"dvz_canvas_video()"},{"location":"api/canvas/#dvz_canvas_pause","text":"Pause the live video screencast. void dvz_canvas_pause ( DvzCanvas * canvas , bool record ); Parameter Type Description canvas DvzCanvas* the canvas record bool whether to pause or continue the recording","title":"dvz_canvas_pause()"},{"location":"api/canvas/#dvz_canvas_stop","text":"Stop the live video screencast and save the file. void dvz_canvas_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_stop()"},{"location":"api/canvas/#internal-event-loop","text":"","title":"Internal event loop"},{"location":"api/canvas/#dvz_canvas_frame","text":"Process a single frame in the event loop. void dvz_canvas_frame ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas This function probably never needs to be called directly, unless writing a custom backend.","title":"dvz_canvas_frame()"},{"location":"api/canvas/#dvz_canvas_frame_submit","text":"Submit the rendered frame to the swapchain system. void dvz_canvas_frame_submit ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_frame_submit()"},{"location":"api/canvas/#internal-event-system","text":"","title":"Internal event system"},{"location":"api/canvas/#dvz_event_callback","text":"Register a callback for canvas events. void dvz_event_callback ( DvzCanvas * canvas , DvzEventType type , double param , DvzEventMode mode , DvzEventCallback callback , void * user_data ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type param double time interval for TIMER events, in seconds mode DvzEventMode whether the callback is sync or async callback DvzEventCallback the callback function user_data void* a pointer to arbitrary user data These user callbacks run either in the main thread ( sync callbacks) or in the background thread * ( async callbacks). Callbacks can access the DvzMouse and DvzKeyboard structures with the current state of the mouse and keyboard. Callback function signature: void(DvzCanvas*, DvzEvent) The event object has a field with the user-specified pointer user_data .","title":"dvz_event_callback()"},{"location":"api/canvas/#dvz_event_pending","text":"Return the number of pending events. int dvz_event_pending ( DvzCanvas * canvas , DvzEventType type ); Parameter Type Description canvas DvzCanvas* the canvas type DvzEventType the event type returns int number of pending events This is the number of events of the given type that are still being processed or pending in the queue.","title":"dvz_event_pending()"},{"location":"api/canvas/#dvz_event_stop","text":"Stop the background event loop. void dvz_event_stop ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas This function sends a special \"closing\" event to the event loop, causing it to stop.","title":"dvz_event_stop()"},{"location":"api/canvas/#dvz_mouse","text":"Create the mouse object holding the current mouse state. DvzMouse dvz_mouse ( void ); | returns | DvzMouse | object |","title":"dvz_mouse()"},{"location":"api/canvas/#dvz_mouse_reset","text":"Reset the mouse state. void dvz_mouse_reset ( DvzMouse * mouse ); Parameter Type Description mouse DvzMouse* the mouse object","title":"dvz_mouse_reset()"},{"location":"api/canvas/#dvz_mouse_event","text":"Emit a mouse event. void dvz_mouse_event ( DvzMouse * mouse , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description mouse DvzMouse* the mouse object canvas DvzCanvas* the canvas ev DvzEvent the mouse event","title":"dvz_mouse_event()"},{"location":"api/canvas/#dvz_mouse_local","text":"Convert mouse coordinates from global to local. void dvz_mouse_local ( DvzMouse * mouse , DvzMouseLocal * mouse_local , DvzCanvas * canvas , DvzViewport viewport ); Parameter Type Description mouse DvzMouse* the mouse object mouse_local DvzMouseLocal* the mouse local object canvas DvzCanvas* the canvas viewport DvzViewport the viewport defining the local coordinates Global coordinates: in pixels, origin at the top-left corner of the window. Local coordinates: in normalize coordinates [-1, 1], origin at the center of a given viewport, taking viewport margins into account","title":"dvz_mouse_local()"},{"location":"api/canvas/#dvz_keyboard","text":"Create the keyboard object holding the current keyboard state. DvzKeyboard dvz_keyboard ( void ); | returns | DvzKeyboard | object |","title":"dvz_keyboard()"},{"location":"api/canvas/#dvz_keyboard_reset","text":"Reset the keyboard state void dvz_keyboard_reset ( DvzKeyboard * keyboard ); | returns | void | object |","title":"dvz_keyboard_reset()"},{"location":"api/canvas/#dvz_keyboard_event","text":"Emit a keyboard event. void dvz_keyboard_event ( DvzKeyboard * keyboard , DvzCanvas * canvas , DvzEvent ev ); Parameter Type Description keyboard DvzKeyboard* the keyboard object canvas DvzCanvas* the canvas ev DvzEvent the keyboard event","title":"dvz_keyboard_event()"},{"location":"api/controller/","text":"Controller API \u00b6 Controller utilities \u00b6 dvz_camera_pos() \u00b6 Set the camera position. void dvz_camera_pos ( DvzPanel * panel , vec3 pos ); Parameter Type Description panel DvzPanel* the panel pos vec3 the position in scene coordinates dvz_camera_look() \u00b6 Set the camera center position (the position the camera points to). void dvz_camera_look ( DvzPanel * panel , vec3 center ); Parameter Type Description panel DvzPanel* the panel center vec3 the center position dvz_arcball_rotate() \u00b6 Set the arcball rotation. void dvz_arcball_rotate ( DvzPanel * panel , float angle , vec3 axis ); Parameter Type Description panel DvzPanel* the panel angle float the rotation angle axis vec3 the rotation angle dvz_mvp_camera() \u00b6 Set up a 3D camera on a Model-View-Projection (MVP) object. void dvz_mvp_camera ( DvzViewport viewport , vec3 eye , vec3 center , vec2 near_far , DvzMVP * mvp ); Parameter Type Description viewport DvzViewport the viewport eye vec3 the camera position in scene coordinates center vec3 the position the camera points to near_far vec2 the near and far values for the perspective matrix mvp DvzMVP* a pointer to an MVP object Internal controller \u00b6 dvz_controller() \u00b6 Create a custom controller. DvzController dvz_controller ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzController controller structure dvz_controller_visual() \u00b6 Add a visual to a controller. void dvz_controller_visual ( DvzController * controller , DvzVisual * visual ); Parameter Type Description controller DvzController* the controller visual DvzVisual* the visual dvz_controller_interact() \u00b6 Add an interact to a controller. void dvz_controller_interact ( DvzController * controller , DvzInteractType type ); Parameter Type Description controller DvzController* the controller interact None the interact dvz_controller_callback() \u00b6 Specify a controller frame callback. void dvz_controller_callback ( DvzController * controller , DvzControllerCallback callback ); Parameter Type Description controller DvzController* the controller callback DvzControllerCallback the callback Callback signature: void(DvzController* controller, DvzEvent ev); dvz_controller_update() \u00b6 Update a controller. void dvz_controller_update ( DvzController * controller ); Parameter Type Description controller DvzController* the controller Not yet implemented dvz_controller_destroy() \u00b6 Destroy a controller. void dvz_controller_destroy ( DvzController * controller ); Parameter Type Description controller DvzController* the controller dvz_controller_builtin() \u00b6 Create a builtin controller. DvzController dvz_controller_builtin ( DvzPanel * panel , DvzControllerType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzControllerType the controller type flags int flags for the builtin controller returns DvzController controller Transform \u00b6 dvz_transform_pos() \u00b6 Apply a CPU builtin transformation on position data. void dvz_transform_pos ( DvzDataCoords coords , DvzArray * pos_in , DvzArray * pos_out , bool inverse ); Parameter Type Description coords DvzDataCoords the data coordinate system and bounds pos_in DvzArray* input array of dvec3 values pos_out DvzArray* output array of dvec3 values inverse bool whether to use the inverse or forward transformation dvz_transform() \u00b6 Convert a 3D position from a coordinate system to another. void dvz_transform ( DvzPanel * panel , DvzCDS source , dvec3 pos_in , DvzCDS target , dvec3 pos_out ); Parameter Type Description panel DvzPanel* the panel source DvzCDS the source coordinate system in None the input position target DvzCDS the target coordinate system out None the output (transformed) position","title":"Controller API"},{"location":"api/controller/#controller-api","text":"","title":"Controller API"},{"location":"api/controller/#controller-utilities","text":"","title":"Controller utilities"},{"location":"api/controller/#dvz_camera_pos","text":"Set the camera position. void dvz_camera_pos ( DvzPanel * panel , vec3 pos ); Parameter Type Description panel DvzPanel* the panel pos vec3 the position in scene coordinates","title":"dvz_camera_pos()"},{"location":"api/controller/#dvz_camera_look","text":"Set the camera center position (the position the camera points to). void dvz_camera_look ( DvzPanel * panel , vec3 center ); Parameter Type Description panel DvzPanel* the panel center vec3 the center position","title":"dvz_camera_look()"},{"location":"api/controller/#dvz_arcball_rotate","text":"Set the arcball rotation. void dvz_arcball_rotate ( DvzPanel * panel , float angle , vec3 axis ); Parameter Type Description panel DvzPanel* the panel angle float the rotation angle axis vec3 the rotation angle","title":"dvz_arcball_rotate()"},{"location":"api/controller/#dvz_mvp_camera","text":"Set up a 3D camera on a Model-View-Projection (MVP) object. void dvz_mvp_camera ( DvzViewport viewport , vec3 eye , vec3 center , vec2 near_far , DvzMVP * mvp ); Parameter Type Description viewport DvzViewport the viewport eye vec3 the camera position in scene coordinates center vec3 the position the camera points to near_far vec2 the near and far values for the perspective matrix mvp DvzMVP* a pointer to an MVP object","title":"dvz_mvp_camera()"},{"location":"api/controller/#internal-controller","text":"","title":"Internal controller"},{"location":"api/controller/#dvz_controller","text":"Create a custom controller. DvzController dvz_controller ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzController controller structure","title":"dvz_controller()"},{"location":"api/controller/#dvz_controller_visual","text":"Add a visual to a controller. void dvz_controller_visual ( DvzController * controller , DvzVisual * visual ); Parameter Type Description controller DvzController* the controller visual DvzVisual* the visual","title":"dvz_controller_visual()"},{"location":"api/controller/#dvz_controller_interact","text":"Add an interact to a controller. void dvz_controller_interact ( DvzController * controller , DvzInteractType type ); Parameter Type Description controller DvzController* the controller interact None the interact","title":"dvz_controller_interact()"},{"location":"api/controller/#dvz_controller_callback","text":"Specify a controller frame callback. void dvz_controller_callback ( DvzController * controller , DvzControllerCallback callback ); Parameter Type Description controller DvzController* the controller callback DvzControllerCallback the callback Callback signature: void(DvzController* controller, DvzEvent ev);","title":"dvz_controller_callback()"},{"location":"api/controller/#dvz_controller_update","text":"Update a controller. void dvz_controller_update ( DvzController * controller ); Parameter Type Description controller DvzController* the controller Not yet implemented","title":"dvz_controller_update()"},{"location":"api/controller/#dvz_controller_destroy","text":"Destroy a controller. void dvz_controller_destroy ( DvzController * controller ); Parameter Type Description controller DvzController* the controller","title":"dvz_controller_destroy()"},{"location":"api/controller/#dvz_controller_builtin","text":"Create a builtin controller. DvzController dvz_controller_builtin ( DvzPanel * panel , DvzControllerType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzControllerType the controller type flags int flags for the builtin controller returns DvzController controller","title":"dvz_controller_builtin()"},{"location":"api/controller/#transform","text":"","title":"Transform"},{"location":"api/controller/#dvz_transform_pos","text":"Apply a CPU builtin transformation on position data. void dvz_transform_pos ( DvzDataCoords coords , DvzArray * pos_in , DvzArray * pos_out , bool inverse ); Parameter Type Description coords DvzDataCoords the data coordinate system and bounds pos_in DvzArray* input array of dvec3 values pos_out DvzArray* output array of dvec3 values inverse bool whether to use the inverse or forward transformation","title":"dvz_transform_pos()"},{"location":"api/controller/#dvz_transform","text":"Convert a 3D position from a coordinate system to another. void dvz_transform ( DvzPanel * panel , DvzCDS source , dvec3 pos_in , DvzCDS target , dvec3 pos_out ); Parameter Type Description panel DvzPanel* the panel source DvzCDS the source coordinate system in None the input position target DvzCDS the target coordinate system out None the output (transformed) position","title":"dvz_transform()"},{"location":"api/enums/","text":"Enumerations \u00b6 Scene \u00b6 DvzControllerType \u00b6 Name Value DVZ_CONTROLLER_NONE 0 DVZ_CONTROLLER_PANZOOM 1 DVZ_CONTROLLER_AXES_2D 2 DVZ_CONTROLLER_ARCBALL 3 DVZ_CONTROLLER_CAMERA 4 DVZ_CONTROLLER_AXES_3D 5 Visuals \u00b6 DvzMarkerType \u00b6 Name Value DVZ_MARKER_DISC 0 DVZ_MARKER_ASTERISK 1 DVZ_MARKER_CHEVRON 2 DVZ_MARKER_CLOVER 3 DVZ_MARKER_CLUB 4 DVZ_MARKER_CROSS 5 DVZ_MARKER_DIAMOND 6 DVZ_MARKER_ARROW 7 DVZ_MARKER_ELLIPSE 8 DVZ_MARKER_HBAR 9 DVZ_MARKER_HEART 10 DVZ_MARKER_INFINITY 11 DVZ_MARKER_PIN 12 DVZ_MARKER_RING 13 DVZ_MARKER_SPADE 14 DVZ_MARKER_SQUARE 15 DVZ_MARKER_TAG 16 DVZ_MARKER_TRIANGLE 17 DVZ_MARKER_VBAR 18 DVZ_MARKER_COUNT 19 DvzJoinType \u00b6 Name Value DVZ_JOIN_SQUARE false DVZ_JOIN_ROUND true DvzCapType \u00b6 Name Value DVZ_CAP_TYPE_NONE 0 DVZ_CAP_ROUND 1 DVZ_CAP_TRIANGLE_IN 2 DVZ_CAP_TRIANGLE_OUT 3 DVZ_CAP_SQUARE 4 DVZ_CAP_BUTT 5 DVZ_CAP_COUNT 6 DvzPathTopology \u00b6 Name Value DVZ_PATH_OPEN 0 DVZ_PATH_CLOSED 1 Miscellaneous \u00b6 DvzDataType \u00b6 Name Value DVZ_DTYPE_NONE 0 DVZ_DTYPE_CUSTOM 1 DVZ_DTYPE_STR 2 DVZ_DTYPE_CHAR 3 DVZ_DTYPE_CVEC2 4 DVZ_DTYPE_CVEC3 5 DVZ_DTYPE_CVEC4 6 DVZ_DTYPE_USHORT 7 DVZ_DTYPE_USVEC2 8 DVZ_DTYPE_USVEC3 9 DVZ_DTYPE_USVEC4 10 DVZ_DTYPE_SHORT 11 DVZ_DTYPE_SVEC2 12 DVZ_DTYPE_SVEC3 13 DVZ_DTYPE_SVEC4 14 DVZ_DTYPE_UINT 15 DVZ_DTYPE_UVEC2 16 DVZ_DTYPE_UVEC3 17 DVZ_DTYPE_UVEC4 18 DVZ_DTYPE_INT 19 DVZ_DTYPE_IVEC2 20 DVZ_DTYPE_IVEC3 21 DVZ_DTYPE_IVEC4 22 DVZ_DTYPE_FLOAT 23 DVZ_DTYPE_VEC2 24 DVZ_DTYPE_VEC3 25 DVZ_DTYPE_VEC4 26 DVZ_DTYPE_DOUBLE 27 DVZ_DTYPE_DVEC2 28 DVZ_DTYPE_DVEC3 29 DVZ_DTYPE_DVEC4 30 DVZ_DTYPE_MAT2 31 DVZ_DTYPE_MAT3 32 DVZ_DTYPE_MAT4 33","title":"Enumerations"},{"location":"api/enums/#enumerations","text":"","title":"Enumerations"},{"location":"api/enums/#scene","text":"","title":"Scene"},{"location":"api/enums/#dvzcontrollertype","text":"Name Value DVZ_CONTROLLER_NONE 0 DVZ_CONTROLLER_PANZOOM 1 DVZ_CONTROLLER_AXES_2D 2 DVZ_CONTROLLER_ARCBALL 3 DVZ_CONTROLLER_CAMERA 4 DVZ_CONTROLLER_AXES_3D 5","title":"DvzControllerType"},{"location":"api/enums/#visuals","text":"","title":"Visuals"},{"location":"api/enums/#dvzmarkertype","text":"Name Value DVZ_MARKER_DISC 0 DVZ_MARKER_ASTERISK 1 DVZ_MARKER_CHEVRON 2 DVZ_MARKER_CLOVER 3 DVZ_MARKER_CLUB 4 DVZ_MARKER_CROSS 5 DVZ_MARKER_DIAMOND 6 DVZ_MARKER_ARROW 7 DVZ_MARKER_ELLIPSE 8 DVZ_MARKER_HBAR 9 DVZ_MARKER_HEART 10 DVZ_MARKER_INFINITY 11 DVZ_MARKER_PIN 12 DVZ_MARKER_RING 13 DVZ_MARKER_SPADE 14 DVZ_MARKER_SQUARE 15 DVZ_MARKER_TAG 16 DVZ_MARKER_TRIANGLE 17 DVZ_MARKER_VBAR 18 DVZ_MARKER_COUNT 19","title":"DvzMarkerType"},{"location":"api/enums/#dvzjointype","text":"Name Value DVZ_JOIN_SQUARE false DVZ_JOIN_ROUND true","title":"DvzJoinType"},{"location":"api/enums/#dvzcaptype","text":"Name Value DVZ_CAP_TYPE_NONE 0 DVZ_CAP_ROUND 1 DVZ_CAP_TRIANGLE_IN 2 DVZ_CAP_TRIANGLE_OUT 3 DVZ_CAP_SQUARE 4 DVZ_CAP_BUTT 5 DVZ_CAP_COUNT 6","title":"DvzCapType"},{"location":"api/enums/#dvzpathtopology","text":"Name Value DVZ_PATH_OPEN 0 DVZ_PATH_CLOSED 1","title":"DvzPathTopology"},{"location":"api/enums/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"api/enums/#dvzdatatype","text":"Name Value DVZ_DTYPE_NONE 0 DVZ_DTYPE_CUSTOM 1 DVZ_DTYPE_STR 2 DVZ_DTYPE_CHAR 3 DVZ_DTYPE_CVEC2 4 DVZ_DTYPE_CVEC3 5 DVZ_DTYPE_CVEC4 6 DVZ_DTYPE_USHORT 7 DVZ_DTYPE_USVEC2 8 DVZ_DTYPE_USVEC3 9 DVZ_DTYPE_USVEC4 10 DVZ_DTYPE_SHORT 11 DVZ_DTYPE_SVEC2 12 DVZ_DTYPE_SVEC3 13 DVZ_DTYPE_SVEC4 14 DVZ_DTYPE_UINT 15 DVZ_DTYPE_UVEC2 16 DVZ_DTYPE_UVEC3 17 DVZ_DTYPE_UVEC4 18 DVZ_DTYPE_INT 19 DVZ_DTYPE_IVEC2 20 DVZ_DTYPE_IVEC3 21 DVZ_DTYPE_IVEC4 22 DVZ_DTYPE_FLOAT 23 DVZ_DTYPE_VEC2 24 DVZ_DTYPE_VEC3 25 DVZ_DTYPE_VEC4 26 DVZ_DTYPE_DOUBLE 27 DVZ_DTYPE_DVEC2 28 DVZ_DTYPE_DVEC3 29 DVZ_DTYPE_DVEC4 30 DVZ_DTYPE_MAT2 31 DVZ_DTYPE_MAT3 32 DVZ_DTYPE_MAT4 33","title":"DvzDataType"},{"location":"api/gpu/","text":"GPU context and objects \u00b6 Context \u00b6 dvz_context() \u00b6 Create a context associated to a GPU. DvzContext * dvz_context ( DvzGpu * gpu , DvzWindow * window ); Parameter Type Description gpu DvzGpu* the GPU window DvzWindow* the window with the surface attached to the GPU dvz_context_reset() \u00b6 Destroy all GPU resources in a GPU context. void dvz_context_reset ( DvzContext * context ); Parameter Type Description context DvzContext* the context dvz_context_destroy() \u00b6 Destroy a context. void dvz_context_destroy ( DvzContext * context ); Parameter Type Description context DvzContext* the context Buffers \u00b6 dvz_ctx_buffers() \u00b6 Allocate one of several buffer regions on the GPU. DvzBufferRegions dvz_ctx_buffers ( DvzContext * context , DvzBufferType buffer_type , uint32_t buffer_count , VkDeviceSize size ); Parameter Type Description context DvzContext* the context buffer_type DvzBufferType the type of buffer to allocate the regions on buffer_count uint32_t the number of buffer regions to allocate size VkDeviceSize the size of each region to allocate, in bytes dvz_ctx_buffers_resize() \u00b6 Resize a set of buffer regions. void dvz_ctx_buffers_resize ( DvzContext * context , DvzBufferRegions * br , VkDeviceSize new_size ); Parameter Type Description context DvzContext* the context br DvzBufferRegions* the buffer regions to resize new_size VkDeviceSize the new size of each buffer region, in bytes Textures \u00b6 dvz_ctx_texture() \u00b6 Create a new GPU texture. DvzTexture * dvz_ctx_texture ( DvzContext * context , uint32_t dims , uvec3 size , VkFormat format ); Parameter Type Description context DvzContext* the context dims uint32_t the number of dimensions of the texture (1, 2, or 3) size uvec3 the width, height, and depth format VkFormat the format of each pixel dvz_texture_resize() \u00b6 Resize a texture. void dvz_texture_resize ( DvzTexture * texture , uvec3 size ); Parameter Type Description texture DvzTexture* the texture size uvec3 the new size (width, height, depth) Warning This function will delete the texture data. dvz_texture_filter() \u00b6 Set the texture filter. void dvz_texture_filter ( DvzTexture * texture , DvzFilterType type , VkFilter filter ); Parameter Type Description texture DvzTexture* the texture type DvzFilterType the filter type filter VkFilter the filter dvz_texture_address_mode() \u00b6 Set the texture address mode. void dvz_texture_address_mode ( DvzTexture * texture , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description texture DvzTexture* the texture axis DvzTextureAxis the axis address_mode VkSamplerAddressMode the address mode dvz_texture_upload() \u00b6 Upload data to a GPU texture. void dvz_texture_upload ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to update size VkDeviceSize size of the data to upload, in bytes data void* pointer to the data to upload Note This function should not be used to update a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead. dvz_texture_download() \u00b6 Download a texture from the GPU to the CPU. void dvz_texture_download ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to download size VkDeviceSize size of the data to download, in bytes data void* pointer to the buffer to download to (should be already allocated) Note This function should not be used to download from a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead. dvz_texture_copy() \u00b6 Copy part of a texture to another texture. void dvz_texture_copy ( DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape ); Parameter Type Description src DvzTexture* the source texture src_offset uvec3 offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 offset within the target texture shape uvec3 shape of the part of the texture to copy This function does not involve CPU-GPU data transfers. dvz_texture_destroy() \u00b6 Destroy a texture. void dvz_texture_destroy ( DvzTexture * texture ); Parameter Type Description texture DvzTexture* the texture Compute pipeline \u00b6 dvz_ctx_compute() \u00b6 Create a new compute pipeline. DvzCompute * dvz_ctx_compute ( DvzContext * context , char * shader_path ); Parameter Type Description context DvzContext* the context shader_path char* path to the .spirv file containing the compute shader Data transfers \u00b6 dvz_upload_buffers() \u00b6 Upload data to 1 or N buffer regions on the GPU while the app event loop is running. void dvz_upload_buffers ( DvzCanvas * canvas , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to the data to upload to the GPU dvz_download_buffers() \u00b6 Download data from a buffer region to the CPU while the app event loop is running. void dvz_download_buffers ( DvzCanvas * canvas , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to a buffer already allocated to contain size bytes dvz_copy_buffers() \u00b6 Copy data between two GPU buffer regions. void dvz_copy_buffers ( DvzCanvas * canvas , DvzBufferRegions src , VkDeviceSize src_offset , DvzBufferRegions dst , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description canvas DvzCanvas* the canvas src DvzBufferRegions the buffer region to copy from src_offset VkDeviceSize the offset within the source buffer region dst DvzBufferRegions the buffer region to copy to dst_offset VkDeviceSize the offset within the target buffer region size VkDeviceSize the size of the data to copy This function does not involve GPU-CPU data transfers. dvz_upload_texture() \u00b6 Upload data to a texture. void dvz_upload_texture ( DvzCanvas * canvas , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas texture DvzTexture* the texture to update offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the uploaded data, in bytes data void* pointer to the data to upload to the GPU dvz_download_texture() \u00b6 Download data from a texture. void dvz_download_texture ( DvzCanvas * canvas , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas texture DvzTexture* the texture to download from offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the downloaded data, in bytes data void* pointer to the buffer that will hold the downloaded data dvz_copy_texture() \u00b6 Copy part of a texture to another. void dvz_copy_texture ( DvzCanvas * canvas , DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape , VkDeviceSize size ); Parameter Type Description canvas DvzCanvas* the canvas src DvzTexture* the source texture src_offset uvec3 the offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 the offset within the target texture shape uvec3 the shape of the part of the texture to copy size VkDeviceSize the corresponding size of that part, in bytes This function does not involve GPU-CPU data transfers. dvz_process_transfers() \u00b6 Process the pending transfers. void dvz_process_transfers ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas br None the buffer regions to update offset None the offset within the buffer regions, in bytes size None the size of the data to upload, in bytes data None pointer to the data to upload to the GPU When the event loop is running, all transfers are enqueued in a queue rather than executed directly. The reason is that proper synchronization is required in order to avoid modifying GPU objects while they are being used for rendering. The transfer processing function is called at a deterministic time within the main event loop.","title":"GPU API"},{"location":"api/gpu/#gpu-context-and-objects","text":"","title":"GPU context and objects"},{"location":"api/gpu/#context","text":"","title":"Context"},{"location":"api/gpu/#dvz_context","text":"Create a context associated to a GPU. DvzContext * dvz_context ( DvzGpu * gpu , DvzWindow * window ); Parameter Type Description gpu DvzGpu* the GPU window DvzWindow* the window with the surface attached to the GPU","title":"dvz_context()"},{"location":"api/gpu/#dvz_context_reset","text":"Destroy all GPU resources in a GPU context. void dvz_context_reset ( DvzContext * context ); Parameter Type Description context DvzContext* the context","title":"dvz_context_reset()"},{"location":"api/gpu/#dvz_context_destroy","text":"Destroy a context. void dvz_context_destroy ( DvzContext * context ); Parameter Type Description context DvzContext* the context","title":"dvz_context_destroy()"},{"location":"api/gpu/#buffers","text":"","title":"Buffers"},{"location":"api/gpu/#dvz_ctx_buffers","text":"Allocate one of several buffer regions on the GPU. DvzBufferRegions dvz_ctx_buffers ( DvzContext * context , DvzBufferType buffer_type , uint32_t buffer_count , VkDeviceSize size ); Parameter Type Description context DvzContext* the context buffer_type DvzBufferType the type of buffer to allocate the regions on buffer_count uint32_t the number of buffer regions to allocate size VkDeviceSize the size of each region to allocate, in bytes","title":"dvz_ctx_buffers()"},{"location":"api/gpu/#dvz_ctx_buffers_resize","text":"Resize a set of buffer regions. void dvz_ctx_buffers_resize ( DvzContext * context , DvzBufferRegions * br , VkDeviceSize new_size ); Parameter Type Description context DvzContext* the context br DvzBufferRegions* the buffer regions to resize new_size VkDeviceSize the new size of each buffer region, in bytes","title":"dvz_ctx_buffers_resize()"},{"location":"api/gpu/#textures","text":"","title":"Textures"},{"location":"api/gpu/#dvz_ctx_texture","text":"Create a new GPU texture. DvzTexture * dvz_ctx_texture ( DvzContext * context , uint32_t dims , uvec3 size , VkFormat format ); Parameter Type Description context DvzContext* the context dims uint32_t the number of dimensions of the texture (1, 2, or 3) size uvec3 the width, height, and depth format VkFormat the format of each pixel","title":"dvz_ctx_texture()"},{"location":"api/gpu/#dvz_texture_resize","text":"Resize a texture. void dvz_texture_resize ( DvzTexture * texture , uvec3 size ); Parameter Type Description texture DvzTexture* the texture size uvec3 the new size (width, height, depth) Warning This function will delete the texture data.","title":"dvz_texture_resize()"},{"location":"api/gpu/#dvz_texture_filter","text":"Set the texture filter. void dvz_texture_filter ( DvzTexture * texture , DvzFilterType type , VkFilter filter ); Parameter Type Description texture DvzTexture* the texture type DvzFilterType the filter type filter VkFilter the filter","title":"dvz_texture_filter()"},{"location":"api/gpu/#dvz_texture_address_mode","text":"Set the texture address mode. void dvz_texture_address_mode ( DvzTexture * texture , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description texture DvzTexture* the texture axis DvzTextureAxis the axis address_mode VkSamplerAddressMode the address mode","title":"dvz_texture_address_mode()"},{"location":"api/gpu/#dvz_texture_upload","text":"Upload data to a GPU texture. void dvz_texture_upload ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to update size VkDeviceSize size of the data to upload, in bytes data void* pointer to the data to upload Note This function should not be used to update a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead.","title":"dvz_texture_upload()"},{"location":"api/gpu/#dvz_texture_download","text":"Download a texture from the GPU to the CPU. void dvz_texture_download ( DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description texture DvzTexture* the texture offset uvec3 offset within the texture shape uvec3 shape of the part of the texture to download size VkDeviceSize size of the data to download, in bytes data void* pointer to the buffer to download to (should be already allocated) Note This function should not be used to download from a texture that is being used for rendering in the main event loop, otherwise full GPU synchronization needs to be done. Look at the Transfers API instead.","title":"dvz_texture_download()"},{"location":"api/gpu/#dvz_texture_copy","text":"Copy part of a texture to another texture. void dvz_texture_copy ( DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape ); Parameter Type Description src DvzTexture* the source texture src_offset uvec3 offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 offset within the target texture shape uvec3 shape of the part of the texture to copy This function does not involve CPU-GPU data transfers.","title":"dvz_texture_copy()"},{"location":"api/gpu/#dvz_texture_destroy","text":"Destroy a texture. void dvz_texture_destroy ( DvzTexture * texture ); Parameter Type Description texture DvzTexture* the texture","title":"dvz_texture_destroy()"},{"location":"api/gpu/#compute-pipeline","text":"","title":"Compute pipeline"},{"location":"api/gpu/#dvz_ctx_compute","text":"Create a new compute pipeline. DvzCompute * dvz_ctx_compute ( DvzContext * context , char * shader_path ); Parameter Type Description context DvzContext* the context shader_path char* path to the .spirv file containing the compute shader","title":"dvz_ctx_compute()"},{"location":"api/gpu/#data-transfers","text":"","title":"Data transfers"},{"location":"api/gpu/#dvz_upload_buffers","text":"Upload data to 1 or N buffer regions on the GPU while the app event loop is running. void dvz_upload_buffers ( DvzCanvas * canvas , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to the data to upload to the GPU","title":"dvz_upload_buffers()"},{"location":"api/gpu/#dvz_download_buffers","text":"Download data from a buffer region to the CPU while the app event loop is running. void dvz_download_buffers ( DvzCanvas * canvas , DvzBufferRegions br , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas br DvzBufferRegions the buffer regions to update offset VkDeviceSize the offset within the buffer regions, in bytes size VkDeviceSize the size of the data to upload, in bytes data void* pointer to a buffer already allocated to contain size bytes","title":"dvz_download_buffers()"},{"location":"api/gpu/#dvz_copy_buffers","text":"Copy data between two GPU buffer regions. void dvz_copy_buffers ( DvzCanvas * canvas , DvzBufferRegions src , VkDeviceSize src_offset , DvzBufferRegions dst , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description canvas DvzCanvas* the canvas src DvzBufferRegions the buffer region to copy from src_offset VkDeviceSize the offset within the source buffer region dst DvzBufferRegions the buffer region to copy to dst_offset VkDeviceSize the offset within the target buffer region size VkDeviceSize the size of the data to copy This function does not involve GPU-CPU data transfers.","title":"dvz_copy_buffers()"},{"location":"api/gpu/#dvz_upload_texture","text":"Upload data to a texture. void dvz_upload_texture ( DvzCanvas * canvas , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas texture DvzTexture* the texture to update offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the uploaded data, in bytes data void* pointer to the data to upload to the GPU","title":"dvz_upload_texture()"},{"location":"api/gpu/#dvz_download_texture","text":"Download data from a texture. void dvz_download_texture ( DvzCanvas * canvas , DvzTexture * texture , uvec3 offset , uvec3 shape , VkDeviceSize size , void * data ); Parameter Type Description canvas DvzCanvas* the canvas texture DvzTexture* the texture to download from offset uvec3 the offset within the texture shape uvec3 the shape of the region to update within the texture size VkDeviceSize the size of the downloaded data, in bytes data void* pointer to the buffer that will hold the downloaded data","title":"dvz_download_texture()"},{"location":"api/gpu/#dvz_copy_texture","text":"Copy part of a texture to another. void dvz_copy_texture ( DvzCanvas * canvas , DvzTexture * src , uvec3 src_offset , DvzTexture * dst , uvec3 dst_offset , uvec3 shape , VkDeviceSize size ); Parameter Type Description canvas DvzCanvas* the canvas src DvzTexture* the source texture src_offset uvec3 the offset within the source texture dst DvzTexture* the target texture dst_offset uvec3 the offset within the target texture shape uvec3 the shape of the part of the texture to copy size VkDeviceSize the corresponding size of that part, in bytes This function does not involve GPU-CPU data transfers.","title":"dvz_copy_texture()"},{"location":"api/gpu/#dvz_process_transfers","text":"Process the pending transfers. void dvz_process_transfers ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas br None the buffer regions to update offset None the offset within the buffer regions, in bytes size None the size of the data to upload, in bytes data None pointer to the data to upload to the GPU When the event loop is running, all transfers are enqueued in a queue rather than executed directly. The reason is that proper synchronization is required in order to avoid modifying GPU objects while they are being used for rendering. The transfer processing function is called at a deterministic time within the main event loop.","title":"dvz_process_transfers()"},{"location":"api/gui/","text":"GUI \u00b6 GUI controls \u00b6 dvz_gui() \u00b6 Create a new GUI dialog. DvzGui * dvz_gui ( DvzCanvas * canvas , char * title , int flags ); Parameter Type Description canvas DvzCanvas* the canvas title char* the GUI title flags int optional flags returns DvzGui* GUI dvz_gui_checkbox() \u00b6 Add a checkbox control. void dvz_gui_checkbox ( DvzGui * gui , char * name , bool value ); Parameter Type Description gui DvzGui* the GUI name char* the control label value bool whether the checkbox is initially checked dvz_gui_slider_float() \u00b6 Add a slider for float number input. void dvz_gui_slider_float ( DvzGui * gui , char * name , float vmin , float vmax , float value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin float the minimum value vmax float the maximum value value float the initial value dvz_gui_slider_int() \u00b6 Add a slider for integer input. void dvz_gui_slider_int ( DvzGui * gui , char * name , int vmin , int vmax , int value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin int the minimum value vmax int the maximum value value int the initial value dvz_gui_label() \u00b6 Add a static, non-modifiable label. void dvz_gui_label ( DvzGui * gui , char * name , char * text ); Parameter Type Description gui DvzGui* the GUI name char* the control label text char* the control text dvz_gui_textbox() \u00b6 Add a textbox control for text input. void dvz_gui_textbox ( DvzGui * gui , char * name , char * value ); Parameter Type Description gui DvzGui* the GUI name char* the control label value char* the initial text dvz_gui_button() \u00b6 Add a button. void dvz_gui_button ( DvzGui * gui , char * name , int flags ); Parameter Type Description gui DvzGui* the GUI name char* the control label flags int optional flags dvz_gui_colormap() \u00b6 Add a colormap image. void dvz_gui_colormap ( DvzGui * gui , DvzColormap cmap ); Parameter Type Description gui DvzGui* the GUI cmap DvzColormap the colormap dvz_gui_demo() \u00b6 Display the Dear ImGUI demo with all supported controls. void dvz_gui_demo ( DvzGui * gui ); Parameter Type Description gui DvzGui* the GUI dvz_gui_destroy() \u00b6 Destroy a GUI. void dvz_gui_destroy ( DvzGui * gui ); Parameter Type Description gui DvzGui* the GUI","title":"GUI API"},{"location":"api/gui/#gui","text":"","title":"GUI"},{"location":"api/gui/#gui-controls","text":"","title":"GUI controls"},{"location":"api/gui/#dvz_gui","text":"Create a new GUI dialog. DvzGui * dvz_gui ( DvzCanvas * canvas , char * title , int flags ); Parameter Type Description canvas DvzCanvas* the canvas title char* the GUI title flags int optional flags returns DvzGui* GUI","title":"dvz_gui()"},{"location":"api/gui/#dvz_gui_checkbox","text":"Add a checkbox control. void dvz_gui_checkbox ( DvzGui * gui , char * name , bool value ); Parameter Type Description gui DvzGui* the GUI name char* the control label value bool whether the checkbox is initially checked","title":"dvz_gui_checkbox()"},{"location":"api/gui/#dvz_gui_slider_float","text":"Add a slider for float number input. void dvz_gui_slider_float ( DvzGui * gui , char * name , float vmin , float vmax , float value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin float the minimum value vmax float the maximum value value float the initial value","title":"dvz_gui_slider_float()"},{"location":"api/gui/#dvz_gui_slider_int","text":"Add a slider for integer input. void dvz_gui_slider_int ( DvzGui * gui , char * name , int vmin , int vmax , int value ); Parameter Type Description gui DvzGui* the GUI name char* the control label vmin int the minimum value vmax int the maximum value value int the initial value","title":"dvz_gui_slider_int()"},{"location":"api/gui/#dvz_gui_label","text":"Add a static, non-modifiable label. void dvz_gui_label ( DvzGui * gui , char * name , char * text ); Parameter Type Description gui DvzGui* the GUI name char* the control label text char* the control text","title":"dvz_gui_label()"},{"location":"api/gui/#dvz_gui_textbox","text":"Add a textbox control for text input. void dvz_gui_textbox ( DvzGui * gui , char * name , char * value ); Parameter Type Description gui DvzGui* the GUI name char* the control label value char* the initial text","title":"dvz_gui_textbox()"},{"location":"api/gui/#dvz_gui_button","text":"Add a button. void dvz_gui_button ( DvzGui * gui , char * name , int flags ); Parameter Type Description gui DvzGui* the GUI name char* the control label flags int optional flags","title":"dvz_gui_button()"},{"location":"api/gui/#dvz_gui_colormap","text":"Add a colormap image. void dvz_gui_colormap ( DvzGui * gui , DvzColormap cmap ); Parameter Type Description gui DvzGui* the GUI cmap DvzColormap the colormap","title":"dvz_gui_colormap()"},{"location":"api/gui/#dvz_gui_demo","text":"Display the Dear ImGUI demo with all supported controls. void dvz_gui_demo ( DvzGui * gui ); Parameter Type Description gui DvzGui* the GUI","title":"dvz_gui_demo()"},{"location":"api/gui/#dvz_gui_destroy","text":"Destroy a GUI. void dvz_gui_destroy ( DvzGui * gui ); Parameter Type Description gui DvzGui* the GUI","title":"dvz_gui_destroy()"},{"location":"api/misc/","text":"Misc API \u00b6 Array \u00b6 dvz_array() \u00b6 Create a new 1D array. DvzArray dvz_array ( uint32_t item_count , DvzDataType dtype ); Parameter Type Description item_count uint32_t initial number of elements dtype DvzDataType the data type of the array returns DvzArray new array dvz_array_point() \u00b6 Create an array with a single dvec3 position. DvzArray dvz_array_point ( dvec3 pos ); Parameter Type Description pos dvec3 initial number of elements returns DvzArray new array dvz_array_wrap() \u00b6 Create a 1D array from an existing compatible memory buffer. DvzArray dvz_array_wrap ( uint32_t item_count , DvzDataType dtype , void * data ); Parameter Type Description item_count uint32_t number of elements in the passed buffer dtype DvzDataType the data type of the array returns DvzArray array wrapping the buffer The created array does not allocate memory, it uses the passed buffer instead. Warning Destroying the array will free the passed pointer! dvz_array_struct() \u00b6 Create a 1D record array with heterogeneous data type. DvzArray dvz_array_struct ( uint32_t item_count , VkDeviceSize item_size ); Parameter Type Description item_count uint32_t number of elements item_size VkDeviceSize size, in bytes, of each item returns DvzArray array dvz_array_3D() \u00b6 Create a 3D array holding a texture. DvzArray dvz_array_3D ( uint32_t ndims , uint32_t width , uint32_t height , uint32_t depth , VkDeviceSize item_size ); Parameter Type Description ndims uint32_t number of dimensions (1, 2, 3) width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension item_size VkDeviceSize size of each item in bytes returns DvzArray array dvz_array_resize() \u00b6 Resize an existing array. void dvz_array_resize ( DvzArray * array , uint32_t item_count ); Parameter Type Description array DvzArray* the array to resize item_count uint32_t the new number of items If the new size is equal to the old size, do nothing. If the new size is smaller than the old size, change the size attribute but do not reallocate If the new size is larger than the old size, reallocate memory and copy over the old values dvz_array_clear() \u00b6 Reset to 0 the contents of an existing array. void dvz_array_clear ( DvzArray * array ); Parameter Type Description array DvzArray* the array to clear dvz_array_reshape() \u00b6 Reshape a 3D array and delete all the data in it . void dvz_array_reshape ( DvzArray * array , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description array DvzArray* the array to reshape and clear width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension Warning The contents of the array will be cleared. Copying the existing data would require more work and is not necessary at the moment. dvz_array_data() \u00b6 Copy data into an array. void dvz_array_data ( DvzArray * array , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data ); Parameter Type Description array DvzArray* the array first_item uint32_t first element in the array to be overwritten item_count uint32_t number of items to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy There will be item_count values copied between first_item and first_item + item_count in the array. There are data_item_count values in the passed buffer. If item_count > data_item_count , the last value of data will be repeated until the last value. Example: C // Create an array of 10 double numbers, initialize all elements with 1.23. DvzArray arr = dvz_array ( 10 , DVZ_DTYPE_DOUBLE ); double item = 1.23 ; dvz_array_data ( & arr , 0 , 10 , 1 , & item ); dvz_array_item() \u00b6 Retrieve a single element from an array. void * dvz_array_item ( DvzArray * array , uint32_t idx ); Parameter Type Description array DvzArray* the array idx uint32_t the index of the element to retrieve returns void* pointer to the requested element dvz_array_column() \u00b6 Copy data into the column of a record array. void dvz_array_column ( DvzArray * array , VkDeviceSize offset , VkDeviceSize col_size , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data , DvzDataType source_dtype , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description array DvzArray* the array offset VkDeviceSize the offset within the array, in bytes col_size VkDeviceSize stride in the source array, in bytes first_item uint32_t first element in the array to be overwritten item_count uint32_t number of elements to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy source_dtype DvzDataType the source dtype (only used when casting) target_dtype DvzDataType the target dtype (only used when casting) copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied element This function is used by the default visual baking function, which copies to the vertex buffer (corresponding to a record array with as many fields as GLSL attributes in the vertex shader) the user-specified visual props (data for the individual elements). dvz_array_insert() \u00b6 Insert data in an array. void dvz_array_insert ( DvzArray * array , uint32_t offset , uint32_t size , void * insert ); Parameter Type Description array DvzArray* the array offset uint32_t the index of the first element of the inserted data in the new array size uint32_t the number of elements to insert insert void* the data to insert dvz_array_copy_region() \u00b6 Copy a region of an array into another. void dvz_array_copy_region ( DvzArray * src_arr , DvzArray * dst_arr , uint32_t src_offset , uint32_t dst_offset , uint32_t item_count ); Parameter Type Description src_arr DvzArray* the source array dst_arr DvzArray* the destination array src_offset uint32_t the index, in the source array, of the first item to copy dst_offset uint32_t the destination index item_count uint32_t the number of items to copy dvz_array_destroy() \u00b6 Destroy an array. void dvz_array_destroy ( DvzArray * array ); Parameter Type Description array DvzArray* the array to destroy This function frees the allocated underlying data buffer. Object \u00b6 dvz_obj_init() \u00b6 Initialize an object. void dvz_obj_init ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object Memory for the object has been allocated and its fields properly initialized. dvz_obj_created() \u00b6 Mark an object as successfully created on the GPU. void dvz_obj_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object dvz_obj_destroyed() \u00b6 Mark an object as destroyed. void dvz_obj_destroyed ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object dvz_obj_is_created() \u00b6 Whether an object has been successfully created. bool dvz_obj_is_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object returns bool boolean indicated whether the object has been successfully created Container \u00b6 dvz_container() \u00b6 Create a container that will contain an arbitrary number of objects of the same type. DvzContainer dvz_container ( uint32_t count , size_t item_size , DvzObjectType type ); Parameter Type Description count uint32_t initial number of objects in the container item_size size_t size of each object, in bytes type DvzObjectType object type dvz_container_delete_if_destroyed() \u00b6 Free a given object in the constainer if it was previously destroyed. void dvz_container_delete_if_destroyed ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container dvz_container_alloc() \u00b6 Get a pointer to a new object in the container. void * dvz_container_alloc ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns void* pointer to an allocated object If the container is full, it will be automatically resized. dvz_container_get() \u00b6 Return the object at a given index. void * dvz_container_get ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container returns None a pointer to the object at the specified index dvz_container_iterator() \u00b6 Start a loop iteration over all valid objects within the container. DvzContainerIterator dvz_container_iterator ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns DvzContainerIterator pointer to the first object dvz_container_iter() \u00b6 Continue an already-started loop iteration on a container. void dvz_container_iter ( DvzContainerIterator * iterator ); Parameter Type Description container None the container returns void pointer to the next object in the container, or NULL at the end dvz_container_destroy() \u00b6 Destroy a container. void dvz_container_destroy ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container idx None the index of the object within the container Free all remaining objects, as well as the container itself. Warning All objects in the container must have been destroyed beforehand, since the generic container does not know how to properly destroy objects that were created with Vulkan. I/O \u00b6 dvz_write_png() \u00b6 Save an image to a PNG file int dvz_write_png ( char * filename , uint32_t width , uint32_t height , uint8_t * image ); Parameter Type Description filename char* path to the PNG file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values dvz_write_ppm() \u00b6 Save an image to a PPM file (short ASCII header and flat binary RGBA values). int dvz_write_ppm ( char * filename , uint32_t width , uint32_t height , uint8_t * image ); Parameter Type Description filename char* path to the PPM file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values dvz_read_file() \u00b6 Read a binary file. uint32_t * dvz_read_file ( char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns uint32_t* to a byte buffer with the file contents dvz_read_npy() \u00b6 Read a NumPy NPY file. char * dvz_read_npy ( char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns char* to a buffer containing the array elements dvz_read_ppm() \u00b6 Read a PPM image file. uint8_t * dvz_read_ppm ( char * filename , int * width , int * height ); Parameter Type Description filename char* path of the file to open width int* width of the image height int* of the image returns uint8_t* to a buffer with the loaded RGBA pixel colors Thread \u00b6 dvz_thread() \u00b6 Create a thread. DvzThread dvz_thread ( DvzThreadCallback callback , void * user_data ); Parameter Type Description callback DvzThreadCallback the function that will run in a background thread user_data void* a pointer to arbitrary user data returns DvzThread object Callback function signature: void*(void*) dvz_thread_lock() \u00b6 Acquire a mutex lock associated to the thread. void dvz_thread_lock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread dvz_thread_unlock() \u00b6 Release a mutex lock associated to the thread. void dvz_thread_unlock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread dvz_thread_join() \u00b6 Destroy a thread after the thread function has finished running. void dvz_thread_join ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread FIFO queue \u00b6 dvz_fifo() \u00b6 Create a FIFO queue. DvzFifo dvz_fifo ( int32_t capacity ); Parameter Type Description capacity int32_t the maximum size returns DvzFifo FIFO queue dvz_fifo_enqueue() \u00b6 Enqueue an object in a queue. void dvz_fifo_enqueue ( DvzFifo * fifo , void * item ); Parameter Type Description fifo DvzFifo* the FIFO queue item void* the pointer to the object to enqueue dvz_fifo_dequeue() \u00b6 Dequeue an object from a queue. void * dvz_fifo_dequeue ( DvzFifo * fifo , bool wait ); Parameter Type Description fifo DvzFifo* the FIFO queue wait bool whether to return immediately, or wait until the queue is non-empty returns void* pointer to the dequeued object, or NULL if the queue is empty dvz_fifo_size() \u00b6 Get the number of items in a queue. int dvz_fifo_size ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue returns int number of elements in the queue dvz_fifo_discard() \u00b6 Discard old items in a queue. void dvz_fifo_discard ( DvzFifo * fifo , int max_size ); Parameter Type Description fifo DvzFifo* the FIFO queue max_size int the number of items to keep in the queue. This function will suppress all items in the queue except the max_size most recent ones. dvz_fifo_reset() \u00b6 Delete all items in a queue. void dvz_fifo_reset ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue dvz_fifo_destroy() \u00b6 Destroy a queue. void dvz_fifo_destroy ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue Mesh \u00b6 dvz_mesh() \u00b6 Create a new mesh. DvzMesh dvz_mesh ( void ); | returns | DvzMesh | mesh object | A mesh is represented by an array of vertices of type DvzGraphicsMeshVertex and indices, where every triplet of vertex indices represents a triangular face of the mesh. dvz_mesh_obj() \u00b6 Load an OBJ mesh. DvzMesh dvz_mesh_obj ( char * file_path ); Parameter Type Description file_path char* the path to the .obj file returns DvzMesh mesh dvz_mesh_grid() \u00b6 Create a grid mesh. DvzMesh dvz_mesh_grid ( uint32_t row_count , uint32_t col_count , vec3 * positions , vec2 * texcoords ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns positions vec3* the 3D position of each vertex in the grid texcoords vec2* the texture coordinates of each vertex returns DvzMesh mesh object The positions buffer should contain row_count * col_count vec3 positions (C order). dvz_mesh_surface() \u00b6 Create a surface mesh. DvzMesh dvz_mesh_surface ( uint32_t row_count , uint32_t col_count , float * heights ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns heights float* the height of each vertex in the grid returns DvzMesh mesh object The heights buffer should contain row_count * col_count float positions (C order). dvz_mesh_cube() \u00b6 Create a unit cube mesh (ranging [-0.5, +0.5]). DvzMesh dvz_mesh_cube ( void ); | returns | DvzMesh | mesh object | dvz_mesh_sphere() \u00b6 Create a sphere mesh. DvzMesh dvz_mesh_sphere ( uint32_t row_count , uint32_t col_count ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns returns DvzMesh mesh object dvz_mesh_cylinder() \u00b6 Create a cylinder mesh. DvzMesh dvz_mesh_cylinder ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object dvz_mesh_cone() \u00b6 Create a cone mesh. DvzMesh dvz_mesh_cone ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object dvz_mesh_square() \u00b6 Create a square mesh. DvzMesh dvz_mesh_square ( void ); | returns | DvzMesh | mesh object | dvz_mesh_disc() \u00b6 Create a disc mesh. DvzMesh dvz_mesh_disc ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object dvz_mesh_normalize() \u00b6 Normalize a mesh. void dvz_mesh_normalize ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh dvz_mesh_destroy() \u00b6 Destroy a mesh. void dvz_mesh_destroy ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh Mesh transform \u00b6 dvz_mesh_transform_reset() \u00b6 Reset the mesh transformation. void dvz_mesh_transform_reset ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh dvz_mesh_transform_add() \u00b6 Append a mesh transformation. void dvz_mesh_transform_add ( DvzMesh * mesh , mat4 transform ); Parameter Type Description mesh DvzMesh* the mesh transform mat4 the transform matrix dvz_mesh_translate() \u00b6 Append a translation transformation. void dvz_mesh_translate ( DvzMesh * mesh , vec3 translate ); Parameter Type Description mesh DvzMesh* the mesh translate vec3 the translation vector dvz_mesh_scale() \u00b6 Append a scaling transformation. void dvz_mesh_scale ( DvzMesh * mesh , vec3 scale ); Parameter Type Description mesh DvzMesh* the mesh scale vec3 the scaling coefficients dvz_mesh_rotate() \u00b6 Append a rotation transformation. void dvz_mesh_rotate ( DvzMesh * mesh , float angle , vec3 axis ); Parameter Type Description mesh DvzMesh* the mesh angle float the rotation angle axis vec3 the rotation axis dvz_mesh_transform() \u00b6 Apply the transformation matrix to a mesh. void dvz_mesh_transform ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh Random \u00b6 dvz_rand_byte() \u00b6 Return a random integer number between 0 and 255. uint8_t dvz_rand_byte ( void ); | returns | uint8_t | number | dvz_rand_float() \u00b6 Return a random floating-point number between 0 and 1. float dvz_rand_float ( void ); | returns | float | number | dvz_rand_normal() \u00b6 Return a random normal floating-point number. float dvz_rand_normal ( void ); | returns | float | number | Misc \u00b6 dvz_sleep() \u00b6 Wait a given number of milliseconds. void dvz_sleep ( int milliseconds ); Parameter Type Description milliseconds int sleep duration dvz_next_pow2() \u00b6 uint64_t dvz_next_pow2 ( uint64_t x );","title":"Misc API"},{"location":"api/misc/#misc-api","text":"","title":"Misc API"},{"location":"api/misc/#array","text":"","title":"Array"},{"location":"api/misc/#dvz_array","text":"Create a new 1D array. DvzArray dvz_array ( uint32_t item_count , DvzDataType dtype ); Parameter Type Description item_count uint32_t initial number of elements dtype DvzDataType the data type of the array returns DvzArray new array","title":"dvz_array()"},{"location":"api/misc/#dvz_array_point","text":"Create an array with a single dvec3 position. DvzArray dvz_array_point ( dvec3 pos ); Parameter Type Description pos dvec3 initial number of elements returns DvzArray new array","title":"dvz_array_point()"},{"location":"api/misc/#dvz_array_wrap","text":"Create a 1D array from an existing compatible memory buffer. DvzArray dvz_array_wrap ( uint32_t item_count , DvzDataType dtype , void * data ); Parameter Type Description item_count uint32_t number of elements in the passed buffer dtype DvzDataType the data type of the array returns DvzArray array wrapping the buffer The created array does not allocate memory, it uses the passed buffer instead. Warning Destroying the array will free the passed pointer!","title":"dvz_array_wrap()"},{"location":"api/misc/#dvz_array_struct","text":"Create a 1D record array with heterogeneous data type. DvzArray dvz_array_struct ( uint32_t item_count , VkDeviceSize item_size ); Parameter Type Description item_count uint32_t number of elements item_size VkDeviceSize size, in bytes, of each item returns DvzArray array","title":"dvz_array_struct()"},{"location":"api/misc/#dvz_array_3d","text":"Create a 3D array holding a texture. DvzArray dvz_array_3D ( uint32_t ndims , uint32_t width , uint32_t height , uint32_t depth , VkDeviceSize item_size ); Parameter Type Description ndims uint32_t number of dimensions (1, 2, 3) width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension item_size VkDeviceSize size of each item in bytes returns DvzArray array","title":"dvz_array_3D()"},{"location":"api/misc/#dvz_array_resize","text":"Resize an existing array. void dvz_array_resize ( DvzArray * array , uint32_t item_count ); Parameter Type Description array DvzArray* the array to resize item_count uint32_t the new number of items If the new size is equal to the old size, do nothing. If the new size is smaller than the old size, change the size attribute but do not reallocate If the new size is larger than the old size, reallocate memory and copy over the old values","title":"dvz_array_resize()"},{"location":"api/misc/#dvz_array_clear","text":"Reset to 0 the contents of an existing array. void dvz_array_clear ( DvzArray * array ); Parameter Type Description array DvzArray* the array to clear","title":"dvz_array_clear()"},{"location":"api/misc/#dvz_array_reshape","text":"Reshape a 3D array and delete all the data in it . void dvz_array_reshape ( DvzArray * array , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description array DvzArray* the array to reshape and clear width uint32_t number of elements along the 1st dimension height uint32_t number of elements along the 2nd dimension depth uint32_t number of elements along the 3rd dimension Warning The contents of the array will be cleared. Copying the existing data would require more work and is not necessary at the moment.","title":"dvz_array_reshape()"},{"location":"api/misc/#dvz_array_data","text":"Copy data into an array. void dvz_array_data ( DvzArray * array , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data ); Parameter Type Description array DvzArray* the array first_item uint32_t first element in the array to be overwritten item_count uint32_t number of items to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy There will be item_count values copied between first_item and first_item + item_count in the array. There are data_item_count values in the passed buffer. If item_count > data_item_count , the last value of data will be repeated until the last value. Example: C // Create an array of 10 double numbers, initialize all elements with 1.23. DvzArray arr = dvz_array ( 10 , DVZ_DTYPE_DOUBLE ); double item = 1.23 ; dvz_array_data ( & arr , 0 , 10 , 1 , & item );","title":"dvz_array_data()"},{"location":"api/misc/#dvz_array_item","text":"Retrieve a single element from an array. void * dvz_array_item ( DvzArray * array , uint32_t idx ); Parameter Type Description array DvzArray* the array idx uint32_t the index of the element to retrieve returns void* pointer to the requested element","title":"dvz_array_item()"},{"location":"api/misc/#dvz_array_column","text":"Copy data into the column of a record array. void dvz_array_column ( DvzArray * array , VkDeviceSize offset , VkDeviceSize col_size , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data , DvzDataType source_dtype , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description array DvzArray* the array offset VkDeviceSize the offset within the array, in bytes col_size VkDeviceSize stride in the source array, in bytes first_item uint32_t first element in the array to be overwritten item_count uint32_t number of elements to write data_item_count uint32_t number of elements in data data void* the buffer containing the data to copy source_dtype DvzDataType the source dtype (only used when casting) target_dtype DvzDataType the target dtype (only used when casting) copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied element This function is used by the default visual baking function, which copies to the vertex buffer (corresponding to a record array with as many fields as GLSL attributes in the vertex shader) the user-specified visual props (data for the individual elements).","title":"dvz_array_column()"},{"location":"api/misc/#dvz_array_insert","text":"Insert data in an array. void dvz_array_insert ( DvzArray * array , uint32_t offset , uint32_t size , void * insert ); Parameter Type Description array DvzArray* the array offset uint32_t the index of the first element of the inserted data in the new array size uint32_t the number of elements to insert insert void* the data to insert","title":"dvz_array_insert()"},{"location":"api/misc/#dvz_array_copy_region","text":"Copy a region of an array into another. void dvz_array_copy_region ( DvzArray * src_arr , DvzArray * dst_arr , uint32_t src_offset , uint32_t dst_offset , uint32_t item_count ); Parameter Type Description src_arr DvzArray* the source array dst_arr DvzArray* the destination array src_offset uint32_t the index, in the source array, of the first item to copy dst_offset uint32_t the destination index item_count uint32_t the number of items to copy","title":"dvz_array_copy_region()"},{"location":"api/misc/#dvz_array_destroy","text":"Destroy an array. void dvz_array_destroy ( DvzArray * array ); Parameter Type Description array DvzArray* the array to destroy This function frees the allocated underlying data buffer.","title":"dvz_array_destroy()"},{"location":"api/misc/#object","text":"","title":"Object"},{"location":"api/misc/#dvz_obj_init","text":"Initialize an object. void dvz_obj_init ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object Memory for the object has been allocated and its fields properly initialized.","title":"dvz_obj_init()"},{"location":"api/misc/#dvz_obj_created","text":"Mark an object as successfully created on the GPU. void dvz_obj_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object","title":"dvz_obj_created()"},{"location":"api/misc/#dvz_obj_destroyed","text":"Mark an object as destroyed. void dvz_obj_destroyed ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object","title":"dvz_obj_destroyed()"},{"location":"api/misc/#dvz_obj_is_created","text":"Whether an object has been successfully created. bool dvz_obj_is_created ( DvzObject * obj ); Parameter Type Description obj DvzObject* the object returns bool boolean indicated whether the object has been successfully created","title":"dvz_obj_is_created()"},{"location":"api/misc/#container","text":"","title":"Container"},{"location":"api/misc/#dvz_container","text":"Create a container that will contain an arbitrary number of objects of the same type. DvzContainer dvz_container ( uint32_t count , size_t item_size , DvzObjectType type ); Parameter Type Description count uint32_t initial number of objects in the container item_size size_t size of each object, in bytes type DvzObjectType object type","title":"dvz_container()"},{"location":"api/misc/#dvz_container_delete_if_destroyed","text":"Free a given object in the constainer if it was previously destroyed. void dvz_container_delete_if_destroyed ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container","title":"dvz_container_delete_if_destroyed()"},{"location":"api/misc/#dvz_container_alloc","text":"Get a pointer to a new object in the container. void * dvz_container_alloc ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns void* pointer to an allocated object If the container is full, it will be automatically resized.","title":"dvz_container_alloc()"},{"location":"api/misc/#dvz_container_get","text":"Return the object at a given index. void * dvz_container_get ( DvzContainer * container , uint32_t idx ); Parameter Type Description container DvzContainer* the container idx uint32_t the index of the object within the container returns None a pointer to the object at the specified index","title":"dvz_container_get()"},{"location":"api/misc/#dvz_container_iterator","text":"Start a loop iteration over all valid objects within the container. DvzContainerIterator dvz_container_iterator ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container returns DvzContainerIterator pointer to the first object","title":"dvz_container_iterator()"},{"location":"api/misc/#dvz_container_iter","text":"Continue an already-started loop iteration on a container. void dvz_container_iter ( DvzContainerIterator * iterator ); Parameter Type Description container None the container returns void pointer to the next object in the container, or NULL at the end","title":"dvz_container_iter()"},{"location":"api/misc/#dvz_container_destroy","text":"Destroy a container. void dvz_container_destroy ( DvzContainer * container ); Parameter Type Description container DvzContainer* the container idx None the index of the object within the container Free all remaining objects, as well as the container itself. Warning All objects in the container must have been destroyed beforehand, since the generic container does not know how to properly destroy objects that were created with Vulkan.","title":"dvz_container_destroy()"},{"location":"api/misc/#io","text":"","title":"I/O"},{"location":"api/misc/#dvz_write_png","text":"Save an image to a PNG file int dvz_write_png ( char * filename , uint32_t width , uint32_t height , uint8_t * image ); Parameter Type Description filename char* path to the PNG file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values","title":"dvz_write_png()"},{"location":"api/misc/#dvz_write_ppm","text":"Save an image to a PPM file (short ASCII header and flat binary RGBA values). int dvz_write_ppm ( char * filename , uint32_t width , uint32_t height , uint8_t * image ); Parameter Type Description filename char* path to the PPM file to create width uint32_t width of the image height uint32_t height of the image image uint8_t* pointer to an array of 32-bit RGBA values","title":"dvz_write_ppm()"},{"location":"api/misc/#dvz_read_file","text":"Read a binary file. uint32_t * dvz_read_file ( char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns uint32_t* to a byte buffer with the file contents","title":"dvz_read_file()"},{"location":"api/misc/#dvz_read_npy","text":"Read a NumPy NPY file. char * dvz_read_npy ( char * filename , size_t * size ); Parameter Type Description filename char* path of the file to open size size_t* of the file returns char* to a buffer containing the array elements","title":"dvz_read_npy()"},{"location":"api/misc/#dvz_read_ppm","text":"Read a PPM image file. uint8_t * dvz_read_ppm ( char * filename , int * width , int * height ); Parameter Type Description filename char* path of the file to open width int* width of the image height int* of the image returns uint8_t* to a buffer with the loaded RGBA pixel colors","title":"dvz_read_ppm()"},{"location":"api/misc/#thread","text":"","title":"Thread"},{"location":"api/misc/#dvz_thread","text":"Create a thread. DvzThread dvz_thread ( DvzThreadCallback callback , void * user_data ); Parameter Type Description callback DvzThreadCallback the function that will run in a background thread user_data void* a pointer to arbitrary user data returns DvzThread object Callback function signature: void*(void*)","title":"dvz_thread()"},{"location":"api/misc/#dvz_thread_lock","text":"Acquire a mutex lock associated to the thread. void dvz_thread_lock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread","title":"dvz_thread_lock()"},{"location":"api/misc/#dvz_thread_unlock","text":"Release a mutex lock associated to the thread. void dvz_thread_unlock ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread","title":"dvz_thread_unlock()"},{"location":"api/misc/#dvz_thread_join","text":"Destroy a thread after the thread function has finished running. void dvz_thread_join ( DvzThread * thread ); Parameter Type Description thread DvzThread* the thread","title":"dvz_thread_join()"},{"location":"api/misc/#fifo-queue","text":"","title":"FIFO queue"},{"location":"api/misc/#dvz_fifo","text":"Create a FIFO queue. DvzFifo dvz_fifo ( int32_t capacity ); Parameter Type Description capacity int32_t the maximum size returns DvzFifo FIFO queue","title":"dvz_fifo()"},{"location":"api/misc/#dvz_fifo_enqueue","text":"Enqueue an object in a queue. void dvz_fifo_enqueue ( DvzFifo * fifo , void * item ); Parameter Type Description fifo DvzFifo* the FIFO queue item void* the pointer to the object to enqueue","title":"dvz_fifo_enqueue()"},{"location":"api/misc/#dvz_fifo_dequeue","text":"Dequeue an object from a queue. void * dvz_fifo_dequeue ( DvzFifo * fifo , bool wait ); Parameter Type Description fifo DvzFifo* the FIFO queue wait bool whether to return immediately, or wait until the queue is non-empty returns void* pointer to the dequeued object, or NULL if the queue is empty","title":"dvz_fifo_dequeue()"},{"location":"api/misc/#dvz_fifo_size","text":"Get the number of items in a queue. int dvz_fifo_size ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue returns int number of elements in the queue","title":"dvz_fifo_size()"},{"location":"api/misc/#dvz_fifo_discard","text":"Discard old items in a queue. void dvz_fifo_discard ( DvzFifo * fifo , int max_size ); Parameter Type Description fifo DvzFifo* the FIFO queue max_size int the number of items to keep in the queue. This function will suppress all items in the queue except the max_size most recent ones.","title":"dvz_fifo_discard()"},{"location":"api/misc/#dvz_fifo_reset","text":"Delete all items in a queue. void dvz_fifo_reset ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue","title":"dvz_fifo_reset()"},{"location":"api/misc/#dvz_fifo_destroy","text":"Destroy a queue. void dvz_fifo_destroy ( DvzFifo * fifo ); Parameter Type Description fifo DvzFifo* the FIFO queue","title":"dvz_fifo_destroy()"},{"location":"api/misc/#mesh","text":"","title":"Mesh"},{"location":"api/misc/#dvz_mesh","text":"Create a new mesh. DvzMesh dvz_mesh ( void ); | returns | DvzMesh | mesh object | A mesh is represented by an array of vertices of type DvzGraphicsMeshVertex and indices, where every triplet of vertex indices represents a triangular face of the mesh.","title":"dvz_mesh()"},{"location":"api/misc/#dvz_mesh_obj","text":"Load an OBJ mesh. DvzMesh dvz_mesh_obj ( char * file_path ); Parameter Type Description file_path char* the path to the .obj file returns DvzMesh mesh","title":"dvz_mesh_obj()"},{"location":"api/misc/#dvz_mesh_grid","text":"Create a grid mesh. DvzMesh dvz_mesh_grid ( uint32_t row_count , uint32_t col_count , vec3 * positions , vec2 * texcoords ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns positions vec3* the 3D position of each vertex in the grid texcoords vec2* the texture coordinates of each vertex returns DvzMesh mesh object The positions buffer should contain row_count * col_count vec3 positions (C order).","title":"dvz_mesh_grid()"},{"location":"api/misc/#dvz_mesh_surface","text":"Create a surface mesh. DvzMesh dvz_mesh_surface ( uint32_t row_count , uint32_t col_count , float * heights ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns heights float* the height of each vertex in the grid returns DvzMesh mesh object The heights buffer should contain row_count * col_count float positions (C order).","title":"dvz_mesh_surface()"},{"location":"api/misc/#dvz_mesh_cube","text":"Create a unit cube mesh (ranging [-0.5, +0.5]). DvzMesh dvz_mesh_cube ( void ); | returns | DvzMesh | mesh object |","title":"dvz_mesh_cube()"},{"location":"api/misc/#dvz_mesh_sphere","text":"Create a sphere mesh. DvzMesh dvz_mesh_sphere ( uint32_t row_count , uint32_t col_count ); Parameter Type Description row_count uint32_t number of rows col_count uint32_t number of columns returns DvzMesh mesh object","title":"dvz_mesh_sphere()"},{"location":"api/misc/#dvz_mesh_cylinder","text":"Create a cylinder mesh. DvzMesh dvz_mesh_cylinder ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object","title":"dvz_mesh_cylinder()"},{"location":"api/misc/#dvz_mesh_cone","text":"Create a cone mesh. DvzMesh dvz_mesh_cone ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object","title":"dvz_mesh_cone()"},{"location":"api/misc/#dvz_mesh_square","text":"Create a square mesh. DvzMesh dvz_mesh_square ( void ); | returns | DvzMesh | mesh object |","title":"dvz_mesh_square()"},{"location":"api/misc/#dvz_mesh_disc","text":"Create a disc mesh. DvzMesh dvz_mesh_disc ( uint32_t count ); Parameter Type Description count uint32_t number of sides returns DvzMesh mesh object","title":"dvz_mesh_disc()"},{"location":"api/misc/#dvz_mesh_normalize","text":"Normalize a mesh. void dvz_mesh_normalize ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_normalize()"},{"location":"api/misc/#dvz_mesh_destroy","text":"Destroy a mesh. void dvz_mesh_destroy ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_destroy()"},{"location":"api/misc/#mesh-transform","text":"","title":"Mesh transform"},{"location":"api/misc/#dvz_mesh_transform_reset","text":"Reset the mesh transformation. void dvz_mesh_transform_reset ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_transform_reset()"},{"location":"api/misc/#dvz_mesh_transform_add","text":"Append a mesh transformation. void dvz_mesh_transform_add ( DvzMesh * mesh , mat4 transform ); Parameter Type Description mesh DvzMesh* the mesh transform mat4 the transform matrix","title":"dvz_mesh_transform_add()"},{"location":"api/misc/#dvz_mesh_translate","text":"Append a translation transformation. void dvz_mesh_translate ( DvzMesh * mesh , vec3 translate ); Parameter Type Description mesh DvzMesh* the mesh translate vec3 the translation vector","title":"dvz_mesh_translate()"},{"location":"api/misc/#dvz_mesh_scale","text":"Append a scaling transformation. void dvz_mesh_scale ( DvzMesh * mesh , vec3 scale ); Parameter Type Description mesh DvzMesh* the mesh scale vec3 the scaling coefficients","title":"dvz_mesh_scale()"},{"location":"api/misc/#dvz_mesh_rotate","text":"Append a rotation transformation. void dvz_mesh_rotate ( DvzMesh * mesh , float angle , vec3 axis ); Parameter Type Description mesh DvzMesh* the mesh angle float the rotation angle axis vec3 the rotation axis","title":"dvz_mesh_rotate()"},{"location":"api/misc/#dvz_mesh_transform","text":"Apply the transformation matrix to a mesh. void dvz_mesh_transform ( DvzMesh * mesh ); Parameter Type Description mesh DvzMesh* the mesh","title":"dvz_mesh_transform()"},{"location":"api/misc/#random","text":"","title":"Random"},{"location":"api/misc/#dvz_rand_byte","text":"Return a random integer number between 0 and 255. uint8_t dvz_rand_byte ( void ); | returns | uint8_t | number |","title":"dvz_rand_byte()"},{"location":"api/misc/#dvz_rand_float","text":"Return a random floating-point number between 0 and 1. float dvz_rand_float ( void ); | returns | float | number |","title":"dvz_rand_float()"},{"location":"api/misc/#dvz_rand_normal","text":"Return a random normal floating-point number. float dvz_rand_normal ( void ); | returns | float | number |","title":"dvz_rand_normal()"},{"location":"api/misc/#misc","text":"","title":"Misc"},{"location":"api/misc/#dvz_sleep","text":"Wait a given number of milliseconds. void dvz_sleep ( int milliseconds ); Parameter Type Description milliseconds int sleep duration","title":"dvz_sleep()"},{"location":"api/misc/#dvz_next_pow2","text":"uint64_t dvz_next_pow2 ( uint64_t x );","title":"dvz_next_pow2()"},{"location":"api/scene/","text":"Scene API \u00b6 App, canvas, main loop \u00b6 dvz_app() \u00b6 Create an application instance. DvzApp * dvz_app ( DvzBackend backend ); Parameter Type Description backend DvzBackend the backend returns DvzApp* pointer to the created app There is typically only one App object in a given application. This object holds a pointer to the Vulkan instance and is responsible for discovering the available GPUs. dvz_canvas() \u00b6 Create a canvas. DvzCanvas * dvz_canvas ( DvzGpu * gpu , uint32_t width , uint32_t height , int flags ); Parameter Type Description gpu DvzGpu* the GPU to use for swapchain presentation width uint32_t the initial window width, in pixels height uint32_t the initial window height, in pixels flags int the creation flags for the canvas dvz_canvas_offscreen() \u00b6 Create an offscreen canvas. DvzCanvas * dvz_canvas_offscreen ( DvzGpu * gpu , uint32_t width , uint32_t height , int flags ); Parameter Type Description gpu DvzGpu* the GPU to use for swapchain presentation width uint32_t the canvas width, in pixels height uint32_t the canvas height, in pixels flags int the creation flags for the canvas dvz_canvas_dpi_scaling() \u00b6 Set the DPI scaling factor of a canvas. void dvz_canvas_dpi_scaling ( DvzCanvas * canvas , float scaling ); Parameter Type Description canvas DvzCanvas* the canvas scaling float the scaling factor dvz_scene() \u00b6 Create a scene with a grid layout. DvzScene * dvz_scene ( DvzCanvas * canvas , uint32_t n_rows , uint32_t n_cols ); Parameter Type Description canvas DvzCanvas* the canvas n_rows uint32_t number of rows in the grid n_cols uint32_t number of columns in the grid returns DvzScene* pointer to the created scene The scene defines a 2D grid where each cell contains a panel (subplot). Panels may support various kinds of interactivity. dvz_app_run() \u00b6 Start the main event loop. void dvz_app_run ( DvzApp * app , uint64_t frame_count ); Parameter Type Description app DvzApp* the app frame_count uint64_t number of frames to process (0 for infinite loop) Every loop iteration processes one frame of all open canvases. dvz_scene_destroy() \u00b6 Destroy a scene. void dvz_scene_destroy ( DvzScene * scene ); Parameter Type Description scene DvzScene* the scene Destroy all panels and visuals in the scene. dvz_canvas_destroy() \u00b6 Destroy a canvas. void dvz_canvas_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas dvz_app_destroy() \u00b6 Destroy the application. int dvz_app_destroy ( DvzApp * app ); Parameter Type Description app DvzApp* the application to destroy This function automatically destroys all objects created within the application. Set panels, add visuals \u00b6 dvz_scene_panel() \u00b6 Add a panel to the scene grid. DvzPanel * dvz_scene_panel ( DvzScene * scene , uint32_t row , uint32_t col , DvzControllerType type , int flags ); Parameter Type Description controller None the scene row uint32_t the row index (0-based) col uint32_t the column index (0-based) type DvzControllerType the controller type flags int flags for the builtin controller returns DvzPanel* panel dvz_scene_visual() \u00b6 Create a builtin visual and add it to a panel. DvzVisual * dvz_scene_visual ( DvzPanel * panel , DvzVisualType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzVisualType the type of visual flags int flags for the builtin visual returns DvzVisual* visual Custom visuals and graphics \u00b6 dvz_blank_graphics() \u00b6 Create a blank graphics (used when creating custom graphics and visuals). DvzGraphics * dvz_blank_graphics ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int graphics flags returns DvzGraphics* blank graphics dvz_custom_graphics() \u00b6 Make a custom graphics and add it to a visual. void dvz_custom_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* a visual graphics DvzGraphics* the custom graphics dvz_blank_visual() \u00b6 Create a blank visual (used when creating custom visuals). DvzVisual * dvz_blank_visual ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int visual flags returns DvzVisual* blank visual dvz_custom_visual() \u00b6 Make a custom visual and add it to a panel. void dvz_custom_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the custom visual Grid and panels \u00b6 dvz_grid() \u00b6 Create a grid of panels. DvzGrid dvz_grid ( DvzCanvas * canvas , uint32_t row_count , uint32_t col_count ); Parameter Type Description canvas DvzCanvas* the canvas row_count uint32_t the number of rows col_count uint32_t the number of columns returns DvzGrid grid object dvz_grid_destroy() \u00b6 Destroy a grid. void dvz_grid_destroy ( DvzGrid * grid ); Parameter Type Description grid DvzGrid* the grid dvz_panel() \u00b6 Create a panel at a given location in a grid. DvzPanel * dvz_panel ( DvzGrid * grid , uint32_t row , uint32_t col ); Parameter Type Description grid DvzGrid* the grid row uint32_t the row index in the grid col uint32_t the column index in the grid returns DvzPanel* panel dvz_panel_update() \u00b6 Update a panel viewport. void dvz_panel_update ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel dvz_panel_margins() \u00b6 Set panel margins. void dvz_panel_margins ( DvzPanel * panel , vec4 margins ); Parameter Type Description panel DvzPanel* the panel margins vec4 the margins, in pixels Margins are represented as a vec4 vector: top, right, bottom, left. dvz_panel_unit() \u00b6 Set the unit in which the panel size is specified. void dvz_panel_unit ( DvzPanel * panel , DvzPanelSizeUnit unit ); Parameter Type Description panel DvzPanel* the panel unit DvzPanelSizeUnit the unit dvz_panel_mode() \u00b6 Set the panel mode (grid or detached). void dvz_panel_mode ( DvzPanel * panel , DvzPanelMode mode ); Parameter Type Description panel DvzPanel* the panel mode DvzPanelMode the mode dvz_panel_visual() \u00b6 Add a visual to a panel. void dvz_panel_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the visual dvz_panel_pos() \u00b6 Set a panel position (in detached mode). void dvz_panel_pos ( DvzPanel * panel , float x , float y ); Parameter Type Description panel DvzPanel* the panel x float the position y float the position The unit in which the coordinates are specified is controller by dvz_panel_unit() . dvz_panel_size() \u00b6 Set a panel size (in detached mode). void dvz_panel_size ( DvzPanel * panel , DvzGridAxis axis , float size ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the axis on which to specify the size size float the size The unit in which the size is specified is controller by dvz_panel_unit() . dvz_panel_span() \u00b6 Set the number of cells a panel is spanning. void dvz_panel_span ( DvzPanel * panel , DvzGridAxis axis , uint32_t span ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the direction to set the span span uint32_t the number of cells the panel spans dvz_panel_cell() \u00b6 Set the position of a panel within a grid. void dvz_panel_cell ( DvzPanel * panel , uint32_t row , uint32_t col ); Parameter Type Description panel DvzPanel* the panel row uint32_t the row index col uint32_t the column index dvz_panel_transpose() \u00b6 Set the coordinate system transposition (order and direction of the 3 xyz axes). void dvz_panel_transpose ( DvzPanel * panel , DvzCDSTranspose transpose ); Parameter Type Description panel DvzPanel* the panel transpose DvzCDSTranspose the transposition mode dvz_panel_contains() \u00b6 Returns whether a point is contained in a panel. bool dvz_panel_contains ( DvzPanel * panel , vec2 pos ); Parameter Type Description panel DvzPanel* the panel pos vec2 the position returns bool boolean dvz_panel_at() \u00b6 Return the panel at a given position within the canvas. DvzPanel * dvz_panel_at ( DvzGrid * grid , vec2 pos ); Parameter Type Description grid DvzGrid* the grid pos vec2 the position in screen coordinates (pixels) returns DvzPanel* panel dvz_panel_destroy() \u00b6 Destroy a panel and all visuals inside it. void dvz_panel_destroy ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel dvz_panel_viewport() \u00b6 Return the viewport of a panel. DvzViewport dvz_panel_viewport ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzViewport viewport Colormaps \u00b6 dvz_colormap() \u00b6 Fetch a color from a colormap and a value. void dvz_colormap ( DvzColormap cmap , uint8_t value , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value color cvec4 the fetched color dvz_colormap_idx() \u00b6 Get the texture integer coordinates corresponding to a colormap and value. void dvz_colormap_idx ( DvzColormap cmap , uint8_t value , cvec2 out ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value out cvec2 the colormap coordinates within the texture dvz_colormap_uv() \u00b6 Get the texture normalized coordinates corresponding to a colormap and value. void dvz_colormap_uv ( DvzColormap cmap , uint8_t value , vec2 uv ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value uv vec2 the colormap coordinates within the texture dvz_colormap_scale() \u00b6 Fetch a color from a colormap and an interpolated value. void dvz_colormap_scale ( DvzColormap cmap , double value , double vmin , double vmax , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value double the value vmin double the minimum value vmax double the maximum value color cvec4 the fetched color dvz_colormap_array() \u00b6 Fetch colors from a colormap and an array of values. void dvz_colormap_array ( DvzColormap cmap , uint32_t count , double * values , double vmin , double vmax , cvec4 * out ); Parameter Type Description cmap DvzColormap the colormap count uint32_t the number of values values double* pointer to the array of double numbers vmin double the minimum value vmax double the maximum value out cvec4* the fetched colors dvz_colormap_packuv() \u00b6 Pack an arbitrary RGB color into a special uv texture coordinates void dvz_colormap_packuv ( cvec3 color , vec2 uv ); Parameter Type Description color cvec3 the RGB color uv vec2 the texture coordinates This is used by the mesh visual, that only accepts texture coordinates in its vertices. When setting the first texture coordinate to -1, the second coordinate, a float, is used to unpack 3 uint8_t RGB values. It only works because integers up to 2^24 can be represented exactly with float32. dvz_colormap_extent() \u00b6 Get the tex coords extent of a colormap. void dvz_colormap_extent ( DvzColormap cmap , vec4 uvuv ); Parameter Type Description cmap DvzColormap the colormap uvuv vec4 the texture coordinates of the upper-left and lower-right corners","title":"Scene API"},{"location":"api/scene/#scene-api","text":"","title":"Scene API"},{"location":"api/scene/#app-canvas-main-loop","text":"","title":"App, canvas, main loop"},{"location":"api/scene/#dvz_app","text":"Create an application instance. DvzApp * dvz_app ( DvzBackend backend ); Parameter Type Description backend DvzBackend the backend returns DvzApp* pointer to the created app There is typically only one App object in a given application. This object holds a pointer to the Vulkan instance and is responsible for discovering the available GPUs.","title":"dvz_app()"},{"location":"api/scene/#dvz_canvas","text":"Create a canvas. DvzCanvas * dvz_canvas ( DvzGpu * gpu , uint32_t width , uint32_t height , int flags ); Parameter Type Description gpu DvzGpu* the GPU to use for swapchain presentation width uint32_t the initial window width, in pixels height uint32_t the initial window height, in pixels flags int the creation flags for the canvas","title":"dvz_canvas()"},{"location":"api/scene/#dvz_canvas_offscreen","text":"Create an offscreen canvas. DvzCanvas * dvz_canvas_offscreen ( DvzGpu * gpu , uint32_t width , uint32_t height , int flags ); Parameter Type Description gpu DvzGpu* the GPU to use for swapchain presentation width uint32_t the canvas width, in pixels height uint32_t the canvas height, in pixels flags int the creation flags for the canvas","title":"dvz_canvas_offscreen()"},{"location":"api/scene/#dvz_canvas_dpi_scaling","text":"Set the DPI scaling factor of a canvas. void dvz_canvas_dpi_scaling ( DvzCanvas * canvas , float scaling ); Parameter Type Description canvas DvzCanvas* the canvas scaling float the scaling factor","title":"dvz_canvas_dpi_scaling()"},{"location":"api/scene/#dvz_scene","text":"Create a scene with a grid layout. DvzScene * dvz_scene ( DvzCanvas * canvas , uint32_t n_rows , uint32_t n_cols ); Parameter Type Description canvas DvzCanvas* the canvas n_rows uint32_t number of rows in the grid n_cols uint32_t number of columns in the grid returns DvzScene* pointer to the created scene The scene defines a 2D grid where each cell contains a panel (subplot). Panels may support various kinds of interactivity.","title":"dvz_scene()"},{"location":"api/scene/#dvz_app_run","text":"Start the main event loop. void dvz_app_run ( DvzApp * app , uint64_t frame_count ); Parameter Type Description app DvzApp* the app frame_count uint64_t number of frames to process (0 for infinite loop) Every loop iteration processes one frame of all open canvases.","title":"dvz_app_run()"},{"location":"api/scene/#dvz_scene_destroy","text":"Destroy a scene. void dvz_scene_destroy ( DvzScene * scene ); Parameter Type Description scene DvzScene* the scene Destroy all panels and visuals in the scene.","title":"dvz_scene_destroy()"},{"location":"api/scene/#dvz_canvas_destroy","text":"Destroy a canvas. void dvz_canvas_destroy ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas","title":"dvz_canvas_destroy()"},{"location":"api/scene/#dvz_app_destroy","text":"Destroy the application. int dvz_app_destroy ( DvzApp * app ); Parameter Type Description app DvzApp* the application to destroy This function automatically destroys all objects created within the application.","title":"dvz_app_destroy()"},{"location":"api/scene/#set-panels-add-visuals","text":"","title":"Set panels, add visuals"},{"location":"api/scene/#dvz_scene_panel","text":"Add a panel to the scene grid. DvzPanel * dvz_scene_panel ( DvzScene * scene , uint32_t row , uint32_t col , DvzControllerType type , int flags ); Parameter Type Description controller None the scene row uint32_t the row index (0-based) col uint32_t the column index (0-based) type DvzControllerType the controller type flags int flags for the builtin controller returns DvzPanel* panel","title":"dvz_scene_panel()"},{"location":"api/scene/#dvz_scene_visual","text":"Create a builtin visual and add it to a panel. DvzVisual * dvz_scene_visual ( DvzPanel * panel , DvzVisualType type , int flags ); Parameter Type Description panel DvzPanel* the panel type DvzVisualType the type of visual flags int flags for the builtin visual returns DvzVisual* visual","title":"dvz_scene_visual()"},{"location":"api/scene/#custom-visuals-and-graphics","text":"","title":"Custom visuals and graphics"},{"location":"api/scene/#dvz_blank_graphics","text":"Create a blank graphics (used when creating custom graphics and visuals). DvzGraphics * dvz_blank_graphics ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int graphics flags returns DvzGraphics* blank graphics","title":"dvz_blank_graphics()"},{"location":"api/scene/#dvz_custom_graphics","text":"Make a custom graphics and add it to a visual. void dvz_custom_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* a visual graphics DvzGraphics* the custom graphics","title":"dvz_custom_graphics()"},{"location":"api/scene/#dvz_blank_visual","text":"Create a blank visual (used when creating custom visuals). DvzVisual * dvz_blank_visual ( DvzScene * scene , int flags ); Parameter Type Description scene DvzScene* the scene flags int visual flags returns DvzVisual* blank visual","title":"dvz_blank_visual()"},{"location":"api/scene/#dvz_custom_visual","text":"Make a custom visual and add it to a panel. void dvz_custom_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the custom visual","title":"dvz_custom_visual()"},{"location":"api/scene/#grid-and-panels","text":"","title":"Grid and panels"},{"location":"api/scene/#dvz_grid","text":"Create a grid of panels. DvzGrid dvz_grid ( DvzCanvas * canvas , uint32_t row_count , uint32_t col_count ); Parameter Type Description canvas DvzCanvas* the canvas row_count uint32_t the number of rows col_count uint32_t the number of columns returns DvzGrid grid object","title":"dvz_grid()"},{"location":"api/scene/#dvz_grid_destroy","text":"Destroy a grid. void dvz_grid_destroy ( DvzGrid * grid ); Parameter Type Description grid DvzGrid* the grid","title":"dvz_grid_destroy()"},{"location":"api/scene/#dvz_panel","text":"Create a panel at a given location in a grid. DvzPanel * dvz_panel ( DvzGrid * grid , uint32_t row , uint32_t col ); Parameter Type Description grid DvzGrid* the grid row uint32_t the row index in the grid col uint32_t the column index in the grid returns DvzPanel* panel","title":"dvz_panel()"},{"location":"api/scene/#dvz_panel_update","text":"Update a panel viewport. void dvz_panel_update ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel","title":"dvz_panel_update()"},{"location":"api/scene/#dvz_panel_margins","text":"Set panel margins. void dvz_panel_margins ( DvzPanel * panel , vec4 margins ); Parameter Type Description panel DvzPanel* the panel margins vec4 the margins, in pixels Margins are represented as a vec4 vector: top, right, bottom, left.","title":"dvz_panel_margins()"},{"location":"api/scene/#dvz_panel_unit","text":"Set the unit in which the panel size is specified. void dvz_panel_unit ( DvzPanel * panel , DvzPanelSizeUnit unit ); Parameter Type Description panel DvzPanel* the panel unit DvzPanelSizeUnit the unit","title":"dvz_panel_unit()"},{"location":"api/scene/#dvz_panel_mode","text":"Set the panel mode (grid or detached). void dvz_panel_mode ( DvzPanel * panel , DvzPanelMode mode ); Parameter Type Description panel DvzPanel* the panel mode DvzPanelMode the mode","title":"dvz_panel_mode()"},{"location":"api/scene/#dvz_panel_visual","text":"Add a visual to a panel. void dvz_panel_visual ( DvzPanel * panel , DvzVisual * visual ); Parameter Type Description panel DvzPanel* the panel visual DvzVisual* the visual","title":"dvz_panel_visual()"},{"location":"api/scene/#dvz_panel_pos","text":"Set a panel position (in detached mode). void dvz_panel_pos ( DvzPanel * panel , float x , float y ); Parameter Type Description panel DvzPanel* the panel x float the position y float the position The unit in which the coordinates are specified is controller by dvz_panel_unit() .","title":"dvz_panel_pos()"},{"location":"api/scene/#dvz_panel_size","text":"Set a panel size (in detached mode). void dvz_panel_size ( DvzPanel * panel , DvzGridAxis axis , float size ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the axis on which to specify the size size float the size The unit in which the size is specified is controller by dvz_panel_unit() .","title":"dvz_panel_size()"},{"location":"api/scene/#dvz_panel_span","text":"Set the number of cells a panel is spanning. void dvz_panel_span ( DvzPanel * panel , DvzGridAxis axis , uint32_t span ); Parameter Type Description panel DvzPanel* the panel axis DvzGridAxis the direction to set the span span uint32_t the number of cells the panel spans","title":"dvz_panel_span()"},{"location":"api/scene/#dvz_panel_cell","text":"Set the position of a panel within a grid. void dvz_panel_cell ( DvzPanel * panel , uint32_t row , uint32_t col ); Parameter Type Description panel DvzPanel* the panel row uint32_t the row index col uint32_t the column index","title":"dvz_panel_cell()"},{"location":"api/scene/#dvz_panel_transpose","text":"Set the coordinate system transposition (order and direction of the 3 xyz axes). void dvz_panel_transpose ( DvzPanel * panel , DvzCDSTranspose transpose ); Parameter Type Description panel DvzPanel* the panel transpose DvzCDSTranspose the transposition mode","title":"dvz_panel_transpose()"},{"location":"api/scene/#dvz_panel_contains","text":"Returns whether a point is contained in a panel. bool dvz_panel_contains ( DvzPanel * panel , vec2 pos ); Parameter Type Description panel DvzPanel* the panel pos vec2 the position returns bool boolean","title":"dvz_panel_contains()"},{"location":"api/scene/#dvz_panel_at","text":"Return the panel at a given position within the canvas. DvzPanel * dvz_panel_at ( DvzGrid * grid , vec2 pos ); Parameter Type Description grid DvzGrid* the grid pos vec2 the position in screen coordinates (pixels) returns DvzPanel* panel","title":"dvz_panel_at()"},{"location":"api/scene/#dvz_panel_destroy","text":"Destroy a panel and all visuals inside it. void dvz_panel_destroy ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel","title":"dvz_panel_destroy()"},{"location":"api/scene/#dvz_panel_viewport","text":"Return the viewport of a panel. DvzViewport dvz_panel_viewport ( DvzPanel * panel ); Parameter Type Description panel DvzPanel* the panel returns DvzViewport viewport","title":"dvz_panel_viewport()"},{"location":"api/scene/#colormaps","text":"","title":"Colormaps"},{"location":"api/scene/#dvz_colormap","text":"Fetch a color from a colormap and a value. void dvz_colormap ( DvzColormap cmap , uint8_t value , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value color cvec4 the fetched color","title":"dvz_colormap()"},{"location":"api/scene/#dvz_colormap_idx","text":"Get the texture integer coordinates corresponding to a colormap and value. void dvz_colormap_idx ( DvzColormap cmap , uint8_t value , cvec2 out ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value out cvec2 the colormap coordinates within the texture","title":"dvz_colormap_idx()"},{"location":"api/scene/#dvz_colormap_uv","text":"Get the texture normalized coordinates corresponding to a colormap and value. void dvz_colormap_uv ( DvzColormap cmap , uint8_t value , vec2 uv ); Parameter Type Description cmap DvzColormap the colormap value uint8_t the value uv vec2 the colormap coordinates within the texture","title":"dvz_colormap_uv()"},{"location":"api/scene/#dvz_colormap_scale","text":"Fetch a color from a colormap and an interpolated value. void dvz_colormap_scale ( DvzColormap cmap , double value , double vmin , double vmax , cvec4 color ); Parameter Type Description cmap DvzColormap the colormap value double the value vmin double the minimum value vmax double the maximum value color cvec4 the fetched color","title":"dvz_colormap_scale()"},{"location":"api/scene/#dvz_colormap_array","text":"Fetch colors from a colormap and an array of values. void dvz_colormap_array ( DvzColormap cmap , uint32_t count , double * values , double vmin , double vmax , cvec4 * out ); Parameter Type Description cmap DvzColormap the colormap count uint32_t the number of values values double* pointer to the array of double numbers vmin double the minimum value vmax double the maximum value out cvec4* the fetched colors","title":"dvz_colormap_array()"},{"location":"api/scene/#dvz_colormap_packuv","text":"Pack an arbitrary RGB color into a special uv texture coordinates void dvz_colormap_packuv ( cvec3 color , vec2 uv ); Parameter Type Description color cvec3 the RGB color uv vec2 the texture coordinates This is used by the mesh visual, that only accepts texture coordinates in its vertices. When setting the first texture coordinate to -1, the second coordinate, a float, is used to unpack 3 uint8_t RGB values. It only works because integers up to 2^24 can be represented exactly with float32.","title":"dvz_colormap_packuv()"},{"location":"api/scene/#dvz_colormap_extent","text":"Get the tex coords extent of a colormap. void dvz_colormap_extent ( DvzColormap cmap , vec4 uvuv ); Parameter Type Description cmap DvzColormap the colormap uvuv vec4 the texture coordinates of the upper-left and lower-right corners","title":"dvz_colormap_extent()"},{"location":"api/visual/","text":"Visual API \u00b6 Visual creation and destruction \u00b6 dvz_visual() \u00b6 Create a blank visual. DvzVisual dvz_visual ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzVisual visual object dvz_visual_graphics() \u00b6 Add a graphics pipeline to a visual. void dvz_visual_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* the visual graphics DvzGraphics* the graphics dvz_visual_compute() \u00b6 Add a compute pipeline to a visual. void dvz_visual_compute ( DvzVisual * visual , DvzCompute * compute ); Parameter Type Description visual DvzVisual* the visual compute DvzCompute* the compute pipeline dvz_visual_destroy() \u00b6 Destroy a visual. void dvz_visual_destroy ( DvzVisual * visual ); Parameter Type Description visual DvzVisual* the visual This function destroys all GPU objects associated to the visual. Visual data \u00b6 dvz_visual_group() \u00b6 Define a new data group within a visual. void dvz_visual_group ( DvzVisual * visual , uint32_t group_idx , uint32_t size ); Parameter Type Description visual DvzVisual* the visual group_idx uint32_t the group index size uint32_t the number of elements in the group dvz_visual_data() \u00b6 Set the data for a given visual prop. void dvz_visual_data ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to upload data void* the data, that should be in the dtype of the prop dvz_visual_data_partial() \u00b6 Set partial data for a given visual prop. void dvz_visual_data_partial ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the prop If the specified data has less elements than the number of elements to update, the last element will be repeated as many times as necessary. dvz_visual_data_append() \u00b6 Append elements to the prop. void dvz_visual_data_append ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to append to the prop data void* the data, that should be in the dtype of the prop dvz_visual_data_source() \u00b6 Set partial data for a given source. void dvz_visual_data_source ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the source dvz_visual_buffer() \u00b6 Set an existing GPU buffer for a visual source. void dvz_visual_buffer ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzBufferRegions br ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index br DvzBufferRegions the buffer regions dvz_visual_texture() \u00b6 Set an existing GPU texture for a visual source. void dvz_visual_texture ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzTexture * texture ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index texture DvzTexture* the texture Visual sources and props \u00b6 dvz_visual_source() \u00b6 Define a new source for a visual. void dvz_visual_source ( DvzVisual * visual , DvzSourceType type , uint32_t source_idx , DvzPipelineType pipeline , uint32_t pipeline_idx , uint32_t slot_idx , VkDeviceSize item_size , int flags ); Parameter Type Description visual DvzVisual* the visual type DvzSourceType the source type source_idx uint32_t the index of the source pipeline DvzPipelineType the pipeline type pipeline_idx uint32_t the index of the pipeline slot_idx uint32_t the binding slot of the GPU object associated to the source item_size VkDeviceSize the size of every element in the source data, in bytes flags int the source creation flags Within a given visual, a source is uniquely determined by its type and index. The index is the index of the source among all sources of the same type within the visual. Within a given visual, a pipeline is uniquely determined by its type and index. The index is the index of the pipeline among all pipelines of the same type within the visual. dvz_visual_source_share() \u00b6 Set up a source share between two sources of the same type, in a given visual. void dvz_visual_source_share ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t other_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index other_idx uint32_t the index of the other source When two sources are shared, they use the same underlying data buffer. dvz_visual_prop() \u00b6 Define a new prop for a visual. DvzProp * dvz_visual_prop ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , DvzDataType dtype , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index dtype DvzDataType the data type of the prop source_type DvzSourceType the type of the source associated to the prop source_idx uint32_t the index of the source associated to the prop returns DvzProp* prop object Within a given visual, a prop is uniquely determined by its type and index. The index is the index of the prop among all props of the same type within the visual. dvz_visual_prop_default() \u00b6 Set up a default value for a prop. void dvz_visual_prop_default ( DvzProp * prop , void * default_value ); Parameter Type Description prop DvzProp* the prop default_value void* a pointer to the default value dvz_visual_prop_copy() \u00b6 Set up how a prop is copied to its associated source. void dvz_visual_prop_copy ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item dvz_visual_prop_cast() \u00b6 Set up how a prop should be cast when it is copied to its source. void dvz_visual_prop_cast ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item target_dtype DvzDataType the data type to cast to copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item Visual fill utils and callback \u00b6 dvz_visual_fill_callback() \u00b6 Set a fill callback for a visual void dvz_visual_fill_callback ( DvzVisual * visual , DvzVisualFillCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualFillCallback the fill callback Callback function signature: void(DvzVisual*, DvzVisualFillEvent) dvz_visual_fill_event() \u00b6 Call the visual fill callback. void dvz_visual_fill_event ( DvzVisual * visual , VkClearColorValue clear_color , DvzCommands * cmds , uint32_t cmd_idx , DvzViewport viewport , void * user_data ); Parameter Type Description visual DvzVisual* the visual clear_color VkClearColorValue the clear color cmds DvzCommands* the command buffers to update cmd_idx uint32_t the index of the command buffer to update viewport DvzViewport the viewport user_data void* arbitrary user data pointer dvz_visual_fill_begin() \u00b6 Begin recording a command buffer and begin the render pass. void dvz_visual_fill_begin ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index dvz_visual_fill_end() \u00b6 Stop recording a command buffer and stop the render pass. void dvz_visual_fill_end ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index dvz_visual_callback_bake() \u00b6 Set the visual bake callback function. void dvz_visual_callback_bake ( DvzVisual * visual , DvzVisualDataCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualDataCallback the bake callback function Callback function signature: void(DvzVisual*, DvzVisualDataEvent) Visual baking helpers \u00b6 dvz_source_get() \u00b6 Return a source object. DvzSource * dvz_source_get ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index returns DvzSource* source dvz_prop_get() \u00b6 Return a prop object. DvzProp * dvz_prop_get ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzProp* array dvz_prop_array() \u00b6 Return the array of a prop. DvzArray * dvz_prop_array ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzArray* array dvz_prop_size() \u00b6 Return the size of a prop array. uint32_t dvz_prop_size ( DvzProp * prop ); Parameter Type Description prop DvzProp* the prop returns uint32_t prop size dvz_prop_item() \u00b6 Return an item in a prop array. void * dvz_prop_item ( DvzProp * prop , uint32_t prop_idx ); Parameter Type Description prop DvzProp* the prop prop_idx uint32_t the prop idx returns void* pointer to the item Graphics pipeline \u00b6 dvz_graphics_callback() \u00b6 Set a graphics data callback. void dvz_graphics_callback ( DvzGraphics * graphics , DvzGraphicsCallback callback ); Parameter Type Description graphics DvzGraphics* the graphics pipeline callback DvzGraphicsCallback the callback function The callback function is called when one calls dvz_graphics_append() on that visual. It allows one to easily add graphical elements, letting the graphics handle low-level GPU implementation details (tesselation with vertices). Callback function signature: void(DvzGraphicsData*, uint32_t, const void*) dvz_graphics_data() \u00b6 Start a data collection for a graphics pipeline. DvzGraphicsData dvz_graphics_data ( DvzGraphics * graphics , DvzArray * vertices , DvzArray * indices , void * user_data ); Parameter Type Description graphics DvzGraphics* the graphics pipeline vertices DvzArray* pointer to an existing array containing vertices of the right type indices DvzArray* pointer to an existing array containing the indices user_data void* arbitrary user-provided pointer returns DvzGraphicsData graphics data object dvz_graphics_alloc() \u00b6 Allocate the graphics data object with the appropriate number of elements. void dvz_graphics_alloc ( DvzGraphicsData * data , uint32_t item_count ); Parameter Type Description data DvzGraphicsData* the graphics data object item_count uint32_t the number of graphical items dvz_graphics_append() \u00b6 Add one graphical element after the graphics data object has been properly allocated. void dvz_graphics_append ( DvzGraphicsData * data , void * item ); Parameter Type Description data DvzGraphicsData* the graphics data object item void* a pointer to an object of the appropriate graphics item type dvz_graphics_builtin() \u00b6 Create a new graphics pipeline of a given builtin type. DvzGraphics * dvz_graphics_builtin ( DvzCanvas * canvas , DvzGraphicsType type , int flags ); Parameter Type Description canvas DvzCanvas* the canvas holding the grahpics pipeline type DvzGraphicsType the graphics type flags int the creation flags for the graphics Visual internal system \u00b6 dvz_visual_update() \u00b6 Update all GPU buffers and textures from the visual props and sources. void dvz_visual_update ( DvzVisual * visual , DvzViewport viewport , DvzDataCoords coords , void * user_data ); Parameter Type Description visual DvzVisual* the visual viewport DvzViewport the viewport coords DvzDataCoords the data coordinates and transformation user_data void* arbitrary user data pointer","title":"Visual API"},{"location":"api/visual/#visual-api","text":"","title":"Visual API"},{"location":"api/visual/#visual-creation-and-destruction","text":"","title":"Visual creation and destruction"},{"location":"api/visual/#dvz_visual","text":"Create a blank visual. DvzVisual dvz_visual ( DvzCanvas * canvas ); Parameter Type Description canvas DvzCanvas* the canvas returns DvzVisual visual object","title":"dvz_visual()"},{"location":"api/visual/#dvz_visual_graphics","text":"Add a graphics pipeline to a visual. void dvz_visual_graphics ( DvzVisual * visual , DvzGraphics * graphics ); Parameter Type Description visual DvzVisual* the visual graphics DvzGraphics* the graphics","title":"dvz_visual_graphics()"},{"location":"api/visual/#dvz_visual_compute","text":"Add a compute pipeline to a visual. void dvz_visual_compute ( DvzVisual * visual , DvzCompute * compute ); Parameter Type Description visual DvzVisual* the visual compute DvzCompute* the compute pipeline","title":"dvz_visual_compute()"},{"location":"api/visual/#dvz_visual_destroy","text":"Destroy a visual. void dvz_visual_destroy ( DvzVisual * visual ); Parameter Type Description visual DvzVisual* the visual This function destroys all GPU objects associated to the visual.","title":"dvz_visual_destroy()"},{"location":"api/visual/#visual-data","text":"","title":"Visual data"},{"location":"api/visual/#dvz_visual_group","text":"Define a new data group within a visual. void dvz_visual_group ( DvzVisual * visual , uint32_t group_idx , uint32_t size ); Parameter Type Description visual DvzVisual* the visual group_idx uint32_t the group index size uint32_t the number of elements in the group","title":"dvz_visual_group()"},{"location":"api/visual/#dvz_visual_data","text":"Set the data for a given visual prop. void dvz_visual_data ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to upload data void* the data, that should be in the dtype of the prop","title":"dvz_visual_data()"},{"location":"api/visual/#dvz_visual_data_partial","text":"Set partial data for a given visual prop. void dvz_visual_data_partial ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the prop If the specified data has less elements than the number of elements to update, the last element will be repeated as many times as necessary.","title":"dvz_visual_data_partial()"},{"location":"api/visual/#dvz_visual_data_append","text":"Append elements to the prop. void dvz_visual_data_append ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , uint32_t count , void * data ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index count uint32_t the number of elements to append to the prop data void* the data, that should be in the dtype of the prop","title":"dvz_visual_data_append()"},{"location":"api/visual/#dvz_visual_data_source","text":"Set partial data for a given source. void dvz_visual_data_source ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t first_item , uint32_t item_count , uint32_t data_item_count , void * data ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index first_item uint32_t the first item to write to item_count uint32_t the number of elements to update in the source array data_item_count uint32_t the number of elements to copy from data data void* the data, that should be in the dtype of the source","title":"dvz_visual_data_source()"},{"location":"api/visual/#dvz_visual_buffer","text":"Set an existing GPU buffer for a visual source. void dvz_visual_buffer ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzBufferRegions br ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index br DvzBufferRegions the buffer regions","title":"dvz_visual_buffer()"},{"location":"api/visual/#dvz_visual_texture","text":"Set an existing GPU texture for a visual source. void dvz_visual_texture ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , DvzTexture * texture ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index texture DvzTexture* the texture","title":"dvz_visual_texture()"},{"location":"api/visual/#visual-sources-and-props","text":"","title":"Visual sources and props"},{"location":"api/visual/#dvz_visual_source","text":"Define a new source for a visual. void dvz_visual_source ( DvzVisual * visual , DvzSourceType type , uint32_t source_idx , DvzPipelineType pipeline , uint32_t pipeline_idx , uint32_t slot_idx , VkDeviceSize item_size , int flags ); Parameter Type Description visual DvzVisual* the visual type DvzSourceType the source type source_idx uint32_t the index of the source pipeline DvzPipelineType the pipeline type pipeline_idx uint32_t the index of the pipeline slot_idx uint32_t the binding slot of the GPU object associated to the source item_size VkDeviceSize the size of every element in the source data, in bytes flags int the source creation flags Within a given visual, a source is uniquely determined by its type and index. The index is the index of the source among all sources of the same type within the visual. Within a given visual, a pipeline is uniquely determined by its type and index. The index is the index of the pipeline among all pipelines of the same type within the visual.","title":"dvz_visual_source()"},{"location":"api/visual/#dvz_visual_source_share","text":"Set up a source share between two sources of the same type, in a given visual. void dvz_visual_source_share ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx , uint32_t other_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index other_idx uint32_t the index of the other source When two sources are shared, they use the same underlying data buffer.","title":"dvz_visual_source_share()"},{"location":"api/visual/#dvz_visual_prop","text":"Define a new prop for a visual. DvzProp * dvz_visual_prop ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx , DvzDataType dtype , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index dtype DvzDataType the data type of the prop source_type DvzSourceType the type of the source associated to the prop source_idx uint32_t the index of the source associated to the prop returns DvzProp* prop object Within a given visual, a prop is uniquely determined by its type and index. The index is the index of the prop among all props of the same type within the visual.","title":"dvz_visual_prop()"},{"location":"api/visual/#dvz_visual_prop_default","text":"Set up a default value for a prop. void dvz_visual_prop_default ( DvzProp * prop , void * default_value ); Parameter Type Description prop DvzProp* the prop default_value void* a pointer to the default value","title":"dvz_visual_prop_default()"},{"location":"api/visual/#dvz_visual_prop_copy","text":"Set up how a prop is copied to its associated source. void dvz_visual_prop_copy ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item","title":"dvz_visual_prop_copy()"},{"location":"api/visual/#dvz_visual_prop_cast","text":"Set up how a prop should be cast when it is copied to its source. void dvz_visual_prop_cast ( DvzProp * prop , uint32_t field_idx , VkDeviceSize offset , DvzDataType target_dtype , DvzArrayCopyType copy_type , uint32_t reps ); Parameter Type Description prop DvzProp* the prop field_idx uint32_t the index of the corresponding struct field in the source offset VkDeviceSize the offset within each source item target_dtype DvzDataType the data type to cast to copy_type DvzArrayCopyType the type of copy reps uint32_t the number of repeats for each copied item","title":"dvz_visual_prop_cast()"},{"location":"api/visual/#visual-fill-utils-and-callback","text":"","title":"Visual fill utils and callback"},{"location":"api/visual/#dvz_visual_fill_callback","text":"Set a fill callback for a visual void dvz_visual_fill_callback ( DvzVisual * visual , DvzVisualFillCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualFillCallback the fill callback Callback function signature: void(DvzVisual*, DvzVisualFillEvent)","title":"dvz_visual_fill_callback()"},{"location":"api/visual/#dvz_visual_fill_event","text":"Call the visual fill callback. void dvz_visual_fill_event ( DvzVisual * visual , VkClearColorValue clear_color , DvzCommands * cmds , uint32_t cmd_idx , DvzViewport viewport , void * user_data ); Parameter Type Description visual DvzVisual* the visual clear_color VkClearColorValue the clear color cmds DvzCommands* the command buffers to update cmd_idx uint32_t the index of the command buffer to update viewport DvzViewport the viewport user_data void* arbitrary user data pointer","title":"dvz_visual_fill_event()"},{"location":"api/visual/#dvz_visual_fill_begin","text":"Begin recording a command buffer and begin the render pass. void dvz_visual_fill_begin ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index","title":"dvz_visual_fill_begin()"},{"location":"api/visual/#dvz_visual_fill_end","text":"Stop recording a command buffer and stop the render pass. void dvz_visual_fill_end ( DvzCanvas * canvas , DvzCommands * cmds , uint32_t idx ); Parameter Type Description canvas DvzCanvas* the canvas cmds DvzCommands* the command buffers idx uint32_t the command buffer index","title":"dvz_visual_fill_end()"},{"location":"api/visual/#dvz_visual_callback_bake","text":"Set the visual bake callback function. void dvz_visual_callback_bake ( DvzVisual * visual , DvzVisualDataCallback callback ); Parameter Type Description visual DvzVisual* the visual callback DvzVisualDataCallback the bake callback function Callback function signature: void(DvzVisual*, DvzVisualDataEvent)","title":"dvz_visual_callback_bake()"},{"location":"api/visual/#visual-baking-helpers","text":"","title":"Visual baking helpers"},{"location":"api/visual/#dvz_source_get","text":"Return a source object. DvzSource * dvz_source_get ( DvzVisual * visual , DvzSourceType source_type , uint32_t source_idx ); Parameter Type Description visual DvzVisual* the visual source_type DvzSourceType the source type source_idx uint32_t the source index returns DvzSource* source","title":"dvz_source_get()"},{"location":"api/visual/#dvz_prop_get","text":"Return a prop object. DvzProp * dvz_prop_get ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzProp* array","title":"dvz_prop_get()"},{"location":"api/visual/#dvz_prop_array","text":"Return the array of a prop. DvzArray * dvz_prop_array ( DvzVisual * visual , DvzPropType prop_type , uint32_t prop_idx ); Parameter Type Description visual DvzVisual* the visual prop_type DvzPropType the prop type prop_idx uint32_t the prop index returns DvzArray* array","title":"dvz_prop_array()"},{"location":"api/visual/#dvz_prop_size","text":"Return the size of a prop array. uint32_t dvz_prop_size ( DvzProp * prop ); Parameter Type Description prop DvzProp* the prop returns uint32_t prop size","title":"dvz_prop_size()"},{"location":"api/visual/#dvz_prop_item","text":"Return an item in a prop array. void * dvz_prop_item ( DvzProp * prop , uint32_t prop_idx ); Parameter Type Description prop DvzProp* the prop prop_idx uint32_t the prop idx returns void* pointer to the item","title":"dvz_prop_item()"},{"location":"api/visual/#graphics-pipeline","text":"","title":"Graphics pipeline"},{"location":"api/visual/#dvz_graphics_callback","text":"Set a graphics data callback. void dvz_graphics_callback ( DvzGraphics * graphics , DvzGraphicsCallback callback ); Parameter Type Description graphics DvzGraphics* the graphics pipeline callback DvzGraphicsCallback the callback function The callback function is called when one calls dvz_graphics_append() on that visual. It allows one to easily add graphical elements, letting the graphics handle low-level GPU implementation details (tesselation with vertices). Callback function signature: void(DvzGraphicsData*, uint32_t, const void*)","title":"dvz_graphics_callback()"},{"location":"api/visual/#dvz_graphics_data","text":"Start a data collection for a graphics pipeline. DvzGraphicsData dvz_graphics_data ( DvzGraphics * graphics , DvzArray * vertices , DvzArray * indices , void * user_data ); Parameter Type Description graphics DvzGraphics* the graphics pipeline vertices DvzArray* pointer to an existing array containing vertices of the right type indices DvzArray* pointer to an existing array containing the indices user_data void* arbitrary user-provided pointer returns DvzGraphicsData graphics data object","title":"dvz_graphics_data()"},{"location":"api/visual/#dvz_graphics_alloc","text":"Allocate the graphics data object with the appropriate number of elements. void dvz_graphics_alloc ( DvzGraphicsData * data , uint32_t item_count ); Parameter Type Description data DvzGraphicsData* the graphics data object item_count uint32_t the number of graphical items","title":"dvz_graphics_alloc()"},{"location":"api/visual/#dvz_graphics_append","text":"Add one graphical element after the graphics data object has been properly allocated. void dvz_graphics_append ( DvzGraphicsData * data , void * item ); Parameter Type Description data DvzGraphicsData* the graphics data object item void* a pointer to an object of the appropriate graphics item type","title":"dvz_graphics_append()"},{"location":"api/visual/#dvz_graphics_builtin","text":"Create a new graphics pipeline of a given builtin type. DvzGraphics * dvz_graphics_builtin ( DvzCanvas * canvas , DvzGraphicsType type , int flags ); Parameter Type Description canvas DvzCanvas* the canvas holding the grahpics pipeline type DvzGraphicsType the graphics type flags int the creation flags for the graphics","title":"dvz_graphics_builtin()"},{"location":"api/visual/#visual-internal-system","text":"","title":"Visual internal system"},{"location":"api/visual/#dvz_visual_update","text":"Update all GPU buffers and textures from the visual props and sources. void dvz_visual_update ( DvzVisual * visual , DvzViewport viewport , DvzDataCoords coords , void * user_data ); Parameter Type Description visual DvzVisual* the visual viewport DvzViewport the viewport coords DvzDataCoords the data coordinates and transformation user_data void* arbitrary user data pointer","title":"dvz_visual_update()"},{"location":"api/vklite/","text":"vklite API \u00b6 GPU \u00b6 dvz_gpu() \u00b6 Initialize a GPU. DvzGpu * dvz_gpu ( DvzApp * app , uint32_t idx ); Parameter Type Description app DvzApp* the app idx uint32_t the GPU index among the system's GPUs returns DvzGpu* pointer to the created GPU object A GPU object is the interface to one of the GPUs on the current system. dvz_gpu_request_features() \u00b6 Request some features before creating the GPU instance. void dvz_gpu_request_features ( DvzGpu * gpu , VkPhysicalDeviceFeatures requested_features ); Parameter Type Description gpu DvzGpu* the GPU requested_features VkPhysicalDeviceFeatures the list of requested features This function needs to be called before creating the GPU with dvz_gpu_create() . dvz_gpu_queue() \u00b6 Request a new Vulkan queue before creating the GPU. void dvz_gpu_queue ( DvzGpu * gpu , uint32_t idx , DvzQueueType type ); Parameter Type Description gpu DvzGpu* the GPU idx uint32_t the queue index (should be regularly increasing: 0, 1, 2...) type DvzQueueType the queue type dvz_gpu_create() \u00b6 Create a GPU once the features and queues have been set up. void dvz_gpu_create ( DvzGpu * gpu , VkSurfaceKHR surface ); Parameter Type Description gpu DvzGpu* the GPU surface VkSurfaceKHR the surface on which the GPU will need to render dvz_gpu_destroy() \u00b6 Destroy the resources associated to a GPU. void dvz_gpu_destroy ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU Coarse synchronization \u00b6 dvz_queue_wait() \u00b6 Wait for a queue to be idle. void dvz_queue_wait ( DvzGpu * gpu , uint32_t queue_idx ); Parameter Type Description gpu DvzGpu* the GPU queue_idx uint32_t the queue index This is one of the different GPU synchronization methods. It is not efficient as it waits until the queue is idle. dvz_app_wait() \u00b6 Full synchronization on all GPUs. void dvz_app_wait ( DvzApp * app ); Parameter Type Description app DvzApp* the application instance This function waits on all queues of all GPUs. The strongest, least efficient of the synchronization methods. dvz_gpu_wait() \u00b6 Full synchronization on a given GPU. void dvz_gpu_wait ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU This function waits on all queues of a given GPU. Window \u00b6 dvz_window() \u00b6 Create a blank window. DvzWindow * dvz_window ( DvzApp * app , uint32_t width , uint32_t height ); Parameter Type Description app DvzApp* the application instance width uint32_t the window width, in pixels height uint32_t the window height, in pixels returns DvzWindow* window This function is rarely used on its own. A bare window offers no functionality that allows one to render to it with Vulkan. One needs a swapchain, an event loop, and so on, which are provided instead at the level of the Canvas. dvz_window_get_size() \u00b6 Get the window size, in pixels. void dvz_window_get_size ( DvzWindow * window , uint32_t * framebuffer_width , uint32_t * framebuffer_height ); Parameter Type Description window DvzWindow* the window framebuffer_width uint32_t* the width, in pixels framebuffer_height uint32_t* the height, in pixels dvz_window_poll_events() \u00b6 Process the pending windowing events by the backend (glfw by default). void dvz_window_poll_events ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window dvz_window_destroy() \u00b6 Destroy a window. void dvz_window_destroy ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window Warning This function must be imperatively called after dvz_swapchain_destroy() . Swapchain \u00b6 dvz_swapchain() \u00b6 Initialize a swapchain. DvzSwapchain dvz_swapchain ( DvzGpu * gpu , DvzWindow * window , uint32_t min_img_count ); Parameter Type Description gpu DvzGpu* the GPU window DvzWindow* the window min_img_count uint32_t the minimum acceptable number of images in the swapchain returns DvzSwapchain swapchain dvz_swapchain_format() \u00b6 Set the swapchain image format. void dvz_swapchain_format ( DvzSwapchain * swapchain , VkFormat format ); Parameter Type Description swapchain DvzSwapchain* the swapchain format VkFormat the format dvz_swapchain_present_mode() \u00b6 Set the swapchain present mode. void dvz_swapchain_present_mode ( DvzSwapchain * swapchain , VkPresentModeKHR present_mode ); Parameter Type Description swapchain DvzSwapchain* the swapchain present_mode VkPresentModeKHR the present mode dvz_swapchain_requested_size() \u00b6 Set the swapchain requested image size. void dvz_swapchain_requested_size ( DvzSwapchain * swapchain , uint32_t width , uint32_t height ); Parameter Type Description swapchain DvzSwapchain* the swapchain width uint32_t the requested width height uint32_t the requested height dvz_swapchain_create() \u00b6 Create the swapchain once it has been set up. void dvz_swapchain_create ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain dvz_swapchain_recreate() \u00b6 Recreate a swapchain (for example after a window resize). void dvz_swapchain_recreate ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain dvz_swapchain_acquire() \u00b6 Acquire a swapchain image. void dvz_swapchain_acquire ( DvzSwapchain * swapchain , DvzSemaphores * semaphores , uint32_t semaphore_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain semaphores DvzSemaphores* the set of signal semaphores semaphore_idx uint32_t the index of the semaphore to signal after image acquisition fences DvzFences* the set of signal fences fence_idx uint32_t the index of the fence to signal after image acquisition dvz_swapchain_present() \u00b6 Present a swapchain image to the screen after it has been rendered. void dvz_swapchain_present ( DvzSwapchain * swapchain , uint32_t queue_idx , DvzSemaphores * semaphores , uint32_t semaphore_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain queue_idx uint32_t the index of the present queue semaphores DvzSemaphores* the set of waiting semaphores semaphore_idx uint32_t the index of the semaphore to wait on before presentation dvz_swapchain_destroy() \u00b6 Destroy a swapchain void dvz_swapchain_destroy ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain Warning This function must imperatively be called before dvz_window_destroy() . Command buffers \u00b6 dvz_commands() \u00b6 Create a set of command buffers. DvzCommands dvz_commands ( DvzGpu * gpu , uint32_t queue , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU queue uint32_t the queue index within the GPU count uint32_t the number of command buffers to create returns DvzCommands set of command buffers dvz_cmd_begin() \u00b6 Start recording a command buffer. void dvz_cmd_begin ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to begin recording on dvz_cmd_end() \u00b6 Stop recording a command buffer. void dvz_cmd_end ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to stop the recording on dvz_cmd_reset() \u00b6 Reset a command buffer. void dvz_cmd_reset ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to reset dvz_cmd_free() \u00b6 Free a set of command buffers. void dvz_cmd_free ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers dvz_cmd_submit_sync() \u00b6 Submit a command buffer on its queue with inefficient full synchronization. void dvz_cmd_submit_sync ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to submit This function is relatively inefficient because it calls dvz_queue_wait() . dvz_commands_destroy() \u00b6 Destroy a set of command buffers. void dvz_commands_destroy ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers GPU buffer \u00b6 dvz_buffer() \u00b6 Initialize a GPU buffer. DvzBuffer dvz_buffer ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBuffer buffer dvz_buffer_size() \u00b6 Set the buffer size. void dvz_buffer_size ( DvzBuffer * buffer , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the buffer size, in bytes dvz_buffer_type() \u00b6 Set the buffer type. void dvz_buffer_type ( DvzBuffer * buffer , DvzBufferType type ); Parameter Type Description buffer DvzBuffer* the buffer type DvzBufferType the buffer type dvz_buffer_usage() \u00b6 Set the buffer usage. void dvz_buffer_usage ( DvzBuffer * buffer , VkBufferUsageFlags usage ); Parameter Type Description buffer DvzBuffer* the buffer usage VkBufferUsageFlags the buffer usage dvz_buffer_memory() \u00b6 Set the buffer memory properties. void dvz_buffer_memory ( DvzBuffer * buffer , VkMemoryPropertyFlags memory ); Parameter Type Description buffer DvzBuffer* the buffer memory VkMemoryPropertyFlags the memory properties dvz_buffer_queue_access() \u00b6 Set the buffer queue access. void dvz_buffer_queue_access ( DvzBuffer * buffer , uint32_t queue_idx ); Parameter Type Description buffer DvzBuffer* the buffer queue_idx uint32_t the queue index dvz_buffer_create() \u00b6 Create the buffer after it has been set. void dvz_buffer_create ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer dvz_buffer_resize() \u00b6 Resize a buffer. void dvz_buffer_resize ( DvzBuffer * buffer , VkDeviceSize size , DvzCommands * cmds ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the new buffer size, in bytes cmds DvzCommands* the command buffers to use for the GPU-GPU data copy transfer dvz_buffer_map() \u00b6 Memory-map a buffer. void * dvz_buffer_map ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size to map, in bytes dvz_buffer_unmap() \u00b6 Unmap a buffer. void dvz_buffer_unmap ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer dvz_buffer_download() \u00b6 Download a buffer data to the CPU. void dvz_buffer_download ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size of the region to download, in bytes data void* the buffer to download on (must be allocated with the appropriate size) dvz_buffer_upload() \u00b6 Upload data to a GPU buffer. void dvz_buffer_upload ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the buffer size, in bytes data void* the data to upload dvz_buffer_destroy() \u00b6 Destroy a buffer void dvz_buffer_destroy ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer dvz_buffer_regions() \u00b6 Create buffer regions on an existing GPU buffer. DvzBufferRegions dvz_buffer_regions ( DvzBuffer * buffer , uint32_t count , VkDeviceSize offset , VkDeviceSize size , VkDeviceSize alignment ); Parameter Type Description buffer DvzBuffer* the buffer count uint32_t the number of successive regions offset VkDeviceSize the offset within the buffer size VkDeviceSize the size of each region, in bytes alignment VkDeviceSize the alignment requirement for the region offsets dvz_buffer_regions_map() \u00b6 Map a buffer region. void * dvz_buffer_regions_map ( DvzBufferRegions * br , uint32_t idx ); Parameter Type Description br DvzBufferRegions* the buffer regions idx uint32_t the index of the buffer region to map dvz_buffer_regions_unmap() \u00b6 Unmap a set of buffer regions. void dvz_buffer_regions_unmap ( DvzBufferRegions * br ); Parameter Type Description br DvzBufferRegions* the buffer regions dvz_buffer_regions_upload() \u00b6 Upload data to a buffer region. void dvz_buffer_regions_upload ( DvzBufferRegions * br , uint32_t idx , void * data ); Parameter Type Description br DvzBufferRegions* the set of buffer regions idx uint32_t the index of the buffer region to upload data to data void* the data to upload GPU images \u00b6 dvz_images() \u00b6 Initialize a set of GPU images. DvzImages dvz_images ( DvzGpu * gpu , VkImageType type , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU type VkImageType the image type count uint32_t the number of images returns DvzImages images dvz_images_format() \u00b6 Set the images format. void dvz_images_format ( DvzImages * images , VkFormat format ); Parameter Type Description images DvzImages* the images format VkFormat the image format dvz_images_layout() \u00b6 Set the images layout. void dvz_images_layout ( DvzImages * images , VkImageLayout layout ); Parameter Type Description images DvzImages* the images layout VkImageLayout the image layout dvz_images_size() \u00b6 Set the images size. void dvz_images_size ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the image width height uint32_t the image height depth uint32_t the image depth dvz_images_tiling() \u00b6 Set the images tiling. void dvz_images_tiling ( DvzImages * images , VkImageTiling tiling ); Parameter Type Description images DvzImages* the images tiling VkImageTiling the image tiling dvz_images_usage() \u00b6 Set the images usage. void dvz_images_usage ( DvzImages * images , VkImageUsageFlags usage ); Parameter Type Description images DvzImages* the images usage VkImageUsageFlags the image usage dvz_images_memory() \u00b6 Set the images memory properties. void dvz_images_memory ( DvzImages * images , VkMemoryPropertyFlags memory ); Parameter Type Description images DvzImages* the images memory VkMemoryPropertyFlags the memory properties dvz_images_aspect() \u00b6 Set the images aspect. void dvz_images_aspect ( DvzImages * images , VkImageAspectFlags aspect ); Parameter Type Description images DvzImages* the images aspect VkImageAspectFlags the image aspect dvz_images_queue_access() \u00b6 Set the images queue access. void dvz_images_queue_access ( DvzImages * images , uint32_t queue_idx ); Parameter Type Description images DvzImages* the images queue_idx uint32_t the queue index This parameter specifies which queues may access the image from command buffers submitted to them. dvz_images_create() \u00b6 Create the images after they have been set up. void dvz_images_create ( DvzImages * images ); Parameter Type Description images DvzImages* the images dvz_images_resize() \u00b6 Resize images. void dvz_images_resize ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the new width height uint32_t the new height depth uint32_t the new depth Warning This function deletes the images contents when resizing. dvz_images_transition() \u00b6 Transition the images to their layout after creation. void dvz_images_transition ( DvzImages * images ); Parameter Type Description images DvzImages* the images This function performs a hard synchronization on the queue and submits a command buffer with the image transition. dvz_images_download() \u00b6 Download the data from a staging GPU image. void dvz_images_download ( DvzImages * staging , uint32_t idx , bool swizzle , bool has_alpha , uint8_t * out ); Parameter Type Description staging DvzImages* the images to download the data from idx uint32_t the index of the image swizzle bool whether the RGB(A) values need to be transposed has_alpha bool whether there is an Alpha component in the output buffer out uint8_t* the buffer that will be filled with the image data (must be already allocated) dvz_images_destroy() \u00b6 Destroy images. void dvz_images_destroy ( DvzImages * images ); Parameter Type Description images DvzImages* the images Sampler \u00b6 dvz_sampler() \u00b6 Initialize a texture sampler. DvzSampler dvz_sampler ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSampler sampler object dvz_sampler_min_filter() \u00b6 Set the sampler min filter. void dvz_sampler_min_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter dvz_sampler_mag_filter() \u00b6 Set the sampler mag filter. void dvz_sampler_mag_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter dvz_sampler_address_mode() \u00b6 Set the sampler address mode void dvz_sampler_address_mode ( DvzSampler * sampler , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description sampler DvzSampler* the sampler axis DvzTextureAxis the sampler axis address_mode VkSamplerAddressMode the address mode dvz_sampler_create() \u00b6 Create the sampler after it has been set up. void dvz_sampler_create ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler dvz_sampler_destroy() \u00b6 Destroy a sampler void dvz_sampler_destroy ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler Pipeline slots \u00b6 Vulkan terminology: descriptor set layout. dvz_slots() \u00b6 Initialize pipeline slots (aka Vulkan descriptor set layout). DvzSlots dvz_slots ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSlots slots dvz_slots_binding() \u00b6 Set the slots binding. void dvz_slots_binding ( DvzSlots * slots , uint32_t idx , VkDescriptorType type ); Parameter Type Description slots DvzSlots* the slots idx uint32_t the slot index to set up type VkDescriptorType the descriptor type for that slot dvz_slots_push() \u00b6 Set up push constants. void dvz_slots_push ( DvzSlots * slots , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description slots DvzSlots* the slots offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant dvz_slots_create() \u00b6 Create the slots after they have been set up. void dvz_slots_create ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots dvz_slots_destroy() \u00b6 Destroy the slots void dvz_slots_destroy ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots Pipeline bindings \u00b6 Vulkan terminology: descriptor sets dvz_bindings() \u00b6 Initialize bindings corresponding to slots. DvzBindings dvz_bindings ( DvzSlots * slots , uint32_t dset_count ); Parameter Type Description slots DvzSlots* the slots dset_count uint32_t the number of descriptor sets (number of swapchain images) dvz_bindings_buffer() \u00b6 Bind a buffer to a slot. void dvz_bindings_buffer ( DvzBindings * bindings , uint32_t idx , DvzBufferRegions br ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br DvzBufferRegions the buffer regions to bind to that slot dvz_bindings_texture() \u00b6 Bind a texture to a slot. void dvz_bindings_texture ( DvzBindings * bindings , uint32_t idx , DvzTexture * texture ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br None the texture to bind to that slot dvz_bindings_update() \u00b6 Update the bindings after the buffers/textures have been set up. void dvz_bindings_update ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings dvz_bindings_destroy() \u00b6 Destroy bindings. void dvz_bindings_destroy ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings Graphics pipeline \u00b6 dvz_graphics() \u00b6 Initialize a graphics pipeline. DvzGraphics dvz_graphics ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzGraphics graphics pipeline dvz_graphics_renderpass() \u00b6 Set the renderpass of a graphics pipeline. void dvz_graphics_renderpass ( DvzGraphics * graphics , DvzRenderpass * renderpass , uint32_t subpass ); Parameter Type Description graphics DvzGraphics* the graphics pipeline renderpass DvzRenderpass* the render pass subpass uint32_t the subpass index dvz_graphics_topology() \u00b6 Set the graphics pipeline primitive topology void dvz_graphics_topology ( DvzGraphics * graphics , VkPrimitiveTopology topology ); Parameter Type Description graphics DvzGraphics* the graphics pipeline topology VkPrimitiveTopology the primitive topology dvz_graphics_shader_glsl() \u00b6 Set the GLSL code of a graphics pipeline. void dvz_graphics_shader_glsl ( DvzGraphics * graphics , VkShaderStageFlagBits stage , char * code ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage code char* the GLSL code of the shader dvz_graphics_shader_spirv() \u00b6 Set the SPIRV code of a graphics pipeline. void dvz_graphics_shader_spirv ( DvzGraphics * graphics , VkShaderStageFlagBits stage , VkDeviceSize size , uint32_t * buffer ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage size VkDeviceSize the size of the SPIRV buffer, in bytes buffer uint32_t* the binary buffer with the SPIRV code dvz_graphics_shader() \u00b6 Set the path to a shader for a graphics pipeline. void dvz_graphics_shader ( DvzGraphics * graphics , VkShaderStageFlagBits stage , char * shader_path ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage shader_path char* the path to the .spirv shader file dvz_graphics_vertex_binding() \u00b6 Set the vertex binding. void dvz_graphics_vertex_binding ( DvzGraphics * graphics , uint32_t binding , VkDeviceSize stride ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index stride VkDeviceSize the stride in the vertex buffer, in bytes dvz_graphics_vertex_attr() \u00b6 Add a vertex attribute. void dvz_graphics_vertex_attr ( DvzGraphics * graphics , uint32_t binding , uint32_t location , VkFormat format , VkDeviceSize offset ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index (as specified in the vertex shader) location uint32_t the location index (as specified in the vertex shader) format VkFormat the format offset VkDeviceSize the offset, in bytes dvz_graphics_blend() \u00b6 Set the graphics blend type. void dvz_graphics_blend ( DvzGraphics * graphics , DvzBlendType blend_type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline blend_type DvzBlendType the blend type dvz_graphics_depth_test() \u00b6 Set the graphics depth test. void dvz_graphics_depth_test ( DvzGraphics * graphics , DvzDepthTest depth_test ); Parameter Type Description graphics DvzGraphics* the graphics pipeline depth_test DvzDepthTest the depth test dvz_graphics_polygon_mode() \u00b6 Set the graphics polygon mode. void dvz_graphics_polygon_mode ( DvzGraphics * graphics , VkPolygonMode polygon_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline polygon_mode VkPolygonMode the polygon mode dvz_graphics_cull_mode() \u00b6 Set the graphics cull mode. void dvz_graphics_cull_mode ( DvzGraphics * graphics , VkCullModeFlags cull_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline cull_mode VkCullModeFlags the cull mode dvz_graphics_front_face() \u00b6 Set the graphics front face. void dvz_graphics_front_face ( DvzGraphics * graphics , VkFrontFace front_face ); Parameter Type Description graphics DvzGraphics* the graphics pipeline front_face VkFrontFace the front face dvz_graphics_create() \u00b6 Create a graphics pipeline after it has been set up. void dvz_graphics_create ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline dvz_graphics_slot() \u00b6 Set a binding slot for a graphics pipeline. void dvz_graphics_slot ( DvzGraphics * graphics , uint32_t idx , VkDescriptorType type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type dvz_graphics_push() \u00b6 Set a graphics pipeline push constant. void dvz_graphics_push ( DvzGraphics * graphics , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description graphics DvzGraphics* the graphics pipeline offset VkDeviceSize the push constant offset, in bytes offset VkDeviceSize the push size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant dvz_graphics_destroy() \u00b6 Destroy a graphics pipeline. void dvz_graphics_destroy ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline Compute pipeline \u00b6 dvz_compute() \u00b6 Initialize a compute pipeline. DvzCompute dvz_compute ( DvzGpu * gpu , char * shader_path ); Parameter Type Description gpu DvzGpu* the GPU shader_path char* (optional) the path to the .spirv file with the compute shader returns DvzCompute compute pipeline dvz_compute_create() \u00b6 Create a compute pipeline after it has been set up. void dvz_compute_create ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline dvz_compute_code() \u00b6 Set the GLSL code directly (the library will compile it automatically to SPIRV). void dvz_compute_code ( DvzCompute * compute , char * code ); Parameter Type Description compute DvzCompute* the compute pipeline code char* the GLSL code defining the compute shader dvz_compute_slot() \u00b6 Declare a slot for the compute pipeline. void dvz_compute_slot ( DvzCompute * compute , uint32_t idx , VkDescriptorType type ); Parameter Type Description compute DvzCompute* the compute pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type dvz_compute_push() \u00b6 Set up push constant. void dvz_compute_push ( DvzCompute * compute , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description compute DvzCompute* the compute pipeline offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shaders that will need to access the push constant dvz_compute_bindings() \u00b6 Associate a bindings object to a compute pipeline. void dvz_compute_bindings ( DvzCompute * compute , DvzBindings * bindings ); Parameter Type Description compute DvzCompute* the compute pipeline bindings DvzBindings* the bindings dvz_compute_destroy() \u00b6 Destroy a compute pipeline. void dvz_compute_destroy ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline Barrier \u00b6 dvz_barrier() \u00b6 Initialize a synchronization barrier (usedwithin a command buffer). DvzBarrier dvz_barrier ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBarrier barrier dvz_barrier_stages() \u00b6 Set the barrier stages. void dvz_barrier_stages ( DvzBarrier * barrier , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description barrier DvzBarrier* the barrier src_stage VkPipelineStageFlags the source stage dst_stage VkPipelineStageFlags the destination stage dvz_barrier_buffer() \u00b6 Set the barrier buffer. void dvz_barrier_buffer ( DvzBarrier * barrier , DvzBufferRegions br ); Parameter Type Description barrier DvzBarrier* the barrier br DvzBufferRegions the buffer regions dvz_barrier_buffer_queue() \u00b6 Set the barrier buffer queue. void dvz_barrier_buffer_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index dvz_barrier_buffer_access() \u00b6 Set the barrier buffer access. void dvz_barrier_buffer_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags dvz_barrier_images() \u00b6 Set the barrier images. void dvz_barrier_images ( DvzBarrier * barrier , DvzImages * images ); Parameter Type Description barrier DvzBarrier* the barrier images DvzImages* the images dvz_barrier_images_layout() \u00b6 Set the barrier images layout. void dvz_barrier_images_layout ( DvzBarrier * barrier , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description barrier DvzBarrier* the barrier src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout dvz_barrier_images_queue() \u00b6 Set the barrier images queue. void dvz_barrier_images_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index dvz_barrier_images_access() \u00b6 Set the barrier images access. void dvz_barrier_images_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags Semaphores \u00b6 dvz_semaphores() \u00b6 Initialize a set of semaphores (GPU-GPU synchronization). DvzSemaphores dvz_semaphores ( DvzGpu * gpu , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of semaphores returns DvzSemaphores semaphores dvz_semaphores_destroy() \u00b6 Destroy semaphores. void dvz_semaphores_destroy ( DvzSemaphores * semaphores ); Parameter Type Description semaphores DvzSemaphores* the semaphores Fences \u00b6 dvz_fences() \u00b6 Initialize a set of fences (CPU-GPU synchronization). DvzFences dvz_fences ( DvzGpu * gpu , uint32_t count , bool signaled ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of fences signaled bool whether the fences are created in the signaled state or not returns DvzFences fences dvz_fences_copy() \u00b6 Copy a fence from a set of fences to another. void dvz_fences_copy ( DvzFences * src_fences , uint32_t src_idx , DvzFences * dst_fences , uint32_t dst_idx ); Parameter Type Description src_fences DvzFences* the source fences src_idx uint32_t the fence index within the source fences dst_fences DvzFences* the destination fences dst_idx uint32_t the fence index within the destination fences dvz_fences_wait() \u00b6 Wait on the GPU until a fence is signaled. void dvz_fences_wait ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index dvz_fences_ready() \u00b6 Return whether a fence is ready. bool dvz_fences_ready ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index dvz_fences_reset() \u00b6 Rset the state of a fence. void dvz_fences_reset ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index dvz_fences_destroy() \u00b6 Destroy fences. void dvz_fences_destroy ( DvzFences * fences ); Parameter Type Description fences DvzFences* the fences Renderpass \u00b6 dvz_renderpass() \u00b6 Initialize a render pass. DvzRenderpass dvz_renderpass ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzRenderpass render pass dvz_renderpass_clear() \u00b6 Set the clear value of a render pass. void dvz_renderpass_clear ( DvzRenderpass * renderpass , VkClearValue value ); Parameter Type Description renderpass DvzRenderpass* the render pass value VkClearValue the clear value dvz_renderpass_attachment() \u00b6 Specify a render pass attachment. void dvz_renderpass_attachment ( DvzRenderpass * renderpass , uint32_t idx , DvzRenderpassAttachmentType type , VkFormat format , VkImageLayout ref_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index type DvzRenderpassAttachmentType the attachment type format VkFormat the attachment image format ref_layout VkImageLayout the image layout dvz_renderpass_attachment_layout() \u00b6 Set the attachment layout. void dvz_renderpass_attachment_layout ( DvzRenderpass * renderpass , uint32_t idx , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout dvz_renderpass_attachment_ops() \u00b6 Set the attachment load and store operations. void dvz_renderpass_attachment_ops ( DvzRenderpass * renderpass , uint32_t idx , VkAttachmentLoadOp load_op , VkAttachmentStoreOp store_op ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index load_op VkAttachmentLoadOp the load operation store_op VkAttachmentStoreOp the store operation dvz_renderpass_subpass_attachment() \u00b6 Set a subpass attachment. void dvz_renderpass_subpass_attachment ( DvzRenderpass * renderpass , uint32_t subpass_idx , uint32_t attachment_idx ); Parameter Type Description renderpass DvzRenderpass* the render pass subpass_idx uint32_t the subpass index attachment_idx uint32_t the attachment index dvz_renderpass_subpass_dependency() \u00b6 Set a subpass dependency. void dvz_renderpass_subpass_dependency ( DvzRenderpass * renderpass , uint32_t dependency_idx , uint32_t src_subpass , uint32_t dst_subpass ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_subpass uint32_t the source subpass index dst_subpass uint32_t the destination subpass index dvz_renderpass_subpass_dependency_access() \u00b6 Set a subpass dependency access. void dvz_renderpass_subpass_dependency_access ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destinationaccess flags dvz_renderpass_subpass_dependency_stage() \u00b6 Set a subpass dependency stage. void dvz_renderpass_subpass_dependency_stage ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_stage VkPipelineStageFlags the source pipeline stages dst_stage VkPipelineStageFlags the destination pipeline stages dvz_renderpass_create() \u00b6 Create a render pass after it has been set up. void dvz_renderpass_create ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass dvz_renderpass_destroy() \u00b6 Destroy a render pass. void dvz_renderpass_destroy ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass Framebuffers \u00b6 dvz_framebuffers() \u00b6 Initialize a set of framebuffers. DvzFramebuffers dvz_framebuffers ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzFramebuffers framebuffers dvz_framebuffers_attachment() \u00b6 Set framebuffers attachment. void dvz_framebuffers_attachment ( DvzFramebuffers * framebuffers , uint32_t attachment_idx , DvzImages * images ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers attachment_idx uint32_t the attachment index images DvzImages* the images dvz_framebuffers_create() \u00b6 Create a set of framebuffers after it has been set up. void dvz_framebuffers_create ( DvzFramebuffers * framebuffers , DvzRenderpass * renderpass ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers renderpass DvzRenderpass* the render pass dvz_framebuffers_destroy() \u00b6 Destroy a set of framebuffers. void dvz_framebuffers_destroy ( DvzFramebuffers * framebuffers ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers Submit \u00b6 dvz_submit() \u00b6 Create a submit object, used to submit command buffers to a GPU queue. DvzSubmit dvz_submit ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSubmit submit dvz_submit_commands() \u00b6 Set the command buffers to submit. void dvz_submit_commands ( DvzSubmit * submit , DvzCommands * commands ); Parameter Type Description submit DvzSubmit* the submit object cmds None the set of command buffers dvz_submit_wait_semaphores() \u00b6 Set the wait semaphores void dvz_submit_wait_semaphores ( DvzSubmit * submit , VkPipelineStageFlags stage , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object stage VkPipelineStageFlags the pipeline stage semaphores DvzSemaphores* the set of semaphores to wait on idx uint32_t the semaphore index to wait on dvz_submit_signal_semaphores() \u00b6 Set the signal semaphores void dvz_submit_signal_semaphores ( DvzSubmit * submit , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object semaphores DvzSemaphores* the set of semaphores to signal after the commands have completed idx uint32_t the semaphore index to signal dvz_submit_send() \u00b6 Submit the command buffers to their queue. void dvz_submit_send ( DvzSubmit * submit , uint32_t cmd_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description submit DvzSubmit* the submit object cmd_idx uint32_t the command buffer index to submit fences DvzFences* the fences to signal after completion fence_idx uint32_t the fence index to signal dvz_submit_reset() \u00b6 Reset a submit object. void dvz_submit_reset ( DvzSubmit * submit ); Parameter Type Description submit DvzSubmit* the submit object Command buffer recording \u00b6 dvz_cmd_begin_renderpass() \u00b6 Begin a render pass. void dvz_cmd_begin_renderpass ( DvzCommands * cmds , uint32_t idx , DvzRenderpass * renderpass , DvzFramebuffers * framebuffers ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record renderpass DvzRenderpass* the render pass framebuffers DvzFramebuffers* the framebuffers dvz_cmd_end_renderpass() \u00b6 End a render pass. void dvz_cmd_end_renderpass ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record dvz_cmd_compute() \u00b6 Launch a compute task. void dvz_cmd_compute ( DvzCommands * cmds , uint32_t idx , DvzCompute * compute , uvec3 size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record compute DvzCompute* the computer pipeline size uvec3 the task shape dvz_cmd_barrier() \u00b6 Register a barrier. void dvz_cmd_barrier ( DvzCommands * cmds , uint32_t idx , DvzBarrier * barrier ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record barrier DvzBarrier* the barrier dvz_cmd_copy_buffer_to_image() \u00b6 Copy a GPU buffer to a GPU image. void dvz_cmd_copy_buffer_to_image ( DvzCommands * cmds , uint32_t idx , DvzBuffer * buffer , DvzImages * images ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record buffer DvzBuffer* the buffer images DvzImages* the image dvz_cmd_copy_image_to_buffer() \u00b6 Copy a GPU image to a GPU buffer. void dvz_cmd_copy_image_to_buffer ( DvzCommands * cmds , uint32_t idx , DvzImages * images , DvzBuffer * buffer ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record images DvzImages* the image buffer DvzBuffer* the buffer dvz_cmd_copy_image() \u00b6 Copy a GPU image to another. void dvz_cmd_copy_image ( DvzCommands * cmds , uint32_t idx , DvzImages * src_img , DvzImages * dst_img ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_img DvzImages* the source image dst_img DvzImages* the destination image dvz_cmd_viewport() \u00b6 Set the viewport. void dvz_cmd_viewport ( DvzCommands * cmds , uint32_t idx , VkViewport viewport ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record viewport VkViewport the viewport dvz_cmd_bind_graphics() \u00b6 Bind a graphics pipeline. void dvz_cmd_bind_graphics ( DvzCommands * cmds , uint32_t idx , DvzGraphics * graphics , DvzBindings * bindings , uint32_t dynamic_idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record graphics DvzGraphics* the graphics pipeline bindings DvzBindings* the bindings associated to the pipeline dynamic_idx uint32_t the dynamic uniform buffer index dvz_cmd_bind_vertex_buffer() \u00b6 Bind a vertex buffer. void dvz_cmd_bind_vertex_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes dvz_cmd_bind_index_buffer() \u00b6 Bind an index buffer. void dvz_cmd_bind_index_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes dvz_cmd_draw() \u00b6 Direct draw. void dvz_cmd_draw ( DvzCommands * cmds , uint32_t idx , uint32_t first_vertex , uint32_t vertex_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_vertex uint32_t index of the first vertex vertex_count uint32_t number of vertices to draw dvz_cmd_draw_indexed() \u00b6 Direct indexed draw. void dvz_cmd_draw_indexed ( DvzCommands * cmds , uint32_t idx , uint32_t first_index , uint32_t vertex_offset , uint32_t index_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_index uint32_t index of the first index vertex_offset uint32_t offset of the vertex index_count uint32_t number of indices to draw dvz_cmd_draw_indirect() \u00b6 Indirect draw. void dvz_cmd_draw_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info dvz_cmd_draw_indexed_indirect() \u00b6 Indirect indexed draw. void dvz_cmd_draw_indexed_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info dvz_cmd_copy_buffer() \u00b6 Copy a GPU buffer to another. void dvz_cmd_copy_buffer ( DvzCommands * cmds , uint32_t idx , DvzBuffer * src_buf , VkDeviceSize src_offset , DvzBuffer * dst_buf , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_buf DvzBuffer* the source buffer src_offset VkDeviceSize the offset in the source buffer dst_buf DvzBuffer* the destination buffer, in bytes dst_offset VkDeviceSize the offset in the destination buffer, in bytes size VkDeviceSize the size of the region to copy, in bytes dvz_cmd_push() \u00b6 Push constants. void dvz_cmd_push ( DvzCommands * cmds , uint32_t idx , DvzSlots * slots , VkShaderStageFlagBits shaders , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record slots DvzSlots* the slots shaders VkShaderStageFlagBits the shader stages that have access to the push constant offset VkDeviceSize the offset in the push constant, in bytes size VkDeviceSize the size in the push constant, in bytes data void* the data to send via the push constant","title":"vklite API"},{"location":"api/vklite/#vklite-api","text":"","title":"vklite API"},{"location":"api/vklite/#gpu","text":"","title":"GPU"},{"location":"api/vklite/#dvz_gpu","text":"Initialize a GPU. DvzGpu * dvz_gpu ( DvzApp * app , uint32_t idx ); Parameter Type Description app DvzApp* the app idx uint32_t the GPU index among the system's GPUs returns DvzGpu* pointer to the created GPU object A GPU object is the interface to one of the GPUs on the current system.","title":"dvz_gpu()"},{"location":"api/vklite/#dvz_gpu_request_features","text":"Request some features before creating the GPU instance. void dvz_gpu_request_features ( DvzGpu * gpu , VkPhysicalDeviceFeatures requested_features ); Parameter Type Description gpu DvzGpu* the GPU requested_features VkPhysicalDeviceFeatures the list of requested features This function needs to be called before creating the GPU with dvz_gpu_create() .","title":"dvz_gpu_request_features()"},{"location":"api/vklite/#dvz_gpu_queue","text":"Request a new Vulkan queue before creating the GPU. void dvz_gpu_queue ( DvzGpu * gpu , uint32_t idx , DvzQueueType type ); Parameter Type Description gpu DvzGpu* the GPU idx uint32_t the queue index (should be regularly increasing: 0, 1, 2...) type DvzQueueType the queue type","title":"dvz_gpu_queue()"},{"location":"api/vklite/#dvz_gpu_create","text":"Create a GPU once the features and queues have been set up. void dvz_gpu_create ( DvzGpu * gpu , VkSurfaceKHR surface ); Parameter Type Description gpu DvzGpu* the GPU surface VkSurfaceKHR the surface on which the GPU will need to render","title":"dvz_gpu_create()"},{"location":"api/vklite/#dvz_gpu_destroy","text":"Destroy the resources associated to a GPU. void dvz_gpu_destroy ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU","title":"dvz_gpu_destroy()"},{"location":"api/vklite/#coarse-synchronization","text":"","title":"Coarse synchronization"},{"location":"api/vklite/#dvz_queue_wait","text":"Wait for a queue to be idle. void dvz_queue_wait ( DvzGpu * gpu , uint32_t queue_idx ); Parameter Type Description gpu DvzGpu* the GPU queue_idx uint32_t the queue index This is one of the different GPU synchronization methods. It is not efficient as it waits until the queue is idle.","title":"dvz_queue_wait()"},{"location":"api/vklite/#dvz_app_wait","text":"Full synchronization on all GPUs. void dvz_app_wait ( DvzApp * app ); Parameter Type Description app DvzApp* the application instance This function waits on all queues of all GPUs. The strongest, least efficient of the synchronization methods.","title":"dvz_app_wait()"},{"location":"api/vklite/#dvz_gpu_wait","text":"Full synchronization on a given GPU. void dvz_gpu_wait ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU This function waits on all queues of a given GPU.","title":"dvz_gpu_wait()"},{"location":"api/vklite/#window","text":"","title":"Window"},{"location":"api/vklite/#dvz_window","text":"Create a blank window. DvzWindow * dvz_window ( DvzApp * app , uint32_t width , uint32_t height ); Parameter Type Description app DvzApp* the application instance width uint32_t the window width, in pixels height uint32_t the window height, in pixels returns DvzWindow* window This function is rarely used on its own. A bare window offers no functionality that allows one to render to it with Vulkan. One needs a swapchain, an event loop, and so on, which are provided instead at the level of the Canvas.","title":"dvz_window()"},{"location":"api/vklite/#dvz_window_get_size","text":"Get the window size, in pixels. void dvz_window_get_size ( DvzWindow * window , uint32_t * framebuffer_width , uint32_t * framebuffer_height ); Parameter Type Description window DvzWindow* the window framebuffer_width uint32_t* the width, in pixels framebuffer_height uint32_t* the height, in pixels","title":"dvz_window_get_size()"},{"location":"api/vklite/#dvz_window_poll_events","text":"Process the pending windowing events by the backend (glfw by default). void dvz_window_poll_events ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window","title":"dvz_window_poll_events()"},{"location":"api/vklite/#dvz_window_destroy","text":"Destroy a window. void dvz_window_destroy ( DvzWindow * window ); Parameter Type Description window DvzWindow* the window Warning This function must be imperatively called after dvz_swapchain_destroy() .","title":"dvz_window_destroy()"},{"location":"api/vklite/#swapchain","text":"","title":"Swapchain"},{"location":"api/vklite/#dvz_swapchain","text":"Initialize a swapchain. DvzSwapchain dvz_swapchain ( DvzGpu * gpu , DvzWindow * window , uint32_t min_img_count ); Parameter Type Description gpu DvzGpu* the GPU window DvzWindow* the window min_img_count uint32_t the minimum acceptable number of images in the swapchain returns DvzSwapchain swapchain","title":"dvz_swapchain()"},{"location":"api/vklite/#dvz_swapchain_format","text":"Set the swapchain image format. void dvz_swapchain_format ( DvzSwapchain * swapchain , VkFormat format ); Parameter Type Description swapchain DvzSwapchain* the swapchain format VkFormat the format","title":"dvz_swapchain_format()"},{"location":"api/vklite/#dvz_swapchain_present_mode","text":"Set the swapchain present mode. void dvz_swapchain_present_mode ( DvzSwapchain * swapchain , VkPresentModeKHR present_mode ); Parameter Type Description swapchain DvzSwapchain* the swapchain present_mode VkPresentModeKHR the present mode","title":"dvz_swapchain_present_mode()"},{"location":"api/vklite/#dvz_swapchain_requested_size","text":"Set the swapchain requested image size. void dvz_swapchain_requested_size ( DvzSwapchain * swapchain , uint32_t width , uint32_t height ); Parameter Type Description swapchain DvzSwapchain* the swapchain width uint32_t the requested width height uint32_t the requested height","title":"dvz_swapchain_requested_size()"},{"location":"api/vklite/#dvz_swapchain_create","text":"Create the swapchain once it has been set up. void dvz_swapchain_create ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain","title":"dvz_swapchain_create()"},{"location":"api/vklite/#dvz_swapchain_recreate","text":"Recreate a swapchain (for example after a window resize). void dvz_swapchain_recreate ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain","title":"dvz_swapchain_recreate()"},{"location":"api/vklite/#dvz_swapchain_acquire","text":"Acquire a swapchain image. void dvz_swapchain_acquire ( DvzSwapchain * swapchain , DvzSemaphores * semaphores , uint32_t semaphore_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain semaphores DvzSemaphores* the set of signal semaphores semaphore_idx uint32_t the index of the semaphore to signal after image acquisition fences DvzFences* the set of signal fences fence_idx uint32_t the index of the fence to signal after image acquisition","title":"dvz_swapchain_acquire()"},{"location":"api/vklite/#dvz_swapchain_present","text":"Present a swapchain image to the screen after it has been rendered. void dvz_swapchain_present ( DvzSwapchain * swapchain , uint32_t queue_idx , DvzSemaphores * semaphores , uint32_t semaphore_idx ); Parameter Type Description swapchain DvzSwapchain* the swapchain queue_idx uint32_t the index of the present queue semaphores DvzSemaphores* the set of waiting semaphores semaphore_idx uint32_t the index of the semaphore to wait on before presentation","title":"dvz_swapchain_present()"},{"location":"api/vklite/#dvz_swapchain_destroy","text":"Destroy a swapchain void dvz_swapchain_destroy ( DvzSwapchain * swapchain ); Parameter Type Description swapchain DvzSwapchain* the swapchain Warning This function must imperatively be called before dvz_window_destroy() .","title":"dvz_swapchain_destroy()"},{"location":"api/vklite/#command-buffers","text":"","title":"Command buffers"},{"location":"api/vklite/#dvz_commands","text":"Create a set of command buffers. DvzCommands dvz_commands ( DvzGpu * gpu , uint32_t queue , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU queue uint32_t the queue index within the GPU count uint32_t the number of command buffers to create returns DvzCommands set of command buffers","title":"dvz_commands()"},{"location":"api/vklite/#dvz_cmd_begin","text":"Start recording a command buffer. void dvz_cmd_begin ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to begin recording on","title":"dvz_cmd_begin()"},{"location":"api/vklite/#dvz_cmd_end","text":"Stop recording a command buffer. void dvz_cmd_end ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to stop the recording on","title":"dvz_cmd_end()"},{"location":"api/vklite/#dvz_cmd_reset","text":"Reset a command buffer. void dvz_cmd_reset ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to reset","title":"dvz_cmd_reset()"},{"location":"api/vklite/#dvz_cmd_free","text":"Free a set of command buffers. void dvz_cmd_free ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers","title":"dvz_cmd_free()"},{"location":"api/vklite/#dvz_cmd_submit_sync","text":"Submit a command buffer on its queue with inefficient full synchronization. void dvz_cmd_submit_sync ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers idx uint32_t the index of the command buffer to submit This function is relatively inefficient because it calls dvz_queue_wait() .","title":"dvz_cmd_submit_sync()"},{"location":"api/vklite/#dvz_commands_destroy","text":"Destroy a set of command buffers. void dvz_commands_destroy ( DvzCommands * cmds ); Parameter Type Description cmds DvzCommands* the set of command buffers","title":"dvz_commands_destroy()"},{"location":"api/vklite/#gpu-buffer","text":"","title":"GPU buffer"},{"location":"api/vklite/#dvz_buffer","text":"Initialize a GPU buffer. DvzBuffer dvz_buffer ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBuffer buffer","title":"dvz_buffer()"},{"location":"api/vklite/#dvz_buffer_size","text":"Set the buffer size. void dvz_buffer_size ( DvzBuffer * buffer , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the buffer size, in bytes","title":"dvz_buffer_size()"},{"location":"api/vklite/#dvz_buffer_type","text":"Set the buffer type. void dvz_buffer_type ( DvzBuffer * buffer , DvzBufferType type ); Parameter Type Description buffer DvzBuffer* the buffer type DvzBufferType the buffer type","title":"dvz_buffer_type()"},{"location":"api/vklite/#dvz_buffer_usage","text":"Set the buffer usage. void dvz_buffer_usage ( DvzBuffer * buffer , VkBufferUsageFlags usage ); Parameter Type Description buffer DvzBuffer* the buffer usage VkBufferUsageFlags the buffer usage","title":"dvz_buffer_usage()"},{"location":"api/vklite/#dvz_buffer_memory","text":"Set the buffer memory properties. void dvz_buffer_memory ( DvzBuffer * buffer , VkMemoryPropertyFlags memory ); Parameter Type Description buffer DvzBuffer* the buffer memory VkMemoryPropertyFlags the memory properties","title":"dvz_buffer_memory()"},{"location":"api/vklite/#dvz_buffer_queue_access","text":"Set the buffer queue access. void dvz_buffer_queue_access ( DvzBuffer * buffer , uint32_t queue_idx ); Parameter Type Description buffer DvzBuffer* the buffer queue_idx uint32_t the queue index","title":"dvz_buffer_queue_access()"},{"location":"api/vklite/#dvz_buffer_create","text":"Create the buffer after it has been set. void dvz_buffer_create ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer","title":"dvz_buffer_create()"},{"location":"api/vklite/#dvz_buffer_resize","text":"Resize a buffer. void dvz_buffer_resize ( DvzBuffer * buffer , VkDeviceSize size , DvzCommands * cmds ); Parameter Type Description buffer DvzBuffer* the buffer size VkDeviceSize the new buffer size, in bytes cmds DvzCommands* the command buffers to use for the GPU-GPU data copy transfer","title":"dvz_buffer_resize()"},{"location":"api/vklite/#dvz_buffer_map","text":"Memory-map a buffer. void * dvz_buffer_map ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size to map, in bytes","title":"dvz_buffer_map()"},{"location":"api/vklite/#dvz_buffer_unmap","text":"Unmap a buffer. void dvz_buffer_unmap ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer","title":"dvz_buffer_unmap()"},{"location":"api/vklite/#dvz_buffer_download","text":"Download a buffer data to the CPU. void dvz_buffer_download ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the size of the region to download, in bytes data void* the buffer to download on (must be allocated with the appropriate size)","title":"dvz_buffer_download()"},{"location":"api/vklite/#dvz_buffer_upload","text":"Upload data to a GPU buffer. void dvz_buffer_upload ( DvzBuffer * buffer , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description buffer DvzBuffer* the buffer offset VkDeviceSize the offset within the buffer, in bytes size VkDeviceSize the buffer size, in bytes data void* the data to upload","title":"dvz_buffer_upload()"},{"location":"api/vklite/#dvz_buffer_destroy","text":"Destroy a buffer void dvz_buffer_destroy ( DvzBuffer * buffer ); Parameter Type Description buffer DvzBuffer* the buffer","title":"dvz_buffer_destroy()"},{"location":"api/vklite/#dvz_buffer_regions","text":"Create buffer regions on an existing GPU buffer. DvzBufferRegions dvz_buffer_regions ( DvzBuffer * buffer , uint32_t count , VkDeviceSize offset , VkDeviceSize size , VkDeviceSize alignment ); Parameter Type Description buffer DvzBuffer* the buffer count uint32_t the number of successive regions offset VkDeviceSize the offset within the buffer size VkDeviceSize the size of each region, in bytes alignment VkDeviceSize the alignment requirement for the region offsets","title":"dvz_buffer_regions()"},{"location":"api/vklite/#dvz_buffer_regions_map","text":"Map a buffer region. void * dvz_buffer_regions_map ( DvzBufferRegions * br , uint32_t idx ); Parameter Type Description br DvzBufferRegions* the buffer regions idx uint32_t the index of the buffer region to map","title":"dvz_buffer_regions_map()"},{"location":"api/vklite/#dvz_buffer_regions_unmap","text":"Unmap a set of buffer regions. void dvz_buffer_regions_unmap ( DvzBufferRegions * br ); Parameter Type Description br DvzBufferRegions* the buffer regions","title":"dvz_buffer_regions_unmap()"},{"location":"api/vklite/#dvz_buffer_regions_upload","text":"Upload data to a buffer region. void dvz_buffer_regions_upload ( DvzBufferRegions * br , uint32_t idx , void * data ); Parameter Type Description br DvzBufferRegions* the set of buffer regions idx uint32_t the index of the buffer region to upload data to data void* the data to upload","title":"dvz_buffer_regions_upload()"},{"location":"api/vklite/#gpu-images","text":"","title":"GPU images"},{"location":"api/vklite/#dvz_images","text":"Initialize a set of GPU images. DvzImages dvz_images ( DvzGpu * gpu , VkImageType type , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU type VkImageType the image type count uint32_t the number of images returns DvzImages images","title":"dvz_images()"},{"location":"api/vklite/#dvz_images_format","text":"Set the images format. void dvz_images_format ( DvzImages * images , VkFormat format ); Parameter Type Description images DvzImages* the images format VkFormat the image format","title":"dvz_images_format()"},{"location":"api/vklite/#dvz_images_layout","text":"Set the images layout. void dvz_images_layout ( DvzImages * images , VkImageLayout layout ); Parameter Type Description images DvzImages* the images layout VkImageLayout the image layout","title":"dvz_images_layout()"},{"location":"api/vklite/#dvz_images_size","text":"Set the images size. void dvz_images_size ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the image width height uint32_t the image height depth uint32_t the image depth","title":"dvz_images_size()"},{"location":"api/vklite/#dvz_images_tiling","text":"Set the images tiling. void dvz_images_tiling ( DvzImages * images , VkImageTiling tiling ); Parameter Type Description images DvzImages* the images tiling VkImageTiling the image tiling","title":"dvz_images_tiling()"},{"location":"api/vklite/#dvz_images_usage","text":"Set the images usage. void dvz_images_usage ( DvzImages * images , VkImageUsageFlags usage ); Parameter Type Description images DvzImages* the images usage VkImageUsageFlags the image usage","title":"dvz_images_usage()"},{"location":"api/vklite/#dvz_images_memory","text":"Set the images memory properties. void dvz_images_memory ( DvzImages * images , VkMemoryPropertyFlags memory ); Parameter Type Description images DvzImages* the images memory VkMemoryPropertyFlags the memory properties","title":"dvz_images_memory()"},{"location":"api/vklite/#dvz_images_aspect","text":"Set the images aspect. void dvz_images_aspect ( DvzImages * images , VkImageAspectFlags aspect ); Parameter Type Description images DvzImages* the images aspect VkImageAspectFlags the image aspect","title":"dvz_images_aspect()"},{"location":"api/vklite/#dvz_images_queue_access","text":"Set the images queue access. void dvz_images_queue_access ( DvzImages * images , uint32_t queue_idx ); Parameter Type Description images DvzImages* the images queue_idx uint32_t the queue index This parameter specifies which queues may access the image from command buffers submitted to them.","title":"dvz_images_queue_access()"},{"location":"api/vklite/#dvz_images_create","text":"Create the images after they have been set up. void dvz_images_create ( DvzImages * images ); Parameter Type Description images DvzImages* the images","title":"dvz_images_create()"},{"location":"api/vklite/#dvz_images_resize","text":"Resize images. void dvz_images_resize ( DvzImages * images , uint32_t width , uint32_t height , uint32_t depth ); Parameter Type Description images DvzImages* the images width uint32_t the new width height uint32_t the new height depth uint32_t the new depth Warning This function deletes the images contents when resizing.","title":"dvz_images_resize()"},{"location":"api/vklite/#dvz_images_transition","text":"Transition the images to their layout after creation. void dvz_images_transition ( DvzImages * images ); Parameter Type Description images DvzImages* the images This function performs a hard synchronization on the queue and submits a command buffer with the image transition.","title":"dvz_images_transition()"},{"location":"api/vklite/#dvz_images_download","text":"Download the data from a staging GPU image. void dvz_images_download ( DvzImages * staging , uint32_t idx , bool swizzle , bool has_alpha , uint8_t * out ); Parameter Type Description staging DvzImages* the images to download the data from idx uint32_t the index of the image swizzle bool whether the RGB(A) values need to be transposed has_alpha bool whether there is an Alpha component in the output buffer out uint8_t* the buffer that will be filled with the image data (must be already allocated)","title":"dvz_images_download()"},{"location":"api/vklite/#dvz_images_destroy","text":"Destroy images. void dvz_images_destroy ( DvzImages * images ); Parameter Type Description images DvzImages* the images","title":"dvz_images_destroy()"},{"location":"api/vklite/#sampler","text":"","title":"Sampler"},{"location":"api/vklite/#dvz_sampler","text":"Initialize a texture sampler. DvzSampler dvz_sampler ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSampler sampler object","title":"dvz_sampler()"},{"location":"api/vklite/#dvz_sampler_min_filter","text":"Set the sampler min filter. void dvz_sampler_min_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter","title":"dvz_sampler_min_filter()"},{"location":"api/vklite/#dvz_sampler_mag_filter","text":"Set the sampler mag filter. void dvz_sampler_mag_filter ( DvzSampler * sampler , VkFilter filter ); Parameter Type Description sampler DvzSampler* the sampler filter VkFilter the filter","title":"dvz_sampler_mag_filter()"},{"location":"api/vklite/#dvz_sampler_address_mode","text":"Set the sampler address mode void dvz_sampler_address_mode ( DvzSampler * sampler , DvzTextureAxis axis , VkSamplerAddressMode address_mode ); Parameter Type Description sampler DvzSampler* the sampler axis DvzTextureAxis the sampler axis address_mode VkSamplerAddressMode the address mode","title":"dvz_sampler_address_mode()"},{"location":"api/vklite/#dvz_sampler_create","text":"Create the sampler after it has been set up. void dvz_sampler_create ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler","title":"dvz_sampler_create()"},{"location":"api/vklite/#dvz_sampler_destroy","text":"Destroy a sampler void dvz_sampler_destroy ( DvzSampler * sampler ); Parameter Type Description sampler DvzSampler* the sampler","title":"dvz_sampler_destroy()"},{"location":"api/vklite/#pipeline-slots","text":"Vulkan terminology: descriptor set layout.","title":"Pipeline slots"},{"location":"api/vklite/#dvz_slots","text":"Initialize pipeline slots (aka Vulkan descriptor set layout). DvzSlots dvz_slots ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSlots slots","title":"dvz_slots()"},{"location":"api/vklite/#dvz_slots_binding","text":"Set the slots binding. void dvz_slots_binding ( DvzSlots * slots , uint32_t idx , VkDescriptorType type ); Parameter Type Description slots DvzSlots* the slots idx uint32_t the slot index to set up type VkDescriptorType the descriptor type for that slot","title":"dvz_slots_binding()"},{"location":"api/vklite/#dvz_slots_push","text":"Set up push constants. void dvz_slots_push ( DvzSlots * slots , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description slots DvzSlots* the slots offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant","title":"dvz_slots_push()"},{"location":"api/vklite/#dvz_slots_create","text":"Create the slots after they have been set up. void dvz_slots_create ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots","title":"dvz_slots_create()"},{"location":"api/vklite/#dvz_slots_destroy","text":"Destroy the slots void dvz_slots_destroy ( DvzSlots * slots ); Parameter Type Description slots DvzSlots* the slots","title":"dvz_slots_destroy()"},{"location":"api/vklite/#pipeline-bindings","text":"Vulkan terminology: descriptor sets","title":"Pipeline bindings"},{"location":"api/vklite/#dvz_bindings","text":"Initialize bindings corresponding to slots. DvzBindings dvz_bindings ( DvzSlots * slots , uint32_t dset_count ); Parameter Type Description slots DvzSlots* the slots dset_count uint32_t the number of descriptor sets (number of swapchain images)","title":"dvz_bindings()"},{"location":"api/vklite/#dvz_bindings_buffer","text":"Bind a buffer to a slot. void dvz_bindings_buffer ( DvzBindings * bindings , uint32_t idx , DvzBufferRegions br ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br DvzBufferRegions the buffer regions to bind to that slot","title":"dvz_bindings_buffer()"},{"location":"api/vklite/#dvz_bindings_texture","text":"Bind a texture to a slot. void dvz_bindings_texture ( DvzBindings * bindings , uint32_t idx , DvzTexture * texture ); Parameter Type Description bindings DvzBindings* the bindings idx uint32_t the slot index br None the texture to bind to that slot","title":"dvz_bindings_texture()"},{"location":"api/vklite/#dvz_bindings_update","text":"Update the bindings after the buffers/textures have been set up. void dvz_bindings_update ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings","title":"dvz_bindings_update()"},{"location":"api/vklite/#dvz_bindings_destroy","text":"Destroy bindings. void dvz_bindings_destroy ( DvzBindings * bindings ); Parameter Type Description bindings DvzBindings* the bindings","title":"dvz_bindings_destroy()"},{"location":"api/vklite/#graphics-pipeline","text":"","title":"Graphics pipeline"},{"location":"api/vklite/#dvz_graphics","text":"Initialize a graphics pipeline. DvzGraphics dvz_graphics ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzGraphics graphics pipeline","title":"dvz_graphics()"},{"location":"api/vklite/#dvz_graphics_renderpass","text":"Set the renderpass of a graphics pipeline. void dvz_graphics_renderpass ( DvzGraphics * graphics , DvzRenderpass * renderpass , uint32_t subpass ); Parameter Type Description graphics DvzGraphics* the graphics pipeline renderpass DvzRenderpass* the render pass subpass uint32_t the subpass index","title":"dvz_graphics_renderpass()"},{"location":"api/vklite/#dvz_graphics_topology","text":"Set the graphics pipeline primitive topology void dvz_graphics_topology ( DvzGraphics * graphics , VkPrimitiveTopology topology ); Parameter Type Description graphics DvzGraphics* the graphics pipeline topology VkPrimitiveTopology the primitive topology","title":"dvz_graphics_topology()"},{"location":"api/vklite/#dvz_graphics_shader_glsl","text":"Set the GLSL code of a graphics pipeline. void dvz_graphics_shader_glsl ( DvzGraphics * graphics , VkShaderStageFlagBits stage , char * code ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage code char* the GLSL code of the shader","title":"dvz_graphics_shader_glsl()"},{"location":"api/vklite/#dvz_graphics_shader_spirv","text":"Set the SPIRV code of a graphics pipeline. void dvz_graphics_shader_spirv ( DvzGraphics * graphics , VkShaderStageFlagBits stage , VkDeviceSize size , uint32_t * buffer ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage size VkDeviceSize the size of the SPIRV buffer, in bytes buffer uint32_t* the binary buffer with the SPIRV code","title":"dvz_graphics_shader_spirv()"},{"location":"api/vklite/#dvz_graphics_shader","text":"Set the path to a shader for a graphics pipeline. void dvz_graphics_shader ( DvzGraphics * graphics , VkShaderStageFlagBits stage , char * shader_path ); Parameter Type Description graphics DvzGraphics* the graphics pipeline stage VkShaderStageFlagBits the shader stage shader_path char* the path to the .spirv shader file","title":"dvz_graphics_shader()"},{"location":"api/vklite/#dvz_graphics_vertex_binding","text":"Set the vertex binding. void dvz_graphics_vertex_binding ( DvzGraphics * graphics , uint32_t binding , VkDeviceSize stride ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index stride VkDeviceSize the stride in the vertex buffer, in bytes","title":"dvz_graphics_vertex_binding()"},{"location":"api/vklite/#dvz_graphics_vertex_attr","text":"Add a vertex attribute. void dvz_graphics_vertex_attr ( DvzGraphics * graphics , uint32_t binding , uint32_t location , VkFormat format , VkDeviceSize offset ); Parameter Type Description graphics DvzGraphics* the graphics pipeline binding uint32_t the binding index (as specified in the vertex shader) location uint32_t the location index (as specified in the vertex shader) format VkFormat the format offset VkDeviceSize the offset, in bytes","title":"dvz_graphics_vertex_attr()"},{"location":"api/vklite/#dvz_graphics_blend","text":"Set the graphics blend type. void dvz_graphics_blend ( DvzGraphics * graphics , DvzBlendType blend_type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline blend_type DvzBlendType the blend type","title":"dvz_graphics_blend()"},{"location":"api/vklite/#dvz_graphics_depth_test","text":"Set the graphics depth test. void dvz_graphics_depth_test ( DvzGraphics * graphics , DvzDepthTest depth_test ); Parameter Type Description graphics DvzGraphics* the graphics pipeline depth_test DvzDepthTest the depth test","title":"dvz_graphics_depth_test()"},{"location":"api/vklite/#dvz_graphics_polygon_mode","text":"Set the graphics polygon mode. void dvz_graphics_polygon_mode ( DvzGraphics * graphics , VkPolygonMode polygon_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline polygon_mode VkPolygonMode the polygon mode","title":"dvz_graphics_polygon_mode()"},{"location":"api/vklite/#dvz_graphics_cull_mode","text":"Set the graphics cull mode. void dvz_graphics_cull_mode ( DvzGraphics * graphics , VkCullModeFlags cull_mode ); Parameter Type Description graphics DvzGraphics* the graphics pipeline cull_mode VkCullModeFlags the cull mode","title":"dvz_graphics_cull_mode()"},{"location":"api/vklite/#dvz_graphics_front_face","text":"Set the graphics front face. void dvz_graphics_front_face ( DvzGraphics * graphics , VkFrontFace front_face ); Parameter Type Description graphics DvzGraphics* the graphics pipeline front_face VkFrontFace the front face","title":"dvz_graphics_front_face()"},{"location":"api/vklite/#dvz_graphics_create","text":"Create a graphics pipeline after it has been set up. void dvz_graphics_create ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline","title":"dvz_graphics_create()"},{"location":"api/vklite/#dvz_graphics_slot","text":"Set a binding slot for a graphics pipeline. void dvz_graphics_slot ( DvzGraphics * graphics , uint32_t idx , VkDescriptorType type ); Parameter Type Description graphics DvzGraphics* the graphics pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type","title":"dvz_graphics_slot()"},{"location":"api/vklite/#dvz_graphics_push","text":"Set a graphics pipeline push constant. void dvz_graphics_push ( DvzGraphics * graphics , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description graphics DvzGraphics* the graphics pipeline offset VkDeviceSize the push constant offset, in bytes offset VkDeviceSize the push size, in bytes shaders VkShaderStageFlags the shader stages that will access the push constant","title":"dvz_graphics_push()"},{"location":"api/vklite/#dvz_graphics_destroy","text":"Destroy a graphics pipeline. void dvz_graphics_destroy ( DvzGraphics * graphics ); Parameter Type Description graphics DvzGraphics* the graphics pipeline","title":"dvz_graphics_destroy()"},{"location":"api/vklite/#compute-pipeline","text":"","title":"Compute pipeline"},{"location":"api/vklite/#dvz_compute","text":"Initialize a compute pipeline. DvzCompute dvz_compute ( DvzGpu * gpu , char * shader_path ); Parameter Type Description gpu DvzGpu* the GPU shader_path char* (optional) the path to the .spirv file with the compute shader returns DvzCompute compute pipeline","title":"dvz_compute()"},{"location":"api/vklite/#dvz_compute_create","text":"Create a compute pipeline after it has been set up. void dvz_compute_create ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline","title":"dvz_compute_create()"},{"location":"api/vklite/#dvz_compute_code","text":"Set the GLSL code directly (the library will compile it automatically to SPIRV). void dvz_compute_code ( DvzCompute * compute , char * code ); Parameter Type Description compute DvzCompute* the compute pipeline code char* the GLSL code defining the compute shader","title":"dvz_compute_code()"},{"location":"api/vklite/#dvz_compute_slot","text":"Declare a slot for the compute pipeline. void dvz_compute_slot ( DvzCompute * compute , uint32_t idx , VkDescriptorType type ); Parameter Type Description compute DvzCompute* the compute pipeline idx uint32_t the slot index type VkDescriptorType the descriptor type","title":"dvz_compute_slot()"},{"location":"api/vklite/#dvz_compute_push","text":"Set up push constant. void dvz_compute_push ( DvzCompute * compute , VkDeviceSize offset , VkDeviceSize size , VkShaderStageFlags shaders ); Parameter Type Description compute DvzCompute* the compute pipeline offset VkDeviceSize the push constant offset, in bytes size VkDeviceSize the push constant size, in bytes shaders VkShaderStageFlags the shaders that will need to access the push constant","title":"dvz_compute_push()"},{"location":"api/vklite/#dvz_compute_bindings","text":"Associate a bindings object to a compute pipeline. void dvz_compute_bindings ( DvzCompute * compute , DvzBindings * bindings ); Parameter Type Description compute DvzCompute* the compute pipeline bindings DvzBindings* the bindings","title":"dvz_compute_bindings()"},{"location":"api/vklite/#dvz_compute_destroy","text":"Destroy a compute pipeline. void dvz_compute_destroy ( DvzCompute * compute ); Parameter Type Description compute DvzCompute* the compute pipeline","title":"dvz_compute_destroy()"},{"location":"api/vklite/#barrier","text":"","title":"Barrier"},{"location":"api/vklite/#dvz_barrier","text":"Initialize a synchronization barrier (usedwithin a command buffer). DvzBarrier dvz_barrier ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzBarrier barrier","title":"dvz_barrier()"},{"location":"api/vklite/#dvz_barrier_stages","text":"Set the barrier stages. void dvz_barrier_stages ( DvzBarrier * barrier , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description barrier DvzBarrier* the barrier src_stage VkPipelineStageFlags the source stage dst_stage VkPipelineStageFlags the destination stage","title":"dvz_barrier_stages()"},{"location":"api/vklite/#dvz_barrier_buffer","text":"Set the barrier buffer. void dvz_barrier_buffer ( DvzBarrier * barrier , DvzBufferRegions br ); Parameter Type Description barrier DvzBarrier* the barrier br DvzBufferRegions the buffer regions","title":"dvz_barrier_buffer()"},{"location":"api/vklite/#dvz_barrier_buffer_queue","text":"Set the barrier buffer queue. void dvz_barrier_buffer_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index","title":"dvz_barrier_buffer_queue()"},{"location":"api/vklite/#dvz_barrier_buffer_access","text":"Set the barrier buffer access. void dvz_barrier_buffer_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags","title":"dvz_barrier_buffer_access()"},{"location":"api/vklite/#dvz_barrier_images","text":"Set the barrier images. void dvz_barrier_images ( DvzBarrier * barrier , DvzImages * images ); Parameter Type Description barrier DvzBarrier* the barrier images DvzImages* the images","title":"dvz_barrier_images()"},{"location":"api/vklite/#dvz_barrier_images_layout","text":"Set the barrier images layout. void dvz_barrier_images_layout ( DvzBarrier * barrier , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description barrier DvzBarrier* the barrier src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout","title":"dvz_barrier_images_layout()"},{"location":"api/vklite/#dvz_barrier_images_queue","text":"Set the barrier images queue. void dvz_barrier_images_queue ( DvzBarrier * barrier , uint32_t src_queue , uint32_t dst_queue ); Parameter Type Description barrier DvzBarrier* the barrier src_queue uint32_t the source queue index dst_queue uint32_t the destination queue index","title":"dvz_barrier_images_queue()"},{"location":"api/vklite/#dvz_barrier_images_access","text":"Set the barrier images access. void dvz_barrier_images_access ( DvzBarrier * barrier , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description barrier DvzBarrier* the barrier src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destination access flags","title":"dvz_barrier_images_access()"},{"location":"api/vklite/#semaphores","text":"","title":"Semaphores"},{"location":"api/vklite/#dvz_semaphores","text":"Initialize a set of semaphores (GPU-GPU synchronization). DvzSemaphores dvz_semaphores ( DvzGpu * gpu , uint32_t count ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of semaphores returns DvzSemaphores semaphores","title":"dvz_semaphores()"},{"location":"api/vklite/#dvz_semaphores_destroy","text":"Destroy semaphores. void dvz_semaphores_destroy ( DvzSemaphores * semaphores ); Parameter Type Description semaphores DvzSemaphores* the semaphores","title":"dvz_semaphores_destroy()"},{"location":"api/vklite/#fences","text":"","title":"Fences"},{"location":"api/vklite/#dvz_fences","text":"Initialize a set of fences (CPU-GPU synchronization). DvzFences dvz_fences ( DvzGpu * gpu , uint32_t count , bool signaled ); Parameter Type Description gpu DvzGpu* the GPU count uint32_t the number of fences signaled bool whether the fences are created in the signaled state or not returns DvzFences fences","title":"dvz_fences()"},{"location":"api/vklite/#dvz_fences_copy","text":"Copy a fence from a set of fences to another. void dvz_fences_copy ( DvzFences * src_fences , uint32_t src_idx , DvzFences * dst_fences , uint32_t dst_idx ); Parameter Type Description src_fences DvzFences* the source fences src_idx uint32_t the fence index within the source fences dst_fences DvzFences* the destination fences dst_idx uint32_t the fence index within the destination fences","title":"dvz_fences_copy()"},{"location":"api/vklite/#dvz_fences_wait","text":"Wait on the GPU until a fence is signaled. void dvz_fences_wait ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index","title":"dvz_fences_wait()"},{"location":"api/vklite/#dvz_fences_ready","text":"Return whether a fence is ready. bool dvz_fences_ready ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index","title":"dvz_fences_ready()"},{"location":"api/vklite/#dvz_fences_reset","text":"Rset the state of a fence. void dvz_fences_reset ( DvzFences * fences , uint32_t idx ); Parameter Type Description fences DvzFences* the fences idx uint32_t the fence index","title":"dvz_fences_reset()"},{"location":"api/vklite/#dvz_fences_destroy","text":"Destroy fences. void dvz_fences_destroy ( DvzFences * fences ); Parameter Type Description fences DvzFences* the fences","title":"dvz_fences_destroy()"},{"location":"api/vklite/#renderpass","text":"","title":"Renderpass"},{"location":"api/vklite/#dvz_renderpass","text":"Initialize a render pass. DvzRenderpass dvz_renderpass ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzRenderpass render pass","title":"dvz_renderpass()"},{"location":"api/vklite/#dvz_renderpass_clear","text":"Set the clear value of a render pass. void dvz_renderpass_clear ( DvzRenderpass * renderpass , VkClearValue value ); Parameter Type Description renderpass DvzRenderpass* the render pass value VkClearValue the clear value","title":"dvz_renderpass_clear()"},{"location":"api/vklite/#dvz_renderpass_attachment","text":"Specify a render pass attachment. void dvz_renderpass_attachment ( DvzRenderpass * renderpass , uint32_t idx , DvzRenderpassAttachmentType type , VkFormat format , VkImageLayout ref_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index type DvzRenderpassAttachmentType the attachment type format VkFormat the attachment image format ref_layout VkImageLayout the image layout","title":"dvz_renderpass_attachment()"},{"location":"api/vklite/#dvz_renderpass_attachment_layout","text":"Set the attachment layout. void dvz_renderpass_attachment_layout ( DvzRenderpass * renderpass , uint32_t idx , VkImageLayout src_layout , VkImageLayout dst_layout ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index src_layout VkImageLayout the source layout dst_layout VkImageLayout the destination layout","title":"dvz_renderpass_attachment_layout()"},{"location":"api/vklite/#dvz_renderpass_attachment_ops","text":"Set the attachment load and store operations. void dvz_renderpass_attachment_ops ( DvzRenderpass * renderpass , uint32_t idx , VkAttachmentLoadOp load_op , VkAttachmentStoreOp store_op ); Parameter Type Description renderpass DvzRenderpass* the render pass idx uint32_t the attachment index load_op VkAttachmentLoadOp the load operation store_op VkAttachmentStoreOp the store operation","title":"dvz_renderpass_attachment_ops()"},{"location":"api/vklite/#dvz_renderpass_subpass_attachment","text":"Set a subpass attachment. void dvz_renderpass_subpass_attachment ( DvzRenderpass * renderpass , uint32_t subpass_idx , uint32_t attachment_idx ); Parameter Type Description renderpass DvzRenderpass* the render pass subpass_idx uint32_t the subpass index attachment_idx uint32_t the attachment index","title":"dvz_renderpass_subpass_attachment()"},{"location":"api/vklite/#dvz_renderpass_subpass_dependency","text":"Set a subpass dependency. void dvz_renderpass_subpass_dependency ( DvzRenderpass * renderpass , uint32_t dependency_idx , uint32_t src_subpass , uint32_t dst_subpass ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_subpass uint32_t the source subpass index dst_subpass uint32_t the destination subpass index","title":"dvz_renderpass_subpass_dependency()"},{"location":"api/vklite/#dvz_renderpass_subpass_dependency_access","text":"Set a subpass dependency access. void dvz_renderpass_subpass_dependency_access ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkAccessFlags src_access , VkAccessFlags dst_access ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_access VkAccessFlags the source access flags dst_access VkAccessFlags the destinationaccess flags","title":"dvz_renderpass_subpass_dependency_access()"},{"location":"api/vklite/#dvz_renderpass_subpass_dependency_stage","text":"Set a subpass dependency stage. void dvz_renderpass_subpass_dependency_stage ( DvzRenderpass * renderpass , uint32_t dependency_idx , VkPipelineStageFlags src_stage , VkPipelineStageFlags dst_stage ); Parameter Type Description renderpass DvzRenderpass* the render pass dependency_idx uint32_t the dependency index src_stage VkPipelineStageFlags the source pipeline stages dst_stage VkPipelineStageFlags the destination pipeline stages","title":"dvz_renderpass_subpass_dependency_stage()"},{"location":"api/vklite/#dvz_renderpass_create","text":"Create a render pass after it has been set up. void dvz_renderpass_create ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass","title":"dvz_renderpass_create()"},{"location":"api/vklite/#dvz_renderpass_destroy","text":"Destroy a render pass. void dvz_renderpass_destroy ( DvzRenderpass * renderpass ); Parameter Type Description renderpass DvzRenderpass* the render pass","title":"dvz_renderpass_destroy()"},{"location":"api/vklite/#framebuffers","text":"","title":"Framebuffers"},{"location":"api/vklite/#dvz_framebuffers","text":"Initialize a set of framebuffers. DvzFramebuffers dvz_framebuffers ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzFramebuffers framebuffers","title":"dvz_framebuffers()"},{"location":"api/vklite/#dvz_framebuffers_attachment","text":"Set framebuffers attachment. void dvz_framebuffers_attachment ( DvzFramebuffers * framebuffers , uint32_t attachment_idx , DvzImages * images ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers attachment_idx uint32_t the attachment index images DvzImages* the images","title":"dvz_framebuffers_attachment()"},{"location":"api/vklite/#dvz_framebuffers_create","text":"Create a set of framebuffers after it has been set up. void dvz_framebuffers_create ( DvzFramebuffers * framebuffers , DvzRenderpass * renderpass ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers renderpass DvzRenderpass* the render pass","title":"dvz_framebuffers_create()"},{"location":"api/vklite/#dvz_framebuffers_destroy","text":"Destroy a set of framebuffers. void dvz_framebuffers_destroy ( DvzFramebuffers * framebuffers ); Parameter Type Description framebuffers DvzFramebuffers* the framebuffers","title":"dvz_framebuffers_destroy()"},{"location":"api/vklite/#submit","text":"","title":"Submit"},{"location":"api/vklite/#dvz_submit","text":"Create a submit object, used to submit command buffers to a GPU queue. DvzSubmit dvz_submit ( DvzGpu * gpu ); Parameter Type Description gpu DvzGpu* the GPU returns DvzSubmit submit","title":"dvz_submit()"},{"location":"api/vklite/#dvz_submit_commands","text":"Set the command buffers to submit. void dvz_submit_commands ( DvzSubmit * submit , DvzCommands * commands ); Parameter Type Description submit DvzSubmit* the submit object cmds None the set of command buffers","title":"dvz_submit_commands()"},{"location":"api/vklite/#dvz_submit_wait_semaphores","text":"Set the wait semaphores void dvz_submit_wait_semaphores ( DvzSubmit * submit , VkPipelineStageFlags stage , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object stage VkPipelineStageFlags the pipeline stage semaphores DvzSemaphores* the set of semaphores to wait on idx uint32_t the semaphore index to wait on","title":"dvz_submit_wait_semaphores()"},{"location":"api/vklite/#dvz_submit_signal_semaphores","text":"Set the signal semaphores void dvz_submit_signal_semaphores ( DvzSubmit * submit , DvzSemaphores * semaphores , uint32_t idx ); Parameter Type Description submit DvzSubmit* the submit object semaphores DvzSemaphores* the set of semaphores to signal after the commands have completed idx uint32_t the semaphore index to signal","title":"dvz_submit_signal_semaphores()"},{"location":"api/vklite/#dvz_submit_send","text":"Submit the command buffers to their queue. void dvz_submit_send ( DvzSubmit * submit , uint32_t cmd_idx , DvzFences * fences , uint32_t fence_idx ); Parameter Type Description submit DvzSubmit* the submit object cmd_idx uint32_t the command buffer index to submit fences DvzFences* the fences to signal after completion fence_idx uint32_t the fence index to signal","title":"dvz_submit_send()"},{"location":"api/vklite/#dvz_submit_reset","text":"Reset a submit object. void dvz_submit_reset ( DvzSubmit * submit ); Parameter Type Description submit DvzSubmit* the submit object","title":"dvz_submit_reset()"},{"location":"api/vklite/#command-buffer-recording","text":"","title":"Command buffer recording"},{"location":"api/vklite/#dvz_cmd_begin_renderpass","text":"Begin a render pass. void dvz_cmd_begin_renderpass ( DvzCommands * cmds , uint32_t idx , DvzRenderpass * renderpass , DvzFramebuffers * framebuffers ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record renderpass DvzRenderpass* the render pass framebuffers DvzFramebuffers* the framebuffers","title":"dvz_cmd_begin_renderpass()"},{"location":"api/vklite/#dvz_cmd_end_renderpass","text":"End a render pass. void dvz_cmd_end_renderpass ( DvzCommands * cmds , uint32_t idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record","title":"dvz_cmd_end_renderpass()"},{"location":"api/vklite/#dvz_cmd_compute","text":"Launch a compute task. void dvz_cmd_compute ( DvzCommands * cmds , uint32_t idx , DvzCompute * compute , uvec3 size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record compute DvzCompute* the computer pipeline size uvec3 the task shape","title":"dvz_cmd_compute()"},{"location":"api/vklite/#dvz_cmd_barrier","text":"Register a barrier. void dvz_cmd_barrier ( DvzCommands * cmds , uint32_t idx , DvzBarrier * barrier ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record barrier DvzBarrier* the barrier","title":"dvz_cmd_barrier()"},{"location":"api/vklite/#dvz_cmd_copy_buffer_to_image","text":"Copy a GPU buffer to a GPU image. void dvz_cmd_copy_buffer_to_image ( DvzCommands * cmds , uint32_t idx , DvzBuffer * buffer , DvzImages * images ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record buffer DvzBuffer* the buffer images DvzImages* the image","title":"dvz_cmd_copy_buffer_to_image()"},{"location":"api/vklite/#dvz_cmd_copy_image_to_buffer","text":"Copy a GPU image to a GPU buffer. void dvz_cmd_copy_image_to_buffer ( DvzCommands * cmds , uint32_t idx , DvzImages * images , DvzBuffer * buffer ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record images DvzImages* the image buffer DvzBuffer* the buffer","title":"dvz_cmd_copy_image_to_buffer()"},{"location":"api/vklite/#dvz_cmd_copy_image","text":"Copy a GPU image to another. void dvz_cmd_copy_image ( DvzCommands * cmds , uint32_t idx , DvzImages * src_img , DvzImages * dst_img ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_img DvzImages* the source image dst_img DvzImages* the destination image","title":"dvz_cmd_copy_image()"},{"location":"api/vklite/#dvz_cmd_viewport","text":"Set the viewport. void dvz_cmd_viewport ( DvzCommands * cmds , uint32_t idx , VkViewport viewport ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record viewport VkViewport the viewport","title":"dvz_cmd_viewport()"},{"location":"api/vklite/#dvz_cmd_bind_graphics","text":"Bind a graphics pipeline. void dvz_cmd_bind_graphics ( DvzCommands * cmds , uint32_t idx , DvzGraphics * graphics , DvzBindings * bindings , uint32_t dynamic_idx ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record graphics DvzGraphics* the graphics pipeline bindings DvzBindings* the bindings associated to the pipeline dynamic_idx uint32_t the dynamic uniform buffer index","title":"dvz_cmd_bind_graphics()"},{"location":"api/vklite/#dvz_cmd_bind_vertex_buffer","text":"Bind a vertex buffer. void dvz_cmd_bind_vertex_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes","title":"dvz_cmd_bind_vertex_buffer()"},{"location":"api/vklite/#dvz_cmd_bind_index_buffer","text":"Bind an index buffer. void dvz_cmd_bind_index_buffer ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions br , VkDeviceSize offset ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record br DvzBufferRegions the buffer regions offset VkDeviceSize the offset within the buffer regions, in bytes","title":"dvz_cmd_bind_index_buffer()"},{"location":"api/vklite/#dvz_cmd_draw","text":"Direct draw. void dvz_cmd_draw ( DvzCommands * cmds , uint32_t idx , uint32_t first_vertex , uint32_t vertex_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_vertex uint32_t index of the first vertex vertex_count uint32_t number of vertices to draw","title":"dvz_cmd_draw()"},{"location":"api/vklite/#dvz_cmd_draw_indexed","text":"Direct indexed draw. void dvz_cmd_draw_indexed ( DvzCommands * cmds , uint32_t idx , uint32_t first_index , uint32_t vertex_offset , uint32_t index_count ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record first_index uint32_t index of the first index vertex_offset uint32_t offset of the vertex index_count uint32_t number of indices to draw","title":"dvz_cmd_draw_indexed()"},{"location":"api/vklite/#dvz_cmd_draw_indirect","text":"Indirect draw. void dvz_cmd_draw_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info","title":"dvz_cmd_draw_indirect()"},{"location":"api/vklite/#dvz_cmd_draw_indexed_indirect","text":"Indirect indexed draw. void dvz_cmd_draw_indexed_indirect ( DvzCommands * cmds , uint32_t idx , DvzBufferRegions indirect ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record indirect DvzBufferRegions buffer regions with the indirect draw info","title":"dvz_cmd_draw_indexed_indirect()"},{"location":"api/vklite/#dvz_cmd_copy_buffer","text":"Copy a GPU buffer to another. void dvz_cmd_copy_buffer ( DvzCommands * cmds , uint32_t idx , DvzBuffer * src_buf , VkDeviceSize src_offset , DvzBuffer * dst_buf , VkDeviceSize dst_offset , VkDeviceSize size ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record src_buf DvzBuffer* the source buffer src_offset VkDeviceSize the offset in the source buffer dst_buf DvzBuffer* the destination buffer, in bytes dst_offset VkDeviceSize the offset in the destination buffer, in bytes size VkDeviceSize the size of the region to copy, in bytes","title":"dvz_cmd_copy_buffer()"},{"location":"api/vklite/#dvz_cmd_push","text":"Push constants. void dvz_cmd_push ( DvzCommands * cmds , uint32_t idx , DvzSlots * slots , VkShaderStageFlagBits shaders , VkDeviceSize offset , VkDeviceSize size , void * data ); Parameter Type Description cmds DvzCommands* the set of command buffers to record idx uint32_t the index of the command buffer to record slots DvzSlots* the slots shaders VkShaderStageFlagBits the shader stages that have access to the push constant offset VkDeviceSize the offset in the push constant, in bytes size VkDeviceSize the size in the push constant, in bytes data void* the data to send via the push constant","title":"dvz_cmd_push()"},{"location":"discussions/","text":"Discussions \u00b6 In this section: Vulkan crash course : an accessible overview of Vulkan for scientific computing, a must-read requirement before writing custom visuals, Best practices : a review of best practices when using Datoviz and writing custom visuals, Library architecture : an overview of the internal organization of the code, Roadmap : development roadmap, Developer notes : notes for contributors and developers, FAQ : frequently-asqued questions","title":"Index"},{"location":"discussions/#discussions","text":"In this section: Vulkan crash course : an accessible overview of Vulkan for scientific computing, a must-read requirement before writing custom visuals, Best practices : a review of best practices when using Datoviz and writing custom visuals, Library architecture : an overview of the internal organization of the code, Roadmap : development roadmap, Developer notes : notes for contributors and developers, FAQ : frequently-asqued questions","title":"Discussions"},{"location":"discussions/architecture/","text":"Library architecture \u00b6 Coming soon.","title":"Library architecture"},{"location":"discussions/architecture/#library-architecture","text":"Coming soon.","title":"Library architecture"},{"location":"discussions/developer/","text":"Developer notes \u00b6 A few random notes for developers and contributors. This page needs to be reorganized a bit. Manage script \u00b6 A bash script manage.sh script at the repository root provides commands for build, test, doc generation, and so on. Command Description ./manage.sh build recompile the library ./manage.sh doc rebuild the doc website in site/ ./manage.sh docs serve the website on localhost:8000 ./manage.sh cython update the Cython binding definitions and recompile the Python module ./manage.sh test test_array_ run all tests starting with the given string Documentation building \u00b6 We use mkdocs, with material theme, and several markdown, theme, and mkdocs plugins. See mkdocs.yml . The site is generated in the site/ subfolder. We use GitHub Pages to serve the website. Several parts of the documentation are auto-generated, via mkdocs hooks implemented in utils/hooks.py . Building the documentation requires Python dependencies found in utils/requirements-build.txt . In particular, we use the mkdocs-simple-hooks package to make it possible to use custom Python functions as mkdocs plugin hooks. API documentation : the list of functions to document is found in the docs/api/*.md files. At documentation build time, the API doc generation script ( utils/gendoc.py ) parses the library header files, extracts the doxygen docstrings, and inserts them at the right places in the API documentation pages. Enumerations : the documentation file api/enums.md contains a list of headers of enumerations. A script parses the enums in the library header files and inserts them in this file, at documentation build time. Colormaps : colormaps definitions are saved in a CSV file in data/textures/color_texture.csv . This file is parsed by utils/export_colormap.py and the table of all colormaps is automatically generated, using NumPy and Pillow to generate base64-encoded individual colormap images. The table is inserted at the end of docs/user/colormaps.md . Visual documentation : visuals are documented manually. The screenshots are generated by the builtin_visual.c unit tests. Graphics documentation : the item, vertex, params structure fields are automatically generated by a script that parses the relevant struct definitions in the library header files. Code snippets and screenshots : the documentation build script parses <!-- CODE_PYTHON path/to/file.py --> and <!-- IMAGE path/to/image.png --> in documentation sources and inserts the code file contents, or the image. Note The API doc generation uses joblib to save time when live-regenerating the documentation. However the cache in utils/.joblib must be deleted (so that it's automatically recreated) whenever the Datoviz code/API changes. Otherwise, the API doc generation script may fail. Shaders \u00b6 All shaders include common GLSL files found in include/datoviz/glsl/ . This path must be passed to the glslc command with the -I flag. This is what the CMake script is using. Compiled shaders of the builtin graphics are bundled into the library, using a special CMake command. The binary contents of the SPIR-V-compiled shaders are integrated in build/_shaders.c , which is compiled along with the other C source files of the library. Dependencies \u00b6 Dear ImGUI \u00b6 Datoviz integrates Dear ImGUI via a git submodule ( fork in the Datoviz GitHub organization). There's a custom branch based on master , but which an additional patch applied to it in order to support creating GUIs with integrated Datoviz canvases (not yet implemented). C formatting \u00b6 We use clang format to automatically format all C source files. The rules are defined in .clang-format . We follow loosely this coding guide. Command-line tool \u00b6 Datoviz includes an executable that implements test and examples, implemented in the cli/ subfolder. Shaders and binary resource embedding \u00b6 Important binary resources such as SPIR-V compiled shaders of all included graphics, and the colormap texture, are built directly into the compiled library object. A cmake script loads these files and generates big build/_colortex.c and build/_shaders.c files, which are then compiled and linked into the library. Environment variables \u00b6 Environment variable Description DVZ_FPS=1 Show the number of frames per second DVZ_LOG_LEVEL=0 Logging level Vertical synchronization is activated by default. The refresh rate is typically limited to 60 FPS. Deactivating it (which is automatic when using DVZ_FPS=1 ) leads to the event loop running as fast as possible, which is useful for benchmarking. It may lead to high CPU and GPU utilization, whereas vertical synchronization is typically light on CPU cycles. Note also that user interaction seems laggy when vertical synchronization is active (the default). When it comes to GUI interaction (mouse movements, drag and drop, and so on), we're used to lags lower than 10 milliseconds, which a frame rate of 60 FPS cannot achieve. Logging levels : 0=trace, 1=debug, 2=info, 3=warning, 4=error DPI scaling factor : Datoviz natively supports DPI scaling for linewidths, font size, axes, etc. Since automatic cross-platform DPI detection does not seem reliable, Datoviz simply uses sensible defaults but provides an easy way for the user to increase or decrease the DPI via this environment variable. This is useful on high-DPI/Retina monitors.","title":"Developer notes"},{"location":"discussions/developer/#developer-notes","text":"A few random notes for developers and contributors. This page needs to be reorganized a bit.","title":"Developer notes"},{"location":"discussions/developer/#manage-script","text":"A bash script manage.sh script at the repository root provides commands for build, test, doc generation, and so on. Command Description ./manage.sh build recompile the library ./manage.sh doc rebuild the doc website in site/ ./manage.sh docs serve the website on localhost:8000 ./manage.sh cython update the Cython binding definitions and recompile the Python module ./manage.sh test test_array_ run all tests starting with the given string","title":"Manage script"},{"location":"discussions/developer/#documentation-building","text":"We use mkdocs, with material theme, and several markdown, theme, and mkdocs plugins. See mkdocs.yml . The site is generated in the site/ subfolder. We use GitHub Pages to serve the website. Several parts of the documentation are auto-generated, via mkdocs hooks implemented in utils/hooks.py . Building the documentation requires Python dependencies found in utils/requirements-build.txt . In particular, we use the mkdocs-simple-hooks package to make it possible to use custom Python functions as mkdocs plugin hooks. API documentation : the list of functions to document is found in the docs/api/*.md files. At documentation build time, the API doc generation script ( utils/gendoc.py ) parses the library header files, extracts the doxygen docstrings, and inserts them at the right places in the API documentation pages. Enumerations : the documentation file api/enums.md contains a list of headers of enumerations. A script parses the enums in the library header files and inserts them in this file, at documentation build time. Colormaps : colormaps definitions are saved in a CSV file in data/textures/color_texture.csv . This file is parsed by utils/export_colormap.py and the table of all colormaps is automatically generated, using NumPy and Pillow to generate base64-encoded individual colormap images. The table is inserted at the end of docs/user/colormaps.md . Visual documentation : visuals are documented manually. The screenshots are generated by the builtin_visual.c unit tests. Graphics documentation : the item, vertex, params structure fields are automatically generated by a script that parses the relevant struct definitions in the library header files. Code snippets and screenshots : the documentation build script parses <!-- CODE_PYTHON path/to/file.py --> and <!-- IMAGE path/to/image.png --> in documentation sources and inserts the code file contents, or the image. Note The API doc generation uses joblib to save time when live-regenerating the documentation. However the cache in utils/.joblib must be deleted (so that it's automatically recreated) whenever the Datoviz code/API changes. Otherwise, the API doc generation script may fail.","title":"Documentation building"},{"location":"discussions/developer/#shaders","text":"All shaders include common GLSL files found in include/datoviz/glsl/ . This path must be passed to the glslc command with the -I flag. This is what the CMake script is using. Compiled shaders of the builtin graphics are bundled into the library, using a special CMake command. The binary contents of the SPIR-V-compiled shaders are integrated in build/_shaders.c , which is compiled along with the other C source files of the library.","title":"Shaders"},{"location":"discussions/developer/#dependencies","text":"","title":"Dependencies"},{"location":"discussions/developer/#dear-imgui","text":"Datoviz integrates Dear ImGUI via a git submodule ( fork in the Datoviz GitHub organization). There's a custom branch based on master , but which an additional patch applied to it in order to support creating GUIs with integrated Datoviz canvases (not yet implemented).","title":"Dear ImGUI"},{"location":"discussions/developer/#c-formatting","text":"We use clang format to automatically format all C source files. The rules are defined in .clang-format . We follow loosely this coding guide.","title":"C formatting"},{"location":"discussions/developer/#command-line-tool","text":"Datoviz includes an executable that implements test and examples, implemented in the cli/ subfolder.","title":"Command-line tool"},{"location":"discussions/developer/#shaders-and-binary-resource-embedding","text":"Important binary resources such as SPIR-V compiled shaders of all included graphics, and the colormap texture, are built directly into the compiled library object. A cmake script loads these files and generates big build/_colortex.c and build/_shaders.c files, which are then compiled and linked into the library.","title":"Shaders and binary resource embedding"},{"location":"discussions/developer/#environment-variables","text":"Environment variable Description DVZ_FPS=1 Show the number of frames per second DVZ_LOG_LEVEL=0 Logging level Vertical synchronization is activated by default. The refresh rate is typically limited to 60 FPS. Deactivating it (which is automatic when using DVZ_FPS=1 ) leads to the event loop running as fast as possible, which is useful for benchmarking. It may lead to high CPU and GPU utilization, whereas vertical synchronization is typically light on CPU cycles. Note also that user interaction seems laggy when vertical synchronization is active (the default). When it comes to GUI interaction (mouse movements, drag and drop, and so on), we're used to lags lower than 10 milliseconds, which a frame rate of 60 FPS cannot achieve. Logging levels : 0=trace, 1=debug, 2=info, 3=warning, 4=error DPI scaling factor : Datoviz natively supports DPI scaling for linewidths, font size, axes, etc. Since automatic cross-platform DPI detection does not seem reliable, Datoviz simply uses sensible defaults but provides an easy way for the user to increase or decrease the DPI via this environment variable. This is useful on high-DPI/Retina monitors.","title":"Environment variables"},{"location":"discussions/faq/","text":"Frequently asked questions \u00b6 What is the distinction between the scene, the canvas, and the window? \u00b6 Datoviz provides three similar, but different abstractions: the scene , the canvas , the window . The scene provides a relatively high-level plotting interface that allows to arrange panels (subplots) in a grid, define controllers, and add visuals to the panels. The canvas is lower-level object that allows to use Vulkan directly via vklite. While the scene deals with visual elements, the canvas deals with Vulkan objects. The window is an abstraction provided by the backend windowing library, glfw at the moment. It is a bare window that doesn't allow for any kind rendering, unless manually creating a swapchain and so on by using Vulkan or vklite directly. Note With the Python bindings, a scene is automatically created when creating a canvas. Most users will only work at the scene level. Advanced users will use the canvas to create custom applications, interactive animations, or even small video games. Finally, the window is only used internally and will probably never be used directly.","title":"FAQ"},{"location":"discussions/faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"discussions/faq/#what-is-the-distinction-between-the-scene-the-canvas-and-the-window","text":"Datoviz provides three similar, but different abstractions: the scene , the canvas , the window . The scene provides a relatively high-level plotting interface that allows to arrange panels (subplots) in a grid, define controllers, and add visuals to the panels. The canvas is lower-level object that allows to use Vulkan directly via vklite. While the scene deals with visual elements, the canvas deals with Vulkan objects. The window is an abstraction provided by the backend windowing library, glfw at the moment. It is a bare window that doesn't allow for any kind rendering, unless manually creating a swapchain and so on by using Vulkan or vklite directly. Note With the Python bindings, a scene is automatically created when creating a canvas. Most users will only work at the scene level. Advanced users will use the canvas to create custom applications, interactive animations, or even small video games. Finally, the window is only used internally and will probably never be used directly.","title":"What is the distinction between the scene, the canvas, and the window?"},{"location":"discussions/practices/","text":"Best practices \u00b6 Coming soon.","title":"Best practices"},{"location":"discussions/practices/#best-practices","text":"Coming soon.","title":"Best practices"},{"location":"discussions/roadmap/","text":"Roadmap \u00b6 This provisional roadmap may be updated at any time depending on user feedback and internal needs at the International Brain Laboratory. Short term \u00b6 Spring 2021 Proper IPython terminal event-loop integration More visuals Text (graphics already implemented) Segments (graphics already implemented) Arrows 3D surface (reuse mesh code) Alternative colormap mesh with just vec3 pos and float value in vertex struct More GUI controls Table Fixed aspect ratio More robust error handling More robust testing Continuous integration Packaging Finish documentation First public 0.1 release Medium term \u00b6 Fall 2021 \"Infinite zooming\" with axes 2D Axes 3D More visuals PSLG Fake 3D spheres Transformation system Earth geographic coordinates Linked interactivity across panels Cython bindings for custom visuals Qt integration Wrapper proof of concepts MATLAB Benchmark suite Long term \u00b6 2022 and beyond Video reader visual Jupyter backend Remove visualization server CUDA interop","title":"Roadmap"},{"location":"discussions/roadmap/#roadmap","text":"This provisional roadmap may be updated at any time depending on user feedback and internal needs at the International Brain Laboratory.","title":"Roadmap"},{"location":"discussions/roadmap/#short-term","text":"Spring 2021 Proper IPython terminal event-loop integration More visuals Text (graphics already implemented) Segments (graphics already implemented) Arrows 3D surface (reuse mesh code) Alternative colormap mesh with just vec3 pos and float value in vertex struct More GUI controls Table Fixed aspect ratio More robust error handling More robust testing Continuous integration Packaging Finish documentation First public 0.1 release","title":"Short term"},{"location":"discussions/roadmap/#medium-term","text":"Fall 2021 \"Infinite zooming\" with axes 2D Axes 3D More visuals PSLG Fake 3D spheres Transformation system Earth geographic coordinates Linked interactivity across panels Cython bindings for custom visuals Qt integration Wrapper proof of concepts MATLAB Benchmark suite","title":"Medium term"},{"location":"discussions/roadmap/#long-term","text":"2022 and beyond Video reader visual Jupyter backend Remove visualization server CUDA interop","title":"Long term"},{"location":"discussions/vulkan/","text":"Vulkan crash course \u00b6 This page proposes a high-level, simplified overview of Vulkan for beginners. Understanding the basic principles Vulkan is required when writing custom visuals or graphics, but it is not required when using existing visuals . Using the GPU for scientific visualization \u00b6 The GPU is a massively parallel computing unit dedicated to real-time graphics rendering. Vulkan is a low-level graphics API that provides extensive control on the GPU for rendering and compute. It is harder to user than older APIs like OpenGL because it proposes a relatively low level of abstraction. This design choice gives more control to the developer and helps achieving higher performance. The GPU is typically used by video games, which render complex, animated 3D meshes with real-time special effects and low latency. The GPU can also be used for scientific applications, which has quite different requirements. Scenes are typically less dynamic, there is less heterogeneity in the types of objects rendered in the scene, and high visual accuracy is an absolute requirement. How to use the GPU for scientific visualization? At a high level, the user has some scientific data: a set of 2D or 3D points, a graph, a volume, an image, and so on. On the other hand, the GPU can only render three types of primitives : points (1D), lines (2D), triangles (3D). Fortunately, the GPU gives full control on, essentially, two things: the way the data is transformed before the primitive positions are determined, the exact color of each pixel of each primitive. In practice, one specifies this via special programs called shaders , that run in parallel on the GPU. They are typically written in a C-like language called GLSL (OpenGL shading language). Note Vulkan does not work directly with GLSL, but with an intermediate representation called SPIR-V (a bit similar to LLVM). Vulkan and other third-parties propose compilers transforming GLSL code into SPIR-V. In Datoviz, all shader code is written in GLSL. It is theoretically possible to use other languages that compile to SPIR-V. The vertex shader is a GLSL program that runs on every vertex (point) of a given graphics pipeline. It must return the final point position in a reference normalized coordinate system. This point is used when generating the primitive (point, one of the two endpoints of a line, or one of the three corners of a triangle). The fragment shader is a GLSL program that runs on every pixel of every primitive (point, line, or triangle). It must return the RGBA values of that pixel. It can discard pixels altogether (for example, slicing a mesh along a plane). Note Vulkan supports other types of shaders, such as geometry shaders and tesselation shaders. However, hardware support for these more recent and advanced shader types is not universal. For example, geometry shaders are not supported on macOS (Metal). Another important type of shader is the compute shader . Compute shaders are used to implement general-purpose parallel computations on the GPU on possibly the same objects (buffer and textures) used for rendering, which allow for highly complex and custom visualization applications. There are, of course, many other parameters and details related to rendering, but these are the most important principles. 2D and 3D graphics on the GPU \u00b6 Rendering high-quality 2D graphics on the GPU is significantly harder than rendering 3D graphics. 3D rendering \u00b6 Rendering a 3D mesh is relatively straightforward. A mesh is typically defined by a set of 3D points , and a set of faces . Each face is determined by three integers: the indices of the three triangle corners within the set of 3D points. Vertex shader In the simplest case, the vertex shader takes as input the 3D points, and applies 3D transformation matrices to account for the camera position and perspective. By convention, there are generally three transformation 4x4 matrices: model matrix : transformation from the local coordinate system (in which the mesh is defined) into the global coordinate system (the 3D world containing the mesh), view matrix : transformation from the global coordinate system to the camera-local coordinate system, projection matrix : applies perspective with 4D homogeneous coordinates. Understanding the mathematics of these transformations is beyond the scope of this page. There are many explanations online. Here is a trivial example of a vertex shader in GLSL: #version 450 layout ( location = 0 ) in vec3 pos ; void main () { // ... define transformation matrices ... gl_Position = proj * view * model * vec4 ( pos , 1.0 ); } The variable pos is a 3D vector with the coordinates of 1 point. The GPU executes the vertex shader in parallel on many points. The output of the vertex shader is gl_Position , a vec4 vector (the last coordinate is the homogeneous coordinate, used for perspective). Fragment shader A trivial fragment shader could output a constant color, independently from the position of the pixel within a triangle. But typically, the fragment shader for a 3D mesh implements mathematical computations to account for lighting, which gives a much more realistic feel. While many lighting models have been created, Datoviz currently implements a classic technique called Phong shading . Again, the details are beyond the scope of this page. One can also apply a texture on a mesh. Each point comes with a pair of special coordinates called the texture coordinates , noted uv . Normalized between 0 and 1, they refer to a specific pixel position within an associated 2D texture. The fragment shader typically fetches the color of the texture pixel (texel) at this exact position. Importantly, the GPU is able to make efficient linear interpolations of these values for pixels between two vertices of a given primitive. For example, to render an image, one specifies two triangles forming a square, and sets the uv coordinates of each of the six vertices (three per triangle) to the different combinations of (0 or 1, 0 or 1) . For every pixel in the square, the correct uv coordinates will be interpolated and the relevant texel will be fetched from the texture on the GPU. 2D rendering \u00b6 Rendering 2D graphics is much trickier on the GPU. How to render a disc, a polygon patch, a thick line, text by using only points, lines, and triangles? The answer is: by leveraging the vertex shader and, more importantly, the fragment shader . One follows two steps: define the primitive type for the 2D object, which will constitute a sort of \"envelope\" of the final object, use the fragment shader to properly discard pixels that are beyond the boundaries of the final object, and compute the alpha transparency value for pixels lying on the border of the object, thereby implementing antialiasing directly on the GPU. For example, to render a thick line, one must triangulate the path, taking care of regions of high curvature and other details. On each triangle, the fragment shader computes the exact position along the path, and the distance to the border of the path. The alpha transparency value is obtained via a so-called signed distance function (a function of space giving the distance, in pixels, to the border of the object). A similar principle is used for markers and text. For text, signed distance functions of each glyph are stored in a texture and used by the fragment shader. In Datoviz, high-quality antialiased 2D graphics are implemented with GLSL code originally written by Nicolas Rougier in his Glumpy library (GPU implementation of agg , antigrain geometry), and published in computer graphics articles . A fundamental principle of Datoviz is to abstract away these low-level details to the user, who can reuse directly these existing graphics for the most common types of scientific visualizations . Vulkan for scientific visualization \u00b6 We've now seen the basic principles of using the GPU for scientific visualization. Let's turn now to Vulkan. Vulkan is a low-level graphics API that has a high entry barrier given the large number of abstractions provided. These abstractions mostly relate to internal details of GPU hardware, but they are essential when one focuses on achieving high performance, which is the main selling point of Datoviz. Here is, for your information only, the ~30 types of objects used in Vulkan: Diagram by Adam Sawicki, for gpuopen Covering all of these objects in detail is totally out of scope of this page. However, we'll briefly explain the most important objects, and how they are used in Datoviz. Importantly, Datoviz implements its own thin wrapper on top of Vulkan (called vklite), which focuses on the most important concepts only. The wrapper provides an API that is easier to use than the original Vulkan API, although it it slightly less flexible. This is acceptable given that the wrapper targets scientific applications, which are less demanding than 3D video games. We'll classify these objects in five broad categories: storing data on the GPU, defining graphics and compute pipelines with shaders, recording graphics and compute commands for the GPU, running the main rendering loop , synchronization . Storing data on the GPU \u00b6 Scientific data is typically obtained from files, from the network, or generated by simulation programs. In order for the GPU to render it, it needs to be uploaded to the GPU. A GPU typically has dedicated video memory, or shares memory with the host. For example, the NVIDIA GEFORCE RTX 2070 SUPER GPU has 8 GB of video memory. In any case, Vulkan defines several objects to control how memory is organized and how the data is stored in video memory. Datoviz has a very simple model where there are only two types of memory: GPU buffers : a GPU buffer is a memory buffer of a given size, that contains arbitrary binary bytes, GPU textures : a GPU texture is defined by a 1D, 2D, or 3D image of a given shape, by an internally-handled memory buffer with the pixel data in a given format, and a sampler which is a special GPU object that specifies how a texel is accessed and interpolated when fetched by the fragment shader. A GPU buffer abstracts away the following Vulkan objects: Buffer, BufferView. A GPU texture abstracts away the following Vulkan objects: Image, ImageView, Sampler. Uploading data from the host memory to a GPU buffer or texture, and downloading data from the GPU back to the host, are complex operations in Vulkan. Again, Datoviz abstracts these processes away in the transfer API. Note A GPU image may be represented in several ways by the GPU. For example, a texture needs to be stored in a special way in order to achieve high performance, but this internal representation is incompatible with the way the image is typically stored in a file or on the host. Vulkan provides an API to transition the image between these different formats. Uploading an image to the GPU therefore involves transitioning the image from whatever format the GPU has chosen, to a standard linear layout that matches the data uploaded from the CPU. These details are abstracted away in Datoviz. Defining pipeline with shaders \u00b6 Datoviz supports two types of pipelines: graphics pipelines (or just graphics ): for rendering points, lines, or triangles with dedicated vertex and fragment shaders, compute pipelines (or just computes ): for general-purpose GPU computations. A graphics pipeline encompasses many steps. The diagram below exposes the most important steps, and is shown for your information only: Schematic from vulkan-tutorial.com In addition to defining shaders, one needs to define the data input of the vertex shader. In Datoviz, a vertex shader accepts several kinds of inputs: attribute : a part of each vertex to process in parallel (for example, a vec3 position for the point being processed), uniform : small data (parameters) shared across all vertices in the pipeline, texture : a sampler giving a way to fetch any texel from a 1D, 2D, or 3D texture, storage buffer : an arbitrary binary buffer that may be accessed from any vertex thread, push constant : a small parameter that is set when recording the command buffer (see below). Uniforms, textures, storage buffers are special types of so-called Vulkan descriptors , that we could also call GPU resources : they represent essentially GPU buffers or textures. They can be accessed from the vertex shader or, actually, from any kind of shader. By contrast, the push constant is a different type of data that is passed to the GPU when recording a command buffer. An attribute is a type of data that is processed in parallel. Vulkan define several abstractions in order to define the way a shader may access descriptors (uniforms, textures, or storage buffers): descriptor set layouts, pipeline layouts, descriptor pools, descriptor sets... These abstractions mostly make sense when focusing on performance, and they are partly abstracted away in Datoviz. Datoviz proposes the following, simplified model for defining GPU resources accessible by shaders: a slot is defined in GLSL in each shader. It is represented by a resource index within the shader, and a resource type (uniform, storage, sampler). It must also be defined in the Datoviz C API, and the GLSL and C descriptions must imperatively match. a binding is an association of a given GPU object (buffer or texture) with a given slot in a given pipeline (graphics or compute). For example, a pipeline may declare that it expects a uniform at slot 0, and a texture sampler at slot 1. This is defined in the slots . Then, before one can render a pipeline, one also needs to declare what GPU buffer to use for slot 0, and what GPU texture to use for slot 1. This is defined in the bindings . Defining slots is done when creating a graphics or compute. Defining bindings is done when rendering an existing graphics or compute. Pipelines encompass the following Vulkan objects: ShaderModule, Pipeline, PipelineLayout, DescriptorPool, DescriptorSetLayout, DescriptorSet. Recording commands for the GPU \u00b6 Once GPU objects have been created, data has been uploaded, graphics and compute pipelines have been defined, the next step is to record commands for the GPU . This aspect of Vulkan is a significant difference with older graphics APIs such as OpenGL. One does not send commands to the GPU in real time, but one pre-records a linear succession of commands within a so-called command buffer , and submits recorded command buffers to special queues . The GPU watches these queues, receives the command buffers, and processes them in parallel. In Vulkan, recording commands are special commands starting wih vkCmd . In Datoviz, they start with dvz_cmd_ . For example, rendering a single graphics pipeline involves the following recording commands: dvz_cmd_begin (...); // begin recording the command buffer dvz_cmd_begin_renderpass (...); // begin the renderpass dvz_cmd_bind_vertex_buffer (...); // bind an existing GPU buffer as vertex buffer dvz_cmd_bind_index_buffer (...); // bind an existing GPU buffer as index buffer dvz_cmd_bind_graphics (...); // bind an existing graphics pipeline dvz_cmd_viewport (...); // set the viewport dvz_cmd_draw (...); // **perform the actual rendering of the graphics pipeline** dvz_cmd_end_renderpass (...); // end the renderpass dvz_cmd_end (...); // stop recording the command buffer Once called on a command buffer, the command buffer is recorded and can be submitted to a GPU queue. Vulkan leaves to the user the choice of defining the number and types of GPU queues for the application. This is also depends heavily on the hardware. Currently, Datoviz requests four queues, but may end up with less queues if the hardware does not support them (this is all transparent to the user): a transfer queue receives command buffers for buffer/image upload, download, copy, transitions... a compute queue receives command buffers with compute tasks, a render queue receives command buffers with either graphics and/or compute tasks, a present queue is used for the main rendering loop (swapchain). Vulkan has been designed with the idea that command buffers will be constantly recreated and/or reused. Multithreaded applications can record command buffers in parallel, and must use special synchronization primitives to efficiently submit the command buffers to the GPU. Scientific applications are typically much less dynamic than video games. Still, some amount of dynamism is expected in some applications. Therefore, Datoviz assumes that command buffers are typically not recreated at every frame, but allows for relatively efficient command buffer recreation when needed. Here are the different ways the GPU objects may change during the lifetime of an application: changing buffer or texture data : update a GPU buffer or texture, doesn't require command buffer recreation, interactivity (pan and zoom, arcball, and so on): update a uniform buffer, changing the number of vertices in a given graphics pipeline: require command buffer recreation (unless using indirect rendering , in which case this involves updating a GPU buffer), push constant change : require command buffer recreation, resize , panel change , viewport change : require command buffer recreation. Datoviz command buffers and queues are based on the following Vulkan objects: CommandPool, CommandBuffer, Queue. Main rendering loop \u00b6 Once the command buffers have been recorded, one needs to submit them to the GPU and render the scene in a window. This step must be done manually when using the Vulkan API. Again, this is abstracted away in Datoviz, at the level of the canvas . This step is actually one of the most complex ones in Vulkan, especially when there's a need to do it as efficiently as possible. First, one considers that the window size is fixed (until it is not). Resizing is a complex operation that requires destroying and recreating a large number of Vulkan objects, and it needs to be handled correctly in the rendering loop. Second, one needs to create a GPU image (like the object that is associated to a texture, but without a sampler) that the GPU will render to. This image will be presented to the screen. One must also define another special image of the same size for the depth buffer , essential with 3D rendering. Third, one must acquire a surface , a special Vulkan object that is used to render something to the window. Creating a window is an OS-dependent operation. Datoviz uses the glfw window library that abstracts these details away and offers an easy way to create windows and to deal with user inputs (mouse, keyboard). Fourth, one needs to create a swapchain . This object provides a way to implement a technique sometimes called double-buffering, or triple-buffering, depending on the number of images used in the swapchain. The idea is to avoid making the GPU wait while an image is being presented to the screen . For example, with a frame rate of 60 images per second, each image remains on screen during about 16 milliseconds. During this time, the GPU is not expected to render to the same image, unless it makes a copy. That's basically the idea of the swapchain: providing a set of 2, 3 or more images that are almost identical. While the image 0 is presented to the screen, the GPU can render the next frame on image 1. When it finishes, it presents image 1 to the screen, while image 0 is being rewritten for the next frame (double buffering), or while it waits until the GPU requests it. This logic must be, in part, implemented by the developer who uses the Vulkan API directly. Datoviz completely abstracts this process away. Fifth, one needs to define a render pass and a set of framebuffers . The render pass defines the way the GPU renders an image, in one or several steps. The framebuffers represent the links between the GPU images and the render pass steps. The render pass must be specified when recording a rendering command buffer. Sixth, one needs to implement the main rendering loop . This is typically an infinite loop where every iteration represents a frame. At every frame, the rendering loop performs the following (simplified) steps: Examine the user events (mouse, keyboard) that occurred in the window since the last frame, Perform the resize if the window size has changed since the last frame, Implement the scene logic (update internal variables as a function of user events and time), Perform the pending transfers (upload/download of GPU buffers/textures) that have been requested since last frame, possibly from a background thread, Optionally, record new command buffers, Acquire a new swapchain image for rendering, Wait until the previous frame that was using the same swapchain image (might be 2 or 3 frames before) has finished rendering, Submit the command buffers to their associated GPU queues, which will render the image, Present the image to the screen, but only after the GPU has finished rendering it (asynchronous operation). This logic is essentially implemented in: dvz_canvas_frame() dvz_canvas_frame_submit() dvz_app_run() The rendering loop involves the following Vulkan objects: SurfaceKHR, SwapchainKHR, Image, ImageView, RenderPass, Framebuffer. Synchronization \u00b6 The last important topic pertains to synchronization . The GPU should be seen as a partly independent device on which tasks are submitted asynchronously (via command buffers and queues), and that processes them in parallel. In addition, each task may involve a massively parallel architecture (for example, processing thousands of vertices or fragments in parallel). Vulkan provides an API to let the CPU communicate with the GPU. A highly inefficient way would be for the CPU to wait until the GPU is idle before submitting new tasks or uploading data. This would be done via \"hard\" synchronization primitives that are implemented in the Vulkan functions vkQueueWaitIdle() and vkDeviceWaitIdle() , and in the dvz_queue|gpu|app_wait() functions in Datoviz. Doing it this way would work and would not require any other more fine-grained synchronization primitive, but it would result in poor performance. Vulkan provides several more fine-grained synchronization primitives, of which Datoviz currently supports three: Inner command buffer synchronization , provided by barriers, GPU-GPU synchronization , provided by semaphores. CPU-GPU synchronization , provided by fences, A barrier is a way for a command buffer to let the GPU know that some recorded commands should wait for completion of other commands. For example, if a command buffer involves launching a compute shader on a buffer, then rendering to a graphics pipeline, a barrier should be defined if ever the graphics pipeline uses the same buffer as used by the compute shader. The graphics pipeline should not start reading a buffer while the same buffer is being written to by the compute pipeline. A semaphore is a way to introduce dependencies between different submissions of command buffers. They are used in the main rendering loop and swapchain logic. When the GPU has finished rendering an image, then this image should be presented to the screen. This is implemented with a semaphore. A fence is a way for the CPU to wait until the GPU has finished some task. This is also used in the main rendering loop: it wouldn't make much sense to start the current frame until the previous frame has not finished rendering (but it can start while the swapchain presents the previously rendered image to the screen). Synchronization is required when uploading data to the GPU. Since the GPU may be constantly reading from GPU buffers and textures, data should not be uploaded to these GPU objects without proper synchronization. Otherwise, the GPU might use corrupted data while rendering the scene. Technical details \u00b6 The vklite API documentation contains the documentation of all Vulkan-related functions. There is no other documentation of vklite at the moment, however you can look at the unit tests to get an idea of how to use each vklite object. GPU features and limits \u00b6 The DvzGpu structure contains a few fields with native Vulkan structures defining GPU capabilities and limits. We give here a few minimal values that we can reasonably expect on almost all devices (according to this Vulkan database ): Texture dimension Maximum allowed texture size (in any axis) 1D 16384 2D 16384 3D 2048","title":"Vulkan crash course"},{"location":"discussions/vulkan/#vulkan-crash-course","text":"This page proposes a high-level, simplified overview of Vulkan for beginners. Understanding the basic principles Vulkan is required when writing custom visuals or graphics, but it is not required when using existing visuals .","title":"Vulkan crash course"},{"location":"discussions/vulkan/#using-the-gpu-for-scientific-visualization","text":"The GPU is a massively parallel computing unit dedicated to real-time graphics rendering. Vulkan is a low-level graphics API that provides extensive control on the GPU for rendering and compute. It is harder to user than older APIs like OpenGL because it proposes a relatively low level of abstraction. This design choice gives more control to the developer and helps achieving higher performance. The GPU is typically used by video games, which render complex, animated 3D meshes with real-time special effects and low latency. The GPU can also be used for scientific applications, which has quite different requirements. Scenes are typically less dynamic, there is less heterogeneity in the types of objects rendered in the scene, and high visual accuracy is an absolute requirement. How to use the GPU for scientific visualization? At a high level, the user has some scientific data: a set of 2D or 3D points, a graph, a volume, an image, and so on. On the other hand, the GPU can only render three types of primitives : points (1D), lines (2D), triangles (3D). Fortunately, the GPU gives full control on, essentially, two things: the way the data is transformed before the primitive positions are determined, the exact color of each pixel of each primitive. In practice, one specifies this via special programs called shaders , that run in parallel on the GPU. They are typically written in a C-like language called GLSL (OpenGL shading language). Note Vulkan does not work directly with GLSL, but with an intermediate representation called SPIR-V (a bit similar to LLVM). Vulkan and other third-parties propose compilers transforming GLSL code into SPIR-V. In Datoviz, all shader code is written in GLSL. It is theoretically possible to use other languages that compile to SPIR-V. The vertex shader is a GLSL program that runs on every vertex (point) of a given graphics pipeline. It must return the final point position in a reference normalized coordinate system. This point is used when generating the primitive (point, one of the two endpoints of a line, or one of the three corners of a triangle). The fragment shader is a GLSL program that runs on every pixel of every primitive (point, line, or triangle). It must return the RGBA values of that pixel. It can discard pixels altogether (for example, slicing a mesh along a plane). Note Vulkan supports other types of shaders, such as geometry shaders and tesselation shaders. However, hardware support for these more recent and advanced shader types is not universal. For example, geometry shaders are not supported on macOS (Metal). Another important type of shader is the compute shader . Compute shaders are used to implement general-purpose parallel computations on the GPU on possibly the same objects (buffer and textures) used for rendering, which allow for highly complex and custom visualization applications. There are, of course, many other parameters and details related to rendering, but these are the most important principles.","title":"Using the GPU for scientific visualization"},{"location":"discussions/vulkan/#2d-and-3d-graphics-on-the-gpu","text":"Rendering high-quality 2D graphics on the GPU is significantly harder than rendering 3D graphics.","title":"2D and 3D graphics on the GPU"},{"location":"discussions/vulkan/#3d-rendering","text":"Rendering a 3D mesh is relatively straightforward. A mesh is typically defined by a set of 3D points , and a set of faces . Each face is determined by three integers: the indices of the three triangle corners within the set of 3D points.","title":"3D rendering"},{"location":"discussions/vulkan/#2d-rendering","text":"Rendering 2D graphics is much trickier on the GPU. How to render a disc, a polygon patch, a thick line, text by using only points, lines, and triangles? The answer is: by leveraging the vertex shader and, more importantly, the fragment shader . One follows two steps: define the primitive type for the 2D object, which will constitute a sort of \"envelope\" of the final object, use the fragment shader to properly discard pixels that are beyond the boundaries of the final object, and compute the alpha transparency value for pixels lying on the border of the object, thereby implementing antialiasing directly on the GPU. For example, to render a thick line, one must triangulate the path, taking care of regions of high curvature and other details. On each triangle, the fragment shader computes the exact position along the path, and the distance to the border of the path. The alpha transparency value is obtained via a so-called signed distance function (a function of space giving the distance, in pixels, to the border of the object). A similar principle is used for markers and text. For text, signed distance functions of each glyph are stored in a texture and used by the fragment shader. In Datoviz, high-quality antialiased 2D graphics are implemented with GLSL code originally written by Nicolas Rougier in his Glumpy library (GPU implementation of agg , antigrain geometry), and published in computer graphics articles . A fundamental principle of Datoviz is to abstract away these low-level details to the user, who can reuse directly these existing graphics for the most common types of scientific visualizations .","title":"2D rendering"},{"location":"discussions/vulkan/#vulkan-for-scientific-visualization","text":"We've now seen the basic principles of using the GPU for scientific visualization. Let's turn now to Vulkan. Vulkan is a low-level graphics API that has a high entry barrier given the large number of abstractions provided. These abstractions mostly relate to internal details of GPU hardware, but they are essential when one focuses on achieving high performance, which is the main selling point of Datoviz. Here is, for your information only, the ~30 types of objects used in Vulkan: Diagram by Adam Sawicki, for gpuopen Covering all of these objects in detail is totally out of scope of this page. However, we'll briefly explain the most important objects, and how they are used in Datoviz. Importantly, Datoviz implements its own thin wrapper on top of Vulkan (called vklite), which focuses on the most important concepts only. The wrapper provides an API that is easier to use than the original Vulkan API, although it it slightly less flexible. This is acceptable given that the wrapper targets scientific applications, which are less demanding than 3D video games. We'll classify these objects in five broad categories: storing data on the GPU, defining graphics and compute pipelines with shaders, recording graphics and compute commands for the GPU, running the main rendering loop , synchronization .","title":"Vulkan for scientific visualization"},{"location":"discussions/vulkan/#storing-data-on-the-gpu","text":"Scientific data is typically obtained from files, from the network, or generated by simulation programs. In order for the GPU to render it, it needs to be uploaded to the GPU. A GPU typically has dedicated video memory, or shares memory with the host. For example, the NVIDIA GEFORCE RTX 2070 SUPER GPU has 8 GB of video memory. In any case, Vulkan defines several objects to control how memory is organized and how the data is stored in video memory. Datoviz has a very simple model where there are only two types of memory: GPU buffers : a GPU buffer is a memory buffer of a given size, that contains arbitrary binary bytes, GPU textures : a GPU texture is defined by a 1D, 2D, or 3D image of a given shape, by an internally-handled memory buffer with the pixel data in a given format, and a sampler which is a special GPU object that specifies how a texel is accessed and interpolated when fetched by the fragment shader. A GPU buffer abstracts away the following Vulkan objects: Buffer, BufferView. A GPU texture abstracts away the following Vulkan objects: Image, ImageView, Sampler. Uploading data from the host memory to a GPU buffer or texture, and downloading data from the GPU back to the host, are complex operations in Vulkan. Again, Datoviz abstracts these processes away in the transfer API. Note A GPU image may be represented in several ways by the GPU. For example, a texture needs to be stored in a special way in order to achieve high performance, but this internal representation is incompatible with the way the image is typically stored in a file or on the host. Vulkan provides an API to transition the image between these different formats. Uploading an image to the GPU therefore involves transitioning the image from whatever format the GPU has chosen, to a standard linear layout that matches the data uploaded from the CPU. These details are abstracted away in Datoviz.","title":"Storing data on the GPU"},{"location":"discussions/vulkan/#defining-pipeline-with-shaders","text":"Datoviz supports two types of pipelines: graphics pipelines (or just graphics ): for rendering points, lines, or triangles with dedicated vertex and fragment shaders, compute pipelines (or just computes ): for general-purpose GPU computations. A graphics pipeline encompasses many steps. The diagram below exposes the most important steps, and is shown for your information only: Schematic from vulkan-tutorial.com In addition to defining shaders, one needs to define the data input of the vertex shader. In Datoviz, a vertex shader accepts several kinds of inputs: attribute : a part of each vertex to process in parallel (for example, a vec3 position for the point being processed), uniform : small data (parameters) shared across all vertices in the pipeline, texture : a sampler giving a way to fetch any texel from a 1D, 2D, or 3D texture, storage buffer : an arbitrary binary buffer that may be accessed from any vertex thread, push constant : a small parameter that is set when recording the command buffer (see below). Uniforms, textures, storage buffers are special types of so-called Vulkan descriptors , that we could also call GPU resources : they represent essentially GPU buffers or textures. They can be accessed from the vertex shader or, actually, from any kind of shader. By contrast, the push constant is a different type of data that is passed to the GPU when recording a command buffer. An attribute is a type of data that is processed in parallel. Vulkan define several abstractions in order to define the way a shader may access descriptors (uniforms, textures, or storage buffers): descriptor set layouts, pipeline layouts, descriptor pools, descriptor sets... These abstractions mostly make sense when focusing on performance, and they are partly abstracted away in Datoviz. Datoviz proposes the following, simplified model for defining GPU resources accessible by shaders: a slot is defined in GLSL in each shader. It is represented by a resource index within the shader, and a resource type (uniform, storage, sampler). It must also be defined in the Datoviz C API, and the GLSL and C descriptions must imperatively match. a binding is an association of a given GPU object (buffer or texture) with a given slot in a given pipeline (graphics or compute). For example, a pipeline may declare that it expects a uniform at slot 0, and a texture sampler at slot 1. This is defined in the slots . Then, before one can render a pipeline, one also needs to declare what GPU buffer to use for slot 0, and what GPU texture to use for slot 1. This is defined in the bindings . Defining slots is done when creating a graphics or compute. Defining bindings is done when rendering an existing graphics or compute. Pipelines encompass the following Vulkan objects: ShaderModule, Pipeline, PipelineLayout, DescriptorPool, DescriptorSetLayout, DescriptorSet.","title":"Defining pipeline with shaders"},{"location":"discussions/vulkan/#recording-commands-for-the-gpu","text":"Once GPU objects have been created, data has been uploaded, graphics and compute pipelines have been defined, the next step is to record commands for the GPU . This aspect of Vulkan is a significant difference with older graphics APIs such as OpenGL. One does not send commands to the GPU in real time, but one pre-records a linear succession of commands within a so-called command buffer , and submits recorded command buffers to special queues . The GPU watches these queues, receives the command buffers, and processes them in parallel. In Vulkan, recording commands are special commands starting wih vkCmd . In Datoviz, they start with dvz_cmd_ . For example, rendering a single graphics pipeline involves the following recording commands: dvz_cmd_begin (...); // begin recording the command buffer dvz_cmd_begin_renderpass (...); // begin the renderpass dvz_cmd_bind_vertex_buffer (...); // bind an existing GPU buffer as vertex buffer dvz_cmd_bind_index_buffer (...); // bind an existing GPU buffer as index buffer dvz_cmd_bind_graphics (...); // bind an existing graphics pipeline dvz_cmd_viewport (...); // set the viewport dvz_cmd_draw (...); // **perform the actual rendering of the graphics pipeline** dvz_cmd_end_renderpass (...); // end the renderpass dvz_cmd_end (...); // stop recording the command buffer Once called on a command buffer, the command buffer is recorded and can be submitted to a GPU queue. Vulkan leaves to the user the choice of defining the number and types of GPU queues for the application. This is also depends heavily on the hardware. Currently, Datoviz requests four queues, but may end up with less queues if the hardware does not support them (this is all transparent to the user): a transfer queue receives command buffers for buffer/image upload, download, copy, transitions... a compute queue receives command buffers with compute tasks, a render queue receives command buffers with either graphics and/or compute tasks, a present queue is used for the main rendering loop (swapchain). Vulkan has been designed with the idea that command buffers will be constantly recreated and/or reused. Multithreaded applications can record command buffers in parallel, and must use special synchronization primitives to efficiently submit the command buffers to the GPU. Scientific applications are typically much less dynamic than video games. Still, some amount of dynamism is expected in some applications. Therefore, Datoviz assumes that command buffers are typically not recreated at every frame, but allows for relatively efficient command buffer recreation when needed. Here are the different ways the GPU objects may change during the lifetime of an application: changing buffer or texture data : update a GPU buffer or texture, doesn't require command buffer recreation, interactivity (pan and zoom, arcball, and so on): update a uniform buffer, changing the number of vertices in a given graphics pipeline: require command buffer recreation (unless using indirect rendering , in which case this involves updating a GPU buffer), push constant change : require command buffer recreation, resize , panel change , viewport change : require command buffer recreation. Datoviz command buffers and queues are based on the following Vulkan objects: CommandPool, CommandBuffer, Queue.","title":"Recording commands for the GPU"},{"location":"discussions/vulkan/#main-rendering-loop","text":"Once the command buffers have been recorded, one needs to submit them to the GPU and render the scene in a window. This step must be done manually when using the Vulkan API. Again, this is abstracted away in Datoviz, at the level of the canvas . This step is actually one of the most complex ones in Vulkan, especially when there's a need to do it as efficiently as possible. First, one considers that the window size is fixed (until it is not). Resizing is a complex operation that requires destroying and recreating a large number of Vulkan objects, and it needs to be handled correctly in the rendering loop. Second, one needs to create a GPU image (like the object that is associated to a texture, but without a sampler) that the GPU will render to. This image will be presented to the screen. One must also define another special image of the same size for the depth buffer , essential with 3D rendering. Third, one must acquire a surface , a special Vulkan object that is used to render something to the window. Creating a window is an OS-dependent operation. Datoviz uses the glfw window library that abstracts these details away and offers an easy way to create windows and to deal with user inputs (mouse, keyboard). Fourth, one needs to create a swapchain . This object provides a way to implement a technique sometimes called double-buffering, or triple-buffering, depending on the number of images used in the swapchain. The idea is to avoid making the GPU wait while an image is being presented to the screen . For example, with a frame rate of 60 images per second, each image remains on screen during about 16 milliseconds. During this time, the GPU is not expected to render to the same image, unless it makes a copy. That's basically the idea of the swapchain: providing a set of 2, 3 or more images that are almost identical. While the image 0 is presented to the screen, the GPU can render the next frame on image 1. When it finishes, it presents image 1 to the screen, while image 0 is being rewritten for the next frame (double buffering), or while it waits until the GPU requests it. This logic must be, in part, implemented by the developer who uses the Vulkan API directly. Datoviz completely abstracts this process away. Fifth, one needs to define a render pass and a set of framebuffers . The render pass defines the way the GPU renders an image, in one or several steps. The framebuffers represent the links between the GPU images and the render pass steps. The render pass must be specified when recording a rendering command buffer. Sixth, one needs to implement the main rendering loop . This is typically an infinite loop where every iteration represents a frame. At every frame, the rendering loop performs the following (simplified) steps: Examine the user events (mouse, keyboard) that occurred in the window since the last frame, Perform the resize if the window size has changed since the last frame, Implement the scene logic (update internal variables as a function of user events and time), Perform the pending transfers (upload/download of GPU buffers/textures) that have been requested since last frame, possibly from a background thread, Optionally, record new command buffers, Acquire a new swapchain image for rendering, Wait until the previous frame that was using the same swapchain image (might be 2 or 3 frames before) has finished rendering, Submit the command buffers to their associated GPU queues, which will render the image, Present the image to the screen, but only after the GPU has finished rendering it (asynchronous operation). This logic is essentially implemented in: dvz_canvas_frame() dvz_canvas_frame_submit() dvz_app_run() The rendering loop involves the following Vulkan objects: SurfaceKHR, SwapchainKHR, Image, ImageView, RenderPass, Framebuffer.","title":"Main rendering loop"},{"location":"discussions/vulkan/#synchronization","text":"The last important topic pertains to synchronization . The GPU should be seen as a partly independent device on which tasks are submitted asynchronously (via command buffers and queues), and that processes them in parallel. In addition, each task may involve a massively parallel architecture (for example, processing thousands of vertices or fragments in parallel). Vulkan provides an API to let the CPU communicate with the GPU. A highly inefficient way would be for the CPU to wait until the GPU is idle before submitting new tasks or uploading data. This would be done via \"hard\" synchronization primitives that are implemented in the Vulkan functions vkQueueWaitIdle() and vkDeviceWaitIdle() , and in the dvz_queue|gpu|app_wait() functions in Datoviz. Doing it this way would work and would not require any other more fine-grained synchronization primitive, but it would result in poor performance. Vulkan provides several more fine-grained synchronization primitives, of which Datoviz currently supports three: Inner command buffer synchronization , provided by barriers, GPU-GPU synchronization , provided by semaphores. CPU-GPU synchronization , provided by fences, A barrier is a way for a command buffer to let the GPU know that some recorded commands should wait for completion of other commands. For example, if a command buffer involves launching a compute shader on a buffer, then rendering to a graphics pipeline, a barrier should be defined if ever the graphics pipeline uses the same buffer as used by the compute shader. The graphics pipeline should not start reading a buffer while the same buffer is being written to by the compute pipeline. A semaphore is a way to introduce dependencies between different submissions of command buffers. They are used in the main rendering loop and swapchain logic. When the GPU has finished rendering an image, then this image should be presented to the screen. This is implemented with a semaphore. A fence is a way for the CPU to wait until the GPU has finished some task. This is also used in the main rendering loop: it wouldn't make much sense to start the current frame until the previous frame has not finished rendering (but it can start while the swapchain presents the previously rendered image to the screen). Synchronization is required when uploading data to the GPU. Since the GPU may be constantly reading from GPU buffers and textures, data should not be uploaded to these GPU objects without proper synchronization. Otherwise, the GPU might use corrupted data while rendering the scene.","title":"Synchronization"},{"location":"discussions/vulkan/#technical-details","text":"The vklite API documentation contains the documentation of all Vulkan-related functions. There is no other documentation of vklite at the moment, however you can look at the unit tests to get an idea of how to use each vklite object.","title":"Technical details"},{"location":"discussions/vulkan/#gpu-features-and-limits","text":"The DvzGpu structure contains a few fields with native Vulkan structures defining GPU capabilities and limits. We give here a few minimal values that we can reasonably expect on almost all devices (according to this Vulkan database ): Texture dimension Maximum allowed texture size (in any axis) 1D 16384 2D 16384 3D 2048","title":"GPU features and limits"},{"location":"examples/","text":"Examples gallery \u00b6 Python examples and screenshots.","title":"Overview"},{"location":"examples/#examples-gallery","text":"Python examples and screenshots.","title":"Examples gallery"},{"location":"examples/brain/","text":"3D brain mesh \u00b6 # from `bindings/python/examples/brain.py` import numpy as np from nilearn import datasets from nilearn.surface import load_surf_data , load_surf_mesh , vol_to_surf from nilearn import plotting from datoviz import canvas , run , colormap # Get the data: fsaverage = datasets . fetch_surf_fsaverage () # Left hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_left' ]) coords , faces = mesh [ 0 ], mesh [ 1 ] bg_data = load_surf_data ( fsaverage [ 'sulc_left' ]) # Right hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_right' ]) coords2 , faces2 = mesh [ 0 ], mesh [ 1 ] bg_data2 = load_surf_data ( fsaverage [ 'sulc_right' ]) # Concatenate. coords = np . vstack (( coords , coords2 )) faces = np . vstack (( faces , faces2 + faces . max () + 1 )) bg_data = np . concatenate (( bg_data , bg_data2 )) # Depth background data. bg_data = ( bg_data - bg_data . min ()) / ( bg_data . max () - bg_data . min ()) N = bg_data . shape [ 0 ] # HACK: uv tex coords to fetch the right colormap value. To be improved cmap = 0 uv = np . c_ [ bg_data , np . ones ( N ) * cmap / 256.0 + . 5 / 256.0 ] # Plot the data: c = canvas ( show_fps = False , width = 1024 , height = 768 ) panel = c . panel ( controller = 'arcball' ) visual = panel . visual ( 'mesh' , transform = 'auto' ) visual . data ( 'pos' , coords ) visual . data ( 'texcoords' , uv ) visual . data ( 'index' , faces . ravel ()) # Light parameters light_params = np . zeros (( 4 , 4 )) # up to 4 lights # ambient, diffuse, specular, specular exponent light_params [ 0 , :] = ( . 4 , . 4 , . 2 , 64 ) visual . data ( 'light_params' , light_params ) gui = c . gui ( \"GUI\" ) @gui . control ( \"slider_float\" , \"glossy\" , value =. 2 , vmin = 0 , vmax = 1 ) def on_change ( value ): light_params [ 0 , 2 ] = value visual . data ( 'light_params' , light_params ) run ()","title":"3D brain mesh"},{"location":"examples/brain/#3d-brain-mesh","text":"# from `bindings/python/examples/brain.py` import numpy as np from nilearn import datasets from nilearn.surface import load_surf_data , load_surf_mesh , vol_to_surf from nilearn import plotting from datoviz import canvas , run , colormap # Get the data: fsaverage = datasets . fetch_surf_fsaverage () # Left hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_left' ]) coords , faces = mesh [ 0 ], mesh [ 1 ] bg_data = load_surf_data ( fsaverage [ 'sulc_left' ]) # Right hemisphere. mesh = load_surf_mesh ( fsaverage [ 'pial_right' ]) coords2 , faces2 = mesh [ 0 ], mesh [ 1 ] bg_data2 = load_surf_data ( fsaverage [ 'sulc_right' ]) # Concatenate. coords = np . vstack (( coords , coords2 )) faces = np . vstack (( faces , faces2 + faces . max () + 1 )) bg_data = np . concatenate (( bg_data , bg_data2 )) # Depth background data. bg_data = ( bg_data - bg_data . min ()) / ( bg_data . max () - bg_data . min ()) N = bg_data . shape [ 0 ] # HACK: uv tex coords to fetch the right colormap value. To be improved cmap = 0 uv = np . c_ [ bg_data , np . ones ( N ) * cmap / 256.0 + . 5 / 256.0 ] # Plot the data: c = canvas ( show_fps = False , width = 1024 , height = 768 ) panel = c . panel ( controller = 'arcball' ) visual = panel . visual ( 'mesh' , transform = 'auto' ) visual . data ( 'pos' , coords ) visual . data ( 'texcoords' , uv ) visual . data ( 'index' , faces . ravel ()) # Light parameters light_params = np . zeros (( 4 , 4 )) # up to 4 lights # ambient, diffuse, specular, specular exponent light_params [ 0 , :] = ( . 4 , . 4 , . 2 , 64 ) visual . data ( 'light_params' , light_params ) gui = c . gui ( \"GUI\" ) @gui . control ( \"slider_float\" , \"glossy\" , value =. 2 , vmin = 0 , vmax = 1 ) def on_change ( value ): light_params [ 0 , 2 ] = value visual . data ( 'light_params' , light_params ) run ()","title":"3D brain mesh"},{"location":"examples/brain_highres/","text":"3D high-res brain mesh \u00b6 Showing a ultra-high resolution mesh of a human brain, acquired with a 7 Tesla MRI. The data is not yet publicly available. Data courtesy of Anneke Alkemade et al.: Alkemade A, Pine K, Kirilina E, Keuken MC, Mulder MJ, Balesar R, Groot JM, Bleys RLAW, Trampel R, Weiskopf N, Herrler A, M\u00f6ller HE, Bazin P-L and Forstmann BU (2020) *7 Tesla MRI Followed by Histological 3D Reconstructions in Whole-Brain Specimens* Front. Neuroanat. 14:536838 doi: 10.3389/fnana.2020.536838 Acknowledgements to Pierre-Louis Bazin and Julia Huntenburg for data access. # from `bindings/python/examples/brain_highres.py` from pathlib import Path import numpy as np from datoviz import canvas , run , colormap c = canvas ( show_fps = True , width = 1024 , height = 768 ) panel = c . panel ( controller = 'arcball' ) visual = panel . visual ( 'mesh' , transform = 'auto' ) ROOT = Path ( __file__ ) . parent . parent . parent . parent pos = np . load ( ROOT / \"data/mesh/brain_highres.vert.npy\" ) faces = np . load ( ROOT / \"data/mesh/brain_highres.faces.npy\" ) assert pos . ndim == 2 assert pos . shape [ 1 ] == 3 assert faces . ndim == 2 assert faces . shape [ 1 ] == 3 print ( f \"Mesh has { len ( faces ) } triangles and { len ( pos ) } vertices\" ) visual . data ( 'pos' , pos ) visual . data ( 'index' , faces . ravel ()) visual . data ( 'clip' , np . array ([ 0 , 0 , 1 , 1 ])) gui = c . gui ( \"GUI\" ) @gui . control ( \"slider_float\" , \"clip\" , vmin =- 1 , vmax =+ 1 , value =+ 1 ) def on_change ( value ): visual . data ( 'clip' , np . array ([ 0 , 0 , 1 , value ])) run ()","title":"3D high-res brain mesh"},{"location":"examples/brain_highres/#3d-high-res-brain-mesh","text":"Showing a ultra-high resolution mesh of a human brain, acquired with a 7 Tesla MRI. The data is not yet publicly available. Data courtesy of Anneke Alkemade et al.: Alkemade A, Pine K, Kirilina E, Keuken MC, Mulder MJ, Balesar R, Groot JM, Bleys RLAW, Trampel R, Weiskopf N, Herrler A, M\u00f6ller HE, Bazin P-L and Forstmann BU (2020) *7 Tesla MRI Followed by Histological 3D Reconstructions in Whole-Brain Specimens* Front. Neuroanat. 14:536838 doi: 10.3389/fnana.2020.536838 Acknowledgements to Pierre-Louis Bazin and Julia Huntenburg for data access. # from `bindings/python/examples/brain_highres.py` from pathlib import Path import numpy as np from datoviz import canvas , run , colormap c = canvas ( show_fps = True , width = 1024 , height = 768 ) panel = c . panel ( controller = 'arcball' ) visual = panel . visual ( 'mesh' , transform = 'auto' ) ROOT = Path ( __file__ ) . parent . parent . parent . parent pos = np . load ( ROOT / \"data/mesh/brain_highres.vert.npy\" ) faces = np . load ( ROOT / \"data/mesh/brain_highres.faces.npy\" ) assert pos . ndim == 2 assert pos . shape [ 1 ] == 3 assert faces . ndim == 2 assert faces . shape [ 1 ] == 3 print ( f \"Mesh has { len ( faces ) } triangles and { len ( pos ) } vertices\" ) visual . data ( 'pos' , pos ) visual . data ( 'index' , faces . ravel ()) visual . data ( 'clip' , np . array ([ 0 , 0 , 1 , 1 ])) gui = c . gui ( \"GUI\" ) @gui . control ( \"slider_float\" , \"clip\" , vmin =- 1 , vmax =+ 1 , value =+ 1 ) def on_change ( value ): visual . data ( 'clip' , np . array ([ 0 , 0 , 1 , value ])) run ()","title":"3D high-res brain mesh"},{"location":"examples/france/","text":"France departements as polygons \u00b6 # from `bindings/python/examples/france.py` from pathlib import Path import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap ROOT = Path ( __file__ ) . resolve () . parent . parent . parent . parent pos = np . fromfile ( ROOT / \"data/misc/departements.polypoints.bin\" , dtype = np . float64 ) pos = pos . reshape (( - 1 , 2 )) pos = np . c_ [ pos [:, 1 ], pos [:, 0 ], np . zeros ( pos . shape [ 0 ])] # latitude, longitude, 0 # Web Mercator projection lat , lon , _ = pos . T lonrad = lon / 180.0 * np . pi latrad = lat / 180.0 * np . pi zoom = 1 c = 256 / 2 * np . pi * 2 ** zoom x = c * ( lonrad + np . pi ) y = - c * ( np . pi - np . log ( np . tan ( np . pi / 4.0 + latrad / 2.0 ))) pos = np . c_ [ x , y , _ ] length = np . fromfile ( ROOT / \"data/misc/departements.polylengths.bin\" , dtype = np . uint32 ) N = len ( length ) color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , cmap = 'viridis' ) c = canvas ( show_fps = False ) panel = c . panel ( controller = 'axes' ) visual = panel . visual ( 'polygon' ) visual . data ( 'pos' , pos ) visual . data ( 'length' , length ) visual . data ( 'color' , color ) run ()","title":"France departements"},{"location":"examples/france/#france-departements-as-polygons","text":"# from `bindings/python/examples/france.py` from pathlib import Path import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap ROOT = Path ( __file__ ) . resolve () . parent . parent . parent . parent pos = np . fromfile ( ROOT / \"data/misc/departements.polypoints.bin\" , dtype = np . float64 ) pos = pos . reshape (( - 1 , 2 )) pos = np . c_ [ pos [:, 1 ], pos [:, 0 ], np . zeros ( pos . shape [ 0 ])] # latitude, longitude, 0 # Web Mercator projection lat , lon , _ = pos . T lonrad = lon / 180.0 * np . pi latrad = lat / 180.0 * np . pi zoom = 1 c = 256 / 2 * np . pi * 2 ** zoom x = c * ( lonrad + np . pi ) y = - c * ( np . pi - np . log ( np . tan ( np . pi / 4.0 + latrad / 2.0 ))) pos = np . c_ [ x , y , _ ] length = np . fromfile ( ROOT / \"data/misc/departements.polylengths.bin\" , dtype = np . uint32 ) N = len ( length ) color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , cmap = 'viridis' ) c = canvas ( show_fps = False ) panel = c . panel ( controller = 'axes' ) visual = panel . visual ( 'polygon' ) visual . data ( 'pos' , pos ) visual . data ( 'length' , length ) visual . data ( 'color' , color ) run ()","title":"France departements as polygons"},{"location":"examples/image/","text":"Image \u00b6 # from `bindings/python/examples/image.py` from pathlib import Path import numpy as np import numpy.random as nr import imageio from datoviz import canvas , run , colormap ROOT = Path ( __file__ ) . parent . parent . parent . parent c = canvas ( show_fps = True ) panel = c . panel ( controller = 'panzoom' ) visual = panel . visual ( 'image' ) # Top left, top right, bottom right, bottom left visual . data ( 'pos' , np . array ([[ - 1 , + 1 , 0 ]]), idx = 0 ) visual . data ( 'pos' , np . array ([[ + 1 , + 1 , 0 ]]), idx = 1 ) visual . data ( 'pos' , np . array ([[ + 1 , - 1 , 0 ]]), idx = 2 ) visual . data ( 'pos' , np . array ([[ - 1 , - 1 , 0 ]]), idx = 3 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 0 ]), idx = 0 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 0 ]), idx = 1 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 1 ]), idx = 2 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 1 ]), idx = 3 ) # First texture. img = imageio . imread ( ROOT / 'data/textures/earth.jpg' ) img = np . dstack (( img , 255 * np . ones ( img . shape [: 2 ]))) img = np . transpose ( img , ( 1 , 0 , 2 )) img = img . astype ( np . uint8 ) visual . image ( img , filtering = 'nearest' , idx = 0 ) # Second texture. n = 256 t = np . linspace ( - 1 , + 1 , n ) x , y = np . meshgrid ( t , t ) z = np . exp ( - 2 * ( x * x + y * y )) z = ( z * 255 ) . astype ( np . uint8 ) img = np . dstack (( z , z , z , 255 * np . ones_like ( z ))) . astype ( np . uint8 ) visual . image ( img , filtering = 'nearest' , idx = 1 ) visual . data ( 'texcoefs' , np . array ([ 1 , . 5 , 0 , 0 ]) . astype ( np . float32 )) # Control the blending via a GUI. gui = c . gui ( \"GUI\" ) @gui . control ( \"slider_float\" , \"blending\" , vmin = 0 , vmax = 1 ) def on_change ( value ): visual . data ( 'texcoefs' , np . array ([ 1 - value , value , 0 , 0 ])) run ()","title":"Image"},{"location":"examples/image/#image","text":"# from `bindings/python/examples/image.py` from pathlib import Path import numpy as np import numpy.random as nr import imageio from datoviz import canvas , run , colormap ROOT = Path ( __file__ ) . parent . parent . parent . parent c = canvas ( show_fps = True ) panel = c . panel ( controller = 'panzoom' ) visual = panel . visual ( 'image' ) # Top left, top right, bottom right, bottom left visual . data ( 'pos' , np . array ([[ - 1 , + 1 , 0 ]]), idx = 0 ) visual . data ( 'pos' , np . array ([[ + 1 , + 1 , 0 ]]), idx = 1 ) visual . data ( 'pos' , np . array ([[ + 1 , - 1 , 0 ]]), idx = 2 ) visual . data ( 'pos' , np . array ([[ - 1 , - 1 , 0 ]]), idx = 3 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 0 ]), idx = 0 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 0 ]), idx = 1 ) visual . data ( 'texcoords' , np . atleast_2d ([ 1 , 1 ]), idx = 2 ) visual . data ( 'texcoords' , np . atleast_2d ([ 0 , 1 ]), idx = 3 ) # First texture. img = imageio . imread ( ROOT / 'data/textures/earth.jpg' ) img = np . dstack (( img , 255 * np . ones ( img . shape [: 2 ]))) img = np . transpose ( img , ( 1 , 0 , 2 )) img = img . astype ( np . uint8 ) visual . image ( img , filtering = 'nearest' , idx = 0 ) # Second texture. n = 256 t = np . linspace ( - 1 , + 1 , n ) x , y = np . meshgrid ( t , t ) z = np . exp ( - 2 * ( x * x + y * y )) z = ( z * 255 ) . astype ( np . uint8 ) img = np . dstack (( z , z , z , 255 * np . ones_like ( z ))) . astype ( np . uint8 ) visual . image ( img , filtering = 'nearest' , idx = 1 ) visual . data ( 'texcoefs' , np . array ([ 1 , . 5 , 0 , 0 ]) . astype ( np . float32 )) # Control the blending via a GUI. gui = c . gui ( \"GUI\" ) @gui . control ( \"slider_float\" , \"blending\" , vmin = 0 , vmax = 1 ) def on_change ( value ): visual . data ( 'texcoefs' , np . array ([ 1 - value , value , 0 , 0 ])) run ()","title":"Image"},{"location":"examples/molecule/","text":"Molecule 3D mesh \u00b6 # from `bindings/python/examples/molecule.py` import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap c = canvas ( show_fps = False ) panel = c . panel ( controller = 'arcball' ) visual = panel . visual ( 'mesh' ) visual . load_obj ( \"data/mesh/cas9_guide.obj\" ) run ()","title":"Molecule 3D mesh"},{"location":"examples/molecule/#molecule-3d-mesh","text":"# from `bindings/python/examples/molecule.py` import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap c = canvas ( show_fps = False ) panel = c . panel ( controller = 'arcball' ) visual = panel . visual ( 'mesh' ) visual . load_obj ( \"data/mesh/cas9_guide.obj\" ) run ()","title":"Molecule 3D mesh"},{"location":"examples/quickstart/","text":"Quickstart tutorial with Python \u00b6 # from `bindings/python/examples/quickstart.py` import time import numpy as np import numpy.random as nr # Import the library. from datoviz import canvas , run , colormap # Create a new canvas and scene. There's only 1 subplot (panel) by default. c = canvas ( show_fps = True ) # Get a panel (by default, the one spanning the entire canvas) # We specify the type of controller we want. Here, we want 2D axes. panel = c . panel ( controller = 'axes' ) # We create a new \"marker\" visual. visual = panel . visual ( 'marker' ) # We prepare the visual properties. Here, we set the marker positions, colors (RGBA bytes), # and size (in pixels). N = 100_000 pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 35 , size = N ) color_values = nr . rand ( N ) # Use a built-in colormap color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = 'viridis' ) # Set the visual props. visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = c . panel_at ( x , y ) if not p : return # Then, we transform into the data coordinate system # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), modifiers= { modifiers } \" ) # We create a GUI dialog. gui = c . gui ( \"Test GUI\" ) # We add a control, a slider controlling a float @gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) def on_change ( value ): # Every time the slider value changes, we update the visual's marker size visual . data ( 'ms' , ms * value ) # NOTE: an upcoming version will support partial updates # We add another control, a slider controlling an int between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) def on_change ( value ): # Recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # Update the color visual visual . data ( 'color' , color ) # We add a button to regenerate the marker positions @gui . control ( \"button\" , \"new positions\" ) def on_change ( value ): pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos ) # We run the main event loop, which will display the canvas until Escape is pressed or the # window is closed. # We start a screencast. This will add playback buttons at the bottom right corner. # NOTE: the video DOESN'T START until you press the play button. # run(video=\"screencast.mp4\") run ()","title":"Simple test with Python"},{"location":"examples/quickstart/#quickstart-tutorial-with-python","text":"# from `bindings/python/examples/quickstart.py` import time import numpy as np import numpy.random as nr # Import the library. from datoviz import canvas , run , colormap # Create a new canvas and scene. There's only 1 subplot (panel) by default. c = canvas ( show_fps = True ) # Get a panel (by default, the one spanning the entire canvas) # We specify the type of controller we want. Here, we want 2D axes. panel = c . panel ( controller = 'axes' ) # We create a new \"marker\" visual. visual = panel . visual ( 'marker' ) # We prepare the visual properties. Here, we set the marker positions, colors (RGBA bytes), # and size (in pixels). N = 100_000 pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 35 , size = N ) color_values = nr . rand ( N ) # Use a built-in colormap color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = 'viridis' ) # Set the visual props. visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = c . panel_at ( x , y ) if not p : return # Then, we transform into the data coordinate system # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), modifiers= { modifiers } \" ) # We create a GUI dialog. gui = c . gui ( \"Test GUI\" ) # We add a control, a slider controlling a float @gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) def on_change ( value ): # Every time the slider value changes, we update the visual's marker size visual . data ( 'ms' , ms * value ) # NOTE: an upcoming version will support partial updates # We add another control, a slider controlling an int between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) def on_change ( value ): # Recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # Update the color visual visual . data ( 'color' , color ) # We add a button to regenerate the marker positions @gui . control ( \"button\" , \"new positions\" ) def on_change ( value ): pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos ) # We run the main event loop, which will display the canvas until Escape is pressed or the # window is closed. # We start a screencast. This will add playback buttons at the bottom right corner. # NOTE: the video DOESN'T START until you press the play button. # run(video=\"screencast.mp4\") run ()","title":"Quickstart tutorial with Python"},{"location":"examples/raster/","text":"Raster plot \u00b6 # from `bindings/python/examples/raster.py` from pathlib import Path ROOT = Path ( __file__ ) . parent . parent . parent . parent import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap c = canvas ( show_fps = True ) panel = c . panel ( controller = 'axes' ) visual = panel . visual ( 'point' ) amps = np . load ( ROOT / \"data/misc/spikes.amps.npy\" ) spike_clusters = np . load ( ROOT / \"data/misc/spikes.clusters.npy\" ) spike_depths = np . load ( ROOT / \"data/misc/spikes.depths.npy\" ) spike_times = np . load ( ROOT / \"data/misc/spikes.times.npy\" ) N = len ( spike_times ) print ( f \" { N } spikes\" ) pos = np . c_ [ spike_times , spike_depths , np . zeros ( N )] color = colormap ( spike_clusters . astype ( np . float64 ), cmap = 'glasbey' , alpha =. 5 ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , np . array ([ 2. ])) run ()","title":"Raster plot"},{"location":"examples/raster/#raster-plot","text":"# from `bindings/python/examples/raster.py` from pathlib import Path ROOT = Path ( __file__ ) . parent . parent . parent . parent import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap c = canvas ( show_fps = True ) panel = c . panel ( controller = 'axes' ) visual = panel . visual ( 'point' ) amps = np . load ( ROOT / \"data/misc/spikes.amps.npy\" ) spike_clusters = np . load ( ROOT / \"data/misc/spikes.clusters.npy\" ) spike_depths = np . load ( ROOT / \"data/misc/spikes.depths.npy\" ) spike_times = np . load ( ROOT / \"data/misc/spikes.times.npy\" ) N = len ( spike_times ) print ( f \" { N } spikes\" ) pos = np . c_ [ spike_times , spike_depths , np . zeros ( N )] color = colormap ( spike_clusters . astype ( np . float64 ), cmap = 'glasbey' , alpha =. 5 ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , np . array ([ 2. ])) run ()","title":"Raster plot"},{"location":"examples/signals/","text":"Digital signals \u00b6 # from `bindings/python/examples/signals.py` import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap c = canvas ( show_fps = True ) panel = c . panel ( controller = 'panzoom' ) visual = panel . visual ( 'line_strip' ) n_signals = 200 n_points = 2000 n_vert = n_signals * n_points t = np . linspace ( 0 , 5 , n_points ) x = np . tile ( t , ( n_signals ,)) assert x . ndim == 1 y = . 2 * nr . randn ( n_signals , n_points ) offsets = np . tile ( np . arange ( n_signals )[:, np . newaxis ], ( 1 , n_points )) y += offsets pos = np . c_ [ x , y . ravel (), np . zeros ( n_vert )] color = np . repeat ( colormap ( np . linspace ( 0 , 1 , n_signals ), cmap = 'glasbey' ), n_points , axis = 0 ) length = np . repeat ( np . array ([ n_points ]), n_signals ) assert pos . shape == ( n_vert , 3 ) assert color . shape == ( n_vert , 4 ) assert length . shape == ( n_signals ,) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'length' , length ) i = 0 k = 50 def f (): global i yk = . 2 * nr . randn ( n_signals , k ) offsets = np . tile ( np . arange ( n_signals )[:, np . newaxis ], ( 1 , k )) yk += offsets y [:, i * k :( i + 1 ) * k ] = yk pos [:, 1 ] = y . ravel () visual . data ( 'pos' , pos ) i += 1 i = i % ( n_points // k ) c . _connect ( 'timer' , f , . 05 ) run ()","title":"Digital signals"},{"location":"examples/signals/#digital-signals","text":"# from `bindings/python/examples/signals.py` import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap c = canvas ( show_fps = True ) panel = c . panel ( controller = 'panzoom' ) visual = panel . visual ( 'line_strip' ) n_signals = 200 n_points = 2000 n_vert = n_signals * n_points t = np . linspace ( 0 , 5 , n_points ) x = np . tile ( t , ( n_signals ,)) assert x . ndim == 1 y = . 2 * nr . randn ( n_signals , n_points ) offsets = np . tile ( np . arange ( n_signals )[:, np . newaxis ], ( 1 , n_points )) y += offsets pos = np . c_ [ x , y . ravel (), np . zeros ( n_vert )] color = np . repeat ( colormap ( np . linspace ( 0 , 1 , n_signals ), cmap = 'glasbey' ), n_points , axis = 0 ) length = np . repeat ( np . array ([ n_points ]), n_signals ) assert pos . shape == ( n_vert , 3 ) assert color . shape == ( n_vert , 4 ) assert length . shape == ( n_signals ,) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'length' , length ) i = 0 k = 50 def f (): global i yk = . 2 * nr . randn ( n_signals , k ) offsets = np . tile ( np . arange ( n_signals )[:, np . newaxis ], ( 1 , k )) yk += offsets y [:, i * k :( i + 1 ) * k ] = yk pos [:, 1 ] = y . ravel () visual . data ( 'pos' , pos ) i += 1 i = i % ( n_points // k ) c . _connect ( 'timer' , f , . 05 ) run ()","title":"Digital signals"},{"location":"examples/twopanels/","text":"Test with two panels and different controllers \u00b6 # from `bindings/python/examples/twopanels.py` import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap N = 100_000 pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 40 , size = N ) color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N )) c = canvas ( rows = 1 , cols = 2 , show_fps = True ) panel0 = c . panel ( 0 , 0 , controller = 'axes' ) panel1 = c . panel ( 0 , 1 , controller = 'arcball' ) visual = panel0 . visual ( 'marker' ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) visual1 = panel1 . visual ( 'marker' , depth_test = True ) visual1 . data ( 'pos' , pos ) visual1 . data ( 'color' , color ) visual1 . data ( 'ms' , ms ) run ()","title":"Two panels"},{"location":"examples/twopanels/#test-with-two-panels-and-different-controllers","text":"# from `bindings/python/examples/twopanels.py` import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap N = 100_000 pos = nr . randn ( N , 3 ) ms = nr . uniform ( low = 2 , high = 40 , size = N ) color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N )) c = canvas ( rows = 1 , cols = 2 , show_fps = True ) panel0 = c . panel ( 0 , 0 , controller = 'axes' ) panel1 = c . panel ( 0 , 1 , controller = 'arcball' ) visual = panel0 . visual ( 'marker' ) visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) visual1 = panel1 . visual ( 'marker' , depth_test = True ) visual1 . data ( 'pos' , pos ) visual1 . data ( 'color' , color ) visual1 . data ( 'ms' , ms ) run ()","title":"Test with two panels and different controllers"},{"location":"howto/","text":"How to guides \u00b6 This section provides step-by-step how-to guides for intermediate to advanced users: How to write a standalone C app using the scene API, How to write a custom visual in C, by reusing existing shaders and without writing custom shaders (Python bindings coming soon), How to write a custom graphics in C and GLSL, by writing custom shaders , How to use the canvas C API to create standalone applications that do not use the high-level scene API, How to use the vklite C API to create standalone offscreen and/or compute applications that only use the vklite API (thin wrapper on top of the Vulkan C API).","title":"Index"},{"location":"howto/#how-to-guides","text":"This section provides step-by-step how-to guides for intermediate to advanced users: How to write a standalone C app using the scene API, How to write a custom visual in C, by reusing existing shaders and without writing custom shaders (Python bindings coming soon), How to write a custom graphics in C and GLSL, by writing custom shaders , How to use the canvas C API to create standalone applications that do not use the high-level scene API, How to use the vklite C API to create standalone offscreen and/or compute applications that only use the vklite API (thin wrapper on top of the Vulkan C API).","title":"How to guides"},{"location":"howto/graphics/","text":"How to write a custom graphics \u00b6 Warning You need to go through the Vulkan crash course before following this guide. You also need to go through the how to write a custom visual guide first. In this section, we'll show how to create a custom graphics by writing custom GLSL shaders . This is an advanced topic as it requires understanding the basic of GPU graphics programming. Note Only the C API supports custom graphics at the moment. Python bindings for custom graphics will come in an upcoming version. Datoviz already includes the code necessary to compile GLSL shaders to SPIR-V on the fly (based on Khronos glslang ). The full source code for this example can be found in examples/custom_graphics.c . As a toy example, we'll create a graphics with square points of various size and color . Specifically, we'll require each point to have a different size (which is not supported in the existing point graphics), and a color depending directly on the size and computed directly on the GPU. We'll use a single byte per vertex to store the vertex size (between 0 and 255 pixels), and we'll use no memory for the color since it will be determined directly by this value. This kind of memory optimization is one of the use-cases of writing custom graphics. Limiting memory usage is important when dealing with extremely large datasets (tens or hundreds of millions of points). Writing a custom graphics involves the following steps: Choosing the primitive type. Defining the vertex data structure and corresponding vertex shader attributes. Writing the vertex shader. Writing the fragment shader. Compiling the GLSL shaders to SPIR-V (may be done automatically in the future). Writing the custom graphics. Writing the custom visual. Writing a simple test. Note Here, we show how to create a custom graphics compatible with the scene API, so that it can be used added to the scene the same way as builtin visuals. One could however decide not to use the scene API at all, and leverage instead the vklite API directly. This allows one to create entirely custom and standalone applications. This is not documented at the moment, and one should look at the vklite unit tests to understand how to use the vklite API directly. Choosing the graphics primitive type \u00b6 Vulkan supports six major types of primitives: point list : square points with an arbitrary size, line list : disjoint aliased line segments, line strip : joined aliased line segments, triangle strip : joined triangles consecutively sharing an edge, triangle fan : joined triangles all sharing a single corner (the first vertex), triangle list : disjoint triangles, Other less common primitive types are described in the Vulkan specification . Warning Triangle fans are not supported on macOS. Schematic from the Vulkan Cookbook by Pawel Lapinski, O'Reilly Note The circular arrows in the triangles above indicate the orientation of the triangles, which is taken into account by the GPU. It is good practice to always ensure that all triangles constituting a given object are consistent. For example, when triangulating a square with two triangles, the order of the vertices should be chosen such that both triangles are directly oriented. The graphics pipeline can be configured to handle triangle orientation in a specific way. For example, one can make a graphics pipeline where indirectly oriented triangles are automatically discarded. Line primitives typically have a width of 1 pixel, although some hardware supports thicker lines. In Datoviz, thick, high-quality lines are implemented with triangles instead (line triangulation), and the antialiased thick line is drawn directly in the fragment shader. \"Basic\" line primitives are only used for testing and for special high-performance applications where scalability and performance are more important than visual quality. The most commonly-used primitive types in scientific visualization are essentially point lists and triangle lists (and to a lesser extent, triangle strips). In this example, we'll use a point list , where each point will correspond to one square. Defining the vertex data structure \u00b6 Once we know we'll use a point list as a primitive, the next step is to define the vertex data structure / vertex shader attributes. Here, we want the following attributes for each vertex: the point position (center of the square), as a vec3 , the point size (edge length of the square, in pixels), as an uint8_t . The point size will be limited to a maximum of 255 pixels in this toy example. We could have simply used a floating-point for the edge length, but that would have used four bytes instead of one. This is also to show the versatility of Vulkan and GPU programming, where we have full control on the data types used on both the GPU and CPU. Here is our vertex C structure: // We define the vertex structure for our graphics pipeline. typedef struct { vec3 pos ; // 3D point position uint8_t size ; // point size, in pixels, between 0 and 255. } PointVertex ; We also need to define the attributes in GLSL: layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0 Attribute format \u00b6 In this example, we use a uint8_t (byte) on the CPU, but a float on the GPU. Vulkan provides a way to specify the way we want to do the casting . This is done when creating the graphics pipeline below. We can just say here that we'll use the Vulkan format VK_FORMAT_R8_USCALED . This format means that: Number of components . There is a single component (scalar), the R in R8 means \"red\" component: this is the component used for scalar values. If using a pair of components, we would have both a R and G component (green). This naming convention using color names comes from the fact that these GPU formats are typically used to represent colors, but they can actually represent any type of numerical data. Number of bits per component . The 8 in R8 means that our red component is represented with 8 bits. Signedness . The U in USCALED means that we use an unsigned format. Scaling . The SCALED means that the byte, a number between 0 and 255, will be converted to a float without normalization: 255 becomes 255.0. Here are the other common scaling options provided by Vulkan when using bytes: Scaling GPU number type Range UNORM float [0.0, 1.0] SNORM float [-1.0, 1.0] USCALED float [0.0, 255.0] SSCALED float [-128.0, +127.0] (?) UINT int [0, 255] SINT int [-128, 127] (?) You'll find more information here: Full list of formats in the Vulkan spec , Hardware support of the formats : some formats are not supported by all existing GPUs. This website is quite useful to know what formats have the best hardware support. Writing the vertex shader \u00b6 We're now ready to write the vertex shader. Here is the full source code of the vertex shader: // code from `examples/custom_point.vert`: // GLSL version #version 450 // To be compatible with the scene API, all graphics shaders must include a common GLSL include // file. It defines common uniform bindings and common functions (for example, transform()). // These .glsl files are found in `include/datoviz/glsl`, so one needs to pass // `-Ipath/to/datoviz/include/datoviz/glsl` to the `glslc` command (see build.sh script). #include \"common.glsl\" // Here, we also use GLSL colormaps to compute the square color directly in the vertex shader, // without using the colormap texture. #include \"colormaps.glsl\" // Here, we describe the vertex shader attributes. layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0 // We made the unusual choice here to use a float in the shader, which corresponds to a uint8 byte // in C. We also decided not to normalize it, i.e. that the byte 255 corresponds to the float 255.0 // in the shader (VK_FORMAT_R8_USCALED format). Other choices can be made when specifying the // attribute format in the custom graphics definition. // Here, we describe the \"varying\" variables. These are special values output by the vertex shader, // and passed to the fragment shader. layout ( location = 0 ) out vec4 out_color ; // Main shader code. void main () { // Here, \"pos\" is the position of the vertex being processed. gl_Position is a special output // variable that returns the vertex final position in normalized device coordinates. It // is a vec4 vector, the fourth component is the homogeneous coordinate. // The \"transform()\" function is defined in common.glsl. It applies the model, view, proj // matrices stored in the first (common) uniform buffer (MVP buffer). gl_Position = transform ( pos ); // This special variable is an output variable that contains the point size, in pixels, // of the vertex being processed. It is reserved to graphics pipelines with a point list // primitive. gl_PointSize = size ; // Here, we set the varying variable that will be passed to the fragment shader. // The function colormap() is implemented in colormaps.glsl. It supports a few colormaps // that are implemented directly in GLSL, without using a texture. The second argument // is a value between 0 and 1, hence the normalization with the size which is in pixels. out_color = colormap ( DVZ_CMAP_HSV , size / 255.0 ); out_color . a = .25 ; // alpha component for some transparency } A few comments can be found below. Common shader resources \u00b6 The #include directive is provided for convenience by the GLSL to SPIR-V compiler glslc . It is used extensively in Datoviz. It provides a simple way of making all graphics shaders share some functions and resources. In particular, we make the convention that, in order to be compatible with the scene API, all graphics pipelines in Datoviz must have the following common slots : layout (std140, binding = 0) uniform MVP {...}; layout (std140, binding = 1) uniform Viewport {...}; Binding Descriptor type Description 0 uniform structure with the model-view-proj matrices 1 uniform structure with viewport information This is done just by including common.glsl in every shader. Note that this is not required when using completely standalone graphics pipelines that will never be used with the scene API. When one needs to add another bindings, the numbering should start at USER_BINDING , a special GLSL macro that is currently 2. Uniform alignment The std140 keyword refers to the alignment of the fields within the uniform structure. We're not going into the details, but we'll present some relatively arbitrary rules that we follow in Datoviz so that we don't need to think too much about memory alignment considerations when working with uniform structures: always use the std140 keyword when defining uniform resources in the shaders, NEVER use the following data types in a uniform structure : vec3 , ivec3 , mat3 , and any format with a 3 in it. If you need a vector with three components, use a vec4 and leave the last component alone. This only affects uniforms, NOT attributes. Varying variables \u00b6 The vertex shader may pass some variables to the next stage, typically the fragment shader, using varying variables . A crucial difference between the vertex and fragment shaders is that the vertex shader executes on every vertex , whereas the fragment shader executes on every pixel . When the vertex shader passes a value to the fragment shader, the GPU makes a linear interpolation for all pixels between two vertices in the same primitive. This is specific to line and triangle primitives, not points. For example, passing 0 to one vertex and 1 to the next vertex in a graphics with a line primitive would result in all pixels being passed a real value between 0 and 1 depending on the position of that pixel within that line segment. This system is used in particular with: Color gradients, Texture coordinates. Position transformation \u00b6 The common.glsl file defines (several overloaded versions of) the function transform() , which applies the model-view-proj matrices stored in the first bound resource, the MVP uniform. The associated C structure is DvzMVP : struct DvzMVP { mat4 model ; // model 4x4 matrix mat4 view ; // view 4x4 matrix mat4 proj ; // projection 4x4 matrix float time ; // elapsed time since the start of the application, in seconds }; The transformation is basically gl_Position = to_vulkan(proj * view * model * position) . The to_vulkan() internal function transforms the position from the OpenGL/Datoviz 3D coordinate system (y up, z toward the user) to the Vulkan coordinate system (y down, z toward the inside of the screen). Special GLSL variables \u00b6 We use a few special GLSL variables in the vertex shader: Name Type Description gl_Position vec4 final vertex position in normalized device coordinates gl_PointSize float size of the point, when using the point list primitive There are many more special variables available in each type of shader. You'll find the list of special GLSL variables here. Colormaps \u00b6 The colormap() function is implemented in colormaps.glsl . It provides a GLSL implementation of a few common colormaps, which allows to compute the color as a function of a scalar value without using a texture . There are a few advantages to this, mostly related to performance and avoiding edge effects when using nearest interpolation in the texture. Writing the fragment shader \u00b6 We now pass to the fragment shader. Here is the code: // code from `examples/custom_point.frag`: #version 450 #include \"common.glsl\" // The \"in\" variables here MUST correspond to the \"out\" variables from the vertex shader. layout ( location = 0 ) in vec4 in_color ; // The first output variable of the fragment shader must be a vec4 variable with the RGBA // components of the pixel being processed. layout ( location = 0 ) out vec4 out_color ; void main () { // This macro is used to implement clipping in the inner viewport, when using panel margins. // All fragment shader of all graphics must include this macro for now. CLIP // Here, we simply pass the varying color (already computed by the vertex shader) to the // output variable. // NOTE: we could also have passed the point size from the vertex shader to the fragment // shader, and compute the colormap here. HOWEVER the computation of the colormap would have // been done for each *pixel*, rather than each *vertex*. Since we're using uniform square // colors in this example, that would have resulted in wasted duplicate computations and // unjustified loss of performance. // When the pixel color is non uniform across the primitive, and not just linearly interpolated // between the vertices, one can compute the pixel color directly in the fragment shader. out_color = in_color ; } Here are a few comments. Clipping \u00b6 Datoviz panels may have margins around them. We make the distinction between: Viewport Description inner viewport area of the panel excluding the margins outer viewport area of the panel including the margins We follow the convention that the normalized coordinates [-1, +1] correspond to the inner viewport . Vertices beyond these limits will be rendered in the margins. Clipping allows to hide all pixels outside the inner viewport. This is how we implement the axes controller: graphics should not be rendered in the margins which contain the tick labels. Any graphics that should be compatible with the axes controller should therefore have the special CLIP macro at the beginning of the fragments shader (implemented in common.glsl ). This macro detects whether the current pixel is beyond the inner viewport, and if the graphics has been configured so, it discards that pixel. Special variables \u00b6 We haven't used any special variable in this fragment shader, but here are two useful variables that we could use: Name Type Description gl_FragCoord vec4 pixel position in window space gl_PointCoord vec2 coordinates of the pixel within the point primitive The gl_PointCoord variable is reserved to graphics pipelines using a point primitive. It provides the coordinates, in pixels, of the current pixel within the square. The origin is at the upper-left corner of the square. Compiling the shaders to SPIR-V \u00b6 Once the shaders have been written, they should be compiled to SPIR-V (unless using Datoviz to compile shaders provided as GLSL code, but this is a work in progress). Here is how to compile the shaders on the command-line: glslc custom_point.vert -o custom_point.vert.spv glslc custom_point.frag -o custom_point.frag.spv The glslc command is provided by the Vulkan SDK. Writing the custom graphics \u00b6 Here is the code to create a custom graphics compatible with the scene API, and to add it to a custom visual: // We create a blank graphics that will become our custom graphics. DvzGraphics * graphics = dvz_blank_graphics ( scene , 0 ); // Custom graphics creation. // The first step is to define the vertex and fragment shaders. When using // dvz_graphics_shader(), one must specify a path to the compiled SPIR-V shaders. // When writing the shaders in GLSL, it is thus necessary to compile them separately with // glslc. dvz_graphics_shader ( graphics , VK_SHADER_STAGE_VERTEX_BIT , \"custom_point.vert.spv\" ); dvz_graphics_shader ( graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"custom_point.frag.spv\" ); // We define the graphics pipeline topology: point list here. dvz_graphics_topology ( graphics , VK_PRIMITIVE_TOPOLOGY_POINT_LIST ); // Next, we declare the size of our vertex structure. dvz_graphics_vertex_binding ( graphics , 0 , sizeof ( PointVertex )); // We now declare the vertex shader attributes, that should correspond to the different // structure fields in the vertex structure. // The first attribute is a vec3 in GLSL, and a vec3 in C too. dvz_graphics_vertex_attr ( graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( PointVertex , pos )); // The second attribute is a float in GLSL, and a byte (uint8) in C. We use the special // format VK_FORMAT_R8_USCALED to declare this. dvz_graphics_vertex_attr ( graphics , 0 , 1 , VK_FORMAT_R8_USCALED , offsetof ( PointVertex , size )); // Now that we've set up the graphics, we create it. dvz_graphics_create ( graphics ); // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); As shown here, the creation of a custom graphics involves the following steps: Defining the shaders, Defining the primitive type, Declaring the vertex structure, the format of each field, and the casting between the GPU and GPU. There are further functions in the vklite API to customize the creation of the graphics pipeline. Refer to the Datoviz C API reference for more details. Writing the custom visual \u00b6 Here is how to add a custom graphics to a custom visual: // We create a blank visual, to which we'll add our custom visual. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // ... creating the custom graphics... // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); At this point, the custom visual contains common sources (vertex, MVP, viewport) and props. One could then define more sources and props. Writing a simple test \u00b6 Finally, here is how to use our custom visual with a custom graphics: // ... creating the custom visual with the custom graphics... // We add the custom visual to the panel. dvz_custom_visual ( panel , visual ); // Now, we prepare the vertex data. We could have defined and used props, but we'll show // another method instead. We create the vertex buffer directly, using the PointVertex // structure we've created. const uint32_t N = 64 ; // number of points PointVertex * vertices = calloc ( N , sizeof ( PointVertex )); // vertex buffer float t = 0 ; for ( uint32_t i = 0 ; i < N ; i ++ ) { t = i / ( float )( N - 1 ); // vertex position vertices [ i ]. pos [ 0 ] = - .75 + 1.25 * t * t ; vertices [ i ]. pos [ 1 ] = + .75 - 1.25 * t ; // vertex size, in byte, between 0 and 255. vertices [ i ]. size = 4 * i + 1 ; } // Here is the crucial bit: we bind the GPU vertex buffer with our struct array. dvz_visual_data_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , 0 , N , N , vertices ); FREE ( vertices ); Here are a few comments: Instead of using visual props, we have defined the vertex structure directly. The whole point of the visual props is to avoid doing this, which may not be particularly easy with complex vertex shaders with many attributes. Also, setting the vertex buffer directly requires to understand how the graphics is implemented on the GPU. If some form of triangulation is required, it is up to the user to do it. In this particular example, there is no triangulation as we have a one-to-one correspondance between the squares and the vertices. Note that the data buffers passed to the dvz_visual_data*() functions make a copy of the data, so we're fine freeing it. Other topics \u00b6 We didn't yet cover these other aspects: Other resources (textures, other uniforms), Other shaders (geometry shader, tesselation shader), Indexed rendering, Indirect rendering, Fixed functions, Depth testing, Dynamic states, Specialization constants, Push constants, Custom command buffers, Interaction with compute shaders, And many other topics... Checklist for Datoviz contributors \u00b6 This is a handy checklist for developers when adding new graphics to the library (via a pull request). graphics.h : Add the typedef of the vertex, item, params structures Add new section and structs for vertex, item, params structures Make sure all fields in the params struct have a byte size that is not 3 or divisible by 3 Put comments after each struct field (used by automatic documentation generator) vklite.h : Make sure the DvzGraphicsType enum exists, or create a new one Shaders: graphics_xxx.vert|frag : Don't forget to import common.glsl in all shaders The first user binding should be params, should match exactly the struct The next bindings should be numbered with USER_BINDING+1 etc The body of the main fragment shader function should always begin with CLIP graphics.c : Add new section, with _graphics_xxx() and _graphics_xxx_callback() if there is a non-default graphics callback function Write the main graphics function Specify the shaders Specify the primitive type Specify the vertex attributes, should match the vertex shader Add the common slots Add slots for params/textures Specify the graphics callback function (optional) Write the graphics callback function This function is called when a new item is added to the graphics. What an \"item\" is is up to the create of a graphics. It's typically the smallest bit of data that has a meaning in the context of the graphics. The graphics callback is mostly used for pre-upload CPU-side \"triangulation\" of the data, so that the visuals that reuse this graphics don't have to know the details of the triangulation. Add the switch case in dvz_graphics_builtin() test_graphics.h : Add the new graphics test declaration test_graphics.c : Write the body of the test function Set to save the screenshot with the graphics name main.c : Add the new test to the list of test functions Test the graphics without interactivity and save the graphics screenshot Add graphics section in docs/reference/graphics.md","title":"How to write a custom graphics"},{"location":"howto/graphics/#how-to-write-a-custom-graphics","text":"Warning You need to go through the Vulkan crash course before following this guide. You also need to go through the how to write a custom visual guide first. In this section, we'll show how to create a custom graphics by writing custom GLSL shaders . This is an advanced topic as it requires understanding the basic of GPU graphics programming. Note Only the C API supports custom graphics at the moment. Python bindings for custom graphics will come in an upcoming version. Datoviz already includes the code necessary to compile GLSL shaders to SPIR-V on the fly (based on Khronos glslang ). The full source code for this example can be found in examples/custom_graphics.c . As a toy example, we'll create a graphics with square points of various size and color . Specifically, we'll require each point to have a different size (which is not supported in the existing point graphics), and a color depending directly on the size and computed directly on the GPU. We'll use a single byte per vertex to store the vertex size (between 0 and 255 pixels), and we'll use no memory for the color since it will be determined directly by this value. This kind of memory optimization is one of the use-cases of writing custom graphics. Limiting memory usage is important when dealing with extremely large datasets (tens or hundreds of millions of points). Writing a custom graphics involves the following steps: Choosing the primitive type. Defining the vertex data structure and corresponding vertex shader attributes. Writing the vertex shader. Writing the fragment shader. Compiling the GLSL shaders to SPIR-V (may be done automatically in the future). Writing the custom graphics. Writing the custom visual. Writing a simple test. Note Here, we show how to create a custom graphics compatible with the scene API, so that it can be used added to the scene the same way as builtin visuals. One could however decide not to use the scene API at all, and leverage instead the vklite API directly. This allows one to create entirely custom and standalone applications. This is not documented at the moment, and one should look at the vklite unit tests to understand how to use the vklite API directly.","title":"How to write a custom graphics"},{"location":"howto/graphics/#choosing-the-graphics-primitive-type","text":"Vulkan supports six major types of primitives: point list : square points with an arbitrary size, line list : disjoint aliased line segments, line strip : joined aliased line segments, triangle strip : joined triangles consecutively sharing an edge, triangle fan : joined triangles all sharing a single corner (the first vertex), triangle list : disjoint triangles, Other less common primitive types are described in the Vulkan specification . Warning Triangle fans are not supported on macOS. Schematic from the Vulkan Cookbook by Pawel Lapinski, O'Reilly Note The circular arrows in the triangles above indicate the orientation of the triangles, which is taken into account by the GPU. It is good practice to always ensure that all triangles constituting a given object are consistent. For example, when triangulating a square with two triangles, the order of the vertices should be chosen such that both triangles are directly oriented. The graphics pipeline can be configured to handle triangle orientation in a specific way. For example, one can make a graphics pipeline where indirectly oriented triangles are automatically discarded. Line primitives typically have a width of 1 pixel, although some hardware supports thicker lines. In Datoviz, thick, high-quality lines are implemented with triangles instead (line triangulation), and the antialiased thick line is drawn directly in the fragment shader. \"Basic\" line primitives are only used for testing and for special high-performance applications where scalability and performance are more important than visual quality. The most commonly-used primitive types in scientific visualization are essentially point lists and triangle lists (and to a lesser extent, triangle strips). In this example, we'll use a point list , where each point will correspond to one square.","title":"Choosing the graphics primitive type"},{"location":"howto/graphics/#defining-the-vertex-data-structure","text":"Once we know we'll use a point list as a primitive, the next step is to define the vertex data structure / vertex shader attributes. Here, we want the following attributes for each vertex: the point position (center of the square), as a vec3 , the point size (edge length of the square, in pixels), as an uint8_t . The point size will be limited to a maximum of 255 pixels in this toy example. We could have simply used a floating-point for the edge length, but that would have used four bytes instead of one. This is also to show the versatility of Vulkan and GPU programming, where we have full control on the data types used on both the GPU and CPU. Here is our vertex C structure: // We define the vertex structure for our graphics pipeline. typedef struct { vec3 pos ; // 3D point position uint8_t size ; // point size, in pixels, between 0 and 255. } PointVertex ; We also need to define the attributes in GLSL: layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0","title":"Defining the vertex data structure"},{"location":"howto/graphics/#attribute-format","text":"In this example, we use a uint8_t (byte) on the CPU, but a float on the GPU. Vulkan provides a way to specify the way we want to do the casting . This is done when creating the graphics pipeline below. We can just say here that we'll use the Vulkan format VK_FORMAT_R8_USCALED . This format means that: Number of components . There is a single component (scalar), the R in R8 means \"red\" component: this is the component used for scalar values. If using a pair of components, we would have both a R and G component (green). This naming convention using color names comes from the fact that these GPU formats are typically used to represent colors, but they can actually represent any type of numerical data. Number of bits per component . The 8 in R8 means that our red component is represented with 8 bits. Signedness . The U in USCALED means that we use an unsigned format. Scaling . The SCALED means that the byte, a number between 0 and 255, will be converted to a float without normalization: 255 becomes 255.0. Here are the other common scaling options provided by Vulkan when using bytes: Scaling GPU number type Range UNORM float [0.0, 1.0] SNORM float [-1.0, 1.0] USCALED float [0.0, 255.0] SSCALED float [-128.0, +127.0] (?) UINT int [0, 255] SINT int [-128, 127] (?) You'll find more information here: Full list of formats in the Vulkan spec , Hardware support of the formats : some formats are not supported by all existing GPUs. This website is quite useful to know what formats have the best hardware support.","title":"Attribute format"},{"location":"howto/graphics/#writing-the-vertex-shader","text":"We're now ready to write the vertex shader. Here is the full source code of the vertex shader: // code from `examples/custom_point.vert`: // GLSL version #version 450 // To be compatible with the scene API, all graphics shaders must include a common GLSL include // file. It defines common uniform bindings and common functions (for example, transform()). // These .glsl files are found in `include/datoviz/glsl`, so one needs to pass // `-Ipath/to/datoviz/include/datoviz/glsl` to the `glslc` command (see build.sh script). #include \"common.glsl\" // Here, we also use GLSL colormaps to compute the square color directly in the vertex shader, // without using the colormap texture. #include \"colormaps.glsl\" // Here, we describe the vertex shader attributes. layout ( location = 0 ) in vec3 pos ; // x, y, z positions layout ( location = 1 ) in float size ; // point size, between 0.0 and 255.0 // We made the unusual choice here to use a float in the shader, which corresponds to a uint8 byte // in C. We also decided not to normalize it, i.e. that the byte 255 corresponds to the float 255.0 // in the shader (VK_FORMAT_R8_USCALED format). Other choices can be made when specifying the // attribute format in the custom graphics definition. // Here, we describe the \"varying\" variables. These are special values output by the vertex shader, // and passed to the fragment shader. layout ( location = 0 ) out vec4 out_color ; // Main shader code. void main () { // Here, \"pos\" is the position of the vertex being processed. gl_Position is a special output // variable that returns the vertex final position in normalized device coordinates. It // is a vec4 vector, the fourth component is the homogeneous coordinate. // The \"transform()\" function is defined in common.glsl. It applies the model, view, proj // matrices stored in the first (common) uniform buffer (MVP buffer). gl_Position = transform ( pos ); // This special variable is an output variable that contains the point size, in pixels, // of the vertex being processed. It is reserved to graphics pipelines with a point list // primitive. gl_PointSize = size ; // Here, we set the varying variable that will be passed to the fragment shader. // The function colormap() is implemented in colormaps.glsl. It supports a few colormaps // that are implemented directly in GLSL, without using a texture. The second argument // is a value between 0 and 1, hence the normalization with the size which is in pixels. out_color = colormap ( DVZ_CMAP_HSV , size / 255.0 ); out_color . a = .25 ; // alpha component for some transparency } A few comments can be found below.","title":"Writing the vertex shader"},{"location":"howto/graphics/#common-shader-resources","text":"The #include directive is provided for convenience by the GLSL to SPIR-V compiler glslc . It is used extensively in Datoviz. It provides a simple way of making all graphics shaders share some functions and resources. In particular, we make the convention that, in order to be compatible with the scene API, all graphics pipelines in Datoviz must have the following common slots : layout (std140, binding = 0) uniform MVP {...}; layout (std140, binding = 1) uniform Viewport {...}; Binding Descriptor type Description 0 uniform structure with the model-view-proj matrices 1 uniform structure with viewport information This is done just by including common.glsl in every shader. Note that this is not required when using completely standalone graphics pipelines that will never be used with the scene API. When one needs to add another bindings, the numbering should start at USER_BINDING , a special GLSL macro that is currently 2.","title":"Common shader resources"},{"location":"howto/graphics/#varying-variables","text":"The vertex shader may pass some variables to the next stage, typically the fragment shader, using varying variables . A crucial difference between the vertex and fragment shaders is that the vertex shader executes on every vertex , whereas the fragment shader executes on every pixel . When the vertex shader passes a value to the fragment shader, the GPU makes a linear interpolation for all pixels between two vertices in the same primitive. This is specific to line and triangle primitives, not points. For example, passing 0 to one vertex and 1 to the next vertex in a graphics with a line primitive would result in all pixels being passed a real value between 0 and 1 depending on the position of that pixel within that line segment. This system is used in particular with: Color gradients, Texture coordinates.","title":"Varying variables"},{"location":"howto/graphics/#position-transformation","text":"The common.glsl file defines (several overloaded versions of) the function transform() , which applies the model-view-proj matrices stored in the first bound resource, the MVP uniform. The associated C structure is DvzMVP : struct DvzMVP { mat4 model ; // model 4x4 matrix mat4 view ; // view 4x4 matrix mat4 proj ; // projection 4x4 matrix float time ; // elapsed time since the start of the application, in seconds }; The transformation is basically gl_Position = to_vulkan(proj * view * model * position) . The to_vulkan() internal function transforms the position from the OpenGL/Datoviz 3D coordinate system (y up, z toward the user) to the Vulkan coordinate system (y down, z toward the inside of the screen).","title":"Position transformation"},{"location":"howto/graphics/#special-glsl-variables","text":"We use a few special GLSL variables in the vertex shader: Name Type Description gl_Position vec4 final vertex position in normalized device coordinates gl_PointSize float size of the point, when using the point list primitive There are many more special variables available in each type of shader. You'll find the list of special GLSL variables here.","title":"Special GLSL variables"},{"location":"howto/graphics/#colormaps","text":"The colormap() function is implemented in colormaps.glsl . It provides a GLSL implementation of a few common colormaps, which allows to compute the color as a function of a scalar value without using a texture . There are a few advantages to this, mostly related to performance and avoiding edge effects when using nearest interpolation in the texture.","title":"Colormaps"},{"location":"howto/graphics/#writing-the-fragment-shader","text":"We now pass to the fragment shader. Here is the code: // code from `examples/custom_point.frag`: #version 450 #include \"common.glsl\" // The \"in\" variables here MUST correspond to the \"out\" variables from the vertex shader. layout ( location = 0 ) in vec4 in_color ; // The first output variable of the fragment shader must be a vec4 variable with the RGBA // components of the pixel being processed. layout ( location = 0 ) out vec4 out_color ; void main () { // This macro is used to implement clipping in the inner viewport, when using panel margins. // All fragment shader of all graphics must include this macro for now. CLIP // Here, we simply pass the varying color (already computed by the vertex shader) to the // output variable. // NOTE: we could also have passed the point size from the vertex shader to the fragment // shader, and compute the colormap here. HOWEVER the computation of the colormap would have // been done for each *pixel*, rather than each *vertex*. Since we're using uniform square // colors in this example, that would have resulted in wasted duplicate computations and // unjustified loss of performance. // When the pixel color is non uniform across the primitive, and not just linearly interpolated // between the vertices, one can compute the pixel color directly in the fragment shader. out_color = in_color ; } Here are a few comments.","title":"Writing the fragment shader"},{"location":"howto/graphics/#clipping","text":"Datoviz panels may have margins around them. We make the distinction between: Viewport Description inner viewport area of the panel excluding the margins outer viewport area of the panel including the margins We follow the convention that the normalized coordinates [-1, +1] correspond to the inner viewport . Vertices beyond these limits will be rendered in the margins. Clipping allows to hide all pixels outside the inner viewport. This is how we implement the axes controller: graphics should not be rendered in the margins which contain the tick labels. Any graphics that should be compatible with the axes controller should therefore have the special CLIP macro at the beginning of the fragments shader (implemented in common.glsl ). This macro detects whether the current pixel is beyond the inner viewport, and if the graphics has been configured so, it discards that pixel.","title":"Clipping"},{"location":"howto/graphics/#special-variables","text":"We haven't used any special variable in this fragment shader, but here are two useful variables that we could use: Name Type Description gl_FragCoord vec4 pixel position in window space gl_PointCoord vec2 coordinates of the pixel within the point primitive The gl_PointCoord variable is reserved to graphics pipelines using a point primitive. It provides the coordinates, in pixels, of the current pixel within the square. The origin is at the upper-left corner of the square.","title":"Special variables"},{"location":"howto/graphics/#compiling-the-shaders-to-spir-v","text":"Once the shaders have been written, they should be compiled to SPIR-V (unless using Datoviz to compile shaders provided as GLSL code, but this is a work in progress). Here is how to compile the shaders on the command-line: glslc custom_point.vert -o custom_point.vert.spv glslc custom_point.frag -o custom_point.frag.spv The glslc command is provided by the Vulkan SDK.","title":"Compiling the shaders to SPIR-V"},{"location":"howto/graphics/#writing-the-custom-graphics","text":"Here is the code to create a custom graphics compatible with the scene API, and to add it to a custom visual: // We create a blank graphics that will become our custom graphics. DvzGraphics * graphics = dvz_blank_graphics ( scene , 0 ); // Custom graphics creation. // The first step is to define the vertex and fragment shaders. When using // dvz_graphics_shader(), one must specify a path to the compiled SPIR-V shaders. // When writing the shaders in GLSL, it is thus necessary to compile them separately with // glslc. dvz_graphics_shader ( graphics , VK_SHADER_STAGE_VERTEX_BIT , \"custom_point.vert.spv\" ); dvz_graphics_shader ( graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"custom_point.frag.spv\" ); // We define the graphics pipeline topology: point list here. dvz_graphics_topology ( graphics , VK_PRIMITIVE_TOPOLOGY_POINT_LIST ); // Next, we declare the size of our vertex structure. dvz_graphics_vertex_binding ( graphics , 0 , sizeof ( PointVertex )); // We now declare the vertex shader attributes, that should correspond to the different // structure fields in the vertex structure. // The first attribute is a vec3 in GLSL, and a vec3 in C too. dvz_graphics_vertex_attr ( graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( PointVertex , pos )); // The second attribute is a float in GLSL, and a byte (uint8) in C. We use the special // format VK_FORMAT_R8_USCALED to declare this. dvz_graphics_vertex_attr ( graphics , 0 , 1 , VK_FORMAT_R8_USCALED , offsetof ( PointVertex , size )); // Now that we've set up the graphics, we create it. dvz_graphics_create ( graphics ); // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); As shown here, the creation of a custom graphics involves the following steps: Defining the shaders, Defining the primitive type, Declaring the vertex structure, the format of each field, and the casting between the GPU and GPU. There are further functions in the vklite API to customize the creation of the graphics pipeline. Refer to the Datoviz C API reference for more details.","title":"Writing the custom graphics"},{"location":"howto/graphics/#writing-the-custom-visual","text":"Here is how to add a custom graphics to a custom visual: // We create a blank visual, to which we'll add our custom visual. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // ... creating the custom graphics... // We add our custom graphics to a custom visual. dvz_custom_graphics ( visual , graphics ); At this point, the custom visual contains common sources (vertex, MVP, viewport) and props. One could then define more sources and props.","title":"Writing the custom visual"},{"location":"howto/graphics/#writing-a-simple-test","text":"Finally, here is how to use our custom visual with a custom graphics: // ... creating the custom visual with the custom graphics... // We add the custom visual to the panel. dvz_custom_visual ( panel , visual ); // Now, we prepare the vertex data. We could have defined and used props, but we'll show // another method instead. We create the vertex buffer directly, using the PointVertex // structure we've created. const uint32_t N = 64 ; // number of points PointVertex * vertices = calloc ( N , sizeof ( PointVertex )); // vertex buffer float t = 0 ; for ( uint32_t i = 0 ; i < N ; i ++ ) { t = i / ( float )( N - 1 ); // vertex position vertices [ i ]. pos [ 0 ] = - .75 + 1.25 * t * t ; vertices [ i ]. pos [ 1 ] = + .75 - 1.25 * t ; // vertex size, in byte, between 0 and 255. vertices [ i ]. size = 4 * i + 1 ; } // Here is the crucial bit: we bind the GPU vertex buffer with our struct array. dvz_visual_data_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , 0 , N , N , vertices ); FREE ( vertices ); Here are a few comments: Instead of using visual props, we have defined the vertex structure directly. The whole point of the visual props is to avoid doing this, which may not be particularly easy with complex vertex shaders with many attributes. Also, setting the vertex buffer directly requires to understand how the graphics is implemented on the GPU. If some form of triangulation is required, it is up to the user to do it. In this particular example, there is no triangulation as we have a one-to-one correspondance between the squares and the vertices. Note that the data buffers passed to the dvz_visual_data*() functions make a copy of the data, so we're fine freeing it.","title":"Writing a simple test"},{"location":"howto/graphics/#other-topics","text":"We didn't yet cover these other aspects: Other resources (textures, other uniforms), Other shaders (geometry shader, tesselation shader), Indexed rendering, Indirect rendering, Fixed functions, Depth testing, Dynamic states, Specialization constants, Push constants, Custom command buffers, Interaction with compute shaders, And many other topics...","title":"Other topics"},{"location":"howto/graphics/#checklist-for-datoviz-contributors","text":"This is a handy checklist for developers when adding new graphics to the library (via a pull request). graphics.h : Add the typedef of the vertex, item, params structures Add new section and structs for vertex, item, params structures Make sure all fields in the params struct have a byte size that is not 3 or divisible by 3 Put comments after each struct field (used by automatic documentation generator) vklite.h : Make sure the DvzGraphicsType enum exists, or create a new one Shaders: graphics_xxx.vert|frag : Don't forget to import common.glsl in all shaders The first user binding should be params, should match exactly the struct The next bindings should be numbered with USER_BINDING+1 etc The body of the main fragment shader function should always begin with CLIP graphics.c : Add new section, with _graphics_xxx() and _graphics_xxx_callback() if there is a non-default graphics callback function Write the main graphics function Specify the shaders Specify the primitive type Specify the vertex attributes, should match the vertex shader Add the common slots Add slots for params/textures Specify the graphics callback function (optional) Write the graphics callback function This function is called when a new item is added to the graphics. What an \"item\" is is up to the create of a graphics. It's typically the smallest bit of data that has a meaning in the context of the graphics. The graphics callback is mostly used for pre-upload CPU-side \"triangulation\" of the data, so that the visuals that reuse this graphics don't have to know the details of the triangulation. Add the switch case in dvz_graphics_builtin() test_graphics.h : Add the new graphics test declaration test_graphics.c : Write the body of the test function Set to save the screenshot with the graphics name main.c : Add the new test to the list of test functions Test the graphics without interactivity and save the graphics screenshot Add graphics section in docs/reference/graphics.md","title":"Checklist for Datoviz contributors"},{"location":"howto/standalone_canvas/","text":"How to use the canvas C API \u00b6 This example shows how to write a standalone C app using only the canvas API , not the scene API. We'll render a triangle without using existing graphics, visuals, panels, and so on. We'll follow these steps: Creating a graphics with custom shaders, Creating a function callback for command buffer refill, Creating a vertex buffer manually. // code from `examples/standalone_canvas.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // Objects we'll need in the refill callback. Using static global variables is not a good practice // in real-world applications... static DvzBufferRegions vertex_buffer ; static DvzGraphics graphics ; static DvzBindings bindings ; // Refill callback. This function is called by the canvas whenever it needs to recreate its command // buffers, for example when initializing the canvas, and when resizing it. static void _triangle_refill ( DvzCanvas * canvas , DvzEvent ev ) { ASSERT ( canvas != NULL ); // The callback is passed an event object with a list of command buffers to recreate. In // this particular example, we just use a single command buffer. ASSERT ( ev . u . rf . cmd_count == 1 ); DvzCommands * cmds = ev . u . rf . cmds [ 0 ]; // There is by default just one command buffer, linked to the render queue. ASSERT ( cmds -> queue_idx == DVZ_DEFAULT_QUEUE_RENDER ); // This is the current swapchain image index for which we need to refill the command buffer. // There is one command buffer per swapchain image, so whenever a command buffer refill is // needed, this callback function is called three times for example, if using triple buffering. uint32_t idx = ev . u . rf . img_idx ; // We begin recording the command buffer here. dvz_cmd_begin ( cmds , idx ); // We begin the default render pass. dvz_cmd_begin_renderpass ( cmds , idx , & canvas -> renderpass , & canvas -> framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( cmds , idx , canvas -> viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( cmds , idx , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( cmds , idx , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( cmds , idx , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( cmds , idx ); dvz_cmd_end ( cmds , idx ); } int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu ( app , 0 ); // We create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1280 , 1024 , 0 ); // We create a new graphics pipeline. graphics = dvz_graphics ( gpu ); // We set the renderpass. dvz_graphics_renderpass ( & graphics , & canvas -> renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for all // graphics pipelines in the application. Defining many small GPU buffers is bad practice. DvzBuffer buffer = dvz_buffer ( gpu ); // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in real // applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); // We set the command buffer refill callback, the function that will be called whenever the // canvas needs to refill its command buffers. The callback generates the GPU commands to draw // the triangle. dvz_event_callback ( canvas , DVZ_EVENT_REFILL , 0 , DVZ_EVENT_MODE_SYNC , _triangle_refill , NULL ); // dvz_app_run(app, 5); // dvz_screenshot_file(canvas, \"../docs/images/screenshots/standalone_canvas.png\"); dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_app_destroy ( app ); return 0 ; }","title":"How to use the canvas C API"},{"location":"howto/standalone_canvas/#how-to-use-the-canvas-c-api","text":"This example shows how to write a standalone C app using only the canvas API , not the scene API. We'll render a triangle without using existing graphics, visuals, panels, and so on. We'll follow these steps: Creating a graphics with custom shaders, Creating a function callback for command buffer refill, Creating a vertex buffer manually. // code from `examples/standalone_canvas.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // Objects we'll need in the refill callback. Using static global variables is not a good practice // in real-world applications... static DvzBufferRegions vertex_buffer ; static DvzGraphics graphics ; static DvzBindings bindings ; // Refill callback. This function is called by the canvas whenever it needs to recreate its command // buffers, for example when initializing the canvas, and when resizing it. static void _triangle_refill ( DvzCanvas * canvas , DvzEvent ev ) { ASSERT ( canvas != NULL ); // The callback is passed an event object with a list of command buffers to recreate. In // this particular example, we just use a single command buffer. ASSERT ( ev . u . rf . cmd_count == 1 ); DvzCommands * cmds = ev . u . rf . cmds [ 0 ]; // There is by default just one command buffer, linked to the render queue. ASSERT ( cmds -> queue_idx == DVZ_DEFAULT_QUEUE_RENDER ); // This is the current swapchain image index for which we need to refill the command buffer. // There is one command buffer per swapchain image, so whenever a command buffer refill is // needed, this callback function is called three times for example, if using triple buffering. uint32_t idx = ev . u . rf . img_idx ; // We begin recording the command buffer here. dvz_cmd_begin ( cmds , idx ); // We begin the default render pass. dvz_cmd_begin_renderpass ( cmds , idx , & canvas -> renderpass , & canvas -> framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( cmds , idx , canvas -> viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( cmds , idx , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( cmds , idx , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( cmds , idx , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( cmds , idx ); dvz_cmd_end ( cmds , idx ); } int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu ( app , 0 ); // We create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1280 , 1024 , 0 ); // We create a new graphics pipeline. graphics = dvz_graphics ( gpu ); // We set the renderpass. dvz_graphics_renderpass ( & graphics , & canvas -> renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for all // graphics pipelines in the application. Defining many small GPU buffers is bad practice. DvzBuffer buffer = dvz_buffer ( gpu ); // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in real // applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); // We set the command buffer refill callback, the function that will be called whenever the // canvas needs to refill its command buffers. The callback generates the GPU commands to draw // the triangle. dvz_event_callback ( canvas , DVZ_EVENT_REFILL , 0 , DVZ_EVENT_MODE_SYNC , _triangle_refill , NULL ); // dvz_app_run(app, 5); // dvz_screenshot_file(canvas, \"../docs/images/screenshots/standalone_canvas.png\"); dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_app_destroy ( app ); return 0 ; }","title":"How to use the canvas C API"},{"location":"howto/standalone_scene/","text":"How to write a standalone C app \u00b6 This example shows how to make a scatter plot using the scene C API in a standalone application. Note A basic build script is provided in the examples/ folder. A better practice would probably be to use cmake but this is not documented yet. Help appreciated! Full source code \u00b6 // code from `examples/standalone_scene.c`: /*************************************************************************************************/ /* Example of a standalone application using the library. */ /*************************************************************************************************/ /// Import the library public header. The compiler needs to be passed the path to the headers and /// shared library, see build.sh. #include <datoviz/datoviz.h> int main ( int argc , char ** argv ) { // Create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // Use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu ( app , 0 ); // Create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1280 , 1024 , 0 ); // Create a new scene, which allows to define several subplots (panels) organized within a // grid. Here we just use a single panel spanning the entire canvas. DvzScene * scene = dvz_scene ( canvas , 1 , 1 ); // Get the panel at row 0, column 0, and initialize it with an axes 2D controller. // The last argument is for optional flags. DvzPanel * panel = dvz_scene_panel ( scene , 0 , 0 , DVZ_CONTROLLER_AXES_2D , 0 ); // Create a new \"marker\" visual within the panel. // The last argument is for optional flags. DvzVisual * visual = dvz_scene_visual ( panel , DVZ_VISUAL_MARKER , 0 ); // Prepare the data for the marker visual: // - positions (three double-precision floating point numbers for x, y, z) // - color (four bytes for r, g, b, a) // - size (a single precision floating point number with the marker size, in pixels) // There are many other settable visual properties, refer to the visual reference guide. const uint32_t N = 100000 ; dvec3 * pos = ( dvec3 * ) calloc ( N , sizeof ( dvec3 )); cvec4 * color = ( cvec4 * ) calloc ( N , sizeof ( cvec4 )); float * size = ( float * ) calloc ( N , sizeof ( float )); for ( uint32_t i = 0 ; i < N ; i ++ ) { // Random gaussian position. pos [ i ][ 0 ] = dvz_rand_normal (); pos [ i ][ 1 ] = dvz_rand_normal (); // Color: random value with a colormap. dvz_colormap_scale ( DVZ_CMAP_VIRIDIS , dvz_rand_float (), 0 , 1 , color [ i ]); // A bit of transparency via the alpha channel. color [ i ][ 3 ] = 196 ; // Random marker size. size [ i ] = 2 + 38 * dvz_rand_float (); } // We link our data to the visual properties. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , N , pos ); dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , N , color ); dvz_visual_data ( visual , DVZ_PROP_MARKER_SIZE , 0 , N , size ); // dvz_app_run(app, 5); // dvz_screenshot_file(canvas, \"../docs/images/screenshots/standalone_scene.png\"); // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_app_destroy ( app ); // We free the memory of the arrays we've created. FREE ( pos ); FREE ( color ); FREE ( size ); return 0 ; }","title":"How to write a standalone C app"},{"location":"howto/standalone_scene/#how-to-write-a-standalone-c-app","text":"This example shows how to make a scatter plot using the scene C API in a standalone application. Note A basic build script is provided in the examples/ folder. A better practice would probably be to use cmake but this is not documented yet. Help appreciated!","title":"How to write a standalone C app"},{"location":"howto/standalone_scene/#full-source-code","text":"// code from `examples/standalone_scene.c`: /*************************************************************************************************/ /* Example of a standalone application using the library. */ /*************************************************************************************************/ /// Import the library public header. The compiler needs to be passed the path to the headers and /// shared library, see build.sh. #include <datoviz/datoviz.h> int main ( int argc , char ** argv ) { // Create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // Use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu ( app , 0 ); // Create a new canvas with the size specified. The last argument is for optional flags. DvzCanvas * canvas = dvz_canvas ( gpu , 1280 , 1024 , 0 ); // Create a new scene, which allows to define several subplots (panels) organized within a // grid. Here we just use a single panel spanning the entire canvas. DvzScene * scene = dvz_scene ( canvas , 1 , 1 ); // Get the panel at row 0, column 0, and initialize it with an axes 2D controller. // The last argument is for optional flags. DvzPanel * panel = dvz_scene_panel ( scene , 0 , 0 , DVZ_CONTROLLER_AXES_2D , 0 ); // Create a new \"marker\" visual within the panel. // The last argument is for optional flags. DvzVisual * visual = dvz_scene_visual ( panel , DVZ_VISUAL_MARKER , 0 ); // Prepare the data for the marker visual: // - positions (three double-precision floating point numbers for x, y, z) // - color (four bytes for r, g, b, a) // - size (a single precision floating point number with the marker size, in pixels) // There are many other settable visual properties, refer to the visual reference guide. const uint32_t N = 100000 ; dvec3 * pos = ( dvec3 * ) calloc ( N , sizeof ( dvec3 )); cvec4 * color = ( cvec4 * ) calloc ( N , sizeof ( cvec4 )); float * size = ( float * ) calloc ( N , sizeof ( float )); for ( uint32_t i = 0 ; i < N ; i ++ ) { // Random gaussian position. pos [ i ][ 0 ] = dvz_rand_normal (); pos [ i ][ 1 ] = dvz_rand_normal (); // Color: random value with a colormap. dvz_colormap_scale ( DVZ_CMAP_VIRIDIS , dvz_rand_float (), 0 , 1 , color [ i ]); // A bit of transparency via the alpha channel. color [ i ][ 3 ] = 196 ; // Random marker size. size [ i ] = 2 + 38 * dvz_rand_float (); } // We link our data to the visual properties. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , N , pos ); dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , N , color ); dvz_visual_data ( visual , DVZ_PROP_MARKER_SIZE , 0 , N , size ); // dvz_app_run(app, 5); // dvz_screenshot_file(canvas, \"../docs/images/screenshots/standalone_scene.png\"); // We run the application. The last argument is the number of frames to run, or 0 for infinite // loop (stop when escape is pressed or when the window is closed). dvz_app_run ( app , 0 ); // We need to clean up all objects handled by Datoviz at the end. dvz_app_destroy ( app ); // We free the memory of the arrays we've created. FREE ( pos ); FREE ( color ); FREE ( size ); return 0 ; }","title":"Full source code"},{"location":"howto/standalone_vklite/","text":"How to use the vklite C API \u00b6 This example shows how to write a standalone C app using only the vklite API (thin wrapper on top of the Vulkan C API), not the canvas or scene API. Creating a Vulkan-aware window is a complex operation as it requires creating a swapchain and implementing a rendering loop using proper CPU-GPU and GPU-GPU synchronization. The canvas abstracts that complexity away and there are probably few reasons not to use it. Therefore, the main reason to use the vklite API directly is probably when doing offscreen rendering and/or compute , and when reusing existing visuals and graphics in Datoviz is not desirable. On this page, we'll show how to make an offscreen render of a triangle using only the vklite API. We'll cover the following steps: Creating a GPU with custom queues. Creating a render pass. Creating GPU images for rendering. Creating framebuffers. Creating a graphics pipeline. Creating pipeline bindings. Creating a vertex buffer. Creating and recording a command buffer. Submitting a command buffer to the GPU and waiting until it has completed. Making a screenshot by creating a staging GPU image, and submitting a command buffer with transition barriers and a GPU image copy. This \"hello world\" script is about 250 lines long (without comments), about 4x smaller than by using the raw Vulkan C API. // code from `examples/standalone_vklite.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // This function downloads the contents of the GPU image on which we have rendered to. static uint8_t * screenshot ( DvzImages * image ) { DvzGpu * gpu = image -> gpu ; // We create a staging image that is accessible from the CPU. DvzImages staging = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); dvz_images_format ( & staging , image -> format ); dvz_images_size ( & staging , image -> width , image -> height , image -> depth ); dvz_images_tiling ( & staging , VK_IMAGE_TILING_LINEAR ); dvz_images_usage ( & staging , VK_IMAGE_USAGE_TRANSFER_DST_BIT ); dvz_images_layout ( & staging , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_images_memory ( & staging , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); dvz_images_create ( & staging ); // We start the image transition command buffers. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); dvz_cmd_begin ( & cmds , 0 ); // We use a barrier to transition the staging image. DvzBarrier barrier = dvz_barrier ( gpu ); dvz_barrier_stages ( & barrier , VK_PIPELINE_STAGE_TRANSFER_BIT , VK_PIPELINE_STAGE_TRANSFER_BIT ); dvz_barrier_images ( & barrier , & staging ); dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_barrier_images_access ( & barrier , 0 , VK_ACCESS_TRANSFER_WRITE_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We copy the original image to the staging image. dvz_cmd_copy_image ( & cmds , 0 , image , & staging ); // We transition the staging image again. dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL , VK_IMAGE_LAYOUT_GENERAL ); dvz_barrier_images_access ( & barrier , VK_ACCESS_TRANSFER_WRITE_BIT , VK_ACCESS_MEMORY_READ_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We end the command buffer, we submit it to the GPU, and we wait until the GPU has completed // it. dvz_cmd_end ( & cmds , 0 ); dvz_cmd_submit_sync ( & cmds , 0 ); // Now, we copy the staging image back onto the host. uint8_t * rgb = ( uint8_t * ) calloc ( image -> width * image -> height , 3 ); dvz_images_download ( & staging , 0 , true , false , rgb ); // We can destroy the staging image. dvz_images_destroy ( & staging ); return rgb ; } int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu ( app , 0 ); // GPU creation. { // We specify the queues we need. Here we just need a single queue that will do the // rendering. dvz_gpu_queue ( gpu , 0 , DVZ_QUEUE_RENDER ); // Once the queues have been set up, we create the GPU. dvz_gpu_create ( gpu , 0 ); } // Framebuffer size. const uint32_t width = 800 ; const uint32_t height = 600 ; // Viewport. DvzViewport viewport = dvz_viewport_default ( width , height ); // We are going to create a renderpass. DvzRenderpass renderpass = dvz_renderpass ( gpu ); VkClearValue clear_color = { 0 }; VkClearValue clear_depth = { 0 }; // We create a GPU image that we will render onto. DvzImages image = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We also create a GPU image for the depth buffer. DvzImages depth = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We will create the framebuffers to link these GPU images with the renderpass. DvzFramebuffers framebuffers = dvz_framebuffers ( gpu ); // Renderpass creation. { // Clear colors. clear_color . color . float32 [ 3 ] = 1 ; clear_depth . depthStencil . depth = 1.0f ; dvz_renderpass_clear ( & renderpass , clear_color ); dvz_renderpass_clear ( & renderpass , clear_depth ); // Color attachment. dvz_renderpass_attachment ( & renderpass , 0 , // DVZ_RENDERPASS_ATTACHMENT_COLOR , VK_FORMAT_B8G8R8A8_UNORM , VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( & renderpass , 0 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_renderpass_attachment_ops ( & renderpass , 0 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_STORE ); // Depth attachment. dvz_renderpass_attachment ( & renderpass , 1 , // DVZ_RENDERPASS_ATTACHMENT_DEPTH , VK_FORMAT_D32_SFLOAT , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( & renderpass , 1 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_ops ( & renderpass , 1 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_DONT_CARE ); // Subpass. dvz_renderpass_subpass_attachment ( & renderpass , 0 , 0 ); dvz_renderpass_subpass_attachment ( & renderpass , 0 , 1 ); dvz_renderpass_subpass_dependency ( & renderpass , 0 , VK_SUBPASS_EXTERNAL , 0 ); dvz_renderpass_subpass_dependency_stage ( & renderpass , 0 , // VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT , VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT ); dvz_renderpass_subpass_dependency_access ( & renderpass , 0 , 0 , VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT ); // Color attachment dvz_images_format ( & image , renderpass . attachments [ 0 ]. format ); dvz_images_size ( & image , width , height , 1 ); dvz_images_tiling ( & image , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & image , VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT ); dvz_images_memory ( & image , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_aspect ( & image , VK_IMAGE_ASPECT_COLOR_BIT ); dvz_images_layout ( & image , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_queue_access ( & image , 0 ); dvz_images_create ( & image ); // Depth attachment. dvz_images_format ( & depth , renderpass . attachments [ 1 ]. format ); dvz_images_size ( & depth , width , height , 1 ); dvz_images_tiling ( & depth , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & depth , VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ); dvz_images_memory ( & depth , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_layout ( & depth , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_aspect ( & depth , VK_IMAGE_ASPECT_DEPTH_BIT ); dvz_images_queue_access ( & depth , 0 ); dvz_images_create ( & depth ); // Create renderpass. dvz_renderpass_create ( & renderpass ); // Create framebuffers. dvz_framebuffers_attachment ( & framebuffers , 0 , & image ); dvz_framebuffers_attachment ( & framebuffers , 1 , & depth ); dvz_framebuffers_create ( & framebuffers , & renderpass ); } // We create a new graphics pipeline. DvzGraphics graphics = dvz_graphics ( gpu ); // Graphics pipeline. { // We set the renderpass. dvz_graphics_renderpass ( & graphics , & renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); } // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. DvzBindings bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for all // graphics pipelines in the application. Defining many small GPU buffers is bad practice. DvzBuffer buffer = dvz_buffer ( gpu ); DvzBufferRegions vertex_buffer ; { // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in // real applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); } // We create a command buffer. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); // Command buffer recording. { // We begin recording the command buffer here. dvz_cmd_begin ( & cmds , 0 ); // We begin the default render pass. dvz_cmd_begin_renderpass ( & cmds , 0 , & renderpass , & framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( & cmds , 0 , viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( & cmds , 0 , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( & cmds , 0 , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( & cmds , 0 , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( & cmds , 0 ); dvz_cmd_end ( & cmds , 0 ); } // We submit the command buffer to the GPU and we *wait* until the GPU has finished completing // it. This uses a hard synchronization primitive so this is not efficient. dvz_cmd_submit_sync ( & cmds , 0 ); // We make a screenshot and save it to a file. uint8_t * rgb = screenshot ( & image ); dvz_write_png ( \"triangle.png\" , width , height , rgb ); log_info ( \"offscreen rendered image written to: `triangle.png`\" ); // We need to clean up all objects handled by Datoviz at the end. { dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_renderpass_destroy ( & renderpass ); dvz_images_destroy ( & image ); dvz_images_destroy ( & depth ); dvz_framebuffers_destroy ( & framebuffers ); dvz_bindings_destroy ( & bindings ); dvz_app_destroy ( app ); } return 0 ; }","title":"How to use the vklite C API"},{"location":"howto/standalone_vklite/#how-to-use-the-vklite-c-api","text":"This example shows how to write a standalone C app using only the vklite API (thin wrapper on top of the Vulkan C API), not the canvas or scene API. Creating a Vulkan-aware window is a complex operation as it requires creating a swapchain and implementing a rendering loop using proper CPU-GPU and GPU-GPU synchronization. The canvas abstracts that complexity away and there are probably few reasons not to use it. Therefore, the main reason to use the vklite API directly is probably when doing offscreen rendering and/or compute , and when reusing existing visuals and graphics in Datoviz is not desirable. On this page, we'll show how to make an offscreen render of a triangle using only the vklite API. We'll cover the following steps: Creating a GPU with custom queues. Creating a render pass. Creating GPU images for rendering. Creating framebuffers. Creating a graphics pipeline. Creating pipeline bindings. Creating a vertex buffer. Creating and recording a command buffer. Submitting a command buffer to the GPU and waiting until it has completed. Making a screenshot by creating a staging GPU image, and submitting a command buffer with transition barriers and a GPU image copy. This \"hello world\" script is about 250 lines long (without comments), about 4x smaller than by using the raw Vulkan C API. // code from `examples/standalone_vklite.c`: /*************************************************************************************************/ /* Example of a standalone application using the vklite API in a canvas. */ /*************************************************************************************************/ /// Import the library public header. #include <datoviz/datoviz.h> // This function downloads the contents of the GPU image on which we have rendered to. static uint8_t * screenshot ( DvzImages * image ) { DvzGpu * gpu = image -> gpu ; // We create a staging image that is accessible from the CPU. DvzImages staging = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); dvz_images_format ( & staging , image -> format ); dvz_images_size ( & staging , image -> width , image -> height , image -> depth ); dvz_images_tiling ( & staging , VK_IMAGE_TILING_LINEAR ); dvz_images_usage ( & staging , VK_IMAGE_USAGE_TRANSFER_DST_BIT ); dvz_images_layout ( & staging , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_images_memory ( & staging , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); dvz_images_create ( & staging ); // We start the image transition command buffers. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); dvz_cmd_begin ( & cmds , 0 ); // We use a barrier to transition the staging image. DvzBarrier barrier = dvz_barrier ( gpu ); dvz_barrier_stages ( & barrier , VK_PIPELINE_STAGE_TRANSFER_BIT , VK_PIPELINE_STAGE_TRANSFER_BIT ); dvz_barrier_images ( & barrier , & staging ); dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL ); dvz_barrier_images_access ( & barrier , 0 , VK_ACCESS_TRANSFER_WRITE_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We copy the original image to the staging image. dvz_cmd_copy_image ( & cmds , 0 , image , & staging ); // We transition the staging image again. dvz_barrier_images_layout ( & barrier , VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL , VK_IMAGE_LAYOUT_GENERAL ); dvz_barrier_images_access ( & barrier , VK_ACCESS_TRANSFER_WRITE_BIT , VK_ACCESS_MEMORY_READ_BIT ); dvz_cmd_barrier ( & cmds , 0 , & barrier ); // We end the command buffer, we submit it to the GPU, and we wait until the GPU has completed // it. dvz_cmd_end ( & cmds , 0 ); dvz_cmd_submit_sync ( & cmds , 0 ); // Now, we copy the staging image back onto the host. uint8_t * rgb = ( uint8_t * ) calloc ( image -> width * image -> height , 3 ); dvz_images_download ( & staging , 0 , true , false , rgb ); // We can destroy the staging image. dvz_images_destroy ( & staging ); return rgb ; } int main ( int argc , char ** argv ) { // We create a singleton application with a GLFW backend. DvzApp * app = dvz_app ( DVZ_BACKEND_GLFW ); // We use the first detected GPU. The last argument is the GPU index. DvzGpu * gpu = dvz_gpu ( app , 0 ); // GPU creation. { // We specify the queues we need. Here we just need a single queue that will do the // rendering. dvz_gpu_queue ( gpu , 0 , DVZ_QUEUE_RENDER ); // Once the queues have been set up, we create the GPU. dvz_gpu_create ( gpu , 0 ); } // Framebuffer size. const uint32_t width = 800 ; const uint32_t height = 600 ; // Viewport. DvzViewport viewport = dvz_viewport_default ( width , height ); // We are going to create a renderpass. DvzRenderpass renderpass = dvz_renderpass ( gpu ); VkClearValue clear_color = { 0 }; VkClearValue clear_depth = { 0 }; // We create a GPU image that we will render onto. DvzImages image = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We also create a GPU image for the depth buffer. DvzImages depth = dvz_images ( gpu , VK_IMAGE_TYPE_2D , 1 ); // We will create the framebuffers to link these GPU images with the renderpass. DvzFramebuffers framebuffers = dvz_framebuffers ( gpu ); // Renderpass creation. { // Clear colors. clear_color . color . float32 [ 3 ] = 1 ; clear_depth . depthStencil . depth = 1.0f ; dvz_renderpass_clear ( & renderpass , clear_color ); dvz_renderpass_clear ( & renderpass , clear_depth ); // Color attachment. dvz_renderpass_attachment ( & renderpass , 0 , // DVZ_RENDERPASS_ATTACHMENT_COLOR , VK_FORMAT_B8G8R8A8_UNORM , VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( & renderpass , 0 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_renderpass_attachment_ops ( & renderpass , 0 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_STORE ); // Depth attachment. dvz_renderpass_attachment ( & renderpass , 1 , // DVZ_RENDERPASS_ATTACHMENT_DEPTH , VK_FORMAT_D32_SFLOAT , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_layout ( & renderpass , 1 , VK_IMAGE_LAYOUT_UNDEFINED , VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ); dvz_renderpass_attachment_ops ( & renderpass , 1 , VK_ATTACHMENT_LOAD_OP_CLEAR , VK_ATTACHMENT_STORE_OP_DONT_CARE ); // Subpass. dvz_renderpass_subpass_attachment ( & renderpass , 0 , 0 ); dvz_renderpass_subpass_attachment ( & renderpass , 0 , 1 ); dvz_renderpass_subpass_dependency ( & renderpass , 0 , VK_SUBPASS_EXTERNAL , 0 ); dvz_renderpass_subpass_dependency_stage ( & renderpass , 0 , // VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT , VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT ); dvz_renderpass_subpass_dependency_access ( & renderpass , 0 , 0 , VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT ); // Color attachment dvz_images_format ( & image , renderpass . attachments [ 0 ]. format ); dvz_images_size ( & image , width , height , 1 ); dvz_images_tiling ( & image , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & image , VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT ); dvz_images_memory ( & image , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_aspect ( & image , VK_IMAGE_ASPECT_COLOR_BIT ); dvz_images_layout ( & image , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_queue_access ( & image , 0 ); dvz_images_create ( & image ); // Depth attachment. dvz_images_format ( & depth , renderpass . attachments [ 1 ]. format ); dvz_images_size ( & depth , width , height , 1 ); dvz_images_tiling ( & depth , VK_IMAGE_TILING_OPTIMAL ); dvz_images_usage ( & depth , VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT ); dvz_images_memory ( & depth , VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT ); dvz_images_layout ( & depth , VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL ); dvz_images_aspect ( & depth , VK_IMAGE_ASPECT_DEPTH_BIT ); dvz_images_queue_access ( & depth , 0 ); dvz_images_create ( & depth ); // Create renderpass. dvz_renderpass_create ( & renderpass ); // Create framebuffers. dvz_framebuffers_attachment ( & framebuffers , 0 , & image ); dvz_framebuffers_attachment ( & framebuffers , 1 , & depth ); dvz_framebuffers_create ( & framebuffers , & renderpass ); } // We create a new graphics pipeline. DvzGraphics graphics = dvz_graphics ( gpu ); // Graphics pipeline. { // We set the renderpass. dvz_graphics_renderpass ( & graphics , & renderpass , 0 ); // We specify the primitive. dvz_graphics_topology ( & graphics , VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST ); // We set the shaders. dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_VERTEX_BIT , \"triangle.vert.spv\" ); dvz_graphics_shader ( & graphics , VK_SHADER_STAGE_FRAGMENT_BIT , \"triangle.frag.spv\" ); // We specify the vertex structure size. dvz_graphics_vertex_binding ( & graphics , 0 , sizeof ( DvzVertex )); // We specify the two vertex attributes. dvz_graphics_vertex_attr ( & graphics , 0 , 0 , VK_FORMAT_R32G32B32_SFLOAT , offsetof ( DvzVertex , pos )); dvz_graphics_vertex_attr ( & graphics , 0 , 1 , VK_FORMAT_R8G8B8A8_UNORM , offsetof ( DvzVertex , color )); // Once we've set up the graphics pipeline, we create it. dvz_graphics_create ( & graphics ); } // We create the (empty) bindings: the shaders do not necessitate any uniform or // texture in this example. DvzBindings bindings = dvz_bindings ( & graphics . slots , 1 ); dvz_bindings_update ( & bindings ); // We create the GPU buffer holding the vertex data. // NOTE: in real applications, once should use few, even a single large vertex buffer for all // graphics pipelines in the application. Defining many small GPU buffers is bad practice. DvzBuffer buffer = dvz_buffer ( gpu ); DvzBufferRegions vertex_buffer ; { // There will be three vertices for 1 triangle. VkDeviceSize size = 3 * sizeof ( DvzVertex ); dvz_buffer_size ( & buffer , size ); // We declare that the buffer will be used as a vertex buffer. dvz_buffer_usage ( & buffer , VK_BUFFER_USAGE_VERTEX_BUFFER_BIT ); // The buffer should be accessible directly from the CPU in this example (bad practice in // real applications). dvz_buffer_memory ( & buffer , VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT ); // Once set up, we create the GPU buffer. dvz_buffer_create ( & buffer ); // We define a view (buffer region) on the entire buffer. vertex_buffer = dvz_buffer_regions ( & buffer , 1 , 0 , size , 0 ); // Define the vertex data. // NOTE: in this example, we don't include the common.glsl shader and we use raw Vulkan // shaders. So the Vulkan coordinate system is used, with the y axis going down. DvzVertex data [ 3 ] = { {{ - 1 , + 1 , 0 }, { 255 , 0 , 0 , 255 }}, // bottom left, red {{ + 1 , + 1 , 0 }, { 0 , 255 , 0 , 255 }}, // bottom right, green {{ + 0 , - 1 , 0 }, { 0 , 0 , 255 , 255 }}, // top, blue }; // We upload the data to the GPU vertex buffer. dvz_buffer_regions_upload ( & vertex_buffer , 0 , data ); } // We create a command buffer. DvzCommands cmds = dvz_commands ( gpu , 0 , 1 ); // Command buffer recording. { // We begin recording the command buffer here. dvz_cmd_begin ( & cmds , 0 ); // We begin the default render pass. dvz_cmd_begin_renderpass ( & cmds , 0 , & renderpass , & framebuffers ); // We set the viewport to the entire framebuffer size. dvz_cmd_viewport ( & cmds , 0 , viewport . viewport ); // We bind the vertex buffer for the upcoming drawing command. dvz_cmd_bind_vertex_buffer ( & cmds , 0 , vertex_buffer , 0 ); // We bind the graphics pipeline. dvz_cmd_bind_graphics ( & cmds , 0 , & graphics , & bindings , 0 ); // We render 3 vertices (1 triangle). dvz_cmd_draw ( & cmds , 0 , 0 , 3 ); // End of the render pass and command buffer. dvz_cmd_end_renderpass ( & cmds , 0 ); dvz_cmd_end ( & cmds , 0 ); } // We submit the command buffer to the GPU and we *wait* until the GPU has finished completing // it. This uses a hard synchronization primitive so this is not efficient. dvz_cmd_submit_sync ( & cmds , 0 ); // We make a screenshot and save it to a file. uint8_t * rgb = screenshot ( & image ); dvz_write_png ( \"triangle.png\" , width , height , rgb ); log_info ( \"offscreen rendered image written to: `triangle.png`\" ); // We need to clean up all objects handled by Datoviz at the end. { dvz_graphics_destroy ( & graphics ); dvz_buffer_destroy ( & buffer ); dvz_renderpass_destroy ( & renderpass ); dvz_images_destroy ( & image ); dvz_images_destroy ( & depth ); dvz_framebuffers_destroy ( & framebuffers ); dvz_bindings_destroy ( & bindings ); dvz_app_destroy ( app ); } return 0 ; }","title":"How to use the vklite C API"},{"location":"howto/visual/","text":"How to write a custom visual \u00b6 Warning You need to go through the Vulkan crash course before following this guide. In this section, we'll show how to create a custom visual based on an existing graphics pipeline, so without writing custom GLSL shaders . Note Only the C API supports custom visuals at the moment. Python bindings for custom visuals will come in an upcoming version. The full source code for this example can be found in examples/custom_visual.c . We'll make a square visual that makes it easy to add uniformly-colored squares to the scene. What is a visual? \u00b6 The visual is the most important abstraction in Datoviz. It abstracts away the internal details related to GPU rendering and proposes a user-friendly interface to set up visual elements. Generally speaking, adding a new visual to a panel involves the following steps: choosing one of the existing visuals on the visual reference page, preparing the data to match the format expected by the visual properties, setting the visual properties with the data. Visual properties, or \"props\" \u00b6 Each predefined visual comes with a set of predefined visual properties, also called props . For example, the marker visual has props for: point position, color, marker size, marker type, angle, and so on. The visual reference page presents the list of all predefined visuals along with their sets of props. You'll probably refer a lot to this page since it contains the most important information you'll need for your visualizations. Each prop is defined by: a name, a data type (for example float32 , uint8 ), a description of how the prop is used for rendering. Note The Python API takes care of converting each prop to the correct data type using NumPy ndarray.astype() . Most props accepting floating-point numbers require single-precision format since this is the optimal format for GPUs. The notable exception is the POS prop (position), which requires double-precision data. Datoviz provides an internal CPU-based data transformation system that requires double precision (single-precision would not be acceptable for scientific data handling). Also, visuals that implement triangulation require double precision. Datoviz converts the transformed position to single-precision at the last moment before uploading it to the GPU. Batch rendering \u00b6 Another crucial notion related to visuals is batch rendering . For performance reasons, it is recommended to use as few visuals as possible in a given scene . For example: to display a scatter plot with 100 points, use a single marker visual with 100 points, instead of 100 visuals with one point , to display 100 polygons, use a single polygon visual with 100 items (each containing an arbitrary number of points), instead of 100 visuals , similarly with paths, images, meshes, text, and so on. This allows the GPU to render all of these different objects of the same type in a single draw command (with the same GPU transformation matrices). To define multiple objects with various sizes in a given visual (for example, displaying multiple paths with the same visual), one typically concatenates all points and properties in big arrays (total size is the sum of all object sizes), and use the special prop length to define the length of each object (vector with as many elements as there are different objects). Distinction between graphics and visuals \u00b6 Datoviz makes the distinction between a graphics (graphics pipeline) and a visual : a graphics is a GPU-level object. It is defined by a vertex shader, a fragment shader, a primitive type (point, line, triangle), and other details. a visual is a user-level object. It encapsulates a particular type of visual element and abstracts away the GPU implementation details. A visual is defined by one or several graphics pipelines, optional compute pipelines, and a set of visual properties that allow the user to specify the visual's data. Importantly, the user doesn't need to know the internal implementation details of a visual to use it. It is normally sufficient to know the props specification. Making a custom visual based on existing graphics \u00b6 In this section, we'll show how to create a custom visual by reusing an existing graphics (without writing custom shaders). The main use-case for this scenario is making a visual with a custom CPU data transformation pipeline . An example is polygon triangulation: since the GPU can only render triangles, one needs to triangulate an arbitrary shape before rendering it. The triangulation is implemented at the level of the visual, so that the user can pass the polygon points without having to triangulate it manually. The visual makes the triangulation internally, and generates the triangles required by the underlying graphics pipeline. In the simple example below, we'll implement a simple square visual with a trivial triangulation (two triangles per square). The custom square visual will provide the following props: Type Index Type Description pos 0 dvec3 square center position color 0 cvec4 square color length 0 float edge length The underlying graphics will be the triangle graphics, where three successive vertices define a single independent triangle. Each square will be triangulated into two triangles, or six vertices. This square visual will be easier to use than the triangle one, since the user won't have to deal with triangulation manually. Here is the code to define the three visual props: // pos prop, dvec3 data type dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // color prop, cvec4 data type dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // length prop, float data type dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 ); Vertex shader attributes, vertex buffer, vertex structure \u00b6 To each graphics is associated a particular vertex shader. A vertex shader defines a list of attributes , which correspond to the different vertex inputs. For example, the triangle graphics we will use in this example has two attributes in its vertex shader: // This GLSL code is at the beginning of the triangle graphics vertex shader. // Two attributes: layout ( location = 0 ) in vec3 pos ; // vertex position layout ( location = 1 ) in vec4 color ; // vertex color In Datoviz, the input data feeding these vertex shader attributes is stored in a GPU buffer called the vertex buffer . The GPU buffer contains a contiguous array of structure elements that match exactly these attributes. Here, the vertex structure of the triangle graphics, and of the other basic graphics, is the standard DvzVertex structure: struct DvzVertex { vec3 pos ; // three single-precision floating-point numbers for x, y, z position cvec4 color ; // four uint8 bytes for the r, g, b, a color components } The vertex shader executes in parallel over all structure elements stored in the vertex buffer. We'll see in the custom graphics page more details about how we link this C structure to the GLSL attributes. The main role of the visual is to copy the user-specified props data into the vertex buffer . This is sometimes straightforward, like in the marker visual, where each vertex corresponds to one marker, but it is often less trivial. In the example covered in this page, where we need to transform squares into triangles, our custom visual will need to create six vertices in the vertex buffer for every square passed by the user . This is implemented in the visual baking function . Visual baking function \u00b6 Once the props are defined, the most important step when creating a custom visual is to implement the baking function . The baking function takes the props data as input, and fills in the vertex buffer , as well as, possibly, other GPU data sources (uniforms, storage buffers, textures). Here, the square baking function must recover the pos and length props in order to compute the four corner position of each square, and make the triangulation with two triangles per square. The props and the vertex buffer (and other sources) come with DvzArray instances, which are thin wrappers around 1D arrays of homogeneous data types. They support few features: no multidimensional arrays, no vectorized operations. // The following code snippet contains the body of the baking function. static void _bake_callback ( DvzVisual * visual , DvzVisualDataEvent ev ) { ASSERT ( visual != NULL ); // First, we obtain the array instances holding the prop data as specified by the user. DvzArray * arr_pos = dvz_prop_array ( visual , DVZ_PROP_POS , 0 ); DvzArray * arr_color = dvz_prop_array ( visual , DVZ_PROP_COLOR , 0 ); DvzArray * arr_length = dvz_prop_array ( visual , DVZ_PROP_LENGTH , 0 ); // We also get the array of the vertex buffer, which we'll need to fill with the triangulation. DvzArray * arr_vertex = dvz_source_array ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 ); // The number of rows in the 1D position array (set by the user) is the number of squares // requested by the user. uint32_t square_count = arr_pos -> item_count ; // We resize the vertex buffer array so that it holds six vertices per square (two triangles). dvz_array_resize ( arr_vertex , 6 * square_count ); // Pointers to the input data. dvec3 * pos = NULL ; cvec4 * color = NULL ; float * length = NULL ; // Pointer to the output vertex. DvzVertex * vertex = ( DvzVertex * ) arr_vertex -> data ; // Here, we triangulate each square by computing the position of each square corner. float hl = 0 ; for ( uint32_t i = 0 ; i < square_count ; i ++ ) { // We get a pointer to the current item in each prop array. pos = dvz_array_item ( arr_pos , i ); color = dvz_array_item ( arr_color , i ); length = dvz_array_item ( arr_length , i ); // This is the half of the square size. hl = ( * length ) / 2 ; // First triangle: // Bottom-left corner. vertex [ 6 * i + 0 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 0 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Bottom-right corner. vertex [ 6 * i + 1 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 1 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Top-right corner. vertex [ 6 * i + 2 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 2 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Second triangle: // Top-right corner again. vertex [ 6 * i + 3 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 3 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Top-left corner. vertex [ 6 * i + 4 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 4 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Bottom-left corner (again). vertex [ 6 * i + 5 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 5 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // We copy the square color to each of the six vertices making the current square. // This is a choice made in this example, and it is up to the custom visual creator // to define how the user data, passed via props, will be used to fill in the vertices. for ( uint32_t j = 0 ; j < 6 ; j ++ ) memcpy ( vertex [ 6 * i + j ]. color , color , sizeof ( cvec4 )); } } Putting everything together \u00b6 Here is the code to create the custom visual. // We create a blank visual in the scene. // For demo purposes, we disable the automatic position normalization. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // We add the existing graphics triangle graphics pipeline. dvz_visual_graphics ( visual , dvz_graphics_builtin ( canvas , DVZ_GRAPHICS_TRIANGLE , 0 )); // We add the vertex buffer source, and we must specify the same vertex struct type // as the one used by the graphics pipeline (standard vertex structure, with pos and color). dvz_visual_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , DVZ_PIPELINE_GRAPHICS , 0 , 0 , sizeof ( DvzVertex ), 0 ); // We specify the visual props. dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 ); // We declare our custom baking function. dvz_visual_callback_bake ( visual , _bake_callback ); // Finally, once the custom visual has been created, we can add it to the panel. dvz_custom_visual ( panel , visual ); Once the custom visual has been created and added to the scene, the last step consists of setting some data, as usual: // We define three squares. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , 3 , ( dvec3 []){{ - .5 , 0 , 0 }, { 0 , 0 , 0 }, { + .5 , 0 , 0 }}); // We use a different color for each square. dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , 3 , ( cvec4 []){{ 255 , 0 , 0 , 255 }, { 0 , 255 , 0 , 255 }, { 0 , 0 , 255 , 255 }}); // NOTE: we use the same length for all squares. dvz_visual_data ( visual , DVZ_PROP_LENGTH , 0 , 1 , ( float []){ .25 }); Note that we used a single value for the last prop (edge length). Datoviz uses the convention that a prop may have less values than objects, in which case the last value is repeated over . In particular, defining a prop with a single element means using the same value for all items in the visual. This is a sort of \"broadcasting\" rule (following NumPy's terminology). Other topics \u00b6 We didn't yet cover these other aspects: Position data transformation, Visual parameters stored in the uniform buffer, Visual flags. Checklist for Datoviz contributors \u00b6 This is a handy checklist for developers when adding new visuals to the library (via a pull request). Determine the graphics you'll be using, and the list of source and props builtin_visuals.h : Make sure the DvzVisualType enum exists, or create a new one visuals.h : Check that all prop types exist, otherwise add them builtin_visuals.c : Make a new section for the visual code Write the main visual function Specify the graphics pipeline(s) Specify the sources: Vertex buffer Index buffer (optional) Param buffer (optional) Textures (optional) Specify the props The cast and copy spec are not mandatory if there is a custom baking callback function Note that the special POS prop is DVEC3 and is typically cast to VEC3, but only after baking and panel transform Add a length prop if there are multiple objects Add the common props Add the param props Specify the baking callback function (optional) Write the baking callback function Add a new switch case in dvz_visual_builtin() test_builtin_visuals.h : Add a new visual test declaration test_builtin_visuals.c : Write the body of the test function main.c : Add the new test to the list of test functions Test the new visual without interactivity and save a visual screenshot Add a section in the visual reference docs/reference/visuals.md , document the props, sources, etc.","title":"How to write a custom visual"},{"location":"howto/visual/#how-to-write-a-custom-visual","text":"Warning You need to go through the Vulkan crash course before following this guide. In this section, we'll show how to create a custom visual based on an existing graphics pipeline, so without writing custom GLSL shaders . Note Only the C API supports custom visuals at the moment. Python bindings for custom visuals will come in an upcoming version. The full source code for this example can be found in examples/custom_visual.c . We'll make a square visual that makes it easy to add uniformly-colored squares to the scene.","title":"How to write a custom visual"},{"location":"howto/visual/#what-is-a-visual","text":"The visual is the most important abstraction in Datoviz. It abstracts away the internal details related to GPU rendering and proposes a user-friendly interface to set up visual elements. Generally speaking, adding a new visual to a panel involves the following steps: choosing one of the existing visuals on the visual reference page, preparing the data to match the format expected by the visual properties, setting the visual properties with the data.","title":"What is a visual?"},{"location":"howto/visual/#visual-properties-or-props","text":"Each predefined visual comes with a set of predefined visual properties, also called props . For example, the marker visual has props for: point position, color, marker size, marker type, angle, and so on. The visual reference page presents the list of all predefined visuals along with their sets of props. You'll probably refer a lot to this page since it contains the most important information you'll need for your visualizations. Each prop is defined by: a name, a data type (for example float32 , uint8 ), a description of how the prop is used for rendering. Note The Python API takes care of converting each prop to the correct data type using NumPy ndarray.astype() . Most props accepting floating-point numbers require single-precision format since this is the optimal format for GPUs. The notable exception is the POS prop (position), which requires double-precision data. Datoviz provides an internal CPU-based data transformation system that requires double precision (single-precision would not be acceptable for scientific data handling). Also, visuals that implement triangulation require double precision. Datoviz converts the transformed position to single-precision at the last moment before uploading it to the GPU.","title":"Visual properties, or \"props\""},{"location":"howto/visual/#batch-rendering","text":"Another crucial notion related to visuals is batch rendering . For performance reasons, it is recommended to use as few visuals as possible in a given scene . For example: to display a scatter plot with 100 points, use a single marker visual with 100 points, instead of 100 visuals with one point , to display 100 polygons, use a single polygon visual with 100 items (each containing an arbitrary number of points), instead of 100 visuals , similarly with paths, images, meshes, text, and so on. This allows the GPU to render all of these different objects of the same type in a single draw command (with the same GPU transformation matrices). To define multiple objects with various sizes in a given visual (for example, displaying multiple paths with the same visual), one typically concatenates all points and properties in big arrays (total size is the sum of all object sizes), and use the special prop length to define the length of each object (vector with as many elements as there are different objects).","title":"Batch rendering"},{"location":"howto/visual/#distinction-between-graphics-and-visuals","text":"Datoviz makes the distinction between a graphics (graphics pipeline) and a visual : a graphics is a GPU-level object. It is defined by a vertex shader, a fragment shader, a primitive type (point, line, triangle), and other details. a visual is a user-level object. It encapsulates a particular type of visual element and abstracts away the GPU implementation details. A visual is defined by one or several graphics pipelines, optional compute pipelines, and a set of visual properties that allow the user to specify the visual's data. Importantly, the user doesn't need to know the internal implementation details of a visual to use it. It is normally sufficient to know the props specification.","title":"Distinction between graphics and visuals"},{"location":"howto/visual/#making-a-custom-visual-based-on-existing-graphics","text":"In this section, we'll show how to create a custom visual by reusing an existing graphics (without writing custom shaders). The main use-case for this scenario is making a visual with a custom CPU data transformation pipeline . An example is polygon triangulation: since the GPU can only render triangles, one needs to triangulate an arbitrary shape before rendering it. The triangulation is implemented at the level of the visual, so that the user can pass the polygon points without having to triangulate it manually. The visual makes the triangulation internally, and generates the triangles required by the underlying graphics pipeline. In the simple example below, we'll implement a simple square visual with a trivial triangulation (two triangles per square). The custom square visual will provide the following props: Type Index Type Description pos 0 dvec3 square center position color 0 cvec4 square color length 0 float edge length The underlying graphics will be the triangle graphics, where three successive vertices define a single independent triangle. Each square will be triangulated into two triangles, or six vertices. This square visual will be easier to use than the triangle one, since the user won't have to deal with triangulation manually. Here is the code to define the three visual props: // pos prop, dvec3 data type dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // color prop, cvec4 data type dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); // length prop, float data type dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 );","title":"Making a custom visual based on existing graphics"},{"location":"howto/visual/#vertex-shader-attributes-vertex-buffer-vertex-structure","text":"To each graphics is associated a particular vertex shader. A vertex shader defines a list of attributes , which correspond to the different vertex inputs. For example, the triangle graphics we will use in this example has two attributes in its vertex shader: // This GLSL code is at the beginning of the triangle graphics vertex shader. // Two attributes: layout ( location = 0 ) in vec3 pos ; // vertex position layout ( location = 1 ) in vec4 color ; // vertex color In Datoviz, the input data feeding these vertex shader attributes is stored in a GPU buffer called the vertex buffer . The GPU buffer contains a contiguous array of structure elements that match exactly these attributes. Here, the vertex structure of the triangle graphics, and of the other basic graphics, is the standard DvzVertex structure: struct DvzVertex { vec3 pos ; // three single-precision floating-point numbers for x, y, z position cvec4 color ; // four uint8 bytes for the r, g, b, a color components } The vertex shader executes in parallel over all structure elements stored in the vertex buffer. We'll see in the custom graphics page more details about how we link this C structure to the GLSL attributes. The main role of the visual is to copy the user-specified props data into the vertex buffer . This is sometimes straightforward, like in the marker visual, where each vertex corresponds to one marker, but it is often less trivial. In the example covered in this page, where we need to transform squares into triangles, our custom visual will need to create six vertices in the vertex buffer for every square passed by the user . This is implemented in the visual baking function .","title":"Vertex shader attributes, vertex buffer, vertex structure"},{"location":"howto/visual/#visual-baking-function","text":"Once the props are defined, the most important step when creating a custom visual is to implement the baking function . The baking function takes the props data as input, and fills in the vertex buffer , as well as, possibly, other GPU data sources (uniforms, storage buffers, textures). Here, the square baking function must recover the pos and length props in order to compute the four corner position of each square, and make the triangulation with two triangles per square. The props and the vertex buffer (and other sources) come with DvzArray instances, which are thin wrappers around 1D arrays of homogeneous data types. They support few features: no multidimensional arrays, no vectorized operations. // The following code snippet contains the body of the baking function. static void _bake_callback ( DvzVisual * visual , DvzVisualDataEvent ev ) { ASSERT ( visual != NULL ); // First, we obtain the array instances holding the prop data as specified by the user. DvzArray * arr_pos = dvz_prop_array ( visual , DVZ_PROP_POS , 0 ); DvzArray * arr_color = dvz_prop_array ( visual , DVZ_PROP_COLOR , 0 ); DvzArray * arr_length = dvz_prop_array ( visual , DVZ_PROP_LENGTH , 0 ); // We also get the array of the vertex buffer, which we'll need to fill with the triangulation. DvzArray * arr_vertex = dvz_source_array ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 ); // The number of rows in the 1D position array (set by the user) is the number of squares // requested by the user. uint32_t square_count = arr_pos -> item_count ; // We resize the vertex buffer array so that it holds six vertices per square (two triangles). dvz_array_resize ( arr_vertex , 6 * square_count ); // Pointers to the input data. dvec3 * pos = NULL ; cvec4 * color = NULL ; float * length = NULL ; // Pointer to the output vertex. DvzVertex * vertex = ( DvzVertex * ) arr_vertex -> data ; // Here, we triangulate each square by computing the position of each square corner. float hl = 0 ; for ( uint32_t i = 0 ; i < square_count ; i ++ ) { // We get a pointer to the current item in each prop array. pos = dvz_array_item ( arr_pos , i ); color = dvz_array_item ( arr_color , i ); length = dvz_array_item ( arr_length , i ); // This is the half of the square size. hl = ( * length ) / 2 ; // First triangle: // Bottom-left corner. vertex [ 6 * i + 0 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 0 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Bottom-right corner. vertex [ 6 * i + 1 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 1 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // Top-right corner. vertex [ 6 * i + 2 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 2 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Second triangle: // Top-right corner again. vertex [ 6 * i + 3 ]. pos [ 0 ] = pos [ 0 ][ 0 ] + hl ; vertex [ 6 * i + 3 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Top-left corner. vertex [ 6 * i + 4 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 4 ]. pos [ 1 ] = pos [ 0 ][ 1 ] + hl ; // Bottom-left corner (again). vertex [ 6 * i + 5 ]. pos [ 0 ] = pos [ 0 ][ 0 ] - hl ; vertex [ 6 * i + 5 ]. pos [ 1 ] = pos [ 0 ][ 1 ] - hl ; // We copy the square color to each of the six vertices making the current square. // This is a choice made in this example, and it is up to the custom visual creator // to define how the user data, passed via props, will be used to fill in the vertices. for ( uint32_t j = 0 ; j < 6 ; j ++ ) memcpy ( vertex [ 6 * i + j ]. color , color , sizeof ( cvec4 )); } }","title":"Visual baking function"},{"location":"howto/visual/#putting-everything-together","text":"Here is the code to create the custom visual. // We create a blank visual in the scene. // For demo purposes, we disable the automatic position normalization. DvzVisual * visual = dvz_blank_visual ( scene , DVZ_VISUAL_FLAGS_TRANSFORM_NONE ); // We add the existing graphics triangle graphics pipeline. dvz_visual_graphics ( visual , dvz_graphics_builtin ( canvas , DVZ_GRAPHICS_TRIANGLE , 0 )); // We add the vertex buffer source, and we must specify the same vertex struct type // as the one used by the graphics pipeline (standard vertex structure, with pos and color). dvz_visual_source ( visual , DVZ_SOURCE_TYPE_VERTEX , 0 , DVZ_PIPELINE_GRAPHICS , 0 , 0 , sizeof ( DvzVertex ), 0 ); // We specify the visual props. dvz_visual_prop ( visual , DVZ_PROP_POS , 0 , DVZ_DTYPE_DVEC3 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_COLOR , 0 , DVZ_DTYPE_CVEC4 , DVZ_SOURCE_TYPE_VERTEX , 0 ); dvz_visual_prop ( visual , DVZ_PROP_LENGTH , 0 , DVZ_DTYPE_FLOAT , DVZ_SOURCE_TYPE_VERTEX , 0 ); // We declare our custom baking function. dvz_visual_callback_bake ( visual , _bake_callback ); // Finally, once the custom visual has been created, we can add it to the panel. dvz_custom_visual ( panel , visual ); Once the custom visual has been created and added to the scene, the last step consists of setting some data, as usual: // We define three squares. dvz_visual_data ( visual , DVZ_PROP_POS , 0 , 3 , ( dvec3 []){{ - .5 , 0 , 0 }, { 0 , 0 , 0 }, { + .5 , 0 , 0 }}); // We use a different color for each square. dvz_visual_data ( visual , DVZ_PROP_COLOR , 0 , 3 , ( cvec4 []){{ 255 , 0 , 0 , 255 }, { 0 , 255 , 0 , 255 }, { 0 , 0 , 255 , 255 }}); // NOTE: we use the same length for all squares. dvz_visual_data ( visual , DVZ_PROP_LENGTH , 0 , 1 , ( float []){ .25 }); Note that we used a single value for the last prop (edge length). Datoviz uses the convention that a prop may have less values than objects, in which case the last value is repeated over . In particular, defining a prop with a single element means using the same value for all items in the visual. This is a sort of \"broadcasting\" rule (following NumPy's terminology).","title":"Putting everything together"},{"location":"howto/visual/#other-topics","text":"We didn't yet cover these other aspects: Position data transformation, Visual parameters stored in the uniform buffer, Visual flags.","title":"Other topics"},{"location":"howto/visual/#checklist-for-datoviz-contributors","text":"This is a handy checklist for developers when adding new visuals to the library (via a pull request). Determine the graphics you'll be using, and the list of source and props builtin_visuals.h : Make sure the DvzVisualType enum exists, or create a new one visuals.h : Check that all prop types exist, otherwise add them builtin_visuals.c : Make a new section for the visual code Write the main visual function Specify the graphics pipeline(s) Specify the sources: Vertex buffer Index buffer (optional) Param buffer (optional) Textures (optional) Specify the props The cast and copy spec are not mandatory if there is a custom baking callback function Note that the special POS prop is DVEC3 and is typically cast to VEC3, but only after baking and panel transform Add a length prop if there are multiple objects Add the common props Add the param props Specify the baking callback function (optional) Write the baking callback function Add a new switch case in dvz_visual_builtin() test_builtin_visuals.h : Add a new visual test declaration test_builtin_visuals.c : Write the body of the test function main.c : Add the new test to the list of test functions Test the new visual without interactivity and save a visual screenshot Add a section in the visual reference docs/reference/visuals.md , document the props, sources, etc.","title":"Checklist for Datoviz contributors"},{"location":"reference/","text":"Reference \u00b6 This section provides a reference of: All included visuals , All included graphics , All included colormaps , All included controllers , and the list of supported event types.","title":"Index"},{"location":"reference/#reference","text":"This section provides a reference of: All included visuals , All included graphics , All included colormaps , All included controllers , and the list of supported event types.","title":"Reference"},{"location":"reference/colormaps/","text":"Colormaps \u00b6 Datoviz natively includes a collection of common colormaps, both continuous and discrete (color palettes). These colormaps come from the following sources: matplotlib bokeh colorcet Kenneth Moreland's page These colormaps are stored in a 256x256 texture. Each row contains either: a 256-color continuous colormap, a 256-color discrete color palette, eight discrete 32-color palettes. Unused space may be used for future or user-defined colormaps. The texture is always loaded both in CPU and GPU memory. It is shared between all visuals and canvases. Datoviz provides a few functions to easily make colors out of scalar values: Python import numpy as np from datoviz import colormap values = np . random . rand ( 1000 ) colors = colormap ( values , vmin = 0 , vmax = 1 , cmap = 'viridis' ) print ( colors ) # output: # [[126 210 78 255] # [ 64 68 135 255] # [ 36 170 130 255] # ... # [ 36 132 141 255] # [ 61 75 137 255] # [ 31 148 139 255]] C DvzColormap cmap = DVZ_CMAP_VIRIDIS ; cvec4 color = { 0 }; uint8_t value = 128 ; double dvalue = .5 ; // Get a single color from a byte. dvz_colormap ( cmap , 128 , color ); // Get a single color from a double, with a custom vmin-vmax range. dvz_colormap_scale ( cmap , dvalue , 0 , 1 , color ); // Get an array of colors from an array of values. const uint32_t N = 10 ; double * values = calloc ( N , sizeof ( double )); cvec4 * colors = calloc ( N , sizeof ( cvec4 )); dvz_colormap_array ( cmap , N , values , 0 , 1 , colors ); FREE ( values ); FREE ( colors ); List of colormaps and color palettes \u00b6 Note The row and col give the offset of the colormap or color palette within the 256x256 colormap texture. Name Row, Col Colormap binary 0, 0 hsv 1, 0 cividis 2, 0 inferno 3, 0 magma 4, 0 plasma 5, 0 viridis 6, 0 blues 7, 0 bugn 8, 0 bupu 9, 0 gnbu 10, 0 greens 11, 0 greys 12, 0 oranges 13, 0 orrd 14, 0 pubu 15, 0 pubugn 16, 0 purples 17, 0 rdpu 18, 0 reds 19, 0 ylgn 20, 0 ylgnbu 21, 0 ylorbr 22, 0 ylorrd 23, 0 afmhot 24, 0 autumn 25, 0 bone 26, 0 cool 27, 0 copper 28, 0 gist_heat 29, 0 gray 30, 0 hot 31, 0 pink 32, 0 spring 33, 0 summer 34, 0 winter 35, 0 wistia 36, 0 brbg 37, 0 bwr 38, 0 coolwarm 39, 0 piyg 40, 0 prgn 41, 0 puor 42, 0 rdbu 43, 0 rdgy 44, 0 rdylbu 45, 0 rdylgn 46, 0 seismic 47, 0 spectral 48, 0 twilight_shifted 49, 0 twilight 50, 0 brg 51, 0 cmrmap 52, 0 cubehelix 53, 0 flag 54, 0 gist_earth 55, 0 gist_ncar 56, 0 gist_rainbow 57, 0 gist_stern 58, 0 gnuplot2 59, 0 gnuplot 60, 0 jet 61, 0 nipy_spectral 62, 0 ocean 63, 0 prism 64, 0 rainbow 65, 0 terrain 66, 0 bkr 67, 0 bky 68, 0 cet_d10 69, 0 cet_d11 70, 0 cet_d8 71, 0 cet_d13 72, 0 cet_d3 73, 0 cet_d1a 74, 0 bjy 75, 0 gwv 76, 0 bwy 77, 0 cet_d12 78, 0 cet_r3 79, 0 cet_d9 80, 0 cwr 81, 0 cet_cbc1 82, 0 cet_cbc2 83, 0 cet_cbl1 84, 0 cet_cbl2 85, 0 cet_cbtc1 86, 0 cet_cbtc2 87, 0 cet_cbtl1 88, 0 bgy 89, 0 bgyw 90, 0 bmw 91, 0 cet_c1 92, 0 cet_c1s 93, 0 cet_c2 94, 0 cet_c4 95, 0 cet_c4s 96, 0 cet_c5 97, 0 cet_i1 98, 0 cet_i3 99, 0 cet_l10 100, 0 cet_l11 101, 0 cet_l12 102, 0 cet_l16 103, 0 cet_l17 104, 0 cet_l18 105, 0 cet_l19 106, 0 cet_l4 107, 0 cet_l7 108, 0 cet_l8 109, 0 cet_l9 110, 0 cet_r1 111, 0 cet_r2 112, 0 colorwheel 113, 0 fire 114, 0 isolum 115, 0 kb 116, 0 kbc 117, 0 kg 118, 0 kgy 119, 0 kr 120, 0 black_body 121, 0 kindlmann 122, 0 extended_kindlmann 123, 0 glasbey 176, 0 glasbey_cool 177, 0 glasbey_dark 178, 0 glasbey_hv 179, 0 glasbey_light 180, 0 glasbey_warm 181, 0 accent 240, 0 dark2 240, 32 paired 240, 64 pastel1 240, 96 pastel2 240, 128 set1 240, 160 set2 240, 192 set3 240, 224 tab10 241, 0 tab20 241, 32 tab20b 241, 64 tab20c 241, 96 category10_10 241, 128 category20_20 241, 160 category20b_20 241, 192 category20c_20 241, 224 colorblind8 242, 0","title":"List of colormaps"},{"location":"reference/colormaps/#colormaps","text":"Datoviz natively includes a collection of common colormaps, both continuous and discrete (color palettes). These colormaps come from the following sources: matplotlib bokeh colorcet Kenneth Moreland's page These colormaps are stored in a 256x256 texture. Each row contains either: a 256-color continuous colormap, a 256-color discrete color palette, eight discrete 32-color palettes. Unused space may be used for future or user-defined colormaps. The texture is always loaded both in CPU and GPU memory. It is shared between all visuals and canvases. Datoviz provides a few functions to easily make colors out of scalar values: Python import numpy as np from datoviz import colormap values = np . random . rand ( 1000 ) colors = colormap ( values , vmin = 0 , vmax = 1 , cmap = 'viridis' ) print ( colors ) # output: # [[126 210 78 255] # [ 64 68 135 255] # [ 36 170 130 255] # ... # [ 36 132 141 255] # [ 61 75 137 255] # [ 31 148 139 255]] C DvzColormap cmap = DVZ_CMAP_VIRIDIS ; cvec4 color = { 0 }; uint8_t value = 128 ; double dvalue = .5 ; // Get a single color from a byte. dvz_colormap ( cmap , 128 , color ); // Get a single color from a double, with a custom vmin-vmax range. dvz_colormap_scale ( cmap , dvalue , 0 , 1 , color ); // Get an array of colors from an array of values. const uint32_t N = 10 ; double * values = calloc ( N , sizeof ( double )); cvec4 * colors = calloc ( N , sizeof ( cvec4 )); dvz_colormap_array ( cmap , N , values , 0 , 1 , colors ); FREE ( values ); FREE ( colors );","title":"Colormaps"},{"location":"reference/colormaps/#list-of-colormaps-and-color-palettes","text":"Note The row and col give the offset of the colormap or color palette within the 256x256 colormap texture. Name Row, Col Colormap binary 0, 0 hsv 1, 0 cividis 2, 0 inferno 3, 0 magma 4, 0 plasma 5, 0 viridis 6, 0 blues 7, 0 bugn 8, 0 bupu 9, 0 gnbu 10, 0 greens 11, 0 greys 12, 0 oranges 13, 0 orrd 14, 0 pubu 15, 0 pubugn 16, 0 purples 17, 0 rdpu 18, 0 reds 19, 0 ylgn 20, 0 ylgnbu 21, 0 ylorbr 22, 0 ylorrd 23, 0 afmhot 24, 0 autumn 25, 0 bone 26, 0 cool 27, 0 copper 28, 0 gist_heat 29, 0 gray 30, 0 hot 31, 0 pink 32, 0 spring 33, 0 summer 34, 0 winter 35, 0 wistia 36, 0 brbg 37, 0 bwr 38, 0 coolwarm 39, 0 piyg 40, 0 prgn 41, 0 puor 42, 0 rdbu 43, 0 rdgy 44, 0 rdylbu 45, 0 rdylgn 46, 0 seismic 47, 0 spectral 48, 0 twilight_shifted 49, 0 twilight 50, 0 brg 51, 0 cmrmap 52, 0 cubehelix 53, 0 flag 54, 0 gist_earth 55, 0 gist_ncar 56, 0 gist_rainbow 57, 0 gist_stern 58, 0 gnuplot2 59, 0 gnuplot 60, 0 jet 61, 0 nipy_spectral 62, 0 ocean 63, 0 prism 64, 0 rainbow 65, 0 terrain 66, 0 bkr 67, 0 bky 68, 0 cet_d10 69, 0 cet_d11 70, 0 cet_d8 71, 0 cet_d13 72, 0 cet_d3 73, 0 cet_d1a 74, 0 bjy 75, 0 gwv 76, 0 bwy 77, 0 cet_d12 78, 0 cet_r3 79, 0 cet_d9 80, 0 cwr 81, 0 cet_cbc1 82, 0 cet_cbc2 83, 0 cet_cbl1 84, 0 cet_cbl2 85, 0 cet_cbtc1 86, 0 cet_cbtc2 87, 0 cet_cbtl1 88, 0 bgy 89, 0 bgyw 90, 0 bmw 91, 0 cet_c1 92, 0 cet_c1s 93, 0 cet_c2 94, 0 cet_c4 95, 0 cet_c4s 96, 0 cet_c5 97, 0 cet_i1 98, 0 cet_i3 99, 0 cet_l10 100, 0 cet_l11 101, 0 cet_l12 102, 0 cet_l16 103, 0 cet_l17 104, 0 cet_l18 105, 0 cet_l19 106, 0 cet_l4 107, 0 cet_l7 108, 0 cet_l8 109, 0 cet_l9 110, 0 cet_r1 111, 0 cet_r2 112, 0 colorwheel 113, 0 fire 114, 0 isolum 115, 0 kb 116, 0 kbc 117, 0 kg 118, 0 kgy 119, 0 kr 120, 0 black_body 121, 0 kindlmann 122, 0 extended_kindlmann 123, 0 glasbey 176, 0 glasbey_cool 177, 0 glasbey_dark 178, 0 glasbey_hv 179, 0 glasbey_light 180, 0 glasbey_warm 181, 0 accent 240, 0 dark2 240, 32 paired 240, 64 pastel1 240, 96 pastel2 240, 128 set1 240, 160 set2 240, 192 set3 240, 224 tab10 241, 0 tab20 241, 32 tab20b 241, 64 tab20c 241, 96 category10_10 241, 128 category20_20 241, 160 category20b_20 241, 192 category20c_20 241, 224 colorblind8 242, 0","title":"List of colormaps and color palettes"},{"location":"reference/controllers/","text":"Controllers \u00b6 List of controllers \u00b6 When creating a new panel, one needs to specify a Controller . This object defines how the user interacts with the panel. The controllers currently implemented are: static : no interactivity, panzoom : pan and zoom with the mouse, axes : axes with ticks, tick labels, grid, and interactivity with pan and zoom, arcbcall : static 3D camera, model rotation with the mouse, camera : first-person 3D camera. More controllers will be implemented in the future. The C interface used to create custom controllers will be refined too. Panzoom \u00b6 The panzoom controller provides mouse interaction patterns for panning and zooming: Mouse dragging with left button : pan Mouse dragging with right button : zoom in x and y axis independently Mouse wheel : zoom in and out in both axes simultaneously Double-click with left button : reset to initial view Axes 2D \u00b6 The axes 2D controller displays ticks, tick labels, grid and provides panzoom interaction. Arcball \u00b6 The arcball controller is used to rotate a 3D object in all directions using the mouse. It is implemented with quaternions. First-person camera \u00b6 Left-dragging controls the camera, the arrow keys control the position, the Z is controlled by the mouse wheel. List of event types \u00b6 Name Description init called at the beginning of the first frame frame called at every frame refill called when the command buffers need to be recreated (e.g. window resize) resize called when the window is resized timer called in the main loop at regular time intervals mouse_press called when a mouse button is pressed mouse_release called when a mouse button is released mouse_move called when the mouse moves mouse_wheel called when the mouse wheel moves mouse_drag_begin called when a mouse drag operation begins mouse_drag_end called when a mouse drag operation ends mouse_click called after a single click mouse_double_click called after a double click key_press called when a key is pressed key_release called when a key is released","title":"List of controllers"},{"location":"reference/controllers/#controllers","text":"","title":"Controllers"},{"location":"reference/controllers/#list-of-controllers","text":"When creating a new panel, one needs to specify a Controller . This object defines how the user interacts with the panel. The controllers currently implemented are: static : no interactivity, panzoom : pan and zoom with the mouse, axes : axes with ticks, tick labels, grid, and interactivity with pan and zoom, arcbcall : static 3D camera, model rotation with the mouse, camera : first-person 3D camera. More controllers will be implemented in the future. The C interface used to create custom controllers will be refined too.","title":"List of controllers"},{"location":"reference/controllers/#panzoom","text":"The panzoom controller provides mouse interaction patterns for panning and zooming: Mouse dragging with left button : pan Mouse dragging with right button : zoom in x and y axis independently Mouse wheel : zoom in and out in both axes simultaneously Double-click with left button : reset to initial view","title":"Panzoom"},{"location":"reference/controllers/#axes-2d","text":"The axes 2D controller displays ticks, tick labels, grid and provides panzoom interaction.","title":"Axes 2D"},{"location":"reference/controllers/#arcball","text":"The arcball controller is used to rotate a 3D object in all directions using the mouse. It is implemented with quaternions.","title":"Arcball"},{"location":"reference/controllers/#first-person-camera","text":"Left-dragging controls the camera, the arrow keys control the position, the Z is controlled by the mouse wheel.","title":"First-person camera"},{"location":"reference/controllers/#list-of-event-types","text":"Name Description init called at the beginning of the first frame frame called at every frame refill called when the command buffers need to be recreated (e.g. window resize) resize called when the window is resized timer called in the main loop at regular time intervals mouse_press called when a mouse button is pressed mouse_release called when a mouse button is released mouse_move called when the mouse moves mouse_wheel called when the mouse wheel moves mouse_drag_begin called when a mouse drag operation begins mouse_drag_end called when a mouse drag operation ends mouse_click called after a single click mouse_double_click called after a double click key_press called when a key is pressed key_release called when a key is released","title":"List of event types"},{"location":"reference/graphics/","text":"Graphics library \u00b6 This page lists all included graphics. The list is divided into: 2D graphics : high-quality antialiased 2D graphical elements, 3D graphics : meshes and volumes, Basic graphics : basic, low-quality, aliased, but fast basic primitives (points, lines, triangles), useful for demo, testing, and when dealing with tens of millions of points Note If not specified, the default vertex structure is DvzVertex : Field Type Description pos vec3 position color cvec4 color RGBA (four bytes) 2D graphics \u00b6 Marker \u00b6 Marker Segment \u00b6 Segment Path \u00b6 Path Text \u00b6 Text Image \u00b6 Image 3D graphics \u00b6 Mesh \u00b6 Mesh The mesh graphics supports the following features: Phong shading Up to four textures Customizable texture blending coefficients Transparency (but does not play well with depth test) Support for arbitrary RGB values (via cvec3 packing into vec2) Customizable plane clipping Plane clipping: when the clip vector is non-zero, the fragment shader implements the following test. If the dot product of the clip vector with the vertex position (in scene coordinates) is negative, the fragment is discarded. This feature allows to cut the mesh along any arbitrary affine plane. Volume slice \u00b6 VolumeSlice Volume \u00b6 Volume Basic graphics \u00b6 Points \u00b6 Point Lines \u00b6 Lines Line strip \u00b6 Triangles \u00b6 Triangle strip \u00b6 Triangle fan \u00b6 Warning Triangle fan graphics is not supported on macOS and should therefore be avoided if macOS compatibility is desirable.","title":"List of graphics"},{"location":"reference/graphics/#graphics-library","text":"This page lists all included graphics. The list is divided into: 2D graphics : high-quality antialiased 2D graphical elements, 3D graphics : meshes and volumes, Basic graphics : basic, low-quality, aliased, but fast basic primitives (points, lines, triangles), useful for demo, testing, and when dealing with tens of millions of points Note If not specified, the default vertex structure is DvzVertex : Field Type Description pos vec3 position color cvec4 color RGBA (four bytes)","title":"Graphics library"},{"location":"reference/graphics/#2d-graphics","text":"","title":"2D graphics"},{"location":"reference/graphics/#marker","text":"Marker","title":"Marker"},{"location":"reference/graphics/#segment","text":"Segment","title":"Segment"},{"location":"reference/graphics/#path","text":"Path","title":"Path"},{"location":"reference/graphics/#text","text":"Text","title":"Text"},{"location":"reference/graphics/#image","text":"Image","title":"Image"},{"location":"reference/graphics/#3d-graphics","text":"","title":"3D graphics"},{"location":"reference/graphics/#mesh","text":"Mesh The mesh graphics supports the following features: Phong shading Up to four textures Customizable texture blending coefficients Transparency (but does not play well with depth test) Support for arbitrary RGB values (via cvec3 packing into vec2) Customizable plane clipping Plane clipping: when the clip vector is non-zero, the fragment shader implements the following test. If the dot product of the clip vector with the vertex position (in scene coordinates) is negative, the fragment is discarded. This feature allows to cut the mesh along any arbitrary affine plane.","title":"Mesh"},{"location":"reference/graphics/#volume-slice","text":"VolumeSlice","title":"Volume slice"},{"location":"reference/graphics/#volume","text":"Volume","title":"Volume"},{"location":"reference/graphics/#basic-graphics","text":"","title":"Basic graphics"},{"location":"reference/graphics/#points","text":"Point","title":"Points"},{"location":"reference/graphics/#lines","text":"Lines","title":"Lines"},{"location":"reference/graphics/#line-strip","text":"","title":"Line strip"},{"location":"reference/graphics/#triangles","text":"","title":"Triangles"},{"location":"reference/graphics/#triangle-strip","text":"","title":"Triangle strip"},{"location":"reference/graphics/#triangle-fan","text":"Warning Triangle fan graphics is not supported on macOS and should therefore be avoided if macOS compatibility is desirable.","title":"Triangle fan"},{"location":"reference/visuals/","text":"Visuals \u00b6 This page lists all visuals currently implemented in the library. Technical notes \u00b6 In a given visual, a prop is entirely defined by its type and its index. A visual may have multiple props of the same type. For example, the segment visual has a first prop pos with the segment start position, and another with the segment end position. The tables below specify the role of these indices in each case. A visual source corresponds to a GPU object holding the data for the visual. Common source types include: vertex buffer, index buffer, uniform buffer, texture. In a given visual, a source is entirely defined by its type and its index. Each prop is typically linked to a given source. Most props correspond either to shader attributes, in which case they are associated with the vertex buffer, or to global variables, in which case they are associated with uniform buffers. A visual is composed of one or several pipelines : graphics pipelines (or just graphics ), and optionally compute pipelines (or just computes ). A graphics pipeline corresponds to a vertex shader, a fragment shader, and possibly other shaders. In a given visual, each pipeline is entirely defined by its type (graphics or compute) and its index. The tables below specify the different pipelines when there are several of them in a given visual. For example, the axes visual contains a segment graphics for tick segments, and a text graphics for tick labels. Props marked uniform below can only receive a single value. They correspond to struct fields in a uniform buffer, and they are thus shared across all vertices of a given visual. 2D visuals \u00b6 Marker \u00b6 Props Type Index Type Description pos 0 dvec3 marker position color 0 cvec4 marker color marker_size 0 float marker size marker_type 0 char marker type angle 0 char marker angle, between 0 (0) and 256 ( M_2PI ) excluded transform 0 char transform enum color 1 vec4 edge color ( uniform ) line_width 0 float edge line width ( uniform ) Marker types Note Marker shapes are computed in real-time in the fragment shader (vector graphics rather than bitmaps). The GLSL code is from Rougier 2014, Antialiased 2D Grid, Marker, and Arrow Shaders . Marker Value Image disc 0 asterisk 1 chevron 2 clover 3 club 4 cross 5 diamond 6 arrow 7 ellipse 8 hbar 9 heart 10 infinity 11 pin 12 ring 13 spade 14 square 15 tag 16 triangle 17 vbar 18 Path \u00b6 Props Type Index Type Description pos 0 dvec3 all path points, concatenated length 0 uint path lengths, one integer per path color 0 cvec4 point colors, one per point topology 0 DvzPathTopology (int) topology of each path (0=open, 1=closed) line_width 0 float line width of all paths ( uniform ) cap_type 0 DvzCapType (int) cap type ( uniform ) join_type 0 DvzJoinType (int) join type ( uniform ) Polygon \u00b6 This visual currently only uses a basic triangle underlying graphics. It performs a triangulation of the polygons with the earcut C++ library by mapbox. Several arbitrary-sized polygons can be specified in the same visual. Props Type Index Type Description pos 0 dvec3 all polygon points, concatenated length 0 uint polygon lengths, one integer per polygon color 0 cvec4 polygon colors, one per polygon Image \u00b6 Props Type Index Type Description pos 0 dvec3 top left position pos 1 dvec3 top right position pos 2 dvec3 bottom right position pos 3 dvec3 bottom left position texcoords 0 vec3 top left texture coordinates texcoords 1 vec3 top right texture coordinates texcoords 2 vec3 bottom right texture coordinates texcoords 3 vec3 bottom left texture coordinates Sources Type Index Description vertex 0 vertex buffer param 0 parameter struct image 0..3 2D texture with image #i Scalar image with colormap \u00b6 This visual is similar to the image visual, except that it accepts scalar images and colormaps computed on the GPU. Props Type Index Type Description pos 0 dvec3 top left position pos 1 dvec3 top right position pos 2 dvec3 bottom right position pos 3 dvec3 bottom left position texcoords 0 vec3 top left texture coordinates texcoords 1 vec3 top right texture coordinates texcoords 2 vec3 bottom right texture coordinates texcoords 3 vec3 bottom left texture coordinates vrange 0 vec2 colormap range ( uniform ) cmap 0 int colormap number ( uniform ) Sources Type Index Description vertex 0 vertex buffer param 0 parameter struct color_texture 0 colormap texture image 0 2D texture with image Axes \u00b6 Tick level Index Level Description 0 minor minor ticks 1 major major ticks 2 grid grid 3 lim axes delimiters Graphics Index Graphics Description 0 segment ticks (minor, major, grid, lim) 1 text tick labels Props Type Index Type Graphics Description pos any level double segment tick positions in data coordinates color any level cvec4 segment tick colors line_width any level float segment tick line width length minor float segment minor tick length length major float segment major tick length text 0 str text tick labels text text_size 0 float text tick labels font size Sources Type Index Graphics Description vertex 0 segment vertex buffer for ticks index 0 segment index buffer for ticks vertex 1 text vertex buffer for labels index 1 text index buffer for labels font_atlas 0 text font atlas for labels 3D visuals \u00b6 Mesh \u00b6 Features: Up to four blendable textures Up to four lights Automatic computation of normals (cross product of face vertices) if the normal prop is not provided Props Type Index Type Description pos 0 dvec3 vertex position normal 0 vec3 vertex normal texcoords 0 vec2 texture coordinates color 0 cvec4 color as RGB 3-bytes alpha 0 char alpha transparency value index 0 uint32 faces, as vertex indices light_pos 0 mat4 light positions ( uniform ) light_params 0 mat4 light coefficients ( uniform ) texcoefs 0 vec4 texture blending coefficients ( uniform ) clip 0 vec4 clip vector ( uniform ) Warning The texcoords and color props are mutually exclusive. The color has precedence over the texcoords. The mesh vertex struct has no color field, only a texcoord field. When the color prop is set, special texcoords values are computed (packing 3 bytes into the second texture coordinate floating-point number). Sources Type Index Description vertex 0 vertex buffer (vertices) index 0 index buffer (faces) param 0 parameter struct image 0..3 2D texture with image #i Volume \u00b6 Props Type Index Type Description pos 0 dvec3 first corner pos 1 dvec3 opposite corner texcoords 0 vec3 texture coordinates of the first corner texcoords 1 vec3 texture coordinates of the opposite corner colormap 0 int colormap enum ( uniform ) Sources Type Index Description vertex 0 vertex buffer param 0 parameter struct color_texture 0 2D texture with the colormap texture volume 0 3D texture with the volume Volume slice \u00b6 Props Type Index Type Description pos 0 dvec3 top left position pos 1 dvec3 top right position pos 2 dvec3 bottom right position pos 3 dvec3 bottom left position texcoords 0 vec3 top left texture coordinates texcoords 1 vec3 top right texture coordinates texcoords 2 vec3 bottom right texture coordinates texcoords 3 vec3 bottom left texture coordinates transfer_x 0 vec4 colormap transfer function, x values ( uniform ) transfer_y 0 vec4 colormap transfer function, y values ( uniform ) transfer_x 1 vec4 alpha transfer function, x values ( uniform ) transfer_y 1 vec4 alpha transfer function, y values ( uniform ) colormap 0 int colormap enum ( uniform ) scale 0 float volume value scaling factor ( uniform ) Sources Type Index Description vertex 0 vertex buffer param 0 parameter struct color_texture 0 2D texture with the colormap texture volume 0 3D texture with the volume Basic visuals \u00b6 The basic visuals are simpler and more efficient, but they do not support antialiasing. Point \u00b6 The point visual is a trimmed-downed version of the marker visual. It is based on the point primitive. Props Type Index Type Description pos 0 dvec3 point position color 0 cvec4 point color marker_size 0 float point size ( uniform ) Line \u00b6 Props Type Index Type Description pos 0 dvec3 line start position pos 1 dvec3 line end position color 0 color line color Line strip \u00b6 Props Type Index Type Description pos 0 dvec3 point position color 0 cvec4 point color length 0 uint32 number of points in each line strip Triangle \u00b6 Props Type Index Type Description pos 0 dvec3 triangle position 0 pos 1 dvec3 triangle position 1 pos 2 dvec3 triangle position 2 color 0 color triangle color Triangle strip \u00b6 Props Type Index Type Description pos 0 dvec3 point position color 0 color point color Triangle fan \u00b6 Warning This visual is not supported on macOS. Props Type Index Type Description pos 0 dvec3 point position color 0 color point color Common data \u00b6 The sources and props below are shared by all builtin visuals. Common sources \u00b6 Type Index Description mvp 0 DvzMVP structure with model-view-proj matrices viewport 0 DvzViewport structure with viewport info Common props \u00b6 Type Index Type Source Description model 0 mat4 mvp model transformation matrix view 0 mat4 mvp view transformation matrix proj 0 mat4 mvp proj transformation matrix time 0 float mvp time since app start, in seconds Common enums \u00b6 Visual transform \u00b6 Visual clip \u00b6 Data types \u00b6 Data type Component size Type size Description char 8 8 1 byte (unsigned byte) cvec2 8 16 2 bytes cvec3 8 24 3 bytes cvec4 8 32 4 bytes ushort 16 16 1 unsigned short integer usvec2 16 32 2 ushort usvec3 16 48 3 ushort usvec4 16 64 4 ushort short 16 16 1 signed short integer svec2 16 32 2 short svec3 16 48 3 short svec4 16 64 4 short uint 32 32 1 unsigned long integer uvec2 32 64 2 uint uvec3 32 96 3 uint uvec4 32 128 4 uint int 32 32 1 long integer ivec2 32 64 2 int ivec3 32 96 3 int ivec4 32 128 4 int float 32 32 1 single-precision floating-point number vec2 32 64 2 float vec3 32 96 3 float vec4 32 128 4 float double 64 64 1 double-precision floating-point number dvec2 64 128 2 double dvec3 64 192 3 double dvec4 64 256 4 double mat2 32 128 2x2 matrix of floats mat3 32 288 3x3 matrix of floats mat4 32 512 4x4 matrix of floats custom - - used by structured/record arrays (heterogeneous types) str 64 64 pointer to char","title":"List of visuals"},{"location":"reference/visuals/#visuals","text":"This page lists all visuals currently implemented in the library.","title":"Visuals"},{"location":"reference/visuals/#technical-notes","text":"In a given visual, a prop is entirely defined by its type and its index. A visual may have multiple props of the same type. For example, the segment visual has a first prop pos with the segment start position, and another with the segment end position. The tables below specify the role of these indices in each case. A visual source corresponds to a GPU object holding the data for the visual. Common source types include: vertex buffer, index buffer, uniform buffer, texture. In a given visual, a source is entirely defined by its type and its index. Each prop is typically linked to a given source. Most props correspond either to shader attributes, in which case they are associated with the vertex buffer, or to global variables, in which case they are associated with uniform buffers. A visual is composed of one or several pipelines : graphics pipelines (or just graphics ), and optionally compute pipelines (or just computes ). A graphics pipeline corresponds to a vertex shader, a fragment shader, and possibly other shaders. In a given visual, each pipeline is entirely defined by its type (graphics or compute) and its index. The tables below specify the different pipelines when there are several of them in a given visual. For example, the axes visual contains a segment graphics for tick segments, and a text graphics for tick labels. Props marked uniform below can only receive a single value. They correspond to struct fields in a uniform buffer, and they are thus shared across all vertices of a given visual.","title":"Technical notes"},{"location":"reference/visuals/#2d-visuals","text":"","title":"2D visuals"},{"location":"reference/visuals/#marker","text":"","title":"Marker"},{"location":"reference/visuals/#path","text":"","title":"Path"},{"location":"reference/visuals/#polygon","text":"This visual currently only uses a basic triangle underlying graphics. It performs a triangulation of the polygons with the earcut C++ library by mapbox. Several arbitrary-sized polygons can be specified in the same visual.","title":"Polygon"},{"location":"reference/visuals/#image","text":"","title":"Image"},{"location":"reference/visuals/#scalar-image-with-colormap","text":"This visual is similar to the image visual, except that it accepts scalar images and colormaps computed on the GPU.","title":"Scalar image with colormap"},{"location":"reference/visuals/#axes","text":"","title":"Axes"},{"location":"reference/visuals/#3d-visuals","text":"","title":"3D visuals"},{"location":"reference/visuals/#mesh","text":"Features: Up to four blendable textures Up to four lights Automatic computation of normals (cross product of face vertices) if the normal prop is not provided","title":"Mesh"},{"location":"reference/visuals/#volume","text":"","title":"Volume"},{"location":"reference/visuals/#volume-slice","text":"","title":"Volume slice"},{"location":"reference/visuals/#basic-visuals","text":"The basic visuals are simpler and more efficient, but they do not support antialiasing.","title":"Basic visuals"},{"location":"reference/visuals/#point","text":"The point visual is a trimmed-downed version of the marker visual. It is based on the point primitive.","title":"Point"},{"location":"reference/visuals/#line","text":"","title":"Line"},{"location":"reference/visuals/#line-strip","text":"","title":"Line strip"},{"location":"reference/visuals/#triangle","text":"","title":"Triangle"},{"location":"reference/visuals/#triangle-strip","text":"","title":"Triangle strip"},{"location":"reference/visuals/#triangle-fan","text":"Warning This visual is not supported on macOS.","title":"Triangle fan"},{"location":"reference/visuals/#common-data","text":"The sources and props below are shared by all builtin visuals.","title":"Common data"},{"location":"reference/visuals/#common-sources","text":"Type Index Description mvp 0 DvzMVP structure with model-view-proj matrices viewport 0 DvzViewport structure with viewport info","title":"Common sources"},{"location":"reference/visuals/#common-props","text":"Type Index Type Source Description model 0 mat4 mvp model transformation matrix view 0 mat4 mvp view transformation matrix proj 0 mat4 mvp proj transformation matrix time 0 float mvp time since app start, in seconds","title":"Common props"},{"location":"reference/visuals/#common-enums","text":"","title":"Common enums"},{"location":"reference/visuals/#visual-transform","text":"","title":"Visual transform"},{"location":"reference/visuals/#visual-clip","text":"","title":"Visual clip"},{"location":"reference/visuals/#data-types","text":"Data type Component size Type size Description char 8 8 1 byte (unsigned byte) cvec2 8 16 2 bytes cvec3 8 24 3 bytes cvec4 8 32 4 bytes ushort 16 16 1 unsigned short integer usvec2 16 32 2 ushort usvec3 16 48 3 ushort usvec4 16 64 4 ushort short 16 16 1 signed short integer svec2 16 32 2 short svec3 16 48 3 short svec4 16 64 4 short uint 32 32 1 unsigned long integer uvec2 32 64 2 uint uvec3 32 96 3 uint uvec4 32 128 4 uint int 32 32 1 long integer ivec2 32 64 2 int ivec3 32 96 3 int ivec4 32 128 4 int float 32 32 1 single-precision floating-point number vec2 32 64 2 float vec3 32 96 3 float vec4 32 128 4 float double 64 64 1 double-precision floating-point number dvec2 64 128 2 double dvec3 64 192 3 double dvec4 64 256 4 double mat2 32 128 2x2 matrix of floats mat3 32 288 3x3 matrix of floats mat4 32 512 4x4 matrix of floats custom - - used by structured/record arrays (heterogeneous types) str 64 64 pointer to char","title":"Data types"},{"location":"tutorials/","text":"Tutorials \u00b6 This section proposes the following guides: Installing Datoviz Datoviz quickstart with Python","title":"Index"},{"location":"tutorials/#tutorials","text":"This section proposes the following guides: Installing Datoviz Datoviz quickstart with Python","title":"Tutorials"},{"location":"tutorials/install/","text":"Installation \u00b6 Warning Datoviz is at an early stage of development and doesn't yet provide precompiled packages. Manual compilation is required. Datoviz should work on most systems. It has been developed on Linux (Ubuntu 20.04), tested on macOS (Intel). Windows support is preliminary, help appreciated on this platform. This section describes how to compile Datoviz on different operating systems. Python bindings \u00b6 Datoviz comprises two parts: A full featured C library , Light Python bindings written in Cython. The philosophy of Datoviz is to implement all the logic and functionality in C , and provide minimal bindings in high-level languages around this functionality. This design choice ensures that future bindings that might be developed in different languages would all share the same functionality (Julia, R, MATLAB, Rust, C#, and so on). Note Most efforts were so far dedicated to the C library, whereas the Python bindings are at still an early stage of development. Dependencies of the Python bindings are: NumPy IPython Building the Cython bindings manually (which is mandatory at the moment) requires the following additional dependencies: cython pyparsing colorcet imageio Dependencies of the C library \u00b6 Mandatory dependencies that need to be installed before compiling the C library are: LunarG Vulkan SDK cmake 3.16+ (build) ninja (build) Optional dependencies are: freetype (optional) libpng (optional) ffmpeg (optional) Qt5 (optional, not supported on Ubuntu strictly below 20.04) The other dependencies below are already included in the library, so you don't need to install them manually : glfw3 3.3+ : cross-platform windowing system cglm : basic types and math computations on vectors and matrices stb_image : image file input and output Dear ImGui : rich graphical user interfaces earcut.hpp : triangulation of polygons triangle : triangulation of complex polygons and planar straight-line graphs (PSLG) tiny_obj_loader : loading of .obj mesh files Manual compilation \u00b6 Ubuntu 20.04+ \u00b6 Install the latest graphics drivers. Install the build tools: sudo apt install build-essential cmake ninja-build xcb libx11-xcb-dev libglfw3-dev Install the optional dependencies: sudo apt install libpng-dev libavcodec-dev libavformat-dev libavfilter-dev libavutil-dev libswresample-dev libvncserver-dev xtightvncviewer libqt5opengl5-dev libfreetype6-dev libassimp-dev Install the latest Lunarg Vulkan SDK (tarball SDK), for example in ~/vulkan cd ~/vulkan ./vulkansdk samples (build the Vulkan samples) ./samples/build/Sample-Programs/Hologram/Hologram (test an example) Important : add source ~/vulkan/setup-env.sh to your ~/.bashrc so that the $VULKAN_SDK environment variable and other variables are properly set in your terminal. Clone the Datoviz repository and build the library: git clone --recursive git@github.com:datoviz/datoviz.git cd datoviz ./manage.sh build Check that the compilation worked by running an example: ./manage.sh demo Note: this will only work if Vulkan SDK's setup-env.sh file is source-ed in the terminal. Compile the Cython module: ./manage.sh cython Export the shared library path in your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py macOS \u00b6 Install the dependencies Type git in a terminal to install it. Install Xcode Install git-lfs (to download large test/example datasets) Install Homebrew if you don't have it already Type brew install cmake ninja Install Vulkan Install the latest Vulkan SDK cd /Volumes/vulkansdk-macos-1.2.154.0 (replace by appropriate version) ./install_vulkan.py Install Datoviz git clone --recursive git@github.com:datoviz/datoviz.git cd datoviz ./manage.sh build ./manage.sh demo Build the Cython module Compile the Cython module: ./manage.sh cython Export the shared library path in your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py Windows 10 \u00b6 Warning Only mingw-w64 is supported at the moment. Microsoft Visual C++ is not yet supported. Help needed to fill in the details below : Install the latest graphics drivers for your system and hardware. Install Winlibs , a Windows port of gcc, using mingw-w64. Make sure the mingw executable is in the PATH. Install CMake for Windows Install the latest Lunarg Vulkan SDK ( .exe executable). Install the Windows Universal C Runtime https://stackoverflow.com/a/52329698 Clone the repository: git clone --recursive git@github.com:datoviz/datoviz.git Enter the following commands within the repository's directory (using the Windows terminal, not in Windows for Linux subsystem): mkdir build cd build cmake .. -G \"MinGW Makefiles\" mingw32-make cd .. To run an example (the batch script will only work in cmd.exe, not Powershell): setup-env.bat set DVZ_INTERACT=1 build\\datoviz.exe test test_scene_ax To build the Cython package: setup-env.bat cd bindings\\cython pip install -r requirements.txt python setup.py build_ext -i -c mingw32 python setup.py develop Copy build\\libdatoviz.dll to bindings\\cython\\datoviz\\ (there has to be a better way) python bindings\\cython\\examples\\quickstart.py Notes \u00b6 CPU emulation \u00b6 CPU Vulkan emulation is useful on computers with no GPUs or on continuous integration servers, for testing purposes only. It is provided by the Swiftshader library developed by Google. Install https://github.com/google/swiftshader Temporarily override your native Vulkan driver with the SwiftShader one: Linux: export LD_LIBRARY_PATH=/path/to/swiftshader/build/Linux/:$LD_LIBRARY_PATH Run the Datoviz tests as usual ./test.sh","title":"Installation"},{"location":"tutorials/install/#installation","text":"Warning Datoviz is at an early stage of development and doesn't yet provide precompiled packages. Manual compilation is required. Datoviz should work on most systems. It has been developed on Linux (Ubuntu 20.04), tested on macOS (Intel). Windows support is preliminary, help appreciated on this platform. This section describes how to compile Datoviz on different operating systems.","title":"Installation"},{"location":"tutorials/install/#python-bindings","text":"Datoviz comprises two parts: A full featured C library , Light Python bindings written in Cython. The philosophy of Datoviz is to implement all the logic and functionality in C , and provide minimal bindings in high-level languages around this functionality. This design choice ensures that future bindings that might be developed in different languages would all share the same functionality (Julia, R, MATLAB, Rust, C#, and so on). Note Most efforts were so far dedicated to the C library, whereas the Python bindings are at still an early stage of development. Dependencies of the Python bindings are: NumPy IPython Building the Cython bindings manually (which is mandatory at the moment) requires the following additional dependencies: cython pyparsing colorcet imageio","title":"Python bindings"},{"location":"tutorials/install/#dependencies-of-the-c-library","text":"Mandatory dependencies that need to be installed before compiling the C library are: LunarG Vulkan SDK cmake 3.16+ (build) ninja (build) Optional dependencies are: freetype (optional) libpng (optional) ffmpeg (optional) Qt5 (optional, not supported on Ubuntu strictly below 20.04) The other dependencies below are already included in the library, so you don't need to install them manually : glfw3 3.3+ : cross-platform windowing system cglm : basic types and math computations on vectors and matrices stb_image : image file input and output Dear ImGui : rich graphical user interfaces earcut.hpp : triangulation of polygons triangle : triangulation of complex polygons and planar straight-line graphs (PSLG) tiny_obj_loader : loading of .obj mesh files","title":"Dependencies of the C library"},{"location":"tutorials/install/#manual-compilation","text":"","title":"Manual compilation"},{"location":"tutorials/install/#ubuntu-2004","text":"Install the latest graphics drivers. Install the build tools: sudo apt install build-essential cmake ninja-build xcb libx11-xcb-dev libglfw3-dev Install the optional dependencies: sudo apt install libpng-dev libavcodec-dev libavformat-dev libavfilter-dev libavutil-dev libswresample-dev libvncserver-dev xtightvncviewer libqt5opengl5-dev libfreetype6-dev libassimp-dev Install the latest Lunarg Vulkan SDK (tarball SDK), for example in ~/vulkan cd ~/vulkan ./vulkansdk samples (build the Vulkan samples) ./samples/build/Sample-Programs/Hologram/Hologram (test an example) Important : add source ~/vulkan/setup-env.sh to your ~/.bashrc so that the $VULKAN_SDK environment variable and other variables are properly set in your terminal. Clone the Datoviz repository and build the library: git clone --recursive git@github.com:datoviz/datoviz.git cd datoviz ./manage.sh build Check that the compilation worked by running an example: ./manage.sh demo Note: this will only work if Vulkan SDK's setup-env.sh file is source-ed in the terminal. Compile the Cython module: ./manage.sh cython Export the shared library path in your environment: source setup-env.sh Try a Python example: python bindings/cython/examples/quickstart.py","title":"Ubuntu 20.04+"},{"location":"tutorials/install/#macos","text":"","title":"macOS"},{"location":"tutorials/install/#windows-10","text":"Warning Only mingw-w64 is supported at the moment. Microsoft Visual C++ is not yet supported. Help needed to fill in the details below : Install the latest graphics drivers for your system and hardware. Install Winlibs , a Windows port of gcc, using mingw-w64. Make sure the mingw executable is in the PATH. Install CMake for Windows Install the latest Lunarg Vulkan SDK ( .exe executable). Install the Windows Universal C Runtime https://stackoverflow.com/a/52329698 Clone the repository: git clone --recursive git@github.com:datoviz/datoviz.git Enter the following commands within the repository's directory (using the Windows terminal, not in Windows for Linux subsystem): mkdir build cd build cmake .. -G \"MinGW Makefiles\" mingw32-make cd .. To run an example (the batch script will only work in cmd.exe, not Powershell): setup-env.bat set DVZ_INTERACT=1 build\\datoviz.exe test test_scene_ax To build the Cython package: setup-env.bat cd bindings\\cython pip install -r requirements.txt python setup.py build_ext -i -c mingw32 python setup.py develop Copy build\\libdatoviz.dll to bindings\\cython\\datoviz\\ (there has to be a better way) python bindings\\cython\\examples\\quickstart.py","title":"Windows 10"},{"location":"tutorials/install/#notes","text":"","title":"Notes"},{"location":"tutorials/install/#cpu-emulation","text":"CPU Vulkan emulation is useful on computers with no GPUs or on continuous integration servers, for testing purposes only. It is provided by the Swiftshader library developed by Google. Install https://github.com/google/swiftshader Temporarily override your native Vulkan driver with the SwiftShader one: Linux: export LD_LIBRARY_PATH=/path/to/swiftshader/build/Linux/:$LD_LIBRARY_PATH Run the Datoviz tests as usual ./test.sh","title":"CPU emulation"},{"location":"tutorials/quickstart/","text":"Quickstart: using Datoviz in Python \u00b6 Once Datoviz has been properly installed, you can start to use it in a few lines of code! In this tutorial, we'll show how to make a simple 2D plot with Datoviz in Python , and we'll go through the most important features of the library. We'll cover the following steps: how to create an application, how to create a canvas, how to create a panel with an axes controller, how to add a visual, how to use colormaps, how to set visual data, how to run the application, how to create a minimal GUI, how to specify event callbacks, how to use mouse picking, how to make a live screencast video ( requires compilation with ffmpeg ), and more. Creating custom visuals, creating standalone C applications with Datoviz are advanced topics, they are covered in the How to section of the documentation. Note The Python bindings are at an early stage of development. They will be significantly improved in the near future. Importing the library \u00b6 Note For now, Datoviz should be used from a Python script. Integration with IPython and Jupyter is still a work in progress. First, we import NumPy and datoviz: import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap Creating a canvas \u00b6 We create a canvas : c = canvas ( show_fps = False ) We can also specify the initial width and height of the window using keyword arguments to canvas() . Creating a panel \u00b6 Next, we create a panel , which is another word for \"subplot\". By default, there is only one panel spanning the entire canvas, but we can also define multiple panels. We also specify the panel's controller , which defines how we interact with it. The axes controller displays axes and ticks for 2D graphics. panel = c . panel ( controller = 'axes' ) Choosing one of the existing visuals \u00b6 We'll make a simple scatter plot with 2D random points, and different colors and marker sizes. We refer to the list of all included visuals provided by the Datoviz documentation, and we find that the marker visual is what we want for our scatter plot. We look at the visual properties (or props ) for this visual: this is the data we'll need to feed to our visual. But first, we create our visual object by specifying its type: visual = panel . visual ( 'marker' ) Preparing the visual data \u00b6 We'll set: the marker positions : pos prop, the marker colors : color prop, the marker sizes : ms prop. First, we generate the data for these props. Random positions \u00b6 N = 100_000 pos = nr . randn ( N , 3 ) Note that positions always have three dimensions in Datoviz. When using 2D plotting, we set the third component to zero. Datoviz uses the standard OpenGL 3D coordinate system: Datoviz coordinate system Note Note that this is different from the Vulkan coordinate system, where y and z go in the opposite direction. The other difference is that in Datoviz, all axes range in the interval [-1, +1] . In the original Vulkan coordinate system, z goes from 0 to 1 instead. The convention used in Datoviz makes it possible to use existing camera matrix routines implemented in the cglm library. The GPU code of all included shaders include the final OpenGL->Vulkan transformation right before the vertex shader output. Other conventions for x, y, z axes will be supported in the future. Position props are specified in the original data coordinate system corresponding to the scientific data to be visualized. Yet, Datoviz requires vertex positions to be in normalized coordinates (between -1 and 1) when sent to the GPU. Since the GPU only deals with single-precision floating point numbers, doing data normalization on the GPU would result in significant loss of precision and would harm performance. Therefore, Datoviz provides a system to make transformations on the CPU in double precision before uploading the data to the GPU. By default, the data is linearly transformed to fit the [-1, +1] cube. Other types of transformations will soon be implemented (polar coordinates, geographic coordinate systems, and so on). Random marker size \u00b6 We define random marker sizes as an array of floating-point values: ms = nr . uniform ( low = 2 , high = 40 , size = N ) Colormap \u00b6 Let's define the colors. We could use random RGBA values for the colors, but we'll use one of the built-in colormap instead. color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = 'viridis' ) The variable color is an (N, 4) array of uint8 (byte values between 0 and 255). This line involves the following steps: Choosing a colormap, here viridis (see the colormap reference page with the list of ~150 included colormaps), Defining an array of scalar values to be fed to the colormap (random values between 0 and 1 here), (Optional) Defining the colormap range ( [0, 1] here), (Optional) Setting an alpha transparency channel (0.75 here). Set the visual data \u00b6 Finally, the most important bit is to set the visual prop data with the arrays we just created : visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms ) Running the application \u00b6 Finally, we run the application by starting the main event loop: run () Making a screenshot \u00b6 We can easily make a screenshot of the first frame of the canvas. Note Screenshot support will be improved soon. run ( screenshot = \"screenshot.png\" ) Recording a screencast video \u00b6 If the library was compiled with ffmpeg, we can easily make a live mp4 screencast of the canvas. Warning The canvas should NOT be resized when doing a screencast, or the video will be corrupted. run ( video = \"screencast.mp4\" ) This command does not start the video recording, one needs to press the Play button at the bottom right corner. We can pause and resume at any time. When we're done, we press the Stop button and the video will be saved to disk. Event callbacks and mouse picking \u00b6 Important From now on, all the code snippets below needs to be added before calling run() . We'll write a callback function that is called when the user clicks in the canvas, and that prints the coordinates of the clicked point in the original data coordinate system. # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = c . panel_at ( x , y ) if not p : return # Then, we transform into the data coordinate system # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), modifiers= { modifiers } \" ) Clicking somewhere shows in the terminal output: Pick at (0.4605, -0.1992), modifiers=() Coordinate systems \u00b6 By default, the panel.pick() function converts coordinates from the window coordinate system (used by the event callbacks) to the data coordinate system. There are other coordinate systems that you can convert to using the target_cds keyword argument to pick() : Name Description data original coordinates of the data scene the coordinates before controller transformation (panzoom etc) in [-1, +1] vulkan the coordinates after controller transformation, in [-1, +1] framebuffer the coordinates in framebuffer pixel coordinates window the coordinates in screen pixel coordinates A few technical notes: The scene coordinate system corresponds to the vertex shader input . The vulkan coordinate system corresponds to the vertex shader output . There's a difference between the framebuffer and window systems with high-DPI monitors. This depends on the OS. For now, DPI support is semi-manual. Datoviz supports a special dpi_scaling variable that rescales the visual elements depending on this value, and that can be adjusted manually (to be documented later). Adding a simple GUI \u00b6 Datoviz integrates the Dear ImGUI library which allows one to create GUIs directly in a Datoviz canvas, without using external dependencies such as Qt. Adding a GUI dialog \u00b6 We create a new GUI dialog. # We create a GUI dialog. gui = c . gui ( \"Test GUI\" ) Adding a control to the GUI \u00b6 We add a slider to change the visual marker size. # We add a control, a slider controlling a float @gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) def on_change ( value ): # Every time the slider value changes, we update the visual's marker size visual . data ( 'ms' , ms * value ) # NOTE: an upcoming version will support partial updates We add another slider, using integers this time, to change the colormap. # We add another control, a slider controlling an int between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) def on_change ( value ): # Recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # Update the color visual visual . data ( 'color' , color ) Finally we add a button to regenerate the marker positions. # We add a button to regenerate the marker positions @gui . control ( \"button\" , \"new positions\" ) def on_change ( value ): pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos )","title":"Quickstart"},{"location":"tutorials/quickstart/#quickstart-using-datoviz-in-python","text":"Once Datoviz has been properly installed, you can start to use it in a few lines of code! In this tutorial, we'll show how to make a simple 2D plot with Datoviz in Python , and we'll go through the most important features of the library. We'll cover the following steps: how to create an application, how to create a canvas, how to create a panel with an axes controller, how to add a visual, how to use colormaps, how to set visual data, how to run the application, how to create a minimal GUI, how to specify event callbacks, how to use mouse picking, how to make a live screencast video ( requires compilation with ffmpeg ), and more. Creating custom visuals, creating standalone C applications with Datoviz are advanced topics, they are covered in the How to section of the documentation. Note The Python bindings are at an early stage of development. They will be significantly improved in the near future.","title":"Quickstart: using Datoviz in Python"},{"location":"tutorials/quickstart/#importing-the-library","text":"Note For now, Datoviz should be used from a Python script. Integration with IPython and Jupyter is still a work in progress. First, we import NumPy and datoviz: import numpy as np import numpy.random as nr from datoviz import canvas , run , colormap","title":"Importing the library"},{"location":"tutorials/quickstart/#creating-a-canvas","text":"We create a canvas : c = canvas ( show_fps = False ) We can also specify the initial width and height of the window using keyword arguments to canvas() .","title":"Creating a canvas"},{"location":"tutorials/quickstart/#creating-a-panel","text":"Next, we create a panel , which is another word for \"subplot\". By default, there is only one panel spanning the entire canvas, but we can also define multiple panels. We also specify the panel's controller , which defines how we interact with it. The axes controller displays axes and ticks for 2D graphics. panel = c . panel ( controller = 'axes' )","title":"Creating a panel"},{"location":"tutorials/quickstart/#choosing-one-of-the-existing-visuals","text":"We'll make a simple scatter plot with 2D random points, and different colors and marker sizes. We refer to the list of all included visuals provided by the Datoviz documentation, and we find that the marker visual is what we want for our scatter plot. We look at the visual properties (or props ) for this visual: this is the data we'll need to feed to our visual. But first, we create our visual object by specifying its type: visual = panel . visual ( 'marker' )","title":"Choosing one of the existing visuals"},{"location":"tutorials/quickstart/#preparing-the-visual-data","text":"We'll set: the marker positions : pos prop, the marker colors : color prop, the marker sizes : ms prop. First, we generate the data for these props.","title":"Preparing the visual data"},{"location":"tutorials/quickstart/#random-positions","text":"N = 100_000 pos = nr . randn ( N , 3 ) Note that positions always have three dimensions in Datoviz. When using 2D plotting, we set the third component to zero. Datoviz uses the standard OpenGL 3D coordinate system: Datoviz coordinate system Note Note that this is different from the Vulkan coordinate system, where y and z go in the opposite direction. The other difference is that in Datoviz, all axes range in the interval [-1, +1] . In the original Vulkan coordinate system, z goes from 0 to 1 instead. The convention used in Datoviz makes it possible to use existing camera matrix routines implemented in the cglm library. The GPU code of all included shaders include the final OpenGL->Vulkan transformation right before the vertex shader output. Other conventions for x, y, z axes will be supported in the future. Position props are specified in the original data coordinate system corresponding to the scientific data to be visualized. Yet, Datoviz requires vertex positions to be in normalized coordinates (between -1 and 1) when sent to the GPU. Since the GPU only deals with single-precision floating point numbers, doing data normalization on the GPU would result in significant loss of precision and would harm performance. Therefore, Datoviz provides a system to make transformations on the CPU in double precision before uploading the data to the GPU. By default, the data is linearly transformed to fit the [-1, +1] cube. Other types of transformations will soon be implemented (polar coordinates, geographic coordinate systems, and so on).","title":"Random positions"},{"location":"tutorials/quickstart/#random-marker-size","text":"We define random marker sizes as an array of floating-point values: ms = nr . uniform ( low = 2 , high = 40 , size = N )","title":"Random marker size"},{"location":"tutorials/quickstart/#colormap","text":"Let's define the colors. We could use random RGBA values for the colors, but we'll use one of the built-in colormap instead. color = colormap ( nr . rand ( N ), vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = 'viridis' ) The variable color is an (N, 4) array of uint8 (byte values between 0 and 255). This line involves the following steps: Choosing a colormap, here viridis (see the colormap reference page with the list of ~150 included colormaps), Defining an array of scalar values to be fed to the colormap (random values between 0 and 1 here), (Optional) Defining the colormap range ( [0, 1] here), (Optional) Setting an alpha transparency channel (0.75 here).","title":"Colormap"},{"location":"tutorials/quickstart/#set-the-visual-data","text":"Finally, the most important bit is to set the visual prop data with the arrays we just created : visual . data ( 'pos' , pos ) visual . data ( 'color' , color ) visual . data ( 'ms' , ms )","title":"Set the visual data"},{"location":"tutorials/quickstart/#running-the-application","text":"Finally, we run the application by starting the main event loop: run ()","title":"Running the application"},{"location":"tutorials/quickstart/#making-a-screenshot","text":"We can easily make a screenshot of the first frame of the canvas. Note Screenshot support will be improved soon. run ( screenshot = \"screenshot.png\" )","title":"Making a screenshot"},{"location":"tutorials/quickstart/#recording-a-screencast-video","text":"If the library was compiled with ffmpeg, we can easily make a live mp4 screencast of the canvas. Warning The canvas should NOT be resized when doing a screencast, or the video will be corrupted. run ( video = \"screencast.mp4\" ) This command does not start the video recording, one needs to press the Play button at the bottom right corner. We can pause and resume at any time. When we're done, we press the Stop button and the video will be saved to disk.","title":"Recording a screencast video"},{"location":"tutorials/quickstart/#event-callbacks-and-mouse-picking","text":"Important From now on, all the code snippets below needs to be added before calling run() . We'll write a callback function that is called when the user clicks in the canvas, and that prints the coordinates of the clicked point in the original data coordinate system. # We define an event callback to implement mouse picking @c . connect def on_mouse_click ( x , y , button , modifiers = ()): # x, y are in pixel coordinates # First, we find the picked panel p = c . panel_at ( x , y ) if not p : return # Then, we transform into the data coordinate system # Supported coordinate systems: # target_cds='data' / 'scene' / 'vulkan' / 'framebuffer' / 'window' xd , yd = p . pick ( x , y ) print ( f \"Pick at ( { xd : .4f } , { yd : .4f } ), modifiers= { modifiers } \" ) Clicking somewhere shows in the terminal output: Pick at (0.4605, -0.1992), modifiers=()","title":"Event callbacks and mouse picking"},{"location":"tutorials/quickstart/#coordinate-systems","text":"By default, the panel.pick() function converts coordinates from the window coordinate system (used by the event callbacks) to the data coordinate system. There are other coordinate systems that you can convert to using the target_cds keyword argument to pick() : Name Description data original coordinates of the data scene the coordinates before controller transformation (panzoom etc) in [-1, +1] vulkan the coordinates after controller transformation, in [-1, +1] framebuffer the coordinates in framebuffer pixel coordinates window the coordinates in screen pixel coordinates A few technical notes: The scene coordinate system corresponds to the vertex shader input . The vulkan coordinate system corresponds to the vertex shader output . There's a difference between the framebuffer and window systems with high-DPI monitors. This depends on the OS. For now, DPI support is semi-manual. Datoviz supports a special dpi_scaling variable that rescales the visual elements depending on this value, and that can be adjusted manually (to be documented later).","title":"Coordinate systems"},{"location":"tutorials/quickstart/#adding-a-simple-gui","text":"Datoviz integrates the Dear ImGUI library which allows one to create GUIs directly in a Datoviz canvas, without using external dependencies such as Qt.","title":"Adding a simple GUI"},{"location":"tutorials/quickstart/#adding-a-gui-dialog","text":"We create a new GUI dialog. # We create a GUI dialog. gui = c . gui ( \"Test GUI\" )","title":"Adding a GUI dialog"},{"location":"tutorials/quickstart/#adding-a-control-to-the-gui","text":"We add a slider to change the visual marker size. # We add a control, a slider controlling a float @gui . control ( \"slider_float\" , \"marker size\" , vmin =. 5 , vmax = 2 ) def on_change ( value ): # Every time the slider value changes, we update the visual's marker size visual . data ( 'ms' , ms * value ) # NOTE: an upcoming version will support partial updates We add another slider, using integers this time, to change the colormap. # We add another control, a slider controlling an int between 1 and 4, to change the colormap. # NOTE: an upcoming version will provide a dropdown menu control cmaps = [ 'viridis' , 'cividis' , 'autumn' , 'winter' ] @gui . control ( \"slider_int\" , \"colormap\" , vmin = 0 , vmax = 3 ) def on_change ( value ): # Recompute the colors. color = colormap ( color_values , vmin = 0 , vmax = 1 , alpha =. 75 * np . ones ( N ), cmap = cmaps [ value ]) # Update the color visual visual . data ( 'color' , color ) Finally we add a button to regenerate the marker positions. # We add a button to regenerate the marker positions @gui . control ( \"button\" , \"new positions\" ) def on_change ( value ): pos = nr . randn ( N , 3 ) visual . data ( 'pos' , pos )","title":"Adding a control to the GUI"}]}